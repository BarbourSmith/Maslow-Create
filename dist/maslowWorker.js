/**
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// If the loader is already loaded, just stop.
if (!self.define) {
  const singleRequire = async name => {
    if (name !== 'require') {
      name = name + '.js';
    }
    if (!registry[name]) {
      
        await new Promise(async resolve => {
          if ("document" in self) {
            const script = document.createElement("script");
            
              script.src = name;
            
            // Ya never know
            script.defer = true;
            document.head.appendChild(script);
            script.onload = resolve;
          } else {
            importScripts(name);
            resolve();
          }
        });
      

      if (!registry[name]) {
        throw new Error(`Module ${name} didn’t register its module`);
      }
    }
    return registry[name];
  };

  const require = async (names, resolve) => {
    const modules = await Promise.all(names.map(singleRequire));
    resolve(modules.length === 1 ? modules[0] : modules);
  };

  const registry = {
    require: Promise.resolve(require)
  };

  self.define = (moduleName, depsNames, factory) => {
    if (registry[moduleName]) {
      // Module is already loading or loaded.
      return;
    }
    registry[moduleName] = new Promise(async resolve => {
      let exports = {};
      const module = {
        
          uri: location.origin + moduleName.slice(1)
        
      };
      const deps = await Promise.all(
        depsNames.map(depName => {
          if (depName === "exports") {
            return exports;
          }
          if (depName === "module") {
            return module;
          }
          return singleRequire(depName);
        })
      );
      const facValue = factory(...deps);
      if(!exports.default) {
        exports.default = facValue;
      }
      resolve(exports);
    });
  };
}
define("./maslowWorker.js",['require', 'exports'], function (require, exports) { 'use strict';

            function _interopNamespace(e) {
                        if (e && e.__esModule) { return e; } else {
                                    var n = {};
                                    if (e) {
                                                Object.keys(e).forEach(function (k) {
                                                            var d = Object.getOwnPropertyDescriptor(e, k);
                                                            Object.defineProperty(n, k, d.get ? d : {
                                                                        enumerable: true,
                                                                        get: function () {
                                                                                    return e[k];
                                                                        }
                                                            });
                                                });
                                    }
                                    n['default'] = e;
                                    return n;
                        }
            }

            var global$1 = (typeof global !== "undefined" ? global :
                        typeof self !== "undefined" ? self :
                        typeof window !== "undefined" ? window : {});

            const pending = [];

            const addPending = (promise) => pending.push(promise);

            var empty = {};

            var fs = /*#__PURE__*/Object.freeze({
              __proto__: null,
              'default': empty
            });

            var v8 = {};

            var v8$1 = /*#__PURE__*/Object.freeze({
              __proto__: null,
              'default': v8
            });

            // When base is undefined the persistent filesystem is disabled.
            let base;

            const getBase = () => base;

            const qualifyPath = (path = '', workspace) => {
              if (workspace !== undefined) {
                return `jsxcad/${workspace}/${path}`;
              } else if (base !== undefined) {
                return `jsxcad/${base}${path}`;
              } else {
                return `jsxcad//${path}`;
              }
            };

            const setupFilesystem = ({ fileBase } = {}) => {
              // A prefix used to partition the persistent filesystem for multiple workspaces.
              if (fileBase !== undefined) {
                if (fileBase.endsWith('/')) {
                  base = fileBase;
                } else {
                  base = `${fileBase}/`;
                }
              } else {
                base = undefined;
              }
            };

            const getFilesystem = () => {
              if (base !== undefined) {
                const [filesystem] = base.split('/');
                return filesystem;
              }
            };

            var global$1$1 = (typeof global$1 !== "undefined" ? global$1 :
                        typeof self !== "undefined" ? self :
                        typeof window !== "undefined" ? window : {});

            // shim for using process in browser
            // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

            function defaultSetTimout() {
                throw new Error('setTimeout has not been defined');
            }
            function defaultClearTimeout () {
                throw new Error('clearTimeout has not been defined');
            }
            var cachedSetTimeout = defaultSetTimout;
            var cachedClearTimeout = defaultClearTimeout;
            if (typeof global$1$1.setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            }
            if (typeof global$1$1.clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            }

            function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) {
                    //normal enviroments in sane situations
                    return setTimeout(fun, 0);
                }
                // if setTimeout wasn't available but was latter defined
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                    cachedSetTimeout = setTimeout;
                    return setTimeout(fun, 0);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedSetTimeout(fun, 0);
                } catch(e){
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                        return cachedSetTimeout.call(null, fun, 0);
                    } catch(e){
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                        return cachedSetTimeout.call(this, fun, 0);
                    }
                }


            }
            function runClearTimeout(marker) {
                if (cachedClearTimeout === clearTimeout) {
                    //normal enviroments in sane situations
                    return clearTimeout(marker);
                }
                // if clearTimeout wasn't available but was latter defined
                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                    cachedClearTimeout = clearTimeout;
                    return clearTimeout(marker);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedClearTimeout(marker);
                } catch (e){
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                        return cachedClearTimeout.call(null, marker);
                    } catch (e){
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                        // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                        return cachedClearTimeout.call(this, marker);
                    }
                }



            }
            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;

            function cleanUpNextTick() {
                if (!draining || !currentQueue) {
                    return;
                }
                draining = false;
                if (currentQueue.length) {
                    queue = currentQueue.concat(queue);
                } else {
                    queueIndex = -1;
                }
                if (queue.length) {
                    drainQueue();
                }
            }

            function drainQueue() {
                if (draining) {
                    return;
                }
                var timeout = runTimeout(cleanUpNextTick);
                draining = true;

                var len = queue.length;
                while(len) {
                    currentQueue = queue;
                    queue = [];
                    while (++queueIndex < len) {
                        if (currentQueue) {
                            currentQueue[queueIndex].run();
                        }
                    }
                    queueIndex = -1;
                    len = queue.length;
                }
                currentQueue = null;
                draining = false;
                runClearTimeout(timeout);
            }
            function nextTick(fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for (var i = 1; i < arguments.length; i++) {
                        args[i - 1] = arguments[i];
                    }
                }
                queue.push(new Item(fun, args));
                if (queue.length === 1 && !draining) {
                    runTimeout(drainQueue);
                }
            }
            // v8 likes predictible objects
            function Item(fun, array) {
                this.fun = fun;
                this.array = array;
            }
            Item.prototype.run = function () {
                this.fun.apply(null, this.array);
            };
            var title = 'browser';
            var platform = 'browser';
            var browser = true;
            var env = {};
            var argv = [];
            var version = ''; // empty string to avoid regexp issues
            var versions = {};
            var release = {};
            var config = {};

            function noop() {}

            var on = noop;
            var addListener = noop;
            var once = noop;
            var off = noop;
            var removeListener = noop;
            var removeAllListeners = noop;
            var emit = noop;

            function binding(name) {
                throw new Error('process.binding is not supported');
            }

            function cwd () { return '/' }
            function chdir (dir) {
                throw new Error('process.chdir is not supported');
            }function umask() { return 0; }

            // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
            var performance = global$1$1.performance || {};
            var performanceNow =
              performance.now        ||
              performance.mozNow     ||
              performance.msNow      ||
              performance.oNow       ||
              performance.webkitNow  ||
              function(){ return (new Date()).getTime() };

            // generate timestamp or delta
            // see http://nodejs.org/api/process.html#process_process_hrtime
            function hrtime(previousTimestamp){
              var clocktime = performanceNow.call(performance)*1e-3;
              var seconds = Math.floor(clocktime);
              var nanoseconds = Math.floor((clocktime%1)*1e9);
              if (previousTimestamp) {
                seconds = seconds - previousTimestamp[0];
                nanoseconds = nanoseconds - previousTimestamp[1];
                if (nanoseconds<0) {
                  seconds--;
                  nanoseconds += 1e9;
                }
              }
              return [seconds,nanoseconds]
            }

            var startTime = new Date();
            function uptime() {
              var currentTime = new Date();
              var dif = currentTime - startTime;
              return dif / 1000;
            }

            var process = {
              nextTick: nextTick,
              title: title,
              browser: browser,
              env: env,
              argv: argv,
              version: version,
              versions: versions,
              on: on,
              addListener: addListener,
              once: once,
              off: off,
              removeListener: removeListener,
              removeAllListeners: removeAllListeners,
              emit: emit,
              binding: binding,
              cwd: cwd,
              chdir: chdir,
              umask: umask,
              hrtime: hrtime,
              platform: platform,
              release: release,
              config: config,
              uptime: uptime
            };

            /* global self */

            const isBrowser =
              typeof window !== 'undefined' && typeof window.document !== 'undefined';

            const checkIsWebWorker = () => {
              try {
                return (
                  self.constructor && self.constructor.name === 'DedicatedWorkerGlobalScope'
                );
              } catch (e) {
                return false;
              }
            };

            const isWebWorker = checkIsWebWorker();

            const isNode =
              typeof process !== 'undefined' &&
              process.versions != null &&
              process.versions.node != null;

            var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global$1 !== 'undefined' ? global$1 : typeof self !== 'undefined' ? self : {};

            function commonjsRequire () {
            	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
            }

            function createCommonjsModule(fn, module) {
            	return module = { exports: {} }, fn(module, module.exports), module.exports;
            }

            var localforage = createCommonjsModule(function (module, exports) {
            /*!
                localForage -- Offline Storage, Improved
                Version 1.8.1
                https://localforage.github.io/localForage
                (c) 2013-2017 Mozilla, Apache License 2.0
            */
            (function(f){{module.exports=f();}})(function(){return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof commonjsRequire=="function"&&commonjsRequire;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw (f.code="MODULE_NOT_FOUND", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r);}return n[o].exports}var i=typeof commonjsRequire=="function"&&commonjsRequire;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
            (function (global){
            var Mutation = global.MutationObserver || global.WebKitMutationObserver;

            var scheduleDrain;

            {
              if (Mutation) {
                var called = 0;
                var observer = new Mutation(nextTick);
                var element = global.document.createTextNode('');
                observer.observe(element, {
                  characterData: true
                });
                scheduleDrain = function () {
                  element.data = (called = ++called % 2);
                };
              } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
                var channel = new global.MessageChannel();
                channel.port1.onmessage = nextTick;
                scheduleDrain = function () {
                  channel.port2.postMessage(0);
                };
              } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
                scheduleDrain = function () {

                  // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                  // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                  var scriptEl = global.document.createElement('script');
                  scriptEl.onreadystatechange = function () {
                    nextTick();

                    scriptEl.onreadystatechange = null;
                    scriptEl.parentNode.removeChild(scriptEl);
                    scriptEl = null;
                  };
                  global.document.documentElement.appendChild(scriptEl);
                };
              } else {
                scheduleDrain = function () {
                  setTimeout(nextTick, 0);
                };
              }
            }

            var draining;
            var queue = [];
            //named nextTick for less confusing stack traces
            function nextTick() {
              draining = true;
              var i, oldQueue;
              var len = queue.length;
              while (len) {
                oldQueue = queue;
                queue = [];
                i = -1;
                while (++i < len) {
                  oldQueue[i]();
                }
                len = queue.length;
              }
              draining = false;
            }

            module.exports = immediate;
            function immediate(task) {
              if (queue.push(task) === 1 && !draining) {
                scheduleDrain();
              }
            }

            }).call(this,typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
            },{}],2:[function(_dereq_,module,exports){
            var immediate = _dereq_(1);

            /* istanbul ignore next */
            function INTERNAL() {}

            var handlers = {};

            var REJECTED = ['REJECTED'];
            var FULFILLED = ['FULFILLED'];
            var PENDING = ['PENDING'];

            module.exports = Promise;

            function Promise(resolver) {
              if (typeof resolver !== 'function') {
                throw new TypeError('resolver must be a function');
              }
              this.state = PENDING;
              this.queue = [];
              this.outcome = void 0;
              if (resolver !== INTERNAL) {
                safelyResolveThenable(this, resolver);
              }
            }

            Promise.prototype["catch"] = function (onRejected) {
              return this.then(null, onRejected);
            };
            Promise.prototype.then = function (onFulfilled, onRejected) {
              if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
                typeof onRejected !== 'function' && this.state === REJECTED) {
                return this;
              }
              var promise = new this.constructor(INTERNAL);
              if (this.state !== PENDING) {
                var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
                unwrap(promise, resolver, this.outcome);
              } else {
                this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
              }

              return promise;
            };
            function QueueItem(promise, onFulfilled, onRejected) {
              this.promise = promise;
              if (typeof onFulfilled === 'function') {
                this.onFulfilled = onFulfilled;
                this.callFulfilled = this.otherCallFulfilled;
              }
              if (typeof onRejected === 'function') {
                this.onRejected = onRejected;
                this.callRejected = this.otherCallRejected;
              }
            }
            QueueItem.prototype.callFulfilled = function (value) {
              handlers.resolve(this.promise, value);
            };
            QueueItem.prototype.otherCallFulfilled = function (value) {
              unwrap(this.promise, this.onFulfilled, value);
            };
            QueueItem.prototype.callRejected = function (value) {
              handlers.reject(this.promise, value);
            };
            QueueItem.prototype.otherCallRejected = function (value) {
              unwrap(this.promise, this.onRejected, value);
            };

            function unwrap(promise, func, value) {
              immediate(function () {
                var returnValue;
                try {
                  returnValue = func(value);
                } catch (e) {
                  return handlers.reject(promise, e);
                }
                if (returnValue === promise) {
                  handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
                } else {
                  handlers.resolve(promise, returnValue);
                }
              });
            }

            handlers.resolve = function (self, value) {
              var result = tryCatch(getThen, value);
              if (result.status === 'error') {
                return handlers.reject(self, result.value);
              }
              var thenable = result.value;

              if (thenable) {
                safelyResolveThenable(self, thenable);
              } else {
                self.state = FULFILLED;
                self.outcome = value;
                var i = -1;
                var len = self.queue.length;
                while (++i < len) {
                  self.queue[i].callFulfilled(value);
                }
              }
              return self;
            };
            handlers.reject = function (self, error) {
              self.state = REJECTED;
              self.outcome = error;
              var i = -1;
              var len = self.queue.length;
              while (++i < len) {
                self.queue[i].callRejected(error);
              }
              return self;
            };

            function getThen(obj) {
              // Make sure we only access the accessor once as required by the spec
              var then = obj && obj.then;
              if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
                return function appyThen() {
                  then.apply(obj, arguments);
                };
              }
            }

            function safelyResolveThenable(self, thenable) {
              // Either fulfill, reject or reject with error
              var called = false;
              function onError(value) {
                if (called) {
                  return;
                }
                called = true;
                handlers.reject(self, value);
              }

              function onSuccess(value) {
                if (called) {
                  return;
                }
                called = true;
                handlers.resolve(self, value);
              }

              function tryToUnwrap() {
                thenable(onSuccess, onError);
              }

              var result = tryCatch(tryToUnwrap);
              if (result.status === 'error') {
                onError(result.value);
              }
            }

            function tryCatch(func, value) {
              var out = {};
              try {
                out.value = func(value);
                out.status = 'success';
              } catch (e) {
                out.status = 'error';
                out.value = e;
              }
              return out;
            }

            Promise.resolve = resolve;
            function resolve(value) {
              if (value instanceof this) {
                return value;
              }
              return handlers.resolve(new this(INTERNAL), value);
            }

            Promise.reject = reject;
            function reject(reason) {
              var promise = new this(INTERNAL);
              return handlers.reject(promise, reason);
            }

            Promise.all = all;
            function all(iterable) {
              var self = this;
              if (Object.prototype.toString.call(iterable) !== '[object Array]') {
                return this.reject(new TypeError('must be an array'));
              }

              var len = iterable.length;
              var called = false;
              if (!len) {
                return this.resolve([]);
              }

              var values = new Array(len);
              var resolved = 0;
              var i = -1;
              var promise = new this(INTERNAL);

              while (++i < len) {
                allResolver(iterable[i], i);
              }
              return promise;
              function allResolver(value, i) {
                self.resolve(value).then(resolveFromAll, function (error) {
                  if (!called) {
                    called = true;
                    handlers.reject(promise, error);
                  }
                });
                function resolveFromAll(outValue) {
                  values[i] = outValue;
                  if (++resolved === len && !called) {
                    called = true;
                    handlers.resolve(promise, values);
                  }
                }
              }
            }

            Promise.race = race;
            function race(iterable) {
              var self = this;
              if (Object.prototype.toString.call(iterable) !== '[object Array]') {
                return this.reject(new TypeError('must be an array'));
              }

              var len = iterable.length;
              var called = false;
              if (!len) {
                return this.resolve([]);
              }

              var i = -1;
              var promise = new this(INTERNAL);

              while (++i < len) {
                resolver(iterable[i]);
              }
              return promise;
              function resolver(value) {
                self.resolve(value).then(function (response) {
                  if (!called) {
                    called = true;
                    handlers.resolve(promise, response);
                  }
                }, function (error) {
                  if (!called) {
                    called = true;
                    handlers.reject(promise, error);
                  }
                });
              }
            }

            },{"1":1}],3:[function(_dereq_,module,exports){
            (function (global){
            if (typeof global.Promise !== 'function') {
              global.Promise = _dereq_(2);
            }

            }).call(this,typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
            },{"2":2}],4:[function(_dereq_,module,exports){

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function getIDB() {
                /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */
                try {
                    if (typeof indexedDB !== 'undefined') {
                        return indexedDB;
                    }
                    if (typeof webkitIndexedDB !== 'undefined') {
                        return webkitIndexedDB;
                    }
                    if (typeof mozIndexedDB !== 'undefined') {
                        return mozIndexedDB;
                    }
                    if (typeof OIndexedDB !== 'undefined') {
                        return OIndexedDB;
                    }
                    if (typeof msIndexedDB !== 'undefined') {
                        return msIndexedDB;
                    }
                } catch (e) {
                    return;
                }
            }

            var idb = getIDB();

            function isIndexedDBValid() {
                try {
                    // Initialize IndexedDB; fall back to vendor-prefixed versions
                    // if needed.
                    if (!idb || !idb.open) {
                        return false;
                    }
                    // We mimic PouchDB here;
                    //
                    // We test for openDatabase because IE Mobile identifies itself
                    // as Safari. Oh the lulz...
                    var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);

                    var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;

                    // Safari <10.1 does not meet our requirements for IDB support
                    // (see: https://github.com/pouchdb/pouchdb/issues/5572).
                    // Safari 10.1 shipped with fetch, we can use that to detect it.
                    // Note: this creates issues with `window.fetch` polyfills and
                    // overrides; see:
                    // https://github.com/localForage/localForage/issues/856
                    return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&
                    // some outdated implementations of IDB that appear on Samsung
                    // and HTC Android devices <4.4 are missing IDBKeyRange
                    // See: https://github.com/mozilla/localForage/issues/128
                    // See: https://github.com/mozilla/localForage/issues/272
                    typeof IDBKeyRange !== 'undefined';
                } catch (e) {
                    return false;
                }
            }

            // Abstracts constructing a Blob object, so it also works in older
            // browsers that don't support the native Blob constructor. (i.e.
            // old QtWebKit versions, at least).
            // Abstracts constructing a Blob object, so it also works in older
            // browsers that don't support the native Blob constructor. (i.e.
            // old QtWebKit versions, at least).
            function createBlob(parts, properties) {
                /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
                parts = parts || [];
                properties = properties || {};
                try {
                    return new Blob(parts, properties);
                } catch (e) {
                    if (e.name !== 'TypeError') {
                        throw e;
                    }
                    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;
                    var builder = new Builder();
                    for (var i = 0; i < parts.length; i += 1) {
                        builder.append(parts[i]);
                    }
                    return builder.getBlob(properties.type);
                }
            }

            // This is CommonJS because lie is an external dependency, so Rollup
            // can just ignore it.
            if (typeof Promise === 'undefined') {
                // In the "nopromises" build this will just throw if you don't have
                // a global promise object, but it would throw anyway later.
                _dereq_(3);
            }
            var Promise$1 = Promise;

            function executeCallback(promise, callback) {
                if (callback) {
                    promise.then(function (result) {
                        callback(null, result);
                    }, function (error) {
                        callback(error);
                    });
                }
            }

            function executeTwoCallbacks(promise, callback, errorCallback) {
                if (typeof callback === 'function') {
                    promise.then(callback);
                }

                if (typeof errorCallback === 'function') {
                    promise["catch"](errorCallback);
                }
            }

            function normalizeKey(key) {
                // Cast the key to a string, as that's all we can set as a key.
                if (typeof key !== 'string') {
                    console.warn(key + ' used as a key, but it is not a string.');
                    key = String(key);
                }

                return key;
            }

            function getCallback() {
                if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
                    return arguments[arguments.length - 1];
                }
            }

            // Some code originally from async_storage.js in
            // [Gaia](https://github.com/mozilla-b2g/gaia).

            var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
            var supportsBlobs = void 0;
            var dbContexts = {};
            var toString = Object.prototype.toString;

            // Transaction Modes
            var READ_ONLY = 'readonly';
            var READ_WRITE = 'readwrite';

            // Transform a binary string to an array buffer, because otherwise
            // weird stuff happens when you try to work with the binary string directly.
            // It is known.
            // From http://stackoverflow.com/questions/14967647/ (continues on next line)
            // encode-decode-image-with-base64-breaks-image (2013-04-21)
            function _binStringToArrayBuffer(bin) {
                var length = bin.length;
                var buf = new ArrayBuffer(length);
                var arr = new Uint8Array(buf);
                for (var i = 0; i < length; i++) {
                    arr[i] = bin.charCodeAt(i);
                }
                return buf;
            }

            //
            // Blobs are not supported in all versions of IndexedDB, notably
            // Chrome <37 and Android <5. In those versions, storing a blob will throw.
            //
            // Various other blob bugs exist in Chrome v37-42 (inclusive).
            // Detecting them is expensive and confusing to users, and Chrome 37-42
            // is at very low usage worldwide, so we do a hacky userAgent check instead.
            //
            // content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
            // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
            // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
            //
            // Code borrowed from PouchDB. See:
            // https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js
            //
            function _checkBlobSupportWithoutCaching(idb) {
                return new Promise$1(function (resolve) {
                    var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
                    var blob = createBlob(['']);
                    txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');

                    txn.onabort = function (e) {
                        // If the transaction aborts now its due to not being able to
                        // write to the database, likely due to the disk being full
                        e.preventDefault();
                        e.stopPropagation();
                        resolve(false);
                    };

                    txn.oncomplete = function () {
                        var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
                        var matchedEdge = navigator.userAgent.match(/Edge\//);
                        // MS Edge pretends to be Chrome 42:
                        // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
                        resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
                    };
                })["catch"](function () {
                    return false; // error, so assume unsupported
                });
            }

            function _checkBlobSupport(idb) {
                if (typeof supportsBlobs === 'boolean') {
                    return Promise$1.resolve(supportsBlobs);
                }
                return _checkBlobSupportWithoutCaching(idb).then(function (value) {
                    supportsBlobs = value;
                    return supportsBlobs;
                });
            }

            function _deferReadiness(dbInfo) {
                var dbContext = dbContexts[dbInfo.name];

                // Create a deferred object representing the current database operation.
                var deferredOperation = {};

                deferredOperation.promise = new Promise$1(function (resolve, reject) {
                    deferredOperation.resolve = resolve;
                    deferredOperation.reject = reject;
                });

                // Enqueue the deferred operation.
                dbContext.deferredOperations.push(deferredOperation);

                // Chain its promise to the database readiness.
                if (!dbContext.dbReady) {
                    dbContext.dbReady = deferredOperation.promise;
                } else {
                    dbContext.dbReady = dbContext.dbReady.then(function () {
                        return deferredOperation.promise;
                    });
                }
            }

            function _advanceReadiness(dbInfo) {
                var dbContext = dbContexts[dbInfo.name];

                // Dequeue a deferred operation.
                var deferredOperation = dbContext.deferredOperations.pop();

                // Resolve its promise (which is part of the database readiness
                // chain of promises).
                if (deferredOperation) {
                    deferredOperation.resolve();
                    return deferredOperation.promise;
                }
            }

            function _rejectReadiness(dbInfo, err) {
                var dbContext = dbContexts[dbInfo.name];

                // Dequeue a deferred operation.
                var deferredOperation = dbContext.deferredOperations.pop();

                // Reject its promise (which is part of the database readiness
                // chain of promises).
                if (deferredOperation) {
                    deferredOperation.reject(err);
                    return deferredOperation.promise;
                }
            }

            function _getConnection(dbInfo, upgradeNeeded) {
                return new Promise$1(function (resolve, reject) {
                    dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();

                    if (dbInfo.db) {
                        if (upgradeNeeded) {
                            _deferReadiness(dbInfo);
                            dbInfo.db.close();
                        } else {
                            return resolve(dbInfo.db);
                        }
                    }

                    var dbArgs = [dbInfo.name];

                    if (upgradeNeeded) {
                        dbArgs.push(dbInfo.version);
                    }

                    var openreq = idb.open.apply(idb, dbArgs);

                    if (upgradeNeeded) {
                        openreq.onupgradeneeded = function (e) {
                            var db = openreq.result;
                            try {
                                db.createObjectStore(dbInfo.storeName);
                                if (e.oldVersion <= 1) {
                                    // Added when support for blob shims was added
                                    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                                }
                            } catch (ex) {
                                if (ex.name === 'ConstraintError') {
                                    console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                                } else {
                                    throw ex;
                                }
                            }
                        };
                    }

                    openreq.onerror = function (e) {
                        e.preventDefault();
                        reject(openreq.error);
                    };

                    openreq.onsuccess = function () {
                        resolve(openreq.result);
                        _advanceReadiness(dbInfo);
                    };
                });
            }

            function _getOriginalConnection(dbInfo) {
                return _getConnection(dbInfo, false);
            }

            function _getUpgradedConnection(dbInfo) {
                return _getConnection(dbInfo, true);
            }

            function _isUpgradeNeeded(dbInfo, defaultVersion) {
                if (!dbInfo.db) {
                    return true;
                }

                var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
                var isDowngrade = dbInfo.version < dbInfo.db.version;
                var isUpgrade = dbInfo.version > dbInfo.db.version;

                if (isDowngrade) {
                    // If the version is not the default one
                    // then warn for impossible downgrade.
                    if (dbInfo.version !== defaultVersion) {
                        console.warn('The database "' + dbInfo.name + '"' + " can't be downgraded from version " + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
                    }
                    // Align the versions to prevent errors.
                    dbInfo.version = dbInfo.db.version;
                }

                if (isUpgrade || isNewStore) {
                    // If the store is new then increment the version (if needed).
                    // This will trigger an "upgradeneeded" event which is required
                    // for creating a store.
                    if (isNewStore) {
                        var incVersion = dbInfo.db.version + 1;
                        if (incVersion > dbInfo.version) {
                            dbInfo.version = incVersion;
                        }
                    }

                    return true;
                }

                return false;
            }

            // encode a blob for indexeddb engines that don't support blobs
            function _encodeBlob(blob) {
                return new Promise$1(function (resolve, reject) {
                    var reader = new FileReader();
                    reader.onerror = reject;
                    reader.onloadend = function (e) {
                        var base64 = btoa(e.target.result || '');
                        resolve({
                            __local_forage_encoded_blob: true,
                            data: base64,
                            type: blob.type
                        });
                    };
                    reader.readAsBinaryString(blob);
                });
            }

            // decode an encoded blob
            function _decodeBlob(encodedBlob) {
                var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
                return createBlob([arrayBuff], { type: encodedBlob.type });
            }

            // is this one of our fancy encoded blobs?
            function _isEncodedBlob(value) {
                return value && value.__local_forage_encoded_blob;
            }

            // Specialize the default `ready()` function by making it dependent
            // on the current database operations. Thus, the driver will be actually
            // ready when it's been initialized (default) *and* there are no pending
            // operations on the database (initiated by some other instances).
            function _fullyReady(callback) {
                var self = this;

                var promise = self._initReady().then(function () {
                    var dbContext = dbContexts[self._dbInfo.name];

                    if (dbContext && dbContext.dbReady) {
                        return dbContext.dbReady;
                    }
                });

                executeTwoCallbacks(promise, callback, callback);
                return promise;
            }

            // Try to establish a new db connection to replace the
            // current one which is broken (i.e. experiencing
            // InvalidStateError while creating a transaction).
            function _tryReconnect(dbInfo) {
                _deferReadiness(dbInfo);

                var dbContext = dbContexts[dbInfo.name];
                var forages = dbContext.forages;

                for (var i = 0; i < forages.length; i++) {
                    var forage = forages[i];
                    if (forage._dbInfo.db) {
                        forage._dbInfo.db.close();
                        forage._dbInfo.db = null;
                    }
                }
                dbInfo.db = null;

                return _getOriginalConnection(dbInfo).then(function (db) {
                    dbInfo.db = db;
                    if (_isUpgradeNeeded(dbInfo)) {
                        // Reopen the database for upgrading.
                        return _getUpgradedConnection(dbInfo);
                    }
                    return db;
                }).then(function (db) {
                    // store the latest db reference
                    // in case the db was upgraded
                    dbInfo.db = dbContext.db = db;
                    for (var i = 0; i < forages.length; i++) {
                        forages[i]._dbInfo.db = db;
                    }
                })["catch"](function (err) {
                    _rejectReadiness(dbInfo, err);
                    throw err;
                });
            }

            // FF doesn't like Promises (micro-tasks) and IDDB store operations,
            // so we have to do it with callbacks
            function createTransaction(dbInfo, mode, callback, retries) {
                if (retries === undefined) {
                    retries = 1;
                }

                try {
                    var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
                    callback(null, tx);
                } catch (err) {
                    if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {
                        return Promise$1.resolve().then(function () {
                            if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                                // increase the db version, to create the new ObjectStore
                                if (dbInfo.db) {
                                    dbInfo.version = dbInfo.db.version + 1;
                                }
                                // Reopen the database for upgrading.
                                return _getUpgradedConnection(dbInfo);
                            }
                        }).then(function () {
                            return _tryReconnect(dbInfo).then(function () {
                                createTransaction(dbInfo, mode, callback, retries - 1);
                            });
                        })["catch"](callback);
                    }

                    callback(err);
                }
            }

            function createDbContext() {
                return {
                    // Running localForages sharing a database.
                    forages: [],
                    // Shared database.
                    db: null,
                    // Database readiness (promise).
                    dbReady: null,
                    // Deferred operations on the database.
                    deferredOperations: []
                };
            }

            // Open the IndexedDB database (automatically creates one if one didn't
            // previously exist), using any options set in the config.
            function _initStorage(options) {
                var self = this;
                var dbInfo = {
                    db: null
                };

                if (options) {
                    for (var i in options) {
                        dbInfo[i] = options[i];
                    }
                }

                // Get the current context of the database;
                var dbContext = dbContexts[dbInfo.name];

                // ...or create a new context.
                if (!dbContext) {
                    dbContext = createDbContext();
                    // Register the new context in the global container.
                    dbContexts[dbInfo.name] = dbContext;
                }

                // Register itself as a running localForage in the current context.
                dbContext.forages.push(self);

                // Replace the default `ready()` function with the specialized one.
                if (!self._initReady) {
                    self._initReady = self.ready;
                    self.ready = _fullyReady;
                }

                // Create an array of initialization states of the related localForages.
                var initPromises = [];

                function ignoreErrors() {
                    // Don't handle errors here,
                    // just makes sure related localForages aren't pending.
                    return Promise$1.resolve();
                }

                for (var j = 0; j < dbContext.forages.length; j++) {
                    var forage = dbContext.forages[j];
                    if (forage !== self) {
                        // Don't wait for itself...
                        initPromises.push(forage._initReady()["catch"](ignoreErrors));
                    }
                }

                // Take a snapshot of the related localForages.
                var forages = dbContext.forages.slice(0);

                // Initialize the connection process only when
                // all the related localForages aren't pending.
                return Promise$1.all(initPromises).then(function () {
                    dbInfo.db = dbContext.db;
                    // Get the connection or open a new one without upgrade.
                    return _getOriginalConnection(dbInfo);
                }).then(function (db) {
                    dbInfo.db = db;
                    if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
                        // Reopen the database for upgrading.
                        return _getUpgradedConnection(dbInfo);
                    }
                    return db;
                }).then(function (db) {
                    dbInfo.db = dbContext.db = db;
                    self._dbInfo = dbInfo;
                    // Share the final connection amongst related localForages.
                    for (var k = 0; k < forages.length; k++) {
                        var forage = forages[k];
                        if (forage !== self) {
                            // Self is already up-to-date.
                            forage._dbInfo.db = dbInfo.db;
                            forage._dbInfo.version = dbInfo.version;
                        }
                    }
                });
            }

            function getItem(key, callback) {
                var self = this;

                key = normalizeKey(key);

                var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                        createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                            if (err) {
                                return reject(err);
                            }

                            try {
                                var store = transaction.objectStore(self._dbInfo.storeName);
                                var req = store.get(key);

                                req.onsuccess = function () {
                                    var value = req.result;
                                    if (value === undefined) {
                                        value = null;
                                    }
                                    if (_isEncodedBlob(value)) {
                                        value = _decodeBlob(value);
                                    }
                                    resolve(value);
                                };

                                req.onerror = function () {
                                    reject(req.error);
                                };
                            } catch (e) {
                                reject(e);
                            }
                        });
                    })["catch"](reject);
                });

                executeCallback(promise, callback);
                return promise;
            }

            // Iterate over all items stored in database.
            function iterate(iterator, callback) {
                var self = this;

                var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                        createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                            if (err) {
                                return reject(err);
                            }

                            try {
                                var store = transaction.objectStore(self._dbInfo.storeName);
                                var req = store.openCursor();
                                var iterationNumber = 1;

                                req.onsuccess = function () {
                                    var cursor = req.result;

                                    if (cursor) {
                                        var value = cursor.value;
                                        if (_isEncodedBlob(value)) {
                                            value = _decodeBlob(value);
                                        }
                                        var result = iterator(value, cursor.key, iterationNumber++);

                                        // when the iterator callback returns any
                                        // (non-`undefined`) value, then we stop
                                        // the iteration immediately
                                        if (result !== void 0) {
                                            resolve(result);
                                        } else {
                                            cursor["continue"]();
                                        }
                                    } else {
                                        resolve();
                                    }
                                };

                                req.onerror = function () {
                                    reject(req.error);
                                };
                            } catch (e) {
                                reject(e);
                            }
                        });
                    })["catch"](reject);
                });

                executeCallback(promise, callback);

                return promise;
            }

            function setItem(key, value, callback) {
                var self = this;

                key = normalizeKey(key);

                var promise = new Promise$1(function (resolve, reject) {
                    var dbInfo;
                    self.ready().then(function () {
                        dbInfo = self._dbInfo;
                        if (toString.call(value) === '[object Blob]') {
                            return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {
                                if (blobSupport) {
                                    return value;
                                }
                                return _encodeBlob(value);
                            });
                        }
                        return value;
                    }).then(function (value) {
                        createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                            if (err) {
                                return reject(err);
                            }

                            try {
                                var store = transaction.objectStore(self._dbInfo.storeName);

                                // The reason we don't _save_ null is because IE 10 does
                                // not support saving the `null` type in IndexedDB. How
                                // ironic, given the bug below!
                                // See: https://github.com/mozilla/localForage/issues/161
                                if (value === null) {
                                    value = undefined;
                                }

                                var req = store.put(value, key);

                                transaction.oncomplete = function () {
                                    // Cast to undefined so the value passed to
                                    // callback/promise is the same as what one would get out
                                    // of `getItem()` later. This leads to some weirdness
                                    // (setItem('foo', undefined) will return `null`), but
                                    // it's not my fault localStorage is our baseline and that
                                    // it's weird.
                                    if (value === undefined) {
                                        value = null;
                                    }

                                    resolve(value);
                                };
                                transaction.onabort = transaction.onerror = function () {
                                    var err = req.error ? req.error : req.transaction.error;
                                    reject(err);
                                };
                            } catch (e) {
                                reject(e);
                            }
                        });
                    })["catch"](reject);
                });

                executeCallback(promise, callback);
                return promise;
            }

            function removeItem(key, callback) {
                var self = this;

                key = normalizeKey(key);

                var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                        createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                            if (err) {
                                return reject(err);
                            }

                            try {
                                var store = transaction.objectStore(self._dbInfo.storeName);
                                // We use a Grunt task to make this safe for IE and some
                                // versions of Android (including those used by Cordova).
                                // Normally IE won't like `.delete()` and will insist on
                                // using `['delete']()`, but we have a build step that
                                // fixes this for us now.
                                var req = store["delete"](key);
                                transaction.oncomplete = function () {
                                    resolve();
                                };

                                transaction.onerror = function () {
                                    reject(req.error);
                                };

                                // The request will be also be aborted if we've exceeded our storage
                                // space.
                                transaction.onabort = function () {
                                    var err = req.error ? req.error : req.transaction.error;
                                    reject(err);
                                };
                            } catch (e) {
                                reject(e);
                            }
                        });
                    })["catch"](reject);
                });

                executeCallback(promise, callback);
                return promise;
            }

            function clear(callback) {
                var self = this;

                var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                        createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                            if (err) {
                                return reject(err);
                            }

                            try {
                                var store = transaction.objectStore(self._dbInfo.storeName);
                                var req = store.clear();

                                transaction.oncomplete = function () {
                                    resolve();
                                };

                                transaction.onabort = transaction.onerror = function () {
                                    var err = req.error ? req.error : req.transaction.error;
                                    reject(err);
                                };
                            } catch (e) {
                                reject(e);
                            }
                        });
                    })["catch"](reject);
                });

                executeCallback(promise, callback);
                return promise;
            }

            function length(callback) {
                var self = this;

                var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                        createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                            if (err) {
                                return reject(err);
                            }

                            try {
                                var store = transaction.objectStore(self._dbInfo.storeName);
                                var req = store.count();

                                req.onsuccess = function () {
                                    resolve(req.result);
                                };

                                req.onerror = function () {
                                    reject(req.error);
                                };
                            } catch (e) {
                                reject(e);
                            }
                        });
                    })["catch"](reject);
                });

                executeCallback(promise, callback);
                return promise;
            }

            function key(n, callback) {
                var self = this;

                var promise = new Promise$1(function (resolve, reject) {
                    if (n < 0) {
                        resolve(null);

                        return;
                    }

                    self.ready().then(function () {
                        createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                            if (err) {
                                return reject(err);
                            }

                            try {
                                var store = transaction.objectStore(self._dbInfo.storeName);
                                var advanced = false;
                                var req = store.openKeyCursor();

                                req.onsuccess = function () {
                                    var cursor = req.result;
                                    if (!cursor) {
                                        // this means there weren't enough keys
                                        resolve(null);

                                        return;
                                    }

                                    if (n === 0) {
                                        // We have the first key, return it if that's what they
                                        // wanted.
                                        resolve(cursor.key);
                                    } else {
                                        if (!advanced) {
                                            // Otherwise, ask the cursor to skip ahead n
                                            // records.
                                            advanced = true;
                                            cursor.advance(n);
                                        } else {
                                            // When we get here, we've got the nth key.
                                            resolve(cursor.key);
                                        }
                                    }
                                };

                                req.onerror = function () {
                                    reject(req.error);
                                };
                            } catch (e) {
                                reject(e);
                            }
                        });
                    })["catch"](reject);
                });

                executeCallback(promise, callback);
                return promise;
            }

            function keys(callback) {
                var self = this;

                var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                        createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                            if (err) {
                                return reject(err);
                            }

                            try {
                                var store = transaction.objectStore(self._dbInfo.storeName);
                                var req = store.openKeyCursor();
                                var keys = [];

                                req.onsuccess = function () {
                                    var cursor = req.result;

                                    if (!cursor) {
                                        resolve(keys);
                                        return;
                                    }

                                    keys.push(cursor.key);
                                    cursor["continue"]();
                                };

                                req.onerror = function () {
                                    reject(req.error);
                                };
                            } catch (e) {
                                reject(e);
                            }
                        });
                    })["catch"](reject);
                });

                executeCallback(promise, callback);
                return promise;
            }

            function dropInstance(options, callback) {
                callback = getCallback.apply(this, arguments);

                var currentConfig = this.config();
                options = typeof options !== 'function' && options || {};
                if (!options.name) {
                    options.name = options.name || currentConfig.name;
                    options.storeName = options.storeName || currentConfig.storeName;
                }

                var self = this;
                var promise;
                if (!options.name) {
                    promise = Promise$1.reject('Invalid arguments');
                } else {
                    var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;

                    var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {
                        var dbContext = dbContexts[options.name];
                        var forages = dbContext.forages;
                        dbContext.db = db;
                        for (var i = 0; i < forages.length; i++) {
                            forages[i]._dbInfo.db = db;
                        }
                        return db;
                    });

                    if (!options.storeName) {
                        promise = dbPromise.then(function (db) {
                            _deferReadiness(options);

                            var dbContext = dbContexts[options.name];
                            var forages = dbContext.forages;

                            db.close();
                            for (var i = 0; i < forages.length; i++) {
                                var forage = forages[i];
                                forage._dbInfo.db = null;
                            }

                            var dropDBPromise = new Promise$1(function (resolve, reject) {
                                var req = idb.deleteDatabase(options.name);

                                req.onerror = req.onblocked = function (err) {
                                    var db = req.result;
                                    if (db) {
                                        db.close();
                                    }
                                    reject(err);
                                };

                                req.onsuccess = function () {
                                    var db = req.result;
                                    if (db) {
                                        db.close();
                                    }
                                    resolve(db);
                                };
                            });

                            return dropDBPromise.then(function (db) {
                                dbContext.db = db;
                                for (var i = 0; i < forages.length; i++) {
                                    var _forage = forages[i];
                                    _advanceReadiness(_forage._dbInfo);
                                }
                            })["catch"](function (err) {
                                (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                                throw err;
                            });
                        });
                    } else {
                        promise = dbPromise.then(function (db) {
                            if (!db.objectStoreNames.contains(options.storeName)) {
                                return;
                            }

                            var newVersion = db.version + 1;

                            _deferReadiness(options);

                            var dbContext = dbContexts[options.name];
                            var forages = dbContext.forages;

                            db.close();
                            for (var i = 0; i < forages.length; i++) {
                                var forage = forages[i];
                                forage._dbInfo.db = null;
                                forage._dbInfo.version = newVersion;
                            }

                            var dropObjectPromise = new Promise$1(function (resolve, reject) {
                                var req = idb.open(options.name, newVersion);

                                req.onerror = function (err) {
                                    var db = req.result;
                                    db.close();
                                    reject(err);
                                };

                                req.onupgradeneeded = function () {
                                    var db = req.result;
                                    db.deleteObjectStore(options.storeName);
                                };

                                req.onsuccess = function () {
                                    var db = req.result;
                                    db.close();
                                    resolve(db);
                                };
                            });

                            return dropObjectPromise.then(function (db) {
                                dbContext.db = db;
                                for (var j = 0; j < forages.length; j++) {
                                    var _forage2 = forages[j];
                                    _forage2._dbInfo.db = db;
                                    _advanceReadiness(_forage2._dbInfo);
                                }
                            })["catch"](function (err) {
                                (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                                throw err;
                            });
                        });
                    }
                }

                executeCallback(promise, callback);
                return promise;
            }

            var asyncStorage = {
                _driver: 'asyncStorage',
                _initStorage: _initStorage,
                _support: isIndexedDBValid(),
                iterate: iterate,
                getItem: getItem,
                setItem: setItem,
                removeItem: removeItem,
                clear: clear,
                length: length,
                key: key,
                keys: keys,
                dropInstance: dropInstance
            };

            function isWebSQLValid() {
                return typeof openDatabase === 'function';
            }

            // Sadly, the best way to save binary data in WebSQL/localStorage is serializing
            // it to Base64, so this is how we store it to prevent very strange errors with less
            // verbose ways of binary <-> string data storage.
            var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

            var BLOB_TYPE_PREFIX = '~~local_forage_type~';
            var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;

            var SERIALIZED_MARKER = '__lfsc__:';
            var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;

            // OMG the serializations!
            var TYPE_ARRAYBUFFER = 'arbf';
            var TYPE_BLOB = 'blob';
            var TYPE_INT8ARRAY = 'si08';
            var TYPE_UINT8ARRAY = 'ui08';
            var TYPE_UINT8CLAMPEDARRAY = 'uic8';
            var TYPE_INT16ARRAY = 'si16';
            var TYPE_INT32ARRAY = 'si32';
            var TYPE_UINT16ARRAY = 'ur16';
            var TYPE_UINT32ARRAY = 'ui32';
            var TYPE_FLOAT32ARRAY = 'fl32';
            var TYPE_FLOAT64ARRAY = 'fl64';
            var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;

            var toString$1 = Object.prototype.toString;

            function stringToBuffer(serializedString) {
                // Fill the string into a ArrayBuffer.
                var bufferLength = serializedString.length * 0.75;
                var len = serializedString.length;
                var i;
                var p = 0;
                var encoded1, encoded2, encoded3, encoded4;

                if (serializedString[serializedString.length - 1] === '=') {
                    bufferLength--;
                    if (serializedString[serializedString.length - 2] === '=') {
                        bufferLength--;
                    }
                }

                var buffer = new ArrayBuffer(bufferLength);
                var bytes = new Uint8Array(buffer);

                for (i = 0; i < len; i += 4) {
                    encoded1 = BASE_CHARS.indexOf(serializedString[i]);
                    encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
                    encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
                    encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);

                    /*jslint bitwise: true */
                    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
                    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
                    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
                }
                return buffer;
            }

            // Converts a buffer to a string to store, serialized, in the backend
            // storage library.
            function bufferToString(buffer) {
                // base64-arraybuffer
                var bytes = new Uint8Array(buffer);
                var base64String = '';
                var i;

                for (i = 0; i < bytes.length; i += 3) {
                    /*jslint bitwise: true */
                    base64String += BASE_CHARS[bytes[i] >> 2];
                    base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
                    base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
                    base64String += BASE_CHARS[bytes[i + 2] & 63];
                }

                if (bytes.length % 3 === 2) {
                    base64String = base64String.substring(0, base64String.length - 1) + '=';
                } else if (bytes.length % 3 === 1) {
                    base64String = base64String.substring(0, base64String.length - 2) + '==';
                }

                return base64String;
            }

            // Serialize a value, afterwards executing a callback (which usually
            // instructs the `setItem()` callback/promise to be executed). This is how
            // we store binary data with localStorage.
            function serialize(value, callback) {
                var valueType = '';
                if (value) {
                    valueType = toString$1.call(value);
                }

                // Cannot use `value instanceof ArrayBuffer` or such here, as these
                // checks fail when running the tests using casper.js...
                //
                // TODO: See why those tests fail and use a better solution.
                if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {
                    // Convert binary arrays to a string and prefix the string with
                    // a special marker.
                    var buffer;
                    var marker = SERIALIZED_MARKER;

                    if (value instanceof ArrayBuffer) {
                        buffer = value;
                        marker += TYPE_ARRAYBUFFER;
                    } else {
                        buffer = value.buffer;

                        if (valueType === '[object Int8Array]') {
                            marker += TYPE_INT8ARRAY;
                        } else if (valueType === '[object Uint8Array]') {
                            marker += TYPE_UINT8ARRAY;
                        } else if (valueType === '[object Uint8ClampedArray]') {
                            marker += TYPE_UINT8CLAMPEDARRAY;
                        } else if (valueType === '[object Int16Array]') {
                            marker += TYPE_INT16ARRAY;
                        } else if (valueType === '[object Uint16Array]') {
                            marker += TYPE_UINT16ARRAY;
                        } else if (valueType === '[object Int32Array]') {
                            marker += TYPE_INT32ARRAY;
                        } else if (valueType === '[object Uint32Array]') {
                            marker += TYPE_UINT32ARRAY;
                        } else if (valueType === '[object Float32Array]') {
                            marker += TYPE_FLOAT32ARRAY;
                        } else if (valueType === '[object Float64Array]') {
                            marker += TYPE_FLOAT64ARRAY;
                        } else {
                            callback(new Error('Failed to get type for BinaryArray'));
                        }
                    }

                    callback(marker + bufferToString(buffer));
                } else if (valueType === '[object Blob]') {
                    // Conver the blob to a binaryArray and then to a string.
                    var fileReader = new FileReader();

                    fileReader.onload = function () {
                        // Backwards-compatible prefix for the blob type.
                        var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);

                        callback(SERIALIZED_MARKER + TYPE_BLOB + str);
                    };

                    fileReader.readAsArrayBuffer(value);
                } else {
                    try {
                        callback(JSON.stringify(value));
                    } catch (e) {
                        console.error("Couldn't convert value into a JSON string: ", value);

                        callback(null, e);
                    }
                }
            }

            // Deserialize data we've inserted into a value column/field. We place
            // special markers into our strings to mark them as encoded; this isn't
            // as nice as a meta field, but it's the only sane thing we can do whilst
            // keeping localStorage support intact.
            //
            // Oftentimes this will just deserialize JSON content, but if we have a
            // special marker (SERIALIZED_MARKER, defined above), we will extract
            // some kind of arraybuffer/binary data/typed array out of the string.
            function deserialize(value) {
                // If we haven't marked this string as being specially serialized (i.e.
                // something other than serialized JSON), we can just return it and be
                // done with it.
                if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
                    return JSON.parse(value);
                }

                // The following code deals with deserializing some kind of Blob or
                // TypedArray. First we separate out the type of data we're dealing
                // with from the data itself.
                var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
                var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);

                var blobType;
                // Backwards-compatible blob type serialization strategy.
                // DBs created with older versions of localForage will simply not have the blob type.
                if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
                    var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
                    blobType = matcher[1];
                    serializedString = serializedString.substring(matcher[0].length);
                }
                var buffer = stringToBuffer(serializedString);

                // Return the right type based on the code/type set during
                // serialization.
                switch (type) {
                    case TYPE_ARRAYBUFFER:
                        return buffer;
                    case TYPE_BLOB:
                        return createBlob([buffer], { type: blobType });
                    case TYPE_INT8ARRAY:
                        return new Int8Array(buffer);
                    case TYPE_UINT8ARRAY:
                        return new Uint8Array(buffer);
                    case TYPE_UINT8CLAMPEDARRAY:
                        return new Uint8ClampedArray(buffer);
                    case TYPE_INT16ARRAY:
                        return new Int16Array(buffer);
                    case TYPE_UINT16ARRAY:
                        return new Uint16Array(buffer);
                    case TYPE_INT32ARRAY:
                        return new Int32Array(buffer);
                    case TYPE_UINT32ARRAY:
                        return new Uint32Array(buffer);
                    case TYPE_FLOAT32ARRAY:
                        return new Float32Array(buffer);
                    case TYPE_FLOAT64ARRAY:
                        return new Float64Array(buffer);
                    default:
                        throw new Error('Unkown type: ' + type);
                }
            }

            var localforageSerializer = {
                serialize: serialize,
                deserialize: deserialize,
                stringToBuffer: stringToBuffer,
                bufferToString: bufferToString
            };

            /*
             * Includes code from:
             *
             * base64-arraybuffer
             * https://github.com/niklasvh/base64-arraybuffer
             *
             * Copyright (c) 2012 Niklas von Hertzen
             * Licensed under the MIT license.
             */

            function createDbTable(t, dbInfo, callback, errorCallback) {
                t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);
            }

            // Open the WebSQL database (automatically creates one if one didn't
            // previously exist), using any options set in the config.
            function _initStorage$1(options) {
                var self = this;
                var dbInfo = {
                    db: null
                };

                if (options) {
                    for (var i in options) {
                        dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
                    }
                }

                var dbInfoPromise = new Promise$1(function (resolve, reject) {
                    // Open the database; the openDatabase API will automatically
                    // create it for us if it doesn't exist.
                    try {
                        dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
                    } catch (e) {
                        return reject(e);
                    }

                    // Create our key/value table if it doesn't exist.
                    dbInfo.db.transaction(function (t) {
                        createDbTable(t, dbInfo, function () {
                            self._dbInfo = dbInfo;
                            resolve();
                        }, function (t, error) {
                            reject(error);
                        });
                    }, reject);
                });

                dbInfo.serializer = localforageSerializer;
                return dbInfoPromise;
            }

            function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
                t.executeSql(sqlStatement, args, callback, function (t, error) {
                    if (error.code === error.SYNTAX_ERR) {
                        t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name = ?", [dbInfo.storeName], function (t, results) {
                            if (!results.rows.length) {
                                // if the table is missing (was deleted)
                                // re-create it table and retry
                                createDbTable(t, dbInfo, function () {
                                    t.executeSql(sqlStatement, args, callback, errorCallback);
                                }, errorCallback);
                            } else {
                                errorCallback(t, error);
                            }
                        }, errorCallback);
                    } else {
                        errorCallback(t, error);
                    }
                }, errorCallback);
            }

            function getItem$1(key, callback) {
                var self = this;

                key = normalizeKey(key);

                var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                        var dbInfo = self._dbInfo;
                        dbInfo.db.transaction(function (t) {
                            tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {
                                var result = results.rows.length ? results.rows.item(0).value : null;

                                // Check to see if this is serialized content we need to
                                // unpack.
                                if (result) {
                                    result = dbInfo.serializer.deserialize(result);
                                }

                                resolve(result);
                            }, function (t, error) {
                                reject(error);
                            });
                        });
                    })["catch"](reject);
                });

                executeCallback(promise, callback);
                return promise;
            }

            function iterate$1(iterator, callback) {
                var self = this;

                var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                        var dbInfo = self._dbInfo;

                        dbInfo.db.transaction(function (t) {
                            tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {
                                var rows = results.rows;
                                var length = rows.length;

                                for (var i = 0; i < length; i++) {
                                    var item = rows.item(i);
                                    var result = item.value;

                                    // Check to see if this is serialized content
                                    // we need to unpack.
                                    if (result) {
                                        result = dbInfo.serializer.deserialize(result);
                                    }

                                    result = iterator(result, item.key, i + 1);

                                    // void(0) prevents problems with redefinition
                                    // of `undefined`.
                                    if (result !== void 0) {
                                        resolve(result);
                                        return;
                                    }
                                }

                                resolve();
                            }, function (t, error) {
                                reject(error);
                            });
                        });
                    })["catch"](reject);
                });

                executeCallback(promise, callback);
                return promise;
            }

            function _setItem(key, value, callback, retriesLeft) {
                var self = this;

                key = normalizeKey(key);

                var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                        // The localStorage API doesn't return undefined values in an
                        // "expected" way, so undefined is always cast to null in all
                        // drivers. See: https://github.com/mozilla/localForage/pull/42
                        if (value === undefined) {
                            value = null;
                        }

                        // Save the original value to pass to the callback.
                        var originalValue = value;

                        var dbInfo = self._dbInfo;
                        dbInfo.serializer.serialize(value, function (value, error) {
                            if (error) {
                                reject(error);
                            } else {
                                dbInfo.db.transaction(function (t) {
                                    tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {
                                        resolve(originalValue);
                                    }, function (t, error) {
                                        reject(error);
                                    });
                                }, function (sqlError) {
                                    // The transaction failed; check
                                    // to see if it's a quota error.
                                    if (sqlError.code === sqlError.QUOTA_ERR) {
                                        // We reject the callback outright for now, but
                                        // it's worth trying to re-run the transaction.
                                        // Even if the user accepts the prompt to use
                                        // more storage on Safari, this error will
                                        // be called.
                                        //
                                        // Try to re-run the transaction.
                                        if (retriesLeft > 0) {
                                            resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));
                                            return;
                                        }
                                        reject(sqlError);
                                    }
                                });
                            }
                        });
                    })["catch"](reject);
                });

                executeCallback(promise, callback);
                return promise;
            }

            function setItem$1(key, value, callback) {
                return _setItem.apply(this, [key, value, callback, 1]);
            }

            function removeItem$1(key, callback) {
                var self = this;

                key = normalizeKey(key);

                var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                        var dbInfo = self._dbInfo;
                        dbInfo.db.transaction(function (t) {
                            tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {
                                resolve();
                            }, function (t, error) {
                                reject(error);
                            });
                        });
                    })["catch"](reject);
                });

                executeCallback(promise, callback);
                return promise;
            }

            // Deletes every item in the table.
            // TODO: Find out if this resets the AUTO_INCREMENT number.
            function clear$1(callback) {
                var self = this;

                var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                        var dbInfo = self._dbInfo;
                        dbInfo.db.transaction(function (t) {
                            tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {
                                resolve();
                            }, function (t, error) {
                                reject(error);
                            });
                        });
                    })["catch"](reject);
                });

                executeCallback(promise, callback);
                return promise;
            }

            // Does a simple `COUNT(key)` to get the number of items stored in
            // localForage.
            function length$1(callback) {
                var self = this;

                var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                        var dbInfo = self._dbInfo;
                        dbInfo.db.transaction(function (t) {
                            // Ahhh, SQL makes this one soooooo easy.
                            tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {
                                var result = results.rows.item(0).c;
                                resolve(result);
                            }, function (t, error) {
                                reject(error);
                            });
                        });
                    })["catch"](reject);
                });

                executeCallback(promise, callback);
                return promise;
            }

            // Return the key located at key index X; essentially gets the key from a
            // `WHERE id = ?`. This is the most efficient way I can think to implement
            // this rarely-used (in my experience) part of the API, but it can seem
            // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
            // the ID of each key will change every time it's updated. Perhaps a stored
            // procedure for the `setItem()` SQL would solve this problem?
            // TODO: Don't change ID on `setItem()`.
            function key$1(n, callback) {
                var self = this;

                var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                        var dbInfo = self._dbInfo;
                        dbInfo.db.transaction(function (t) {
                            tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {
                                var result = results.rows.length ? results.rows.item(0).key : null;
                                resolve(result);
                            }, function (t, error) {
                                reject(error);
                            });
                        });
                    })["catch"](reject);
                });

                executeCallback(promise, callback);
                return promise;
            }

            function keys$1(callback) {
                var self = this;

                var promise = new Promise$1(function (resolve, reject) {
                    self.ready().then(function () {
                        var dbInfo = self._dbInfo;
                        dbInfo.db.transaction(function (t) {
                            tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {
                                var keys = [];

                                for (var i = 0; i < results.rows.length; i++) {
                                    keys.push(results.rows.item(i).key);
                                }

                                resolve(keys);
                            }, function (t, error) {
                                reject(error);
                            });
                        });
                    })["catch"](reject);
                });

                executeCallback(promise, callback);
                return promise;
            }

            // https://www.w3.org/TR/webdatabase/#databases
            // > There is no way to enumerate or delete the databases available for an origin from this API.
            function getAllStoreNames(db) {
                return new Promise$1(function (resolve, reject) {
                    db.transaction(function (t) {
                        t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (t, results) {
                            var storeNames = [];

                            for (var i = 0; i < results.rows.length; i++) {
                                storeNames.push(results.rows.item(i).name);
                            }

                            resolve({
                                db: db,
                                storeNames: storeNames
                            });
                        }, function (t, error) {
                            reject(error);
                        });
                    }, function (sqlError) {
                        reject(sqlError);
                    });
                });
            }

            function dropInstance$1(options, callback) {
                callback = getCallback.apply(this, arguments);

                var currentConfig = this.config();
                options = typeof options !== 'function' && options || {};
                if (!options.name) {
                    options.name = options.name || currentConfig.name;
                    options.storeName = options.storeName || currentConfig.storeName;
                }

                var self = this;
                var promise;
                if (!options.name) {
                    promise = Promise$1.reject('Invalid arguments');
                } else {
                    promise = new Promise$1(function (resolve) {
                        var db;
                        if (options.name === currentConfig.name) {
                            // use the db reference of the current instance
                            db = self._dbInfo.db;
                        } else {
                            db = openDatabase(options.name, '', '', 0);
                        }

                        if (!options.storeName) {
                            // drop all database tables
                            resolve(getAllStoreNames(db));
                        } else {
                            resolve({
                                db: db,
                                storeNames: [options.storeName]
                            });
                        }
                    }).then(function (operationInfo) {
                        return new Promise$1(function (resolve, reject) {
                            operationInfo.db.transaction(function (t) {
                                function dropTable(storeName) {
                                    return new Promise$1(function (resolve, reject) {
                                        t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {
                                            resolve();
                                        }, function (t, error) {
                                            reject(error);
                                        });
                                    });
                                }

                                var operations = [];
                                for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                                    operations.push(dropTable(operationInfo.storeNames[i]));
                                }

                                Promise$1.all(operations).then(function () {
                                    resolve();
                                })["catch"](function (e) {
                                    reject(e);
                                });
                            }, function (sqlError) {
                                reject(sqlError);
                            });
                        });
                    });
                }

                executeCallback(promise, callback);
                return promise;
            }

            var webSQLStorage = {
                _driver: 'webSQLStorage',
                _initStorage: _initStorage$1,
                _support: isWebSQLValid(),
                iterate: iterate$1,
                getItem: getItem$1,
                setItem: setItem$1,
                removeItem: removeItem$1,
                clear: clear$1,
                length: length$1,
                key: key$1,
                keys: keys$1,
                dropInstance: dropInstance$1
            };

            function isLocalStorageValid() {
                try {
                    return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&
                    // in IE8 typeof localStorage.setItem === 'object'
                    !!localStorage.setItem;
                } catch (e) {
                    return false;
                }
            }

            function _getKeyPrefix(options, defaultConfig) {
                var keyPrefix = options.name + '/';

                if (options.storeName !== defaultConfig.storeName) {
                    keyPrefix += options.storeName + '/';
                }
                return keyPrefix;
            }

            // Check if localStorage throws when saving an item
            function checkIfLocalStorageThrows() {
                var localStorageTestKey = '_localforage_support_test';

                try {
                    localStorage.setItem(localStorageTestKey, true);
                    localStorage.removeItem(localStorageTestKey);

                    return false;
                } catch (e) {
                    return true;
                }
            }

            // Check if localStorage is usable and allows to save an item
            // This method checks if localStorage is usable in Safari Private Browsing
            // mode, or in any other case where the available quota for localStorage
            // is 0 and there wasn't any saved items yet.
            function _isLocalStorageUsable() {
                return !checkIfLocalStorageThrows() || localStorage.length > 0;
            }

            // Config the localStorage backend, using options set in the config.
            function _initStorage$2(options) {
                var self = this;
                var dbInfo = {};
                if (options) {
                    for (var i in options) {
                        dbInfo[i] = options[i];
                    }
                }

                dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);

                if (!_isLocalStorageUsable()) {
                    return Promise$1.reject();
                }

                self._dbInfo = dbInfo;
                dbInfo.serializer = localforageSerializer;

                return Promise$1.resolve();
            }

            // Remove all keys from the datastore, effectively destroying all data in
            // the app's key/value store!
            function clear$2(callback) {
                var self = this;
                var promise = self.ready().then(function () {
                    var keyPrefix = self._dbInfo.keyPrefix;

                    for (var i = localStorage.length - 1; i >= 0; i--) {
                        var key = localStorage.key(i);

                        if (key.indexOf(keyPrefix) === 0) {
                            localStorage.removeItem(key);
                        }
                    }
                });

                executeCallback(promise, callback);
                return promise;
            }

            // Retrieve an item from the store. Unlike the original async_storage
            // library in Gaia, we don't modify return values at all. If a key's value
            // is `undefined`, we pass that value to the callback function.
            function getItem$2(key, callback) {
                var self = this;

                key = normalizeKey(key);

                var promise = self.ready().then(function () {
                    var dbInfo = self._dbInfo;
                    var result = localStorage.getItem(dbInfo.keyPrefix + key);

                    // If a result was found, parse it from the serialized
                    // string into a JS object. If result isn't truthy, the key
                    // is likely undefined and we'll pass it straight to the
                    // callback.
                    if (result) {
                        result = dbInfo.serializer.deserialize(result);
                    }

                    return result;
                });

                executeCallback(promise, callback);
                return promise;
            }

            // Iterate over all items in the store.
            function iterate$2(iterator, callback) {
                var self = this;

                var promise = self.ready().then(function () {
                    var dbInfo = self._dbInfo;
                    var keyPrefix = dbInfo.keyPrefix;
                    var keyPrefixLength = keyPrefix.length;
                    var length = localStorage.length;

                    // We use a dedicated iterator instead of the `i` variable below
                    // so other keys we fetch in localStorage aren't counted in
                    // the `iterationNumber` argument passed to the `iterate()`
                    // callback.
                    //
                    // See: github.com/mozilla/localForage/pull/435#discussion_r38061530
                    var iterationNumber = 1;

                    for (var i = 0; i < length; i++) {
                        var key = localStorage.key(i);
                        if (key.indexOf(keyPrefix) !== 0) {
                            continue;
                        }
                        var value = localStorage.getItem(key);

                        // If a result was found, parse it from the serialized
                        // string into a JS object. If result isn't truthy, the
                        // key is likely undefined and we'll pass it straight
                        // to the iterator.
                        if (value) {
                            value = dbInfo.serializer.deserialize(value);
                        }

                        value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);

                        if (value !== void 0) {
                            return value;
                        }
                    }
                });

                executeCallback(promise, callback);
                return promise;
            }

            // Same as localStorage's key() method, except takes a callback.
            function key$2(n, callback) {
                var self = this;
                var promise = self.ready().then(function () {
                    var dbInfo = self._dbInfo;
                    var result;
                    try {
                        result = localStorage.key(n);
                    } catch (error) {
                        result = null;
                    }

                    // Remove the prefix from the key, if a key is found.
                    if (result) {
                        result = result.substring(dbInfo.keyPrefix.length);
                    }

                    return result;
                });

                executeCallback(promise, callback);
                return promise;
            }

            function keys$2(callback) {
                var self = this;
                var promise = self.ready().then(function () {
                    var dbInfo = self._dbInfo;
                    var length = localStorage.length;
                    var keys = [];

                    for (var i = 0; i < length; i++) {
                        var itemKey = localStorage.key(i);
                        if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                            keys.push(itemKey.substring(dbInfo.keyPrefix.length));
                        }
                    }

                    return keys;
                });

                executeCallback(promise, callback);
                return promise;
            }

            // Supply the number of keys in the datastore to the callback function.
            function length$2(callback) {
                var self = this;
                var promise = self.keys().then(function (keys) {
                    return keys.length;
                });

                executeCallback(promise, callback);
                return promise;
            }

            // Remove an item from the store, nice and simple.
            function removeItem$2(key, callback) {
                var self = this;

                key = normalizeKey(key);

                var promise = self.ready().then(function () {
                    var dbInfo = self._dbInfo;
                    localStorage.removeItem(dbInfo.keyPrefix + key);
                });

                executeCallback(promise, callback);
                return promise;
            }

            // Set a key's value and run an optional callback once the value is set.
            // Unlike Gaia's implementation, the callback function is passed the value,
            // in case you want to operate on that value only after you're sure it
            // saved, or something like that.
            function setItem$2(key, value, callback) {
                var self = this;

                key = normalizeKey(key);

                var promise = self.ready().then(function () {
                    // Convert undefined values to null.
                    // https://github.com/mozilla/localForage/pull/42
                    if (value === undefined) {
                        value = null;
                    }

                    // Save the original value to pass to the callback.
                    var originalValue = value;

                    return new Promise$1(function (resolve, reject) {
                        var dbInfo = self._dbInfo;
                        dbInfo.serializer.serialize(value, function (value, error) {
                            if (error) {
                                reject(error);
                            } else {
                                try {
                                    localStorage.setItem(dbInfo.keyPrefix + key, value);
                                    resolve(originalValue);
                                } catch (e) {
                                    // localStorage capacity exceeded.
                                    // TODO: Make this a specific error/event.
                                    if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                                        reject(e);
                                    }
                                    reject(e);
                                }
                            }
                        });
                    });
                });

                executeCallback(promise, callback);
                return promise;
            }

            function dropInstance$2(options, callback) {
                callback = getCallback.apply(this, arguments);

                options = typeof options !== 'function' && options || {};
                if (!options.name) {
                    var currentConfig = this.config();
                    options.name = options.name || currentConfig.name;
                    options.storeName = options.storeName || currentConfig.storeName;
                }

                var self = this;
                var promise;
                if (!options.name) {
                    promise = Promise$1.reject('Invalid arguments');
                } else {
                    promise = new Promise$1(function (resolve) {
                        if (!options.storeName) {
                            resolve(options.name + '/');
                        } else {
                            resolve(_getKeyPrefix(options, self._defaultConfig));
                        }
                    }).then(function (keyPrefix) {
                        for (var i = localStorage.length - 1; i >= 0; i--) {
                            var key = localStorage.key(i);

                            if (key.indexOf(keyPrefix) === 0) {
                                localStorage.removeItem(key);
                            }
                        }
                    });
                }

                executeCallback(promise, callback);
                return promise;
            }

            var localStorageWrapper = {
                _driver: 'localStorageWrapper',
                _initStorage: _initStorage$2,
                _support: isLocalStorageValid(),
                iterate: iterate$2,
                getItem: getItem$2,
                setItem: setItem$2,
                removeItem: removeItem$2,
                clear: clear$2,
                length: length$2,
                key: key$2,
                keys: keys$2,
                dropInstance: dropInstance$2
            };

            var sameValue = function sameValue(x, y) {
                return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
            };

            var includes = function includes(array, searchElement) {
                var len = array.length;
                var i = 0;
                while (i < len) {
                    if (sameValue(array[i], searchElement)) {
                        return true;
                    }
                    i++;
                }

                return false;
            };

            var isArray = Array.isArray || function (arg) {
                return Object.prototype.toString.call(arg) === '[object Array]';
            };

            // Drivers are stored here when `defineDriver()` is called.
            // They are shared across all instances of localForage.
            var DefinedDrivers = {};

            var DriverSupport = {};

            var DefaultDrivers = {
                INDEXEDDB: asyncStorage,
                WEBSQL: webSQLStorage,
                LOCALSTORAGE: localStorageWrapper
            };

            var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];

            var OptionalDriverMethods = ['dropInstance'];

            var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);

            var DefaultConfig = {
                description: '',
                driver: DefaultDriverOrder.slice(),
                name: 'localforage',
                // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
                // we can use without a prompt.
                size: 4980736,
                storeName: 'keyvaluepairs',
                version: 1.0
            };

            function callWhenReady(localForageInstance, libraryMethod) {
                localForageInstance[libraryMethod] = function () {
                    var _args = arguments;
                    return localForageInstance.ready().then(function () {
                        return localForageInstance[libraryMethod].apply(localForageInstance, _args);
                    });
                };
            }

            function extend() {
                for (var i = 1; i < arguments.length; i++) {
                    var arg = arguments[i];

                    if (arg) {
                        for (var _key in arg) {
                            if (arg.hasOwnProperty(_key)) {
                                if (isArray(arg[_key])) {
                                    arguments[0][_key] = arg[_key].slice();
                                } else {
                                    arguments[0][_key] = arg[_key];
                                }
                            }
                        }
                    }
                }

                return arguments[0];
            }

            var LocalForage = function () {
                function LocalForage(options) {
                    _classCallCheck(this, LocalForage);

                    for (var driverTypeKey in DefaultDrivers) {
                        if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                            var driver = DefaultDrivers[driverTypeKey];
                            var driverName = driver._driver;
                            this[driverTypeKey] = driverName;

                            if (!DefinedDrivers[driverName]) {
                                // we don't need to wait for the promise,
                                // since the default drivers can be defined
                                // in a blocking manner
                                this.defineDriver(driver);
                            }
                        }
                    }

                    this._defaultConfig = extend({}, DefaultConfig);
                    this._config = extend({}, this._defaultConfig, options);
                    this._driverSet = null;
                    this._initDriver = null;
                    this._ready = false;
                    this._dbInfo = null;

                    this._wrapLibraryMethodsWithReady();
                    this.setDriver(this._config.driver)["catch"](function () {});
                }

                // Set any config values for localForage; can be called anytime before
                // the first API call (e.g. `getItem`, `setItem`).
                // We loop through options so we don't overwrite existing config
                // values.


                LocalForage.prototype.config = function config(options) {
                    // If the options argument is an object, we use it to set values.
                    // Otherwise, we return either a specified config value or all
                    // config values.
                    if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
                        // If localforage is ready and fully initialized, we can't set
                        // any new configuration values. Instead, we return an error.
                        if (this._ready) {
                            return new Error("Can't call config() after localforage " + 'has been used.');
                        }

                        for (var i in options) {
                            if (i === 'storeName') {
                                options[i] = options[i].replace(/\W/g, '_');
                            }

                            if (i === 'version' && typeof options[i] !== 'number') {
                                return new Error('Database version must be a number.');
                            }

                            this._config[i] = options[i];
                        }

                        // after all config options are set and
                        // the driver option is used, try setting it
                        if ('driver' in options && options.driver) {
                            return this.setDriver(this._config.driver);
                        }

                        return true;
                    } else if (typeof options === 'string') {
                        return this._config[options];
                    } else {
                        return this._config;
                    }
                };

                // Used to define a custom driver, shared across all instances of
                // localForage.


                LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
                    var promise = new Promise$1(function (resolve, reject) {
                        try {
                            var driverName = driverObject._driver;
                            var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');

                            // A driver name should be defined and not overlap with the
                            // library-defined, default drivers.
                            if (!driverObject._driver) {
                                reject(complianceError);
                                return;
                            }

                            var driverMethods = LibraryMethods.concat('_initStorage');
                            for (var i = 0, len = driverMethods.length; i < len; i++) {
                                var driverMethodName = driverMethods[i];

                                // when the property is there,
                                // it should be a method even when optional
                                var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                                if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {
                                    reject(complianceError);
                                    return;
                                }
                            }

                            var configureMissingMethods = function configureMissingMethods() {
                                var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {
                                    return function () {
                                        var error = new Error('Method ' + methodName + ' is not implemented by the current driver');
                                        var promise = Promise$1.reject(error);
                                        executeCallback(promise, arguments[arguments.length - 1]);
                                        return promise;
                                    };
                                };

                                for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                                    var optionalDriverMethod = OptionalDriverMethods[_i];
                                    if (!driverObject[optionalDriverMethod]) {
                                        driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                                    }
                                }
                            };

                            configureMissingMethods();

                            var setDriverSupport = function setDriverSupport(support) {
                                if (DefinedDrivers[driverName]) {
                                    console.info('Redefining LocalForage driver: ' + driverName);
                                }
                                DefinedDrivers[driverName] = driverObject;
                                DriverSupport[driverName] = support;
                                // don't use a then, so that we can define
                                // drivers that have simple _support methods
                                // in a blocking manner
                                resolve();
                            };

                            if ('_support' in driverObject) {
                                if (driverObject._support && typeof driverObject._support === 'function') {
                                    driverObject._support().then(setDriverSupport, reject);
                                } else {
                                    setDriverSupport(!!driverObject._support);
                                }
                            } else {
                                setDriverSupport(true);
                            }
                        } catch (e) {
                            reject(e);
                        }
                    });

                    executeTwoCallbacks(promise, callback, errorCallback);
                    return promise;
                };

                LocalForage.prototype.driver = function driver() {
                    return this._driver || null;
                };

                LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
                    var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));

                    executeTwoCallbacks(getDriverPromise, callback, errorCallback);
                    return getDriverPromise;
                };

                LocalForage.prototype.getSerializer = function getSerializer(callback) {
                    var serializerPromise = Promise$1.resolve(localforageSerializer);
                    executeTwoCallbacks(serializerPromise, callback);
                    return serializerPromise;
                };

                LocalForage.prototype.ready = function ready(callback) {
                    var self = this;

                    var promise = self._driverSet.then(function () {
                        if (self._ready === null) {
                            self._ready = self._initDriver();
                        }

                        return self._ready;
                    });

                    executeTwoCallbacks(promise, callback, callback);
                    return promise;
                };

                LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
                    var self = this;

                    if (!isArray(drivers)) {
                        drivers = [drivers];
                    }

                    var supportedDrivers = this._getSupportedDrivers(drivers);

                    function setDriverToConfig() {
                        self._config.driver = self.driver();
                    }

                    function extendSelfWithDriver(driver) {
                        self._extend(driver);
                        setDriverToConfig();

                        self._ready = self._initStorage(self._config);
                        return self._ready;
                    }

                    function initDriver(supportedDrivers) {
                        return function () {
                            var currentDriverIndex = 0;

                            function driverPromiseLoop() {
                                while (currentDriverIndex < supportedDrivers.length) {
                                    var driverName = supportedDrivers[currentDriverIndex];
                                    currentDriverIndex++;

                                    self._dbInfo = null;
                                    self._ready = null;

                                    return self.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                                }

                                setDriverToConfig();
                                var error = new Error('No available storage method found.');
                                self._driverSet = Promise$1.reject(error);
                                return self._driverSet;
                            }

                            return driverPromiseLoop();
                        };
                    }

                    // There might be a driver initialization in progress
                    // so wait for it to finish in order to avoid a possible
                    // race condition to set _dbInfo
                    var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function () {
                        return Promise$1.resolve();
                    }) : Promise$1.resolve();

                    this._driverSet = oldDriverSetDone.then(function () {
                        var driverName = supportedDrivers[0];
                        self._dbInfo = null;
                        self._ready = null;

                        return self.getDriver(driverName).then(function (driver) {
                            self._driver = driver._driver;
                            setDriverToConfig();
                            self._wrapLibraryMethodsWithReady();
                            self._initDriver = initDriver(supportedDrivers);
                        });
                    })["catch"](function () {
                        setDriverToConfig();
                        var error = new Error('No available storage method found.');
                        self._driverSet = Promise$1.reject(error);
                        return self._driverSet;
                    });

                    executeTwoCallbacks(this._driverSet, callback, errorCallback);
                    return this._driverSet;
                };

                LocalForage.prototype.supports = function supports(driverName) {
                    return !!DriverSupport[driverName];
                };

                LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
                    extend(this, libraryMethodsAndProperties);
                };

                LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
                    var supportedDrivers = [];
                    for (var i = 0, len = drivers.length; i < len; i++) {
                        var driverName = drivers[i];
                        if (this.supports(driverName)) {
                            supportedDrivers.push(driverName);
                        }
                    }
                    return supportedDrivers;
                };

                LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
                    // Add a stub for each driver API method that delays the call to the
                    // corresponding driver method until localForage is ready. These stubs
                    // will be replaced by the driver methods as soon as the driver is
                    // loaded, so there is no performance impact.
                    for (var i = 0, len = LibraryMethods.length; i < len; i++) {
                        callWhenReady(this, LibraryMethods[i]);
                    }
                };

                LocalForage.prototype.createInstance = function createInstance(options) {
                    return new LocalForage(options);
                };

                return LocalForage;
            }();

            // The actual localForage object that we expose as a module or via a
            // global. It's extended by pulling in one of our other libraries.


            var localforage_js = new LocalForage();

            module.exports = localforage_js;

            },{"3":3}]},{},[4])(4)
            });
            });

            let dbInstance;

            const db = () => {
              if (dbInstance === undefined) {
                dbInstance = localforage.createInstance({
                  name: 'jsxcad',
                  driver: localforage.INDEXEDDB,
                  storeName: 'jsxcad',
                  description: 'jsxcad local filesystem',
                });
              }
              return dbInstance;
            };

            const files = new Map();
            const fileCreationWatchers = new Set();

            const getFile = async (options, unqualifiedPath) => {
              if (typeof unqualifiedPath !== 'string') {
                throw Error(`die: ${JSON.stringify(unqualifiedPath)}`);
              }
              const path = qualifyPath(unqualifiedPath);
              let file = files.get(path);
              if (file === undefined) {
                file = { path: unqualifiedPath, watchers: new Set(), storageKey: path };
                files.set(path, file);
                for (const watcher of fileCreationWatchers) {
                  await watcher(options, file);
                }
              }
              return file;
            };

            /* global self */

            const watchers = new Set();

            const log = async (entry) => {
              if (isWebWorker) {
                return self.ask({ log: { entry } });
              }

              for (const watcher of watchers) {
                watcher(entry);
              }
            };

            var nodeFetch = _ => _;

            // Copyright Joyent, Inc. and other Node contributors.

            // Split a filename into [root, dir, basename, ext], unix version
            // 'root' is just a slash, or nothing.
            var splitPathRe =
                /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
            var splitPath = function(filename) {
              return splitPathRe.exec(filename).slice(1);
            };

            function dirname(path) {
              var result = splitPath(path),
                  root = result[0],
                  dir = result[1];

              if (!root && !dir) {
                // No dirname whatsoever
                return '.';
              }

              if (dir) {
                // It has a dirname, strip trailing slash
                dir = dir.substr(0, dir.length - 1);
              }

              return root + dir;
            }

            /* global self */

            const { promises } = fs;
            const { serialize } = v8$1;

            // FIX Convert data by representation.

            const writeFile = async (options, path, data) => {
              if (path.startsWith('source/source/')) {
                throw Error('source/source');
              }
              data = await data;
              // FIX: Should be checking for a proxy fs, not webworker.
              // if (false && isWebWorker) {
              //  return self.ask({ writeFile: { options: { ...options, as: 'bytes' }, path, data: await data } });
              // }

              const {
                doSerialize = true,
                ephemeral,
                workspace = getFilesystem(),
              } = options;
              let originalWorkspace = getFilesystem();
              if (workspace !== originalWorkspace) {
                log({ op: 'text', text: `Write ${path} of ${workspace}` });
                // Switch to the source filesystem, if necessary.
                setupFilesystem({ fileBase: workspace });
              }

              await log({ op: 'text', text: `Write ${path}` });
              const file = await getFile(options, path);
              file.data = data;

              for (const watcher of file.watchers) {
                await watcher(options, file);
              }

              const base = getBase();
              if (!ephemeral && base !== undefined) {
                const persistentPath = qualifyPath(path);
                if (isNode) {
                  try {
                    await promises.mkdir(dirname(persistentPath), { recursive: true });
                  } catch (error) {}
                  try {
                    if (doSerialize) {
                      data = serialize(data);
                    }
                    await promises.writeFile(persistentPath, data);
                  } catch (error) {}
                } else if (isBrowser || isWebWorker) {
                  await db().setItem(persistentPath, data);
                  if (isWebWorker) {
                    await self.ask({ touchFile: { path, workspace: workspace } });
                  }
                }
              }

              if (workspace !== originalWorkspace) {
                // Switch back to the original filesystem, if necessary.
                setupFilesystem({ fileBase: originalWorkspace });
              }

              return true;
            };

            const write = async (path, data, options = {}) => {
              if (typeof data === 'function') {
                // Always fail to write functions.
                return undefined;
              }
              return writeFile(options, path, data);
            };

            /* global self */

            const { promises: promises$1 } = fs;
            const { deserialize } = v8$1;

            const getUrlFetcher = async () => {
              if (isBrowser) {
                return window.fetch;
              }
              if (isWebWorker) {
                return self.fetch;
              }
              if (isNode) {
                return nodeFetch;
              }
              throw Error('die');
            };

            const getFileFetcher = async (qualify = qualifyPath, doSerialize = true) => {
              if (isNode) {
                // FIX: Put this through getFile, also.
                return async (path) => {
                  let data = await promises$1.readFile(qualify(path));
                  if (doSerialize) {
                    data = deserialize(data);
                  }
                  return data;
                };
              } else if (isBrowser || isWebWorker) {
                return async (path) => {
                  const data = await db().getItem(qualify(path));
                  if (data !== null) {
                    return data;
                  }
                };
              } else {
                throw Error('die');
              }
            };

            // Fetch from internal store.
            const fetchPersistent = async (path, doSerialize) => {
              try {
                const base = getBase();
                if (base !== undefined) {
                  const fetchFile = await getFileFetcher(qualifyPath, doSerialize);
                  const data = await fetchFile(path);
                  return data;
                }
              } catch (e) {
                if (e.code && e.code === 'ENOENT') {
                  return;
                }
                console.log(e);
              }
            };

            // Fetch from external sources.
            const fetchSources = async (sources) => {
              const fetchUrl = await getUrlFetcher();
              const fetchFile = await getFileFetcher((path) => path, false);
              // Try to load the data from a source.
              for (const source of sources) {
                if (typeof source === 'string') {
                  try {
                    if (source.startsWith('http:') || source.startsWith('https:')) {
                      log({ op: 'text', text: `# Fetching ${source}` });
                      const response = await fetchUrl(source);
                      if (response.ok) {
                        return new Uint8Array(await response.arrayBuffer());
                      }
                    } else {
                      log({ op: 'text', text: `# Fetching ${source}` });
                      // Assume a file path.
                      const data = await fetchFile(source);
                      if (data !== undefined) {
                        return data;
                      }
                    }
                  } catch (e) {}
                } else {
                  throw Error('die');
                }
              }
            };

            // Deprecated
            const readFile = async (options, path) => {
              const { allowFetch = true, ephemeral } = options;
              const {
                sources = [],
                workspace = getFilesystem(),
                useCache = true,
                decode,
              } = options;
              let originalWorkspace = getFilesystem();
              if (workspace !== originalWorkspace) {
                log({ op: 'text', text: `Read ${path} of ${workspace}` });
                // Switch to the source filesystem, if necessary.
                setupFilesystem({ fileBase: workspace });
              } else {
                log({ op: 'text', text: `Read ${path}` });
              }
              const file = await getFile(options, path);
              if (file.data === undefined || useCache === false) {
                file.data = await fetchPersistent(path, true);
              }
              if (workspace !== originalWorkspace) {
                // Switch back to the original filesystem, if necessary.
                setupFilesystem({ fileBase: originalWorkspace });
              }
              if (file.data === undefined && allowFetch && sources.length > 0) {
                let data = await fetchSources(sources);
                if (decode) {
                  data = new TextDecoder(decode).decode(data);
                }
                file.data = data;
                if (!ephemeral && file.data !== undefined) {
                  // Update persistent cache.
                  await writeFile({ ...options, doSerialize: true }, path, file.data);
                }
              }
              if (file.data !== undefined) {
                if (file.data.then) {
                  // Resolve any outstanding promises.
                  file.data = await file.data;
                }
              }
              return file.data;
            };

            const read = async (path, options = {}) => readFile(options, path);

            const sources = new Map();

            // Note: later additions will be used in preference to earlier additions.
            // This will allow overriding defective or unavailable sources.
            const addSource = (path, source) => {
              if (sources.has(path)) {
                sources.get(path).unshift(source);
              } else {
                sources.set(path, [source]);
              }
            };

            const emitted = [];

            const emit$1 = (value) => emitted.push(value);

            const spatialResolution = 1e5;

            // Quantize values for use in spatial coordinates, and so on, even if the usual quantizeForSpace is disabled.
            const reallyQuantizeForSpace = (value) =>
              Math.round(value * spatialResolution) / spatialResolution;

            const solve2Linear = (a, b, c, d, u, v) => {
              const det = a * d - b * c;
              const invdet = 1.0 / det;
              const x = u * d - b * v;
              const y = -u * c + a * v;
              return [x * invdet, y * invdet];
            };

            /**
             * Calculates the absolute value of the give vector
             *
             * @param {vec3} [out] - receiving vector
             * @param {vec3} vec - given value
             * @returns {vec3} absolute value of the vector
             */
            const abs = ([x, y, z]) => [Math.abs(x), Math.abs(y), Math.abs(z)];

            /**
             * Adds two Points.
             *
             * @param {vec3} a the first vector to add
             * @param {vec3} b the second vector to add
             * @returns {vec3} the added vectors
             */
            const add = ([ax = 0, ay = 0, az = 0], [bx = 0, by = 0, bz = 0]) => [
              ax + bx,
              ay + by,
              az + bz,
            ];

            /**
             * Calculates the dot product of two vec3's
             *
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {Number} dot product of a and b
             */
            const dot = ([ax, ay, az], [bx, by, bz]) => ax * bx + ay * by + az * bz;

            /**
             * Scales the length of a vector by some amount.
             *
             * @param {number} the amount to scale
             * @param {vec3} the vector to scale
             * @returns {vec3}
             */
            const scale = (amount, [x = 0, y = 0, z = 0]) => [
              x * amount,
              y * amount,
              z * amount,
            ];

            /**
             * Normalize a vec3
             *
             * @param {vec3} a vector to normalize
             * @returns {vec3} out
             */
            const normalize = (a) => {
              const [x, y, z] = a;
              const len = x * x + y * y + z * z;
              if (len > 0) {
                // TODO: evaluate use of glm_invsqrt here?
                return scale(1 / Math.sqrt(len), a);
              } else {
                return a;
              }
            };

            /**
             * Get the angle between two 3D vectors
             * @param {vec3} a The first operand
             * @param {vec3} b The second operand
             * @returns {Number} The angle in radians
             */
            const angle = (a, b) => {
              const cosine = reallyQuantizeForSpace(dot(normalize(a), normalize(b)));
              return cosine > 1.0 ? 0 : Math.acos(cosine);
            };

            // Normalize negative zero to positive zero.
            const f = (v) => (v === 0 ? 0 : v);

            const canonicalize = ([x = 0, y = 0, z = 0]) => [
              f(reallyQuantizeForSpace(x)),
              f(reallyQuantizeForSpace(y)),
              f(reallyQuantizeForSpace(z)),
            ];

            /**
             * Computes the cross product of two vec3's
             *
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {vec3} out
             */
            const cross = ([ax, ay, az], [bx, by, bz]) => [
              ay * bz - az * by,
              az * bx - ax * bz,
              ax * by - ay * bx,
            ];

            /**
             * Calculates the euclidian distance between two vec3's
             *
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {Number} distance between a and b
             */
            const distance = ([ax, ay, az], [bx, by, bz]) => {
              const x = bx - ax;
              const y = by - ay;
              const z = bz - az;
              return Math.sqrt(x * x + y * y + z * z);
            };

            /**
             * Divides two vec3's
             *
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {vec3} out
             */
            const divide = ([ax, ay, az], [bx, by, bz]) => [
              ax / bx,
              ay / by,
              az / bz,
            ];

            const equals = ([ax, ay, az], [bx, by, bz]) =>
              ax === bx && ay === by && az === bz;

            /**
             * Creates a new vec3 from the point given.
             * Missing ranks are implicitly zero.
             *
             * @param {Number} x X component
             * @param {Number} y Y component
             * @param {Number} z Z component
             * @returns {vec3} a new 3D vector
             */
            const fromPoint = ([x = 0, y = 0, z = 0]) => [x, y, z];

            /** create a vec3 from a single scalar value
             * all components of the resulting vec3 have the value of the
             * input scalar
             * @param  {Float} scalar
             * @returns {Vec3}
             */
            const fromScalar = (scalar) => [scalar, scalar, scalar];

            /**
             * Creates a new vec3 initialized with the given values
             *
             * @param {Number} x X component
             * @param {Number} y Y component
             * @param {Number} z Z component
             * @returns {vec3} a new 3D vector
             */
            const fromValues = (x = 0, y = 0, z = 0) => [x, y, z];

            // extend to a 3D vector by adding a z coordinate:
            const fromVec2 = ([x = 0, y = 0], z = 0) => [x, y, z];

            /**
             * Calculates the length of a vec3
             *
             * @param {vec3} a vector to calculate length of
             * @returns {Number} length of a
             */
            const length = ([x = 0, y = 0, z = 0]) =>
              Math.sqrt(x * x + y * y + z * z);

            /**
             * Performs a linear interpolation between two vec3's
             *
             * @param {Number} t interpolant (0.0 to 1.0) applied between the two inputs
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {vec3} out
             */
            const lerp = (t, [ax, ay, az], [bx, by, bz]) => [
              ax + t * (bx - ax),
              ay + t * (by - ay),
              az + t * (bz - az),
            ];

            /**
             * Returns the maximum of two vec3's
             *
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {vec3} out
             */
            const max = ([ax, ay, az], [bx, by, bz]) => [
              Math.max(ax, bx),
              Math.max(ay, by),
              Math.max(az, bz),
            ];

            /**
             * Returns the minimum of two vec3's
             *
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {vec3} out
             */
            const min = ([ax, ay, az], [bx, by, bz]) => [
              Math.min(ax, bx),
              Math.min(ay, by),
              Math.min(az, bz),
            ];

            /**
             * Multiplies two vec3's
             *
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {vec3} out
             */
            const multiply = ([ax, ay, az], [bx, by, bz]) => [
              ax * bx,
              ay * by,
              az * bz,
            ];

            /**
             * Negates the components of a vec3
             *
             * @param {vec3} a vector to negate
             * @returns {vec3} out
             */
            const negate = ([x, y, z]) => [-x, -y, -z];

            // find a vector that is somewhat orthogonal to this one
            const orthogonal = (vec) => {
              const temp = abs(vec);
              if (temp[0] <= temp[1] && temp[0] <= temp[2]) {
                return [1, 0, 0];
              } else if (temp[1] <= temp[0] && temp[1] <= temp[2]) {
                return [0, 1, 0];
              } else {
                return [0, 0, 1];
              }
            };

            const rotateX = ([x, y, z], radians) => [
              x,
              y * Math.cos(radians) - z * Math.sin(radians),
              y * Math.sin(radians) + z * Math.cos(radians),
            ];

            const rotateY = ([x, y, z], radians) => [
              z * Math.sin(radians) + x * Math.cos(radians),
              y,
              z * Math.cos(radians) - x * Math.sin(radians),
            ];

            const rotateZ = ([x, y, z], radians) => [
              x * Math.cos(radians) - y * Math.sin(radians),
              x * Math.sin(radians) + y * Math.cos(radians),
              z,
            ];

            /**
             * Calculates the squared euclidian distance between two vec3's
             *
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {Number} squared distance between a and b
             */
            const squaredDistance = ([ax, ay, az], [bx, by, bz]) => {
              const x = bx - ax;
              const y = by - ay;
              const z = bz - az;
              return x * x + y * y + z * z;
            };

            /**
             * Calculates the squared length of a vec3
             *
             * @param {vec3} a vector to calculate squared length of
             * @returns {Number} squared length of a
             */
            const squaredLength = ([x, y, z]) => x * x + y * y + z * z;

            /**
             * Subtracts vector b from vector a
             *
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {vec3} out
             */
            const subtract = ([ax, ay, az], [bx, by, bz]) => [
              ax - bx,
              ay - by,
              az - bz,
            ];

            /**
             * Transforms the vec3 with a mat4.
             * 4th vector component is implicitly '1'
             * @param {[[<vec3>], <mat4> , <vec3>]} params
             * @param {mat4} params[1] matrix matrix to transform with
             * @param {vec3} params[2] vector the vector to transform
             * @returns {vec3} out
             */
            const transform = (matrix, [x = 0, y = 0, z = 0]) => {
              let w = matrix[3] * x + matrix[7] * y + matrix[11] * z + matrix[15];
              w = w || 1.0;
              return [
                (matrix[0] * x + matrix[4] * y + matrix[8] * z + matrix[12]) / w,
                (matrix[1] * x + matrix[5] * y + matrix[9] * z + matrix[13]) / w,
                (matrix[2] * x + matrix[6] * y + matrix[10] * z + matrix[14]) / w,
              ];
            };

            /**
             * Rotate vector 3D vector around the x-axis
             * @param {Number} angle The angle of rotation
             * @param {vec3} origin The origin of the rotation
             * @param {vec3} vector The vec3 point to rotate
             * @returns {vec3} out
             */
            const turnX = (angle, origin, vector) => {
              const p = subtract(vector, origin);
              // rotate
              const r = [
                p[0],
                p[1] * Math.cos(angle) - p[2] * Math.sin(angle),
                p[1] * Math.sin(angle) + p[2] * Math.cos(angle),
              ];
              // translate
              return add(r, origin);
            };

            /**
             * Rotate vector 3D vector around the y-axis
             * @param {Number} angle The angle of rotation
             * @param {vec3} origin The origin of the rotation
             * @param {vec3} vector The vec3 point to turn
             * @returns {vec3} out
             */
            const turnY = (angle, origin, vector) => {
              const p = subtract(vector, origin);
              // turn
              const r = [
                p[2] * Math.sin(angle) + p[0] * Math.cos(angle),
                p[1],
                p[2] * Math.cos(angle) - p[0] * Math.sin(angle),
              ];
              // translate
              return add(r, origin);
            };

            /**
             * Rotate vector 3D vector around the z-axis
             * @param {Number} angle The angle of rotation in radians
             * @param {vec3} origin The origin of the rotation
             * @param {vec3} vector The vec3 point to turn
             * @returns {vec3} out
             */
            const turnZ = (angle, origin, vector) => {
              const p = subtract(vector, origin);
              // turn
              const r = [
                p[0] * Math.cos(angle) - p[1] * Math.sin(angle),
                p[0] * Math.sin(angle) + p[1] * Math.cos(angle),
                p[2],
              ];
              // translate
              return add(r, origin);
            };

            /**
             * Calculates the unit vector of the given vector
             *
             * @param {vec3} vector - the base vector for calculations
             * @returns {vec3} unit vector of the given vector
             */
            const unit = (vector) => {
              const [x, y, z] = vector;
              const magnitude = length(vector);
              return [x / magnitude, y / magnitude, z / magnitude];
            };

            var vec = /*#__PURE__*/Object.freeze({
                        __proto__: null,
                        abs: abs,
                        add: add,
                        angle: angle,
                        canonicalize: canonicalize,
                        cross: cross,
                        distance: distance,
                        divide: divide,
                        dot: dot,
                        equals: equals,
                        fromPoint: fromPoint,
                        fromScalar: fromScalar,
                        fromValues: fromValues,
                        fromVec2: fromVec2,
                        length: length,
                        lerp: lerp,
                        max: max,
                        min: min,
                        multiply: multiply,
                        negate: negate,
                        normalize: normalize,
                        orthogonal: orthogonal,
                        rotateX: rotateX,
                        rotateY: rotateY,
                        rotateZ: rotateZ,
                        scale: scale,
                        squaredDistance: squaredDistance,
                        squaredLength: squaredLength,
                        subtract: subtract,
                        transform: transform,
                        turnX: turnX,
                        turnY: turnY,
                        turnZ: turnZ,
                        unit: unit
            });

            /**
             * Calculates the dot product of two vec2's
             *
             * @param {vec2} a the first operand
             * @param {vec2} b the second operand
             * @returns {Number} dot product of a and b
             */
            const dot$1 = ([ax, ay], [bx, by]) => ax * bx + ay * by;

            const fromAngleRadians = (radians) => [
              Math.cos(radians),
              Math.sin(radians),
            ];

            /**
             * Rotates a vec2 by an angle
             *
             * @param {Number} angle the angle of rotation (in radians)
             * @param {vec2} vector the vector to rotate
             * @returns {vec2} out
             */
            const rotate = (angle, [x, y]) => {
              const c = Math.cos(angle);
              const s = Math.sin(angle);
              return [x * c - y * s, x * s + y * c];
            };

            /**
             * Calculates the normal value of the give vector
             * The normal value is the given vector rotated 90 degress.
             *
             * @param {vec2} vec - given value
             * @returns {vec2} normal value of the vector
             */
            const normal = (vec) => rotate(Math.PI / 2, vec);

            /**
             * Normalize the given vector.
             *
             * @param {vec2} a vector to normalize
             * @returns {vec2} normalized (unit) vector
             */
            const normalize$1 = ([x, y]) => {
              let len = x * x + y * y;
              if (len > 0) {
                len = 1 / Math.sqrt(len);
                return [x * len, y * len];
              } else {
                return [x, y];
              }
            };

            /**
             * Scales a vec2 by a scalar number
             *
             * @param {Number} amount amount to scale the vector by
             * @param {vec2} vector the vector to scale
             * @returns {vec2} out
             */
            const scale$1 = (amount, [x, y]) => [x * amount, y * amount];

            /**
             * Subtracts vector b from vector a
             *
             * @param {vec2} a the first operand
             * @param {vec2} b the second operand
             * @returns {vec2} out
             */
            const subtract$1 = ([ax, ay], [bx, by]) => [ax - bx, ay - by];

            /**
             * Set a mat4 to the identity matrix
             *
             * @returns {mat4} out
             */

            const identityMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

            const identity = () => identityMatrix;

            const EPSILON = 1e-5;

            /**
             * Creates a matrix from a given angle around a given axis
             * This is equivalent to (but much faster than):
             *
             *     mat4.identity(dest);
             *     mat4.rotate(dest, dest, rad, axis);
             *
             * @param {mat4} out mat4 receiving operation result
             * @param {Number} rad the angle to rotate the matrix by
             * @param {vec3} axis the axis to rotate around
             * @returns {mat4} out
             */
            const fromRotation = (rad, [x, y, z]) => {
              let len = Math.sqrt(x * x + y * y + z * z);

              if (Math.abs(len) < EPSILON) {
                return identity();
              }

              len = 1 / len;
              x *= len;
              y *= len;
              z *= len;

              const s = Math.sin(rad);
              const c = Math.cos(rad);
              const t = 1 - c;

              // Perform rotation-specific matrix multiplication
              return [
                x * x * t + c,
                y * x * t + z * s,
                z * x * t - y * s,
                0,
                x * y * t - z * s,
                y * y * t + c,
                z * y * t + x * s,
                0,
                x * z * t + y * s,
                y * z * t - x * s,
                z * z * t + c,
                0,
                0,
                0,
                0,
                1,
              ];
            };

            /**
             * Creates a matrix from a vector scaling
             * This is equivalent to (but much faster than):
             *
             *     mat4.identity(dest);
             *     mat4.scale(dest, dest, vec);
             *
             * @param {vec3} v Scaling vector
             * @returns {mat4} out
             */
            const fromScaling = ([x = 1, y = 1, z = 1]) => [
              x,
              0,
              0,
              0,
              0,
              y,
              0,
              0,
              0,
              0,
              z,
              0,
              0,
              0,
              0,
              1,
            ];

            /**
             * Creates a matrix from a vector translation
             * This is equivalent to (but much faster than):
             *
             *     mat4.identity(dest);
             *     mat4.translate(dest, dest, vec);
             *
             * @param {mat4} out mat4 receiving operation result
             * @param {vec3} v Translation vector
             * @returns {mat4} out
             */
            const fromTranslation = ([x = 0, y = 0, z = 0]) => [
              1,
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              0,
              1,
              0,
              x,
              y,
              z,
              1,
            ];

            /**
             * Create a new mat4 with the given values
             *
             * @param {Number} m00 Component in column 0, row 0 position (index 0)
             * @param {Number} m01 Component in column 0, row 1 position (index 1)
             * @param {Number} m02 Component in column 0, row 2 position (index 2)
             * @param {Number} m03 Component in column 0, row 3 position (index 3)
             * @param {Number} m10 Component in column 1, row 0 position (index 4)
             * @param {Number} m11 Component in column 1, row 1 position (index 5)
             * @param {Number} m12 Component in column 1, row 2 position (index 6)
             * @param {Number} m13 Component in column 1, row 3 position (index 7)
             * @param {Number} m20 Component in column 2, row 0 position (index 8)
             * @param {Number} m21 Component in column 2, row 1 position (index 9)
             * @param {Number} m22 Component in column 2, row 2 position (index 10)
             * @param {Number} m23 Component in column 2, row 3 position (index 11)
             * @param {Number} m30 Component in column 3, row 0 position (index 12)
             * @param {Number} m31 Component in column 3, row 1 position (index 13)
             * @param {Number} m32 Component in column 3, row 2 position (index 14)
             * @param {Number} m33 Component in column 3, row 3 position (index 15)
             * @returns {mat4} A new mat4
             */
            const fromValues$1 = (
              m00,
              m01,
              m02,
              m03,
              m10,
              m11,
              m12,
              m13,
              m20,
              m21,
              m22,
              m23,
              m30,
              m31,
              m32,
              m33
            ) => [
              m00,
              m01,
              m02,
              m03,
              m10,
              m11,
              m12,
              m13,
              m20,
              m21,
              m22,
              m23,
              m30,
              m31,
              m32,
              m33,
            ];

            /**
             * Creates a matrix from the given angle around the X axis
             * This is equivalent to (but much faster than):
             *
             *     mat4.identity(dest);
             *     mat4.rotateX(dest, dest, rad);
             *
             * @param {Number} rad the angle to rotate the matrix by
             * @returns {mat4} out
             */
            const fromXRotation = (rad) => {
              const s = Math.sin(rad);
              const c = Math.cos(rad);

              // Perform axis-specific matrix multiplication
              return [1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1];
            };

            /**
             * Creates a matrix from the given angle around the Y axis
             * This is equivalent to (but much faster than):
             *
             *     mat4.identity(dest);
             *     mat4.rotateY(dest, dest, rad);
             *
             * @param {Number} rad the angle to rotate the matrix by
             * @returns {mat4} out
             */
            const fromYRotation = (rad) => {
              const s = Math.sin(rad);
              const c = Math.cos(rad);
              // Perform axis-specific matrix multiplication
              return [c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1];
            };

            /**
             * Creates a matrix from the given angle around the Z axis
             * This is equivalent to (but much faster than):
             *
             *     mat4.identity(dest);
             *     mat4.rotateZ(dest, dest, rad);
             *
             * @param {Number} rad the angle to rotate the matrix by
             * @returns {mat4} out
             */
            const fromZRotation = (rad) => {
              const s = Math.sin(rad);
              const c = Math.cos(rad);
              // Perform axis-specific matrix multiplication
              return [c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            };

            /**
             * determine whether the input matrix is a mirroring transformation
             *
             * @param {mat4} mat the input matrix
             * @returns {boolean} output
             */
            const isMirroring = (mat) => {
              const u = [mat[0], mat[4], mat[8]];
              const v = [mat[1], mat[5], mat[9]];
              const w = [mat[2], mat[6], mat[10]];

              // for a true orthogonal, non-mirrored base, u.cross(v) == w
              // If they have an opposite direction then we are mirroring
              const mirrorvalue = dot(cross(u, v), w);
              const ismirror = mirrorvalue < 0;
              return ismirror;
            };

            /**
             * Multiplies two mat4's
             *
             * @param {mat4} a the first operand
             * @param {mat4} b the second operand
             * @returns {mat4} out
             */
            const multiply$1 = (a, b) => {
              const out = Array(16);
              const a00 = a[0];
              const a01 = a[1];
              const a02 = a[2];
              const a03 = a[3];
              const a10 = a[4];
              const a11 = a[5];
              const a12 = a[6];
              const a13 = a[7];
              const a20 = a[8];
              const a21 = a[9];
              const a22 = a[10];
              const a23 = a[11];
              const a30 = a[12];
              const a31 = a[13];
              const a32 = a[14];
              const a33 = a[15];

              // Cache only the current line of the second matrix
              let b0 = b[0];
              let b1 = b[1];
              let b2 = b[2];
              let b3 = b[3];
              out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
              out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
              out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
              out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

              b0 = b[4];
              b1 = b[5];
              b2 = b[6];
              b3 = b[7];
              out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
              out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
              out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
              out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

              b0 = b[8];
              b1 = b[9];
              b2 = b[10];
              b3 = b[11];
              out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
              out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
              out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
              out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

              b0 = b[12];
              b1 = b[13];
              b2 = b[14];
              b3 = b[15];
              out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
              out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
              out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
              out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
              return out;
            };

            const isClosed = (path) => path.length === 0 || path[0] !== null;

            const transform$1 = (matrix, path) =>
              path.map((point, index) =>
                point === null ? null : transform(matrix, point)
              );

            const translate = (vector, path) =>
              transform$1(fromTranslation(vector), path);
            const rotateX$1 = (radians, path) =>
              transform$1(fromXRotation(radians), path);
            const rotateZ$1 = (radians, path) =>
              transform$1(fromZRotation(radians), path);
            const scale$2 = (vector, path) => transform$1(fromScaling(vector), path);

            const createOpenPath = (...points) => [null, ...points];

            const assertUnique = (path) => {
              let last = null;
              for (const point of path) {
                if (point === undefined) {
                  throw Error(`die: ${JSON.stringify(path)}`);
                }
                if (last !== null && equals(point, last)) {
                  throw Error(`die: ${JSON.stringify(path)}`);
                }
                last = point;
              }
            };

            const assertGood = (path) => {
              assertUnique(path);
            };

            const canonicalizePoint = (point, index) => {
              if (point === null) {
                if (index !== 0) throw Error('Path has null not at head');
                return point;
              } else {
                return canonicalize(point);
              }
            };

            const canonicalize$1 = (path) => path.map(canonicalizePoint);

            const close = (path) => (isClosed(path) ? path : path.slice(1));

            const concatenate = (...paths) => {
              const result = [null, ...[].concat(...paths.map(close))];
              return result;
            };

            const deduplicate = (path) => {
              const unique = [];
              let last = path[path.length - 1];
              for (const point of path) {
                if (last === null || point === null || !equals(point, last)) {
                  unique.push(point);
                }
                last = point;
              }
              return unique;
            };

            const flip = (path) => {
              if (path[0] === null) {
                return [null, ...path.slice(1).reverse()];
              } else {
                return path.slice().reverse();
              }
            };

            const getEdges = (path) => {
              const edges = [];
              let last = null;
              for (const point of path) {
                if (point === null) {
                  continue;
                }
                if (last !== null) {
                  edges.push([last, point]);
                }
                last = point;
              }
              if (path[0] !== null) {
                edges.push([last, path[0]]);
              }
              return edges;
            };

            const X = 0;
            const Y = 1;

            /**
             * Measure the area of a path as though it were a polygon.
             * A negative area indicates a clockwise path, and a positive area indicates a counter-clock-wise path.
             * See: http://mathworld.wolfram.com/PolygonArea.html
             * @returns {Number} The area the path would have if it were a polygon.
             */
            const measureArea = (path) => {
              let last = path.length - 1;
              let current = path[0] === null ? 1 : 0;
              let twiceArea = 0;
              for (; current < path.length; last = current++) {
                twiceArea +=
                  path[last][X] * path[current][Y] - path[last][Y] * path[current][X];
              }
              return twiceArea / 2;
            };

            const isClockwise = (path) => measureArea(path) < 0;

            const isCounterClockwise = (path) => measureArea(path) > 0;

            const open = (path) => (isClosed(path) ? [null, ...path] : path);

            var HAS_WEAKSET_SUPPORT = typeof WeakSet === 'function';
            var keys = Object.keys;
            /**
             * @function addToCache
             *
             * add object to cache if an object
             *
             * @param value the value to potentially add to cache
             * @param cache the cache to add to
             */
            function addToCache(value, cache) {
                if (value && typeof value === 'object') {
                    cache.add(value);
                }
            }
            /**
             * @function hasPair
             *
             * @description
             * does the `pairToMatch` exist in the list of `pairs` provided based on the
             * `isEqual` check
             *
             * @param pairs the pairs to compare against
             * @param pairToMatch the pair to match
             * @param isEqual the equality comparator used
             * @param meta the meta provided
             * @returns does the pair exist in the pairs provided
             */
            function hasPair(pairs, pairToMatch, isEqual, meta) {
                var length = pairs.length;
                var pair;
                for (var index = 0; index < length; index++) {
                    pair = pairs[index];
                    if (isEqual(pair[0], pairToMatch[0], meta) &&
                        isEqual(pair[1], pairToMatch[1], meta)) {
                        return true;
                    }
                }
                return false;
            }
            /**
             * @function hasValue
             *
             * @description
             * does the `valueToMatch` exist in the list of `values` provided based on the
             * `isEqual` check
             *
             * @param values the values to compare against
             * @param valueToMatch the value to match
             * @param isEqual the equality comparator used
             * @param meta the meta provided
             * @returns does the value exist in the values provided
             */
            function hasValue(values, valueToMatch, isEqual, meta) {
                var length = values.length;
                for (var index = 0; index < length; index++) {
                    if (isEqual(values[index], valueToMatch, meta)) {
                        return true;
                    }
                }
                return false;
            }
            /**
             * @function sameValueZeroEqual
             *
             * @description
             * are the values passed strictly equal or both NaN
             *
             * @param a the value to compare against
             * @param b the value to test
             * @returns are the values equal by the SameValueZero principle
             */
            function sameValueZeroEqual(a, b) {
                return a === b || (a !== a && b !== b);
            }
            /**
             * @function isPlainObject
             *
             * @description
             * is the value a plain object
             *
             * @param value the value to test
             * @returns is the value a plain object
             */
            function isPlainObject(value) {
                return value.constructor === Object || value.constructor == null;
            }
            /**
             * @function isPromiseLike
             *
             * @description
             * is the value promise-like (meaning it is thenable)
             *
             * @param value the value to test
             * @returns is the value promise-like
             */
            function isPromiseLike(value) {
                return !!value && typeof value.then === 'function';
            }
            /**
             * @function isReactElement
             *
             * @description
             * is the value passed a react element
             *
             * @param value the value to test
             * @returns is the value a react element
             */
            function isReactElement(value) {
                return !!(value && value.$$typeof);
            }
            /**
             * @function getNewCacheFallback
             *
             * @description
             * in cases where WeakSet is not supported, creates a new custom
             * object that mimics the necessary API aspects for cache purposes
             *
             * @returns the new cache object
             */
            function getNewCacheFallback() {
                return Object.create({
                    _values: [],
                    add: function (value) {
                        this._values.push(value);
                    },
                    has: function (value) {
                        return this._values.indexOf(value) !== -1;
                    },
                });
            }
            /**
             * @function getNewCache
             *
             * @description
             * get a new cache object to prevent circular references
             *
             * @returns the new cache object
             */
            var getNewCache = (function (canUseWeakMap) {
                if (canUseWeakMap) {
                    return function _getNewCache() {
                        return new WeakSet();
                    };
                }
                return getNewCacheFallback;
            })(HAS_WEAKSET_SUPPORT);
            /**
             * @function createCircularEqualCreator
             *
             * @description
             * create a custom isEqual handler specific to circular objects
             *
             * @param [isEqual] the isEqual comparator to use instead of isDeepEqual
             * @returns the method to create the `isEqual` function
             */
            function createCircularEqualCreator(isEqual) {
                return function createCircularEqual(comparator) {
                    var _comparator = isEqual || comparator;
                    return function circularEqual(a, b, cache) {
                        if (cache === void 0) { cache = getNewCache(); }
                        var hasA = cache.has(a);
                        var hasB = cache.has(b);
                        if (hasA || hasB) {
                            return hasA && hasB;
                        }
                        addToCache(a, cache);
                        addToCache(b, cache);
                        return _comparator(a, b, cache);
                    };
                };
            }
            /**
             * @function toPairs
             *
             * @description
             * convert the map passed into pairs (meaning an array of [key, value] tuples)
             *
             * @param map the map to convert to [key, value] pairs (entries)
             * @returns the [key, value] pairs
             */
            function toPairs(map) {
                var pairs = new Array(map.size);
                var index = 0;
                map.forEach(function (value, key) {
                    pairs[index++] = [key, value];
                });
                return pairs;
            }
            /**
             * @function toValues
             *
             * @description
             * convert the set passed into values
             *
             * @param set the set to convert to values
             * @returns the values
             */
            function toValues(set) {
                var values = new Array(set.size);
                var index = 0;
                set.forEach(function (value) {
                    values[index++] = value;
                });
                return values;
            }
            /**
             * @function areArraysEqual
             *
             * @description
             * are the arrays equal in value
             *
             * @param a the array to test
             * @param b the array to test against
             * @param isEqual the comparator to determine equality
             * @param meta the meta object to pass through
             * @returns are the arrays equal
             */
            function areArraysEqual(a, b, isEqual, meta) {
                var length = a.length;
                if (b.length !== length) {
                    return false;
                }
                for (var index = 0; index < length; index++) {
                    if (!isEqual(a[index], b[index], meta)) {
                        return false;
                    }
                }
                return true;
            }
            /**
             * @function areMapsEqual
             *
             * @description
             * are the maps equal in value
             *
             * @param a the map to test
             * @param b the map to test against
             * @param isEqual the comparator to determine equality
             * @param meta the meta map to pass through
             * @returns are the maps equal
             */
            function areMapsEqual(a, b, isEqual, meta) {
                if (a.size !== b.size) {
                    return false;
                }
                var pairsA = toPairs(a);
                var pairsB = toPairs(b);
                var length = pairsA.length;
                for (var index = 0; index < length; index++) {
                    if (!hasPair(pairsB, pairsA[index], isEqual, meta) ||
                        !hasPair(pairsA, pairsB[index], isEqual, meta)) {
                        return false;
                    }
                }
                return true;
            }
            var OWNER = '_owner';
            var hasOwnProperty = Function.prototype.bind.call(Function.prototype.call, Object.prototype.hasOwnProperty);
            /**
             * @function areObjectsEqual
             *
             * @description
             * are the objects equal in value
             *
             * @param a the object to test
             * @param b the object to test against
             * @param isEqual the comparator to determine equality
             * @param meta the meta object to pass through
             * @returns are the objects equal
             */
            function areObjectsEqual(a, b, isEqual, meta) {
                var keysA = keys(a);
                var length = keysA.length;
                if (keys(b).length !== length) {
                    return false;
                }
                var key;
                for (var index = 0; index < length; index++) {
                    key = keysA[index];
                    if (!hasOwnProperty(b, key)) {
                        return false;
                    }
                    if (key === OWNER && isReactElement(a)) {
                        if (!isReactElement(b)) {
                            return false;
                        }
                    }
                    else if (!isEqual(a[key], b[key], meta)) {
                        return false;
                    }
                }
                return true;
            }
            /**
             * @function areRegExpsEqual
             *
             * @description
             * are the regExps equal in value
             *
             * @param a the regExp to test
             * @param b the regExp to test agains
             * @returns are the regExps equal
             */
            function areRegExpsEqual(a, b) {
                return (a.source === b.source &&
                    a.global === b.global &&
                    a.ignoreCase === b.ignoreCase &&
                    a.multiline === b.multiline &&
                    a.unicode === b.unicode &&
                    a.sticky === b.sticky &&
                    a.lastIndex === b.lastIndex);
            }
            /**
             * @function areSetsEqual
             *
             * @description
             * are the sets equal in value
             *
             * @param a the set to test
             * @param b the set to test against
             * @param isEqual the comparator to determine equality
             * @param meta the meta set to pass through
             * @returns are the sets equal
             */
            function areSetsEqual(a, b, isEqual, meta) {
                if (a.size !== b.size) {
                    return false;
                }
                var valuesA = toValues(a);
                var valuesB = toValues(b);
                var length = valuesA.length;
                for (var index = 0; index < length; index++) {
                    if (!hasValue(valuesB, valuesA[index], isEqual, meta) ||
                        !hasValue(valuesA, valuesB[index], isEqual, meta)) {
                        return false;
                    }
                }
                return true;
            }

            var isArray = Array.isArray;
            var HAS_MAP_SUPPORT = typeof Map === 'function';
            var HAS_SET_SUPPORT = typeof Set === 'function';
            var OBJECT_TYPEOF = 'object';
            function createComparator(createIsEqual) {
                var isEqual = 
                /* eslint-disable no-use-before-define */
                typeof createIsEqual === 'function'
                    ? createIsEqual(comparator)
                    : comparator;
                /* eslint-enable */
                /**
                 * @function comparator
                 *
                 * @description
                 * compare the value of the two objects and return true if they are equivalent in values
                 *
                 * @param a the value to test against
                 * @param b the value to test
                 * @param [meta] an optional meta object that is passed through to all equality test calls
                 * @returns are a and b equivalent in value
                 */
                function comparator(a, b, meta) {
                    if (sameValueZeroEqual(a, b)) {
                        return true;
                    }
                    if (a && b && typeof a === OBJECT_TYPEOF && typeof b === OBJECT_TYPEOF) {
                        if (isPlainObject(a) && isPlainObject(b)) {
                            return areObjectsEqual(a, b, isEqual, meta);
                        }
                        var arrayA = isArray(a);
                        var arrayB = isArray(b);
                        if (arrayA || arrayB) {
                            return arrayA === arrayB && areArraysEqual(a, b, isEqual, meta);
                        }
                        var aDate = a instanceof Date;
                        var bDate = b instanceof Date;
                        if (aDate || bDate) {
                            return aDate === bDate && sameValueZeroEqual(a.getTime(), b.getTime());
                        }
                        var aRegExp = a instanceof RegExp;
                        var bRegExp = b instanceof RegExp;
                        if (aRegExp || bRegExp) {
                            return aRegExp === bRegExp && areRegExpsEqual(a, b);
                        }
                        if (isPromiseLike(a) || isPromiseLike(b)) {
                            return a === b;
                        }
                        if (HAS_MAP_SUPPORT) {
                            var aMap = a instanceof Map;
                            var bMap = b instanceof Map;
                            if (aMap || bMap) {
                                return aMap === bMap && areMapsEqual(a, b, isEqual, meta);
                            }
                        }
                        if (HAS_SET_SUPPORT) {
                            var aSet = a instanceof Set;
                            var bSet = b instanceof Set;
                            if (aSet || bSet) {
                                return aSet === bSet && areSetsEqual(a, b, isEqual, meta);
                            }
                        }
                        return areObjectsEqual(a, b, isEqual, meta);
                    }
                    return false;
                }
                return comparator;
            }

            // comparator
            var deepEqual = createComparator();
            var shallowEqual = createComparator(function () { return sameValueZeroEqual; });
            var circularDeepEqual = createComparator(createCircularEqualCreator());
            var circularShallowEqual = createComparator(createCircularEqualCreator(sameValueZeroEqual));

            /**
             * @constant DEFAULT_OPTIONS_KEYS the default options keys
             */
            var DEFAULT_OPTIONS_KEYS = {
                isEqual: true,
                isMatchingKey: true,
                isPromise: true,
                maxSize: true,
                onCacheAdd: true,
                onCacheChange: true,
                onCacheHit: true,
                transformKey: true,
            };
            /**
             * @function slice
             *
             * @description
             * slice.call() pre-bound
             */
            var slice = Array.prototype.slice;
            /**
             * @function cloneArray
             *
             * @description
             * clone the array-like object and return the new array
             *
             * @param arrayLike the array-like object to clone
             * @returns the clone as an array
             */
            function cloneArray(arrayLike) {
                var length = arrayLike.length;
                if (!length) {
                    return [];
                }
                if (length === 1) {
                    return [arrayLike[0]];
                }
                if (length === 2) {
                    return [arrayLike[0], arrayLike[1]];
                }
                if (length === 3) {
                    return [arrayLike[0], arrayLike[1], arrayLike[2]];
                }
                return slice.call(arrayLike, 0);
            }
            /**
             * @function getCustomOptions
             *
             * @description
             * get the custom options on the object passed
             *
             * @param options the memoization options passed
             * @returns the custom options passed
             */
            function getCustomOptions(options) {
                var customOptions = {};
                /* eslint-disable no-restricted-syntax */
                for (var key in options) {
                    if (!DEFAULT_OPTIONS_KEYS[key]) {
                        customOptions[key] = options[key];
                    }
                }
                /* eslint-enable */
                return customOptions;
            }
            /**
             * @function isMemoized
             *
             * @description
             * is the function passed already memoized
             *
             * @param fn the function to test
             * @returns is the function already memoized
             */
            function isMemoized(fn) {
                return (typeof fn === 'function' &&
                    fn.isMemoized);
            }
            /**
             * @function isSameValueZero
             *
             * @description
             * are the objects equal based on SameValueZero equality
             *
             * @param object1 the first object to compare
             * @param object2 the second object to compare
             * @returns are the two objects equal
             */
            function isSameValueZero(object1, object2) {
                // eslint-disable-next-line no-self-compare
                return object1 === object2 || (object1 !== object1 && object2 !== object2);
            }
            /**
             * @function mergeOptions
             *
             * @description
             * merge the options into the target
             *
             * @param existingOptions the options provided
             * @param newOptions the options to include
             * @returns the merged options
             */
            function mergeOptions(existingOptions, newOptions) {
                // @ts-ignore
                var target = {};
                /* eslint-disable no-restricted-syntax */
                for (var key in existingOptions) {
                    target[key] = existingOptions[key];
                }
                for (var key in newOptions) {
                    target[key] = newOptions[key];
                }
                /* eslint-enable */
                return target;
            }

            // utils
            var Cache = /** @class */ (function () {
                function Cache(options) {
                    this.keys = [];
                    this.values = [];
                    this.options = options;
                    var isMatchingKeyFunction = typeof options.isMatchingKey === 'function';
                    if (isMatchingKeyFunction) {
                        this.getKeyIndex = this._getKeyIndexFromMatchingKey;
                    }
                    else if (options.maxSize > 1) {
                        this.getKeyIndex = this._getKeyIndexForMany;
                    }
                    else {
                        this.getKeyIndex = this._getKeyIndexForSingle;
                    }
                    this.canTransformKey = typeof options.transformKey === 'function';
                    this.shouldCloneArguments = this.canTransformKey || isMatchingKeyFunction;
                    this.shouldUpdateOnAdd = typeof options.onCacheAdd === 'function';
                    this.shouldUpdateOnChange = typeof options.onCacheChange === 'function';
                    this.shouldUpdateOnHit = typeof options.onCacheHit === 'function';
                }
                Object.defineProperty(Cache.prototype, "size", {
                    get: function () {
                        return this.keys.length;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Cache.prototype, "snapshot", {
                    get: function () {
                        return {
                            keys: cloneArray(this.keys),
                            size: this.size,
                            values: cloneArray(this.values),
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @function _getKeyIndexFromMatchingKey
                 *
                 * @description
                 * gets the matching key index when a custom key matcher is used
                 *
                 * @param keyToMatch the key to match
                 * @returns the index of the matching key, or -1
                 */
                Cache.prototype._getKeyIndexFromMatchingKey = function (keyToMatch) {
                    var _a = this.options, isMatchingKey = _a.isMatchingKey, maxSize = _a.maxSize;
                    var keys = this.keys;
                    var keysLength = keys.length;
                    if (!keysLength) {
                        return -1;
                    }
                    if (isMatchingKey(keys[0], keyToMatch)) {
                        return 0;
                    }
                    if (maxSize > 1) {
                        for (var index = 1; index < keysLength; index++) {
                            if (isMatchingKey(keys[index], keyToMatch)) {
                                return index;
                            }
                        }
                    }
                    return -1;
                };
                /**
                 * @function _getKeyIndexForMany
                 *
                 * @description
                 * gets the matching key index when multiple keys are used
                 *
                 * @param keyToMatch the key to match
                 * @returns the index of the matching key, or -1
                 */
                Cache.prototype._getKeyIndexForMany = function (keyToMatch) {
                    var isEqual = this.options.isEqual;
                    var keys = this.keys;
                    var keysLength = keys.length;
                    if (!keysLength) {
                        return -1;
                    }
                    if (keysLength === 1) {
                        return this._getKeyIndexForSingle(keyToMatch);
                    }
                    var keyLength = keyToMatch.length;
                    var existingKey;
                    var argIndex;
                    if (keyLength > 1) {
                        for (var index = 0; index < keysLength; index++) {
                            existingKey = keys[index];
                            if (existingKey.length === keyLength) {
                                argIndex = 0;
                                for (; argIndex < keyLength; argIndex++) {
                                    if (!isEqual(existingKey[argIndex], keyToMatch[argIndex])) {
                                        break;
                                    }
                                }
                                if (argIndex === keyLength) {
                                    return index;
                                }
                            }
                        }
                    }
                    else {
                        for (var index = 0; index < keysLength; index++) {
                            existingKey = keys[index];
                            if (existingKey.length === keyLength &&
                                isEqual(existingKey[0], keyToMatch[0])) {
                                return index;
                            }
                        }
                    }
                    return -1;
                };
                /**
                 * @function _getKeyIndexForSingle
                 *
                 * @description
                 * gets the matching key index when a single key is used
                 *
                 * @param keyToMatch the key to match
                 * @returns the index of the matching key, or -1
                 */
                Cache.prototype._getKeyIndexForSingle = function (keyToMatch) {
                    var keys = this.keys;
                    if (!keys.length) {
                        return -1;
                    }
                    var existingKey = keys[0];
                    var length = existingKey.length;
                    if (keyToMatch.length !== length) {
                        return -1;
                    }
                    var isEqual = this.options.isEqual;
                    if (length > 1) {
                        for (var index = 0; index < length; index++) {
                            if (!isEqual(existingKey[index], keyToMatch[index])) {
                                return -1;
                            }
                        }
                        return 0;
                    }
                    return isEqual(existingKey[0], keyToMatch[0]) ? 0 : -1;
                };
                /**
                 * @function orderByLru
                 *
                 * @description
                 * order the array based on a Least-Recently-Used basis
                 *
                 * @param key the new key to move to the front
                 * @param value the new value to move to the front
                 * @param startingIndex the index of the item to move to the front
                 */
                Cache.prototype.orderByLru = function (key, value, startingIndex) {
                    var keys = this.keys;
                    var values = this.values;
                    var currentLength = keys.length;
                    var index = startingIndex;
                    while (index--) {
                        keys[index + 1] = keys[index];
                        values[index + 1] = values[index];
                    }
                    keys[0] = key;
                    values[0] = value;
                    var maxSize = this.options.maxSize;
                    if (currentLength === maxSize && startingIndex === currentLength) {
                        keys.pop();
                        values.pop();
                    }
                    else if (startingIndex >= maxSize) {
                        // eslint-disable-next-line no-multi-assign
                        keys.length = values.length = maxSize;
                    }
                };
                /**
                 * @function updateAsyncCache
                 *
                 * @description
                 * update the promise method to auto-remove from cache if rejected, and
                 * if resolved then fire cache hit / changed
                 *
                 * @param memoized the memoized function
                 */
                Cache.prototype.updateAsyncCache = function (memoized) {
                    var _this = this;
                    var _a = this.options, onCacheChange = _a.onCacheChange, onCacheHit = _a.onCacheHit;
                    var firstKey = this.keys[0];
                    var firstValue = this.values[0];
                    this.values[0] = firstValue.then(function (value) {
                        if (_this.shouldUpdateOnHit) {
                            onCacheHit(_this, _this.options, memoized);
                        }
                        if (_this.shouldUpdateOnChange) {
                            onCacheChange(_this, _this.options, memoized);
                        }
                        return value;
                    }, function (error) {
                        var keyIndex = _this.getKeyIndex(firstKey);
                        if (keyIndex !== -1) {
                            _this.keys.splice(keyIndex, 1);
                            _this.values.splice(keyIndex, 1);
                        }
                        throw error;
                    });
                };
                return Cache;
            }());

            // cache
            function createMemoizedFunction(fn, options) {
                if (options === void 0) { options = {}; }
                if (isMemoized(fn)) {
                    return createMemoizedFunction(fn.fn, mergeOptions(fn.options, options));
                }
                if (typeof fn !== 'function') {
                    throw new TypeError('You must pass a function to `memoize`.');
                }
                var _a = options.isEqual, isEqual = _a === void 0 ? isSameValueZero : _a, isMatchingKey = options.isMatchingKey, _b = options.isPromise, isPromise = _b === void 0 ? false : _b, _c = options.maxSize, maxSize = _c === void 0 ? 1 : _c, onCacheAdd = options.onCacheAdd, onCacheChange = options.onCacheChange, onCacheHit = options.onCacheHit, transformKey = options.transformKey;
                var normalizedOptions = mergeOptions({
                    isEqual: isEqual,
                    isMatchingKey: isMatchingKey,
                    isPromise: isPromise,
                    maxSize: maxSize,
                    onCacheAdd: onCacheAdd,
                    onCacheChange: onCacheChange,
                    onCacheHit: onCacheHit,
                    transformKey: transformKey,
                }, getCustomOptions(options));
                var cache = new Cache(normalizedOptions);
                var keys = cache.keys, values = cache.values, canTransformKey = cache.canTransformKey, shouldCloneArguments = cache.shouldCloneArguments, shouldUpdateOnAdd = cache.shouldUpdateOnAdd, shouldUpdateOnChange = cache.shouldUpdateOnChange, shouldUpdateOnHit = cache.shouldUpdateOnHit;
                // @ts-ignore
                var memoized = function memoized() {
                    // @ts-ignore
                    var key = shouldCloneArguments
                        ? cloneArray(arguments)
                        : arguments;
                    if (canTransformKey) {
                        key = transformKey(key);
                    }
                    var keyIndex = keys.length ? cache.getKeyIndex(key) : -1;
                    if (keyIndex !== -1) {
                        if (shouldUpdateOnHit) {
                            onCacheHit(cache, normalizedOptions, memoized);
                        }
                        if (keyIndex) {
                            cache.orderByLru(keys[keyIndex], values[keyIndex], keyIndex);
                            if (shouldUpdateOnChange) {
                                onCacheChange(cache, normalizedOptions, memoized);
                            }
                        }
                    }
                    else {
                        var newValue = fn.apply(this, arguments);
                        var newKey = shouldCloneArguments
                            ? key
                            : cloneArray(arguments);
                        cache.orderByLru(newKey, newValue, keys.length);
                        if (isPromise) {
                            cache.updateAsyncCache(memoized);
                        }
                        if (shouldUpdateOnAdd) {
                            onCacheAdd(cache, normalizedOptions, memoized);
                        }
                        if (shouldUpdateOnChange) {
                            onCacheChange(cache, normalizedOptions, memoized);
                        }
                    }
                    return values[0];
                };
                memoized.cache = cache;
                memoized.fn = fn;
                memoized.isMemoized = true;
                memoized.options = normalizedOptions;
                return memoized;
            }

            const memoizedOps = new Set();

            const memoize = (op, options) => {
              const memoizedOp = createMemoizedFunction(op, options);
              memoizedOps.add(memoizedOp);
              return memoizedOp;
            };

            const clearCache = () => {
              for (const memoizedOp of memoizedOps) {
                const cache = memoizedOp.cache;
                cache.keys.length = 0;
                cache.values.length = 0;
              }
            };

            // This is a very thin abstraction layer to decouple from any particular cache implementation.

            const maxSize = 500;

            // Keyed by identity

            /** @type {function(*):?} */
            const cache = (op) => memoize(op, { maxSize });

            // Keyed by matrix structure and geometry identity.

            const isMatchingTransformKey = ([aMatrix, aGeometry], [bMatrix, bGeometry]) =>
              aGeometry === bGeometry && deepEqual(aMatrix, bMatrix);

            const cacheTransform = (op) => memoize(op, { isMatchingKey: isMatchingTransformKey, maxSize });

            // Keyed by tag-list and geometry identity.

            const isMatchingRewriteTagsKey = ([aAdd, aRemove, aGeometry, aConditionTags, aConditionSpec],
                                              [bAdd, bRemove, bGeometry, bConditionTags, bConditionSpec]) =>
              aGeometry === bGeometry && aConditionSpec === bConditionSpec && deepEqual(aConditionTags, bConditionTags) && deepEqual(aAdd, bAdd) && deepEqual(aRemove, bRemove);

            const cacheRewriteTags = (op) => memoize(op, { isMatchingKey: isMatchingRewriteTagsKey, maxSize });

            // Keyed by plane structure and geometry identity.

            const isMatchingCutKey = ([aPlane, aGeometry], [bPlane, bGeometry]) =>
              aGeometry === bGeometry && deepEqual(aPlane, bPlane);

            const cacheCut = (op) => memoize(op, { isMatchingKey: isMatchingCutKey, maxSize });

            // Keyed by points structure.

            const isMatchingPointsKey = ([aPoints], [bPoints]) => deepEqual(aPoints, bPoints);

            const cachePoints = (op) => memoize(op, { isMatchingKey: isMatchingPointsKey, maxSize });

            const X$1 = 0;
            const Y$1 = 1;

            // The resolution is 1 / multiplier.
            /** @type {function(multiplier:number):Normalizer} */
            const createNormalize2 = (multiplier = 1e5) => {
              const map = new Map();
              const update = (key, value) => {
                if (!map.has(key)) {
                  map.set(key, value);
                }
              };
              const normalize2 = (coordinate) => {
                // Apply a spatial quantization to the 2 dimensional coordinate.
                const nx = Math.floor(coordinate[X$1] * multiplier - 0.5);
                const ny = Math.floor(coordinate[Y$1] * multiplier - 0.5);
                // Look for an existing inhabitant.
                const value = map.get(`${nx}/${ny}`);
                if (value !== undefined) {
                  return value;
                }
                // One of the ~0 or ~1 values will match the rounded values above.
                // The other will match the adjacent cell.
                const nx0 = nx;
                const ny0 = ny;
                const nx1 = nx + 1;
                const ny1 = ny + 1;
                // Populate the space of the quantized coordinate and its adjacencies.
                const normalized = coordinate;
                update(`${nx0}/${ny0}`, normalized);
                update(`${nx0}/${ny1}`, normalized);
                update(`${nx1}/${ny0}`, normalized);
                update(`${nx1}/${ny1}`, normalized);
                // This is now the normalized coordinate for this region.
                return normalized;
              };
              return normalize2;
            };

            const X$1$1 = 0;
            const Y$1$1 = 1;
            const Z = 2;

            // The resolution is 1 / multiplier.
            // export const createNormalize3 = (multiplier = 1e5) => {

            /** @type {function():Normalizer} */
            const createNormalize3 = (multiplier = 1e5 * 2) => {
              const map = new Map();
              const update = (key, value) => {
                if (!map.has(key)) {
                  map.set(key, value);
                }
              };
              const normalize3 = (coordinate) => {
                // Apply a spatial quantization to the 2 dimensional coordinate.
                const nx = Math.floor(coordinate[X$1$1] * multiplier - 0.5);
                const ny = Math.floor(coordinate[Y$1$1] * multiplier - 0.5);
                const nz = Math.floor(coordinate[Z] * multiplier - 0.5);
                // Look for an existing inhabitant.
                const value = map.get(`${nx}/${ny}/${nz}`);
                if (value !== undefined) {
                  return value;
                }
                // One of the ~0 or ~1 values will match the rounded values above.
                // The other will match the adjacent cell.
                const nx0 = nx;
                const ny0 = ny;
                const nz0 = nz;
                const nx1 = nx + 1;
                const ny1 = ny + 1;
                const nz1 = nz + 1;
                // Populate the space of the quantized coordinate and its adjacencies.
                const normalized = coordinate;
                update(`${nx0}/${ny0}/${nz0}`, normalized);
                update(`${nx0}/${ny0}/${nz1}`, normalized);
                update(`${nx0}/${ny1}/${nz0}`, normalized);
                update(`${nx0}/${ny1}/${nz1}`, normalized);
                update(`${nx1}/${ny0}/${nz0}`, normalized);
                update(`${nx1}/${ny0}/${nz1}`, normalized);
                update(`${nx1}/${ny1}/${nz0}`, normalized);
                update(`${nx1}/${ny1}/${nz1}`, normalized);
                // This is now the normalized coordinate for this region.
                return normalized;
              };
              return normalize3;
            };

            const canonicalize$2 = ([x = 0, y = 0, z = 0, w = 0]) => [
              reallyQuantizeForSpace(x),
              reallyQuantizeForSpace(y),
              reallyQuantizeForSpace(z),
              reallyQuantizeForSpace(w),
            ];

            /**
             * Compare the given planes for equality
             * @return {boolean} true if planes are equal
             */
            const equals$1 = (a, b) =>
              a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];

            /**
             * Flip the given plane (vec4)
             *
             * @param {vec4} vec - plane to flip
             * @return {vec4} flipped plane
             */
            const flip$1 = ([x = 0, y = 0, z = 0, w = 0]) => [-x, -y, -z, -w];

            /**
             * Create a new plane from the given points
             *
             * @param {Vec3} a - 3D point
             * @param {Vec3} b - 3D point
             * @param {Vec3} c - 3D point
             * @returns {Vec4} a new plane with properly typed values
             */

            const fromPoints = (a, b, c) => {
              // let n = b.minus(a).cross(c.minus(a)).unit()
              // FIXME optimize later
              const ba = subtract(b, a);
              const ca = subtract(c, a);
              const cr = cross(ba, ca);
              const normal = unit(cr); // normal part
              //
              const w = dot(normal, a);
              return [normal[0], normal[1], normal[2], w];
            };

            const X$2 = 0;
            const Y$2 = 1;
            const Z$1 = 2;
            const W = 3;

            // Newell's method for computing the plane of a polygon.
            const fromPolygon = (polygon) => {
              const normal = [0, 0, 0];
              const reference = [0, 0, 0];
              let lastPoint = polygon[polygon.length - 1];
              for (const thisPoint of polygon) {
                normal[X$2] += (lastPoint[Y$2] - thisPoint[Y$2]) * (lastPoint[Z$1] + thisPoint[Z$1]);
                normal[Y$2] += (lastPoint[Z$1] - thisPoint[Z$1]) * (lastPoint[X$2] + thisPoint[X$2]);
                normal[Z$1] += (lastPoint[X$2] - thisPoint[X$2]) * (lastPoint[Y$2] + thisPoint[Y$2]);
                reference[X$2] += lastPoint[X$2];
                reference[Y$2] += lastPoint[Y$2];
                reference[Z$1] += lastPoint[Z$1];
                lastPoint = thisPoint;
              }
              const factor = 1 / length(normal);
              const plane = scale(factor, normal);
              plane[W] = (dot(reference, normal) * factor) / polygon.length;
              if (isNaN(plane[X$2])) {
                return undefined;
              } else {
                return plane;
              }
            };

            const W$1 = 3;

            /**
             * Calculate the distance to the given point
             * @return {Number} signed distance to point
             */
            const signedDistanceToPoint = (plane, point) =>
              dot(plane, point) - plane[W$1];

            const W$2 = 3;
            /**
             * Split the given line by the given plane.
             * Robust splitting, even if the line is parallel to the plane
             * @type {function(plane:Plane, start:Point, end:Point):Point}
             */
            const splitLineByPlane = (plane, start, end) => {
              const direction = subtract(end, start);
              const lambda = (plane[W$2] - dot(plane, start)) / dot(plane, direction);
              if (Number.isNaN(lambda)) {
                return start;
              }
              return add(start, scale(lambda, direction));
            };

            const W$3 = 3;

            /**
             * Split the given line by the given plane.
             * Robust splitting, even if the line is parallel to the plane
             * @type {function(plane:Plane, start:Point, end:Point):Point}
             */
            const splitLineSegmentByPlane = (plane, start, end) => {
              const direction = subtract(end, start);
              let lambda = (plane[W$3] - dot(plane, start)) / dot(plane, direction);
              if (Number.isNaN(lambda)) lambda = 0;
              if (lambda > 1) lambda = 1;
              if (lambda < 0) lambda = 0;
              return add(start, scale(lambda, direction));
            };

            const W$4 = 3;

            const toPolygon = (plane, size = 1e10) => {
              const v = unit(cross(plane, orthogonal(plane)));
              const u = cross(v, plane);
              const origin = scale(plane[W$4], plane);
              return [
                add(origin, scale(-size, u)),
                add(origin, scale(-size, v)),
                add(origin, scale(size, u)),
                add(origin, scale(size, v)),
              ];
            };

            const X$1$2 = 0;
            const Y$1$2 = 1;
            const Z$1$1 = 2;
            const W$5 = 3;

            const toXYPlaneTransforms = (plane, rightVector) => {
              if (plane === undefined) {
                throw Error('die');
              }
              if (rightVector === undefined) {
                rightVector = orthogonal(plane);
              }

              const v = unit(cross(plane, rightVector));
              const u = cross(v, plane);
              const p = multiply(plane, fromScalar(plane[W$5]));

              const to = fromValues$1(
                u[X$1$2],
                v[X$1$2],
                plane[X$1$2],
                0,
                u[Y$1$2],
                v[Y$1$2],
                plane[Y$1$2],
                0,
                u[Z$1$1],
                v[Z$1$1],
                plane[Z$1$1],
                0,
                0,
                0,
                -plane[W$5],
                1
              );

              const from = fromValues$1(
                u[X$1$2],
                u[Y$1$2],
                u[Z$1$1],
                0,
                v[X$1$2],
                v[Y$1$2],
                v[Z$1$1],
                0,
                plane[X$1$2],
                plane[Y$1$2],
                plane[Z$1$1],
                0,
                p[X$1$2],
                p[Y$1$2],
                p[Z$1$1],
                1
              );

              return [to, from];
            };

            /**
             * Transform the given plane using the given matrix
             * @return {Array} a new plane with properly typed values
             */
            const transform$2 = (matrix, plane) => {
              const ismirror = isMirroring(matrix);
              // get two vectors in the plane:
              const r = orthogonal(plane);
              const u = cross(plane, r);
              const v = cross(plane, u);
              // get 3 points in the plane:
              let point1 = multiply(plane, [plane[3], plane[3], plane[3]]);
              let point2 = add(point1, u);
              let point3 = add(point1, v);
              // transform the points:
              point1 = transform(matrix, point1);
              point2 = transform(matrix, point2);
              point3 = transform(matrix, point3);
              // and create a new plane from the transformed points:
              let newplane = fromPoints(point1, point2, point3);
              if (ismirror) {
                // the transform is mirroring so mirror the plane
                newplane = flip$1(newplane);
              }
              return newplane;
            };

            const canonicalize$3 = (polygon) => polygon.map(canonicalize);

            /**
             * Flip the give polygon to face the opposite direction.
             *
             * @param {poly3} polygon - the polygon to flip
             * @returns {poly3} a new poly3
             */
            const flip$2 = (polygon) => [...polygon].reverse();

            /**
             * Create a Polygon from the given points.
             * @type {function(Point[], Plane):Polygon}
             */
            const fromPoints$1 = (points, planeof) => [...points];

            const toPlane = (polygon) => {
              if (polygon.plane === undefined) {
                polygon.plane = fromPolygon(polygon);
              }
              return polygon.plane;
            };

            /**
             * Check whether the polygon is convex.
             * @returns {boolean}
             */
            const areVerticesConvex = (vertices, plane) => {
              if (plane === undefined) {
                return false;
              }
              const numvertices = vertices.length;
              if (numvertices > 3) {
                let prevprevpos = vertices[numvertices - 2];
                let prevpos = vertices[numvertices - 1];
                for (let i = 0; i < numvertices; i++) {
                  const pos = vertices[i];
                  if (!isConvexPoint(prevprevpos, prevpos, pos, plane)) {
                    return false;
                  }
                  prevprevpos = prevpos;
                  prevpos = pos;
                }
              }
              return true;
            };

            // calculate whether three points form a convex corner
            //  prevpoint, point, nextpoint: the 3 coordinates (Vector3D instances)
            //  normal: the normal vector of the plane
            const isConvexPoint = (prevpoint, point, nextpoint, plane) => {
              const crossproduct = cross(
                subtract(point, prevpoint),
                subtract(nextpoint, point)
              );
              // The plane of a polygon is structurally equivalent to its normal.
              const crossdotnormal = dot(crossproduct, plane);
              // CHECK: 0 or EPS?
              return crossdotnormal >= 0;
            };

            const isConvex = (polygon) =>
              areVerticesConvex(polygon, toPlane(polygon));

            /**
             * Transforms the vertices of a polygon, producing a new poly3.
             *
             * The polygon does not need to be a poly3, but may be any array of
             * points. The points being represented as arrays of values.
             *
             * If the original has a 'plane' property, the result will have a clone
             * of the plane.
             *
             * @param {Function} [transform=vec3.clone] - function used to transform the vertices.
             * @returns {Array} a copy with transformed vertices and copied properties.
             *
             * @example
             * const vertices = [ [0, 0, 0], [0, 10, 0], [0, 10, 10] ]
             * let observed = poly3.map(vertices)
             */
            const map = (original, transform) => {
              if (original === undefined) {
                original = [];
              }
              if (transform === undefined) {
                transform = (_) => _;
              }
              return original.map((vertex) => transform(vertex));
            };

            // measure the area of the given poly3 (3D planar polygon)
            // translated from the orginal C++ code from Dan Sunday
            // 2000 softSurfer http://geomalgorithms.com
            const measureArea$1 = (poly3) => {
              let area = poly3.area;
              if (area !== undefined) {
                return area;
              }

              area = 0;
              const n = poly3.length;
              if (n < 3) {
                return 0; // degenerate polygon
              }
              const vertices = poly3;

              // calculate a real normal
              const a = vertices[0];
              const b = vertices[1];
              const c = vertices[2];
              const ba = subtract(b, a);
              const ca = subtract(c, a);
              const normal = cross(ba, ca);
              // let normal = b.minus(a).cross(c.minus(a))
              // let normal = poly3.plane.normal // unit based normal, CANNOT use

              // determin direction of projection
              const ax = Math.abs(normal[0]);
              const ay = Math.abs(normal[1]);
              const az = Math.abs(normal[2]);
              const an = Math.sqrt(ax * ax + ay * ay + az * az); // length of normal

              let coord = 3; // ignore Z coordinates
              if (ax > ay && ax > az) {
                coord = 1; // ignore X coordinates
              } else if (ay > az) {
                coord = 2; // ignore Y coordinates
              }

              let h = 0;
              let i = 1;
              let j = 2;
              switch (coord) {
                case 1: // ignore X coordinates
                  // compute area of 2D projection
                  for (i = 1; i < n; i++) {
                    h = i - 1;
                    j = (i + 1) % n;
                    area += vertices[i][1] * (vertices[j][2] - vertices[h][2]);
                  }
                  area += vertices[0][1] * (vertices[1][2] - vertices[n - 1][2]);
                  // scale to get area
                  area *= an / (2 * normal[0]);
                  break;

                case 2: // ignore Y coordinates
                  // compute area of 2D projection
                  for (i = 1; i < n; i++) {
                    h = i - 1;
                    j = (i + 1) % n;
                    area += vertices[i][2] * (vertices[j][0] - vertices[h][0]);
                  }
                  area += vertices[0][2] * (vertices[1][0] - vertices[n - 1][0]);
                  // scale to get area
                  area *= an / (2 * normal[1]);
                  break;

                case 3: // ignore Z coordinates
                default:
                  // compute area of 2D projection
                  for (i = 1; i < n; i++) {
                    h = i - 1;
                    j = (i + 1) % n;
                    area += vertices[i][0] * (vertices[j][1] - vertices[h][1]);
                  }
                  area += vertices[0][0] * (vertices[1][1] - vertices[n - 1][1]);
                  // scale to get area
                  area *= an / (2 * normal[2]);
                  break;
              }

              poly3.area = area;
              return area;
            };

            // Affine transformation of polygon. Returns a new polygon.
            const transform$3 = (matrix, polygon) => {
              const transformed = map(polygon, (vertex) => transform(matrix, vertex));
              if (isMirroring(matrix)) {
                // Reverse the order to preserve the orientation.
                transformed.reverse();
              }
              return transformed;
            };

            const isDegenerate = (polygon) => {
              for (let nth = 0; nth < polygon.length; nth++) {
                if (equals(polygon[nth], polygon[(nth + 1) % polygon.length])) {
                  return true;
                }
              }
              return false;
            };

            const canonicalize$4 = (polygons) => {
              const canonicalized = [];
              for (let polygon of polygons) {
                polygon = canonicalize$3(polygon);
                if (!isDegenerate(polygon)) {
                  canonicalized.push(polygon);
                }
              }
              return canonicalized;
            };

            const measureBoundingBox = (polygons) => {
              if (polygons.measureBoundingBox === undefined) {
                const min = [Infinity, Infinity, Infinity];
                const max = [-Infinity, -Infinity, -Infinity];
                for (const path of polygons) {
                  for (const point of path) {
                    if (point[0] < min[0]) min[0] = point[0];
                    if (point[1] < min[1]) min[1] = point[1];
                    if (point[2] < min[2]) min[2] = point[2];
                    if (point[0] > max[0]) max[0] = point[0];
                    if (point[1] > max[1]) max[1] = point[1];
                    if (point[2] > max[2]) max[2] = point[2];
                  }
                }
                polygons.measureBoundingBox = [min, max];
              }
              return polygons.measureBoundingBox;
            };

            const iota = 1e-5;
            const X$3 = 0;
            const Y$3 = 1;
            const Z$2 = 2;

            // Requires a conservative gap.
            const doesNotOverlap = (a, b) => {
              if (a.length === 0 || b.length === 0) {
                return true;
              }
              const [minA, maxA] = measureBoundingBox(a);
              const [minB, maxB] = measureBoundingBox(b);
              if (maxA[X$3] <= minB[X$3] - iota * 10) {
                return true;
              }
              if (maxA[Y$3] <= minB[Y$3] - iota * 10) {
                return true;
              }
              if (maxA[Z$2] <= minB[Z$2] - iota * 10) {
                return true;
              }
              if (maxB[X$3] <= minA[X$3] - iota * 10) {
                return true;
              }
              if (maxB[Y$3] <= minA[Y$3] - iota * 10) {
                return true;
              }
              if (maxB[Z$2] <= minA[Z$2] - iota * 10) {
                return true;
              }
              return false;
            };

            /**
             * Transforms each polygon of Polygons.
             *
             * @param {Polygons} original - the Polygons to transform.
             * @param {Function} [transform=identity] - function used to transform the polygons.
             * @returns {Polygons} a copy with transformed polygons.
             */
            const map$1 = (original, transform) => {
              if (original === undefined) {
                original = [];
              }
              if (transform === undefined) {
                transform = (_) => _;
              }
              return original.map((polygon) => transform(polygon));
            };

            const flip$3 = (polygons) => map$1(polygons, flip$2);

            // const EPSILON = 1e-5;
            const EPSILON2 = 1e-10;

            const pushWhenValid = (out, points, expectedPlane) => {
              const validated = [];
              const l = points.length;
              for (let i = 0; i < l; i++) {
                if (squaredDistance(points[i], points[(i + 1) % l]) > EPSILON2) {
                  validated.push(points[i]);
                }
              }
              if (validated.length < 3) {
                return;
              }
              const plane = fromPolygon(validated);
              if (plane === undefined) {
                return;
              }
              if (expectedPlane !== undefined) {
                validated.plane = expectedPlane;
              }
              out.push(validated);
            };

            const toTriangles = (options = {}, paths) => {
              const triangles = [];
              for (const path of paths) {
                for (let nth = 2; nth < path.length; nth++) {
                  triangles.push([path[0], path[nth - 1], path[nth]]);
                }
              }
              return triangles;
            };

            var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global$1 !== 'undefined' ? global$1 : typeof self !== 'undefined' ? self : {};

            function unwrapExports (x) {
            	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
            }

            function createCommonjsModule$1(fn, module) {
            	return module = { exports: {} }, fn(module, module.exports), module.exports;
            }

            var global$1$2 = (typeof global$1 !== "undefined" ? global$1 :
                        typeof self !== "undefined" ? self :
                        typeof window !== "undefined" ? window : {});

            // shim for using process in browser
            // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

            function defaultSetTimout$1() {
                throw new Error('setTimeout has not been defined');
            }
            function defaultClearTimeout$1 () {
                throw new Error('clearTimeout has not been defined');
            }
            var cachedSetTimeout$1 = defaultSetTimout$1;
            var cachedClearTimeout$1 = defaultClearTimeout$1;
            if (typeof global$1$2.setTimeout === 'function') {
                cachedSetTimeout$1 = setTimeout;
            }
            if (typeof global$1$2.clearTimeout === 'function') {
                cachedClearTimeout$1 = clearTimeout;
            }

            function runTimeout$1(fun) {
                if (cachedSetTimeout$1 === setTimeout) {
                    //normal enviroments in sane situations
                    return setTimeout(fun, 0);
                }
                // if setTimeout wasn't available but was latter defined
                if ((cachedSetTimeout$1 === defaultSetTimout$1 || !cachedSetTimeout$1) && setTimeout) {
                    cachedSetTimeout$1 = setTimeout;
                    return setTimeout(fun, 0);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedSetTimeout$1(fun, 0);
                } catch(e){
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                        return cachedSetTimeout$1.call(null, fun, 0);
                    } catch(e){
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                        return cachedSetTimeout$1.call(this, fun, 0);
                    }
                }


            }
            function runClearTimeout$1(marker) {
                if (cachedClearTimeout$1 === clearTimeout) {
                    //normal enviroments in sane situations
                    return clearTimeout(marker);
                }
                // if clearTimeout wasn't available but was latter defined
                if ((cachedClearTimeout$1 === defaultClearTimeout$1 || !cachedClearTimeout$1) && clearTimeout) {
                    cachedClearTimeout$1 = clearTimeout;
                    return clearTimeout(marker);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedClearTimeout$1(marker);
                } catch (e){
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                        return cachedClearTimeout$1.call(null, marker);
                    } catch (e){
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                        // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                        return cachedClearTimeout$1.call(this, marker);
                    }
                }



            }
            var queue$1 = [];
            var draining$1 = false;
            var currentQueue$1;
            var queueIndex$1 = -1;

            function cleanUpNextTick$1() {
                if (!draining$1 || !currentQueue$1) {
                    return;
                }
                draining$1 = false;
                if (currentQueue$1.length) {
                    queue$1 = currentQueue$1.concat(queue$1);
                } else {
                    queueIndex$1 = -1;
                }
                if (queue$1.length) {
                    drainQueue$1();
                }
            }

            function drainQueue$1() {
                if (draining$1) {
                    return;
                }
                var timeout = runTimeout$1(cleanUpNextTick$1);
                draining$1 = true;

                var len = queue$1.length;
                while(len) {
                    currentQueue$1 = queue$1;
                    queue$1 = [];
                    while (++queueIndex$1 < len) {
                        if (currentQueue$1) {
                            currentQueue$1[queueIndex$1].run();
                        }
                    }
                    queueIndex$1 = -1;
                    len = queue$1.length;
                }
                currentQueue$1 = null;
                draining$1 = false;
                runClearTimeout$1(timeout);
            }
            function nextTick$1(fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for (var i = 1; i < arguments.length; i++) {
                        args[i - 1] = arguments[i];
                    }
                }
                queue$1.push(new Item$1(fun, args));
                if (queue$1.length === 1 && !draining$1) {
                    runTimeout$1(drainQueue$1);
                }
            }
            // v8 likes predictible objects
            function Item$1(fun, array) {
                this.fun = fun;
                this.array = array;
            }
            Item$1.prototype.run = function () {
                this.fun.apply(null, this.array);
            };
            var title$1 = 'browser';
            var platform$1 = 'browser';
            var browser$1 = true;
            var env$1 = {};
            var argv$1 = [];
            var version$1 = ''; // empty string to avoid regexp issues
            var versions$1 = {};
            var release$1 = {};
            var config$1 = {};

            function noop$1() {}

            var on$1 = noop$1;
            var addListener$1 = noop$1;
            var once$1 = noop$1;
            var off$1 = noop$1;
            var removeListener$1 = noop$1;
            var removeAllListeners$1 = noop$1;
            var emit$2 = noop$1;

            function binding$1(name) {
                throw new Error('process.binding is not supported');
            }

            function cwd$1 () { return '/' }
            function chdir$1 (dir) {
                throw new Error('process.chdir is not supported');
            }function umask$1() { return 0; }

            // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
            var performance$1 = global$1$2.performance || {};
            var performanceNow$1 =
              performance$1.now        ||
              performance$1.mozNow     ||
              performance$1.msNow      ||
              performance$1.oNow       ||
              performance$1.webkitNow  ||
              function(){ return (new Date()).getTime() };

            // generate timestamp or delta
            // see http://nodejs.org/api/process.html#process_process_hrtime
            function hrtime$1(previousTimestamp){
              var clocktime = performanceNow$1.call(performance$1)*1e-3;
              var seconds = Math.floor(clocktime);
              var nanoseconds = Math.floor((clocktime%1)*1e9);
              if (previousTimestamp) {
                seconds = seconds - previousTimestamp[0];
                nanoseconds = nanoseconds - previousTimestamp[1];
                if (nanoseconds<0) {
                  seconds--;
                  nanoseconds += 1e9;
                }
              }
              return [seconds,nanoseconds]
            }

            var startTime$1 = new Date();
            function uptime$1() {
              var currentTime = new Date();
              var dif = currentTime - startTime$1;
              return dif / 1000;
            }

            var process$1 = {
              nextTick: nextTick$1,
              title: title$1,
              browser: browser$1,
              env: env$1,
              argv: argv$1,
              version: version$1,
              versions: versions$1,
              on: on$1,
              addListener: addListener$1,
              once: once$1,
              off: off$1,
              removeListener: removeListener$1,
              removeAllListeners: removeAllListeners$1,
              emit: emit$2,
              binding: binding$1,
              cwd: cwd$1,
              chdir: chdir$1,
              umask: umask$1,
              hrtime: hrtime$1,
              platform: platform$1,
              release: release$1,
              config: config$1,
              uptime: uptime$1
            };

            var enums = createCommonjsModule$1(function (module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            /**
             * By far the most widely used winding rules for polygon filling are EvenOdd & NonZero (GDI, GDI+, XLib, OpenGL, Cairo, AGG, Quartz, SVG, Gr32)
             * Others rules include Positive, Negative and ABS_GTR_EQ_TWO (only in OpenGL)
             * see http://glprogramming.com/red/chapter11.html
             */
            var PolyFillType;
            (function (PolyFillType) {
                PolyFillType["EvenOdd"] = "evenOdd";
                PolyFillType["NonZero"] = "nonZero";
                PolyFillType["Positive"] = "positive";
                PolyFillType["Negative"] = "negative";
            })(PolyFillType = exports.PolyFillType || (exports.PolyFillType = {}));
            var ClipType;
            (function (ClipType) {
                ClipType["Intersection"] = "intersection";
                ClipType["Union"] = "union";
                ClipType["Difference"] = "difference";
                ClipType["Xor"] = "xor";
            })(ClipType = exports.ClipType || (exports.ClipType = {}));
            var PolyType;
            (function (PolyType) {
                PolyType["Subject"] = "subject";
                PolyType["Clip"] = "clip";
            })(PolyType = exports.PolyType || (exports.PolyType = {}));
            var JoinType;
            (function (JoinType) {
                JoinType["Square"] = "square";
                JoinType["Round"] = "round";
                JoinType["Miter"] = "miter";
            })(JoinType = exports.JoinType || (exports.JoinType = {}));
            var EndType;
            (function (EndType) {
                EndType["ClosedPolygon"] = "closedPolygon";
                EndType["ClosedLine"] = "closedLine";
                EndType["OpenButt"] = "openButt";
                EndType["OpenSquare"] = "openSquare";
                EndType["OpenRound"] = "openRound";
            })(EndType = exports.EndType || (exports.EndType = {}));
            var PointInPolygonResult;
            (function (PointInPolygonResult) {
                PointInPolygonResult[PointInPolygonResult["Outside"] = 0] = "Outside";
                PointInPolygonResult[PointInPolygonResult["Inside"] = 1] = "Inside";
                PointInPolygonResult[PointInPolygonResult["OnBoundary"] = -1] = "OnBoundary";
            })(PointInPolygonResult = exports.PointInPolygonResult || (exports.PointInPolygonResult = {}));
            /**
             * Format to use when loading the native library instance.
             */
            var NativeClipperLibRequestedFormat;
            (function (NativeClipperLibRequestedFormat) {
                /**
                 * Try to load the WebAssembly version, if it fails try to load the Asm.js version.
                 */
                NativeClipperLibRequestedFormat["WasmWithAsmJsFallback"] = "wasmWithAsmJsFallback";
                /**
                 * Load the WebAssembly version exclusively.
                 */
                NativeClipperLibRequestedFormat["WasmOnly"] = "wasmOnly";
                /**
                 * Load the Asm.js version exclusively.
                 */
                NativeClipperLibRequestedFormat["AsmJsOnly"] = "asmJsOnly";
            })(NativeClipperLibRequestedFormat = exports.NativeClipperLibRequestedFormat || (exports.NativeClipperLibRequestedFormat = {}));
            /**
             * The format the native library being used is in.
             */
            var NativeClipperLibLoadedFormat;
            (function (NativeClipperLibLoadedFormat) {
                /**
                 * WebAssembly.
                 */
                NativeClipperLibLoadedFormat["Wasm"] = "wasm";
                /**
                 * Asm.js.
                 */
                NativeClipperLibLoadedFormat["AsmJs"] = "asmJs";
            })(NativeClipperLibLoadedFormat = exports.NativeClipperLibLoadedFormat || (exports.NativeClipperLibLoadedFormat = {}));

            });

            unwrapExports(enums);
            var enums_1 = enums.PolyFillType;
            var enums_2 = enums.ClipType;
            var enums_3 = enums.PolyType;
            var enums_4 = enums.JoinType;
            var enums_5 = enums.EndType;
            var enums_6 = enums.PointInPolygonResult;
            var enums_7 = enums.NativeClipperLibRequestedFormat;
            var enums_8 = enums.NativeClipperLibLoadedFormat;

            var nativeEnumConversion = createCommonjsModule$1(function (module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });

            function polyFillTypeToNative(nativeLib, polyFillType) {
                switch (polyFillType) {
                    case enums.PolyFillType.EvenOdd:
                        return nativeLib.PolyFillType.EvenOdd;
                    case enums.PolyFillType.NonZero:
                        return nativeLib.PolyFillType.NonZero;
                    case enums.PolyFillType.Positive:
                        return nativeLib.PolyFillType.Positive;
                    case enums.PolyFillType.Negative:
                        return nativeLib.PolyFillType.Negative;
                    default:
                        throw new Error("unknown poly fill type");
                }
            }
            exports.polyFillTypeToNative = polyFillTypeToNative;
            function clipTypeToNative(nativeLib, clipType) {
                switch (clipType) {
                    case enums.ClipType.Intersection:
                        return nativeLib.ClipType.Intersection;
                    case enums.ClipType.Union:
                        return nativeLib.ClipType.Union;
                    case enums.ClipType.Difference:
                        return nativeLib.ClipType.Difference;
                    case enums.ClipType.Xor:
                        return nativeLib.ClipType.Xor;
                    default:
                        throw new Error("unknown clip type");
                }
            }
            exports.clipTypeToNative = clipTypeToNative;
            function polyTypeToNative(nativeLib, polyType) {
                switch (polyType) {
                    case enums.PolyType.Subject:
                        return nativeLib.PolyType.Subject;
                    case enums.PolyType.Clip:
                        return nativeLib.PolyType.Clip;
                    default:
                        throw new Error("unknown poly type");
                }
            }
            exports.polyTypeToNative = polyTypeToNative;
            function joinTypeToNative(nativeLib, joinType) {
                switch (joinType) {
                    case enums.JoinType.Square:
                        return nativeLib.JoinType.Square;
                    case enums.JoinType.Round:
                        return nativeLib.JoinType.Round;
                    case enums.JoinType.Miter:
                        return nativeLib.JoinType.Miter;
                    default:
                        throw new Error("unknown join type");
                }
            }
            exports.joinTypeToNative = joinTypeToNative;
            function endTypeToNative(nativeLib, endType) {
                switch (endType) {
                    case enums.EndType.ClosedPolygon:
                        return nativeLib.EndType.ClosedPolygon;
                    case enums.EndType.ClosedLine:
                        return nativeLib.EndType.ClosedLine;
                    case enums.EndType.OpenButt:
                        return nativeLib.EndType.OpenButt;
                    case enums.EndType.OpenSquare:
                        return nativeLib.EndType.OpenSquare;
                    case enums.EndType.OpenRound:
                        return nativeLib.EndType.OpenRound;
                    default:
                        throw new Error("unknown end type");
                }
            }
            exports.endTypeToNative = endTypeToNative;

            });

            unwrapExports(nativeEnumConversion);
            var nativeEnumConversion_1 = nativeEnumConversion.polyFillTypeToNative;
            var nativeEnumConversion_2 = nativeEnumConversion.clipTypeToNative;
            var nativeEnumConversion_3 = nativeEnumConversion.polyTypeToNative;
            var nativeEnumConversion_4 = nativeEnumConversion.joinTypeToNative;
            var nativeEnumConversion_5 = nativeEnumConversion.endTypeToNative;

            var mem = createCommonjsModule$1(function (module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            function mallocDoubleArray(nativeClipperLib, len) {
                var nofBytes = len * Float64Array.BYTES_PER_ELEMENT;
                var ptr = nativeClipperLib._malloc(nofBytes);
                return new Float64Array(nativeClipperLib.HEAPF64.buffer, ptr, len);
            }
            exports.mallocDoubleArray = mallocDoubleArray;
            function freeTypedArray(nativeClipperLib, array) {
                nativeClipperLib._free(array.byteOffset);
            }
            exports.freeTypedArray = freeTypedArray;

            });

            unwrapExports(mem);
            var mem_1 = mem.mallocDoubleArray;
            var mem_2 = mem.freeTypedArray;

            var PathToNativePath = createCommonjsModule$1(function (module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });

            var coordsPerPoint = 2;
            function getNofItemsForPath(path) {
                return 1 + path.length * coordsPerPoint;
            }
            exports.getNofItemsForPath = getNofItemsForPath;
            // js to c++
            function writePathToDoubleArray(path, heapBytes, startPtr) {
                var len = path.length;
                heapBytes[startPtr] = len;
                var arrayI = 1 + startPtr;
                for (var i = 0; i < len; i++) {
                    heapBytes[arrayI++] = path[i].x;
                    heapBytes[arrayI++] = path[i].y;
                }
                return arrayI;
            }
            exports.writePathToDoubleArray = writePathToDoubleArray;
            function pathToDoubleArray(nativeClipperLib, path) {
                var nofItems = getNofItemsForPath(path);
                var heapBytes = mem.mallocDoubleArray(nativeClipperLib, nofItems);
                writePathToDoubleArray(path, heapBytes, 0);
                return heapBytes;
            }
            exports.pathToDoubleArray = pathToDoubleArray;
            function doubleArrayToNativePath(nativeClipperLib, array, freeArray) {
                var p = new nativeClipperLib.Path();
                nativeClipperLib.toPath(p, array.byteOffset);
                if (freeArray) {
                    mem.freeTypedArray(nativeClipperLib, array);
                }
                return p;
            }
            exports.doubleArrayToNativePath = doubleArrayToNativePath;
            function pathToNativePath(nativeClipperLib, path) {
                var array = pathToDoubleArray(nativeClipperLib, path);
                return doubleArrayToNativePath(nativeClipperLib, array, true);
            }
            exports.pathToNativePath = pathToNativePath;
            // c++ to js
            function nativePathToDoubleArray(nativeClipperLib, nativePath, freeNativePath) {
                var array = nativeClipperLib.fromPath(nativePath);
                if (freeNativePath) {
                    nativePath.delete();
                }
                return array;
            }
            exports.nativePathToDoubleArray = nativePathToDoubleArray;
            function doubleArrayToPath(nativeClipperLib, array, _freeDoubleArray, startPtr) {
                var len = array[startPtr];
                var path = [];
                path.length = len;
                var arrayI = 1 + startPtr;
                for (var i = 0; i < len; i++) {
                    path[i] = {
                        x: array[arrayI++],
                        y: array[arrayI++]
                    };
                }
                if (_freeDoubleArray) {
                    mem.freeTypedArray(nativeClipperLib, array);
                }
                return {
                    path: path,
                    ptrEnd: arrayI
                };
            }
            exports.doubleArrayToPath = doubleArrayToPath;
            function nativePathToPath(nativeClipperLib, nativePath, freeNativePath) {
                var array = nativePathToDoubleArray(nativeClipperLib, nativePath, freeNativePath);
                return doubleArrayToPath(nativeClipperLib, array, true, 0).path;
            }
            exports.nativePathToPath = nativePathToPath;

            });

            unwrapExports(PathToNativePath);
            var PathToNativePath_1 = PathToNativePath.getNofItemsForPath;
            var PathToNativePath_2 = PathToNativePath.writePathToDoubleArray;
            var PathToNativePath_3 = PathToNativePath.pathToDoubleArray;
            var PathToNativePath_4 = PathToNativePath.doubleArrayToNativePath;
            var PathToNativePath_5 = PathToNativePath.pathToNativePath;
            var PathToNativePath_6 = PathToNativePath.nativePathToDoubleArray;
            var PathToNativePath_7 = PathToNativePath.doubleArrayToPath;
            var PathToNativePath_8 = PathToNativePath.nativePathToPath;

            var PathsToNativePaths = createCommonjsModule$1(function (module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });


            // js to c++
            function pathsToDoubleArray(nativeClipperLib, myPaths) {
                var nofPaths = myPaths.length;
                // first calculate nof items required
                var nofItems = 1; // for path count
                for (var i = 0; i < nofPaths; i++) {
                    nofItems += PathToNativePath.getNofItemsForPath(myPaths[i]);
                }
                var heapBytes = mem.mallocDoubleArray(nativeClipperLib, nofItems);
                heapBytes[0] = nofPaths;
                var ptr = 1;
                for (var i = 0; i < nofPaths; i++) {
                    var path = myPaths[i];
                    ptr = PathToNativePath.writePathToDoubleArray(path, heapBytes, ptr);
                }
                return heapBytes;
            }
            exports.pathsToDoubleArray = pathsToDoubleArray;
            function doubleArrayToNativePaths(nativeClipperLib, array, freeArray) {
                var p = new nativeClipperLib.Paths();
                nativeClipperLib.toPaths(p, array.byteOffset);
                if (freeArray) {
                    mem.freeTypedArray(nativeClipperLib, array);
                }
                return p;
            }
            exports.doubleArrayToNativePaths = doubleArrayToNativePaths;
            function pathsToNativePaths(nativeClipperLib, paths) {
                var array = pathsToDoubleArray(nativeClipperLib, paths);
                return doubleArrayToNativePaths(nativeClipperLib, array, true);
            }
            exports.pathsToNativePaths = pathsToNativePaths;
            // c++ to js
            function nativePathsToDoubleArray(nativeClipperLib, nativePaths, freeNativePaths) {
                var array = nativeClipperLib.fromPaths(nativePaths);
                if (freeNativePaths) {
                    nativePaths.delete();
                }
                return array;
            }
            exports.nativePathsToDoubleArray = nativePathsToDoubleArray;
            function doubleArrayToPaths(nativeClipperLib, array, _freeDoubleArray) {
                var len = array[0];
                var paths = [];
                paths.length = len;
                var arrayI = 1;
                for (var i = 0; i < len; i++) {
                    var result = PathToNativePath.doubleArrayToPath(nativeClipperLib, array, false, arrayI);
                    paths[i] = result.path;
                    arrayI = result.ptrEnd;
                }
                if (_freeDoubleArray) {
                    mem.freeTypedArray(nativeClipperLib, array);
                }
                return paths;
            }
            exports.doubleArrayToPaths = doubleArrayToPaths;
            function nativePathsToPaths(nativeClipperLib, nativePaths, freeNativePaths) {
                var array = nativePathsToDoubleArray(nativeClipperLib, nativePaths, freeNativePaths);
                return doubleArrayToPaths(nativeClipperLib, array, true);
            }
            exports.nativePathsToPaths = nativePathsToPaths;

            });

            unwrapExports(PathsToNativePaths);
            var PathsToNativePaths_1 = PathsToNativePaths.pathsToDoubleArray;
            var PathsToNativePaths_2 = PathsToNativePaths.doubleArrayToNativePaths;
            var PathsToNativePaths_3 = PathsToNativePaths.pathsToNativePaths;
            var PathsToNativePaths_4 = PathsToNativePaths.nativePathsToDoubleArray;
            var PathsToNativePaths_5 = PathsToNativePaths.doubleArrayToPaths;
            var PathsToNativePaths_6 = PathsToNativePaths.nativePathsToPaths;

            var PolyNode_1 = createCommonjsModule$1(function (module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });

            /**
             * PolyNodes are encapsulated within a PolyTree container, and together provide a data structure representing the parent-child relationships of polygon
             * contours returned by clipping/ofsetting methods.
             *
             * A PolyNode object represents a single polygon. It's isHole property indicates whether it's an outer or a hole. PolyNodes may own any number of PolyNode
             * children (childs), where children of outer polygons are holes, and children of holes are (nested) outer polygons.
             */
            var PolyNode = /** @class */ (function () {
                function PolyNode() {
                    this._childs = [];
                    this._contour = [];
                    this._isOpen = false;
                    this._index = 0;
                }
                Object.defineProperty(PolyNode.prototype, "parent", {
                    /**
                     * Returns the parent PolyNode.
                     *
                     * The PolyTree object (which is also a PolyNode) does not have a parent and will return undefined.
                     */
                    get: function () {
                        return this._parent;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(PolyNode.prototype, "childs", {
                    /**
                     * A read-only list of PolyNode.
                     * Outer PolyNode childs contain hole PolyNodes, and hole PolyNode childs contain nested outer PolyNodes.
                     */
                    get: function () {
                        return this._childs;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(PolyNode.prototype, "contour", {
                    /**
                     * Returns a path list which contains any number of vertices.
                     */
                    get: function () {
                        return this._contour;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(PolyNode.prototype, "isOpen", {
                    /**
                     * Returns true when the PolyNode's Contour results from a clipping operation on an open contour (path). Only top-level PolyNodes can contain open contours.
                     */
                    get: function () {
                        return this._isOpen;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(PolyNode.prototype, "index", {
                    /**
                     * Index in the parent's child list, or 0 if no parent.
                     */
                    get: function () {
                        return this._index;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(PolyNode.prototype, "isHole", {
                    /**
                     * Returns true when the PolyNode's polygon (Contour) is a hole.
                     *
                     * Children of outer polygons are always holes, and children of holes are always (nested) outer polygons.
                     * The isHole property of a PolyTree object is undefined but its children are always top-level outer polygons.
                     *
                     * @return {boolean}
                     */
                    get: function () {
                        if (this._isHole === undefined) {
                            var result = true;
                            var node = this._parent;
                            while (node !== undefined) {
                                result = !result;
                                node = node._parent;
                            }
                            this._isHole = result;
                        }
                        return this._isHole;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * The returned PolyNode will be the first child if any, otherwise the next sibling, otherwise the next sibling of the Parent etc.
                 *
                 * A PolyTree can be traversed very easily by calling GetFirst() followed by GetNext() in a loop until the returned object is undefined.
                 *
                 * @return {PolyNode | undefined}
                 */
                PolyNode.prototype.getNext = function () {
                    if (this._childs.length > 0) {
                        return this._childs[0];
                    }
                    else {
                        return this.getNextSiblingUp();
                    }
                };
                PolyNode.prototype.getNextSiblingUp = function () {
                    if (this._parent === undefined) {
                        return undefined;
                    }
                    else if (this._index === this._parent._childs.length - 1) {
                        //noinspection TailRecursionJS
                        return this._parent.getNextSiblingUp();
                    }
                    else {
                        return this._parent._childs[this._index + 1];
                    }
                };
                PolyNode.fillFromNativePolyNode = function (pn, nativeLib, nativePolyNode, parent, childIndex, freeNativePolyNode) {
                    pn._parent = parent;
                    var childs = nativePolyNode.childs;
                    for (var i = 0, max = childs.size(); i < max; i++) {
                        var newChild = PolyNode.fromNativePolyNode(nativeLib, childs.get(i), pn, i, freeNativePolyNode);
                        pn._childs.push(newChild);
                    }
                    // do we need to clear the object ourselves? for now let's assume so (seems to work)
                    pn._contour = PathToNativePath.nativePathToPath(nativeLib, nativePolyNode.contour, true);
                    pn._isOpen = nativePolyNode.isOpen();
                    pn._index = childIndex;
                    if (freeNativePolyNode) {
                        nativePolyNode.delete();
                    }
                };
                PolyNode.fromNativePolyNode = function (nativeLib, nativePolyNode, parent, childIndex, freeNativePolyNode) {
                    var pn = new PolyNode();
                    PolyNode.fillFromNativePolyNode(pn, nativeLib, nativePolyNode, parent, childIndex, freeNativePolyNode);
                    return pn;
                };
                return PolyNode;
            }());
            exports.PolyNode = PolyNode;

            });

            unwrapExports(PolyNode_1);
            var PolyNode_2 = PolyNode_1.PolyNode;

            var PolyTree_1 = createCommonjsModule$1(function (module, exports) {
            var __extends = (commonjsGlobal$1 && commonjsGlobal$1.__extends) || (function () {
                var extendStatics = function (d, b) {
                    extendStatics = Object.setPrototypeOf ||
                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return extendStatics(d, b);
                };
                return function (d, b) {
                    extendStatics(d, b);
                    function __() { this.constructor = d; }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", { value: true });

            /**
             * PolyTree is intended as a read-only data structure that should only be used to receive solutions from clipping and offsetting operations. It's an
             * alternative to the Paths data structure which also receives these solutions. PolyTree's two major advantages over the Paths structure are: it properly
             * represents the parent-child relationships of the returned polygons; it differentiates between open and closed paths. However, since PolyTree is a more
             * complex structure than the Paths structure, and since it's more computationally expensive to process (the Execute method being roughly 5-10% slower), it
             * should used only be when parent-child polygon relationships are needed, or when open paths are being 'clipped'.
             *
             * A PolyTree object is a container for any number of PolyNode children, with each contained PolyNode representing a single polygon contour (either an outer
             * or hole polygon). PolyTree itself is a specialized PolyNode whose immediate children represent the top-level outer polygons of the solution. (It's own
             * Contour property is always empty.) The contained top-level PolyNodes may contain their own PolyNode children representing hole polygons that may also
             * contain children representing nested outer polygons etc. Children of outers will always be holes, and children of holes will always be outers.
             *
             * PolyTrees can also contain open paths. Open paths will always be represented by top level PolyNodes. Two functions are provided to quickly separate out
             * open and closed paths from a polytree - openPathsFromPolyTree and closedPathsFromPolyTree.
             */
            var PolyTree = /** @class */ (function (_super) {
                __extends(PolyTree, _super);
                function PolyTree() {
                    var _this = _super.call(this) || this;
                    _this._total = 0;
                    return _this;
                }
                Object.defineProperty(PolyTree.prototype, "total", {
                    /**
                     * Returns the total number of PolyNodes (polygons) contained within the PolyTree. This value is not to be confused with childs.length which returns the
                     * number of immediate children only (Childs) contained by PolyTree.
                     */
                    get: function () {
                        return this._total;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * This method returns the first outer polygon contour if any, otherwise undefined.
                 *
                 * This function is equivalent to calling childs[0].
                 */
                PolyTree.prototype.getFirst = function () {
                    if (this.childs.length > 0) {
                        return this.childs[0];
                    }
                    else {
                        return undefined;
                    }
                };
                /**
                 * Internal use.
                 * Constructs a PolyTree from a native PolyTree.
                 */
                PolyTree.fromNativePolyTree = function (nativeLib, nativePolyTree, freeNativePolyTree) {
                    var pt = new PolyTree();
                    PolyNode_1.PolyNode.fillFromNativePolyNode(pt, nativeLib, nativePolyTree, undefined, 0, false); // do NOT free them, they are freed on destruction of the polytree
                    pt._total = nativePolyTree.total();
                    if (freeNativePolyTree) {
                        nativePolyTree.delete(); // this deletes all inner paths, contours etc
                    }
                    return pt;
                };
                return PolyTree;
            }(PolyNode_1.PolyNode));
            exports.PolyTree = PolyTree;

            });

            unwrapExports(PolyTree_1);
            var PolyTree_2 = PolyTree_1.PolyTree;

            var Clipper_1 = createCommonjsModule$1(function (module, exports) {
            var __assign = (commonjsGlobal$1 && commonjsGlobal$1.__assign) || function () {
                __assign = Object.assign || function(t) {
                    for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                            t[p] = s[p];
                    }
                    return t;
                };
                return __assign.apply(this, arguments);
            };
            Object.defineProperty(exports, "__esModule", { value: true });




            var Clipper = /** @class */ (function () {
                /**
                 * The Clipper constructor creates an instance of the Clipper class. One or more InitOptions may be passed as a parameter to set the corresponding properties.
                 * (These properties can still be set or reset after construction.)
                 *
                 * @param _nativeLib
                 * @param initOptions
                 */
                function Clipper(_nativeLib, initOptions) {
                    if (initOptions === void 0) { initOptions = {}; }
                    this._nativeLib = _nativeLib;
                    var realInitOptions = __assign({ reverseSolutions: false, strictlySimple: false, preserveCollinear: false }, initOptions);
                    var nativeInitOptions = 0;
                    if (realInitOptions.reverseSolutions) {
                        nativeInitOptions += _nativeLib.InitOptions.ReverseSolution;
                    }
                    if (realInitOptions.strictlySimple) {
                        nativeInitOptions += _nativeLib.InitOptions.StrictlySimple;
                    }
                    if (realInitOptions.preserveCollinear) {
                        nativeInitOptions += _nativeLib.InitOptions.PreserveCollinear;
                    }
                    this._clipper = new _nativeLib.Clipper(nativeInitOptions);
                }
                Object.defineProperty(Clipper.prototype, "preserveCollinear", {
                    /**
                     * By default, when three or more vertices are collinear in input polygons (subject or clip), the Clipper object removes the 'inner' vertices before
                     * clipping. When enabled the preserveCollinear property prevents this default behavior to allow these inner vertices to appear in the solution.
                     *
                     * @return {boolean} - true if set, false otherwise
                     */
                    get: function () {
                        return this._clipper.preserveCollinear;
                    },
                    /**
                     * By default, when three or more vertices are collinear in input polygons (subject or clip), the Clipper object removes the 'inner' vertices before
                     * clipping. When enabled the preserveCollinear property prevents this default behavior to allow these inner vertices to appear in the solution.
                     *
                     * @param value - value to set
                     */
                    set: function (value) {
                        this._clipper.preserveCollinear = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Clipper.prototype, "reverseSolution", {
                    /**
                     * When this property is set to true, polygons returned in the solution parameter of the execute() method will have orientations opposite to their normal
                     * orientations.
                     *
                     * @return {boolean} - true if set, false otherwise
                     */
                    get: function () {
                        return this._clipper.reverseSolution;
                    },
                    /**
                     * When this property is set to true, polygons returned in the solution parameter of the execute() method will have orientations opposite to their normal
                     * orientations.
                     *
                     * @param value - value to set
                     */
                    set: function (value) {
                        this._clipper.reverseSolution = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Clipper.prototype, "strictlySimple", {
                    /**
                     * Terminology:
                     * - A simple polygon is one that does not self-intersect.
                     * - A weakly simple polygon is a simple polygon that contains 'touching' vertices, or 'touching' edges.
                     * - A strictly simple polygon is a simple polygon that does not contain 'touching' vertices, or 'touching' edges.
                     *
                     * Vertices 'touch' if they share the same coordinates (and are not adjacent). An edge touches another if one of its end vertices touches another edge
                     * excluding its adjacent edges, or if they are co-linear and overlapping (including adjacent edges).
                     *
                     * Polygons returned by clipping operations (see Clipper.execute()) should always be simple polygons. When the StrictlySimply property is enabled,
                     * polygons returned will be strictly simple, otherwise they may be weakly simple. It's computationally expensive ensuring polygons are strictly simple
                     * and so this property is disabled by default.
                     *
                     * Note: There's currently no guarantee that polygons will be strictly simple since 'simplifying' is still a work in progress.
                     *
                     * @return {boolean} - true if set, false otherwise
                     */
                    get: function () {
                        return this._clipper.strictlySimple;
                    },
                    /**
                     * Terminology:
                     * - A simple polygon is one that does not self-intersect.
                     * - A weakly simple polygon is a simple polygon that contains 'touching' vertices, or 'touching' edges.
                     * - A strictly simple polygon is a simple polygon that does not contain 'touching' vertices, or 'touching' edges.
                     *
                     * Vertices 'touch' if they share the same coordinates (and are not adjacent). An edge touches another if one of its end vertices touches another edge
                     * excluding its adjacent edges, or if they are co-linear and overlapping (including adjacent edges).
                     *
                     * Polygons returned by clipping operations (see Clipper.execute()) should always be simple polygons. When the StrictlySimply property is enabled,
                     * polygons returned will be strictly simple, otherwise they may be weakly simple. It's computationally expensive ensuring polygons are strictly simple
                     * and so this property is disabled by default.
                     *
                     * Note: There's currently no guarantee that polygons will be strictly simple since 'simplifying' is still a work in progress.
                     *
                     * @param value - value to set
                     */
                    set: function (value) {
                        this._clipper.strictlySimple = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Any number of subject and clip paths can be added to a clipping task, either individually via the addPath() method, or as groups via the addPaths()
                 * method, or even using both methods.
                 *
                 * 'Subject' paths may be either open (lines) or closed (polygons) or even a mixture of both, but 'clipping' paths must always be closed. Clipper allows
                 * polygons to clip both lines and other polygons, but doesn't allow lines to clip either lines or polygons.
                 *
                 * With closed paths, orientation should conform with the filling rule that will be passed via Clipper's execute method.
                 *
                 * Path Coordinate range:
                 * Path coordinates must be between ± 9007199254740991, otherwise a range error will be thrown when attempting to add the path to the Clipper object.
                 * If coordinates can be kept between ± 0x3FFFFFFF (± 1.0e+9), a modest increase in performance (approx. 15-20%) over the larger range can be achieved by
                 * avoiding large integer math.
                 *
                 * Return Value:
                 * The function will return false if the path is invalid for clipping. A path is invalid for clipping when:
                 * - it has less than 2 vertices
                 * - it has 2 vertices but is not an open path
                 * - the vertices are all co-linear and it is not an open path
                 *
                 * @param path - Path to add
                 * @param polyType - Polygon type
                 * @param closed - If the path is closed
                 */
                Clipper.prototype.addPath = function (path, polyType, closed) {
                    var nativePath = PathToNativePath.pathToNativePath(this._nativeLib, path);
                    try {
                        return this._clipper.addPath(nativePath, nativeEnumConversion.polyTypeToNative(this._nativeLib, polyType), closed);
                    }
                    finally {
                        nativePath.delete();
                    }
                };
                /**
                 * Any number of subject and clip paths can be added to a clipping task, either individually via the addPath() method, or as groups via the addPaths()
                 * method, or even using both methods.
                 *
                 * 'Subject' paths may be either open (lines) or closed (polygons) or even a mixture of both, but 'clipping' paths must always be closed. Clipper allows
                 * polygons to clip both lines and other polygons, but doesn't allow lines to clip either lines or polygons.
                 *
                 * With closed paths, orientation should conform with the filling rule that will be passed via Clipper's execute method.
                 *
                 * Path Coordinate range:
                 * Path coordinates must be between ± 9007199254740991, otherwise a range error will be thrown when attempting to add the path to the Clipper object.
                 * If coordinates can be kept between ± 0x3FFFFFFF (± 1.0e+9), a modest increase in performance (approx. 15-20%) over the larger range can be achieved
                 * by avoiding large integer math.
                 *
                 * Return Value:
                 * The function will return false if the path is invalid for clipping. A path is invalid for clipping when:
                 * - it has less than 2 vertices
                 * - it has 2 vertices but is not an open path
                 * - the vertices are all co-linear and it is not an open path
                 *
                 * @param paths - Paths to add
                 * @param polyType - Paths polygon type
                 * @param closed - If all the inner paths are closed
                 */
                Clipper.prototype.addPaths = function (paths, polyType, closed) {
                    var nativePaths = PathsToNativePaths.pathsToNativePaths(this._nativeLib, paths);
                    try {
                        return this._clipper.addPaths(nativePaths, nativeEnumConversion.polyTypeToNative(this._nativeLib, polyType), closed);
                    }
                    finally {
                        nativePaths.delete();
                    }
                };
                /**
                 * The Clear method removes any existing subject and clip polygons allowing the Clipper object to be reused for clipping operations on different polygon sets.
                 */
                Clipper.prototype.clear = function () {
                    this._clipper.clear();
                };
                /**
                 * This method returns the axis-aligned bounding rectangle of all polygons that have been added to the Clipper object.
                 *
                 * @return {{left: number, right: number, top: number, bottom: number}} - Bounds
                 */
                Clipper.prototype.getBounds = function () {
                    var nativeBounds = this._clipper.getBounds();
                    var rect = {
                        left: nativeBounds.left,
                        right: nativeBounds.right,
                        top: nativeBounds.top,
                        bottom: nativeBounds.bottom
                    };
                    nativeBounds.delete();
                    return rect;
                };
                /**
                 * Once subject and clip paths have been assigned (via addPath and/or addPaths), execute can then perform the clipping operation (intersection, union,
                 * difference or XOR) specified by the clipType parameter.
                 *
                 * The solution parameter in this case is a Paths or PolyTree structure. The Paths structure is simpler than the PolyTree structure. Because of this it is
                 * quicker to populate and hence clipping performance is a little better (it's roughly 10% faster). However, the PolyTree data structure provides more
                 * information about the returned paths which may be important to users. Firstly, the PolyTree structure preserves nested parent-child polygon relationships
                 * (ie outer polygons owning/containing holes and holes owning/containing other outer polygons etc). Also, only the PolyTree structure can differentiate
                 * between open and closed paths since each PolyNode has an IsOpen property. (The Path structure has no member indicating whether it's open or closed.)
                 * For this reason, when open paths are passed to a Clipper object, the user must use a PolyTree object as the solution parameter, otherwise an exception
                 * will be raised.
                 *
                 * When a PolyTree object is used in a clipping operation on open paths, two ancilliary functions have been provided to quickly separate out open and
                 * closed paths from the solution - OpenPathsFromPolyTree and ClosedPathsFromPolyTree. PolyTreeToPaths is also available to convert path data to a Paths
                 * structure (irrespective of whether they're open or closed).
                 *
                 * There are several things to note about the solution paths returned:
                 * - they aren't in any specific order
                 * - they should never overlap or be self-intersecting (but see notes on rounding)
                 * - holes will be oriented opposite outer polygons
                 * - the solution fill type can be considered either EvenOdd or NonZero since it will comply with either filling rule
                 * - polygons may rarely share a common edge (though this is now very rare as of version 6)
                 *
                 * The subjFillType and clipFillType parameters define the polygon fill rule to be applied to the polygons (ie closed paths) in the subject and clip
                 * paths respectively. (It's usual though obviously not essential that both sets of polygons use the same fill rule.)
                 *
                 * execute can be called multiple times without reassigning subject and clip polygons (ie when different clipping operations are required on the
                 * same polygon sets).
                 *
                 * @param clipType - Clip operation type
                 * @param subjFillType - Fill type of the subject polygons
                 * @param clipFillType - Fill type of the clip polygons
                 * @param cleanDistance - Clean distance over the output, or undefined for no cleaning.
                 * @return {Paths | undefined} - The solution or undefined if there was an error
                 */
                Clipper.prototype.executeToPaths = function (clipType, subjFillType, clipFillType, cleanDistance) {
                    var outNativePaths = new this._nativeLib.Paths();
                    try {
                        var success = this._clipper.executePathsWithFillTypes(nativeEnumConversion.clipTypeToNative(this._nativeLib, clipType), outNativePaths, nativeEnumConversion.polyFillTypeToNative(this._nativeLib, subjFillType), nativeEnumConversion.polyFillTypeToNative(this._nativeLib, clipFillType));
                        if (!success) {
                            return undefined;
                        }
                        else {
                            if (cleanDistance !== undefined) {
                                this._nativeLib.cleanPolygons(outNativePaths, cleanDistance);
                            }
                            return PathsToNativePaths.nativePathsToPaths(this._nativeLib, outNativePaths, true); // frees outNativePaths
                        }
                    }
                    finally {
                        if (!outNativePaths.isDeleted()) {
                            outNativePaths.delete();
                        }
                    }
                };
                /**
                 * Once subject and clip paths have been assigned (via addPath and/or addPaths), execute can then perform the clipping operation (intersection, union,
                 * difference or XOR) specified by the clipType parameter.
                 *
                 * The solution parameter can be either a Paths or PolyTree structure. The Paths structure is simpler than the PolyTree structure. Because of this it is
                 * quicker to populate and hence clipping performance is a little better (it's roughly 10% faster). However, the PolyTree data structure provides more
                 * information about the returned paths which may be important to users. Firstly, the PolyTree structure preserves nested parent-child polygon relationships
                 * (ie outer polygons owning/containing holes and holes owning/containing other outer polygons etc). Also, only the PolyTree structure can differentiate
                 * between open and closed paths since each PolyNode has an IsOpen property. (The Path structure has no member indicating whether it's open or closed.)
                 * For this reason, when open paths are passed to a Clipper object, the user must use a PolyTree object as the solution parameter, otherwise an exception
                 * will be raised.
                 *
                 * When a PolyTree object is used in a clipping operation on open paths, two ancilliary functions have been provided to quickly separate out open and
                 * closed paths from the solution - OpenPathsFromPolyTree and ClosedPathsFromPolyTree. PolyTreeToPaths is also available to convert path data to a Paths
                 * structure (irrespective of whether they're open or closed).
                 *
                 * There are several things to note about the solution paths returned:
                 * - they aren't in any specific order
                 * - they should never overlap or be self-intersecting (but see notes on rounding)
                 * - holes will be oriented opposite outer polygons
                 * - the solution fill type can be considered either EvenOdd or NonZero since it will comply with either filling rule
                 * - polygons may rarely share a common edge (though this is now very rare as of version 6)
                 *
                 * The subjFillType and clipFillType parameters define the polygon fill rule to be applied to the polygons (ie closed paths) in the subject and clip
                 * paths respectively. (It's usual though obviously not essential that both sets of polygons use the same fill rule.)
                 *
                 * execute can be called multiple times without reassigning subject and clip polygons (ie when different clipping operations are required on the
                 * same polygon sets).
                 *
                 * @param clipType - Clip operation type
                 * @param subjFillType - Fill type of the subject polygons
                 * @param clipFillType - Fill type of the clip polygons
                 * @return {PolyTree | undefined} - The solution or undefined if there was an error
                 */
                Clipper.prototype.executeToPolyTee = function (clipType, subjFillType, clipFillType) {
                    var outNativePolyTree = new this._nativeLib.PolyTree();
                    try {
                        var success = this._clipper.executePolyTreeWithFillTypes(nativeEnumConversion.clipTypeToNative(this._nativeLib, clipType), outNativePolyTree, nativeEnumConversion.polyFillTypeToNative(this._nativeLib, subjFillType), nativeEnumConversion.polyFillTypeToNative(this._nativeLib, clipFillType));
                        if (!success) {
                            return undefined;
                        }
                        else {
                            return PolyTree_1.PolyTree.fromNativePolyTree(this._nativeLib, outNativePolyTree, true); // frees outNativePolyTree
                        }
                    }
                    finally {
                        if (!outNativePolyTree.isDeleted()) {
                            outNativePolyTree.delete();
                        }
                    }
                };
                /**
                 * Checks if the object has been disposed.
                 *
                 * @return {boolean} - true if disposed, false if not
                 */
                Clipper.prototype.isDisposed = function () {
                    return this._clipper === undefined || this._clipper.isDeleted();
                };
                /**
                 * Since this library uses WASM/ASM.JS internally for speed this means that you must dispose objects after you are done using them or mem leaks will occur.
                 */
                Clipper.prototype.dispose = function () {
                    if (this._clipper) {
                        this._clipper.delete();
                        this._clipper = undefined;
                    }
                };
                return Clipper;
            }());
            exports.Clipper = Clipper;

            });

            unwrapExports(Clipper_1);
            var Clipper_2 = Clipper_1.Clipper;

            var ClipperError_1 = createCommonjsModule$1(function (module, exports) {
            var __extends = (commonjsGlobal$1 && commonjsGlobal$1.__extends) || (function () {
                var extendStatics = function (d, b) {
                    extendStatics = Object.setPrototypeOf ||
                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                    return extendStatics(d, b);
                };
                return function (d, b) {
                    extendStatics(d, b);
                    function __() { this.constructor = d; }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", { value: true });
            var ClipperError = /** @class */ (function (_super) {
                __extends(ClipperError, _super);
                function ClipperError(message) {
                    var _this = _super.call(this, message) || this;
                    _this.message = message;
                    Object.setPrototypeOf(_this, ClipperError.prototype);
                    _this.name = _this.constructor.name;
                    _this.stack = new Error().stack;
                    return _this;
                }
                return ClipperError;
            }(Error));
            exports.ClipperError = ClipperError;

            });

            unwrapExports(ClipperError_1);
            var ClipperError_2 = ClipperError_1.ClipperError;

            var clipFunctions = createCommonjsModule$1(function (module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });



            var devMode =  process$1.env && process$1.env.NODE_ENV !== "production";
            var addPathOrPaths = function (clipper, inputDatas, polyType) {
                if (inputDatas === undefined) {
                    return;
                }
                // add each input
                for (var i = 0, maxi = inputDatas.length; i < maxi; i++) {
                    var inputData = inputDatas[i];
                    // add the path/paths
                    var pathOrPaths = inputData.data;
                    if (!pathOrPaths || pathOrPaths.length <= 0) {
                        continue;
                    }
                    var closed_1 = inputData.closed === undefined ? true : inputData.closed;
                    // is it a path or paths?
                    if (Array.isArray(pathOrPaths[0])) {
                        // paths
                        if (!clipper.addPaths(pathOrPaths, polyType, closed_1)) {
                            throw new ClipperError_1.ClipperError("invalid paths");
                        }
                    }
                    else {
                        // path
                        if (!clipper.addPath(pathOrPaths, polyType, closed_1)) {
                            throw new ClipperError_1.ClipperError(`invalid path: ${JSON.stringify(pathOrPaths)}`);
                        }
                    }
                }
            };
            function clipToPathsOrPolyTree(polyTreeMode, nativeClipperLib, params) {
                if (devMode) {
                    if (!polyTreeMode && params.subjectInputs && params.subjectInputs.some(function (si) { return !si.closed; })) {
                        throw new Error("clip to a PolyTree (not to a Path) when using open paths");
                    }
                }
                var clipper = new Clipper_1.Clipper(nativeClipperLib, params);
                //noinspection UnusedCatchParameterJS
                try {
                    addPathOrPaths(clipper, params.subjectInputs, enums.PolyType.Subject);
                    addPathOrPaths(clipper, params.clipInputs, enums.PolyType.Clip);
                    var result = void 0;
                    var clipFillType = params.clipFillType === undefined ? params.subjectFillType : params.clipFillType;
                    if (!polyTreeMode) {
                        result = clipper.executeToPaths(params.clipType, params.subjectFillType, clipFillType, params.cleanDistance);
                    }
                    else {
                        if (params.cleanDistance !== undefined) {
                            throw new ClipperError_1.ClipperError("cleaning is not available for poly tree results");
                        }
                        result = clipper.executeToPolyTee(params.clipType, params.subjectFillType, clipFillType);
                    }
                    if (result === undefined) {
                        throw new ClipperError_1.ClipperError("error while performing clipping task");
                    }
                    return result;
                }
                finally {
                    clipper.dispose();
                }
            }
            exports.clipToPathsOrPolyTree = clipToPathsOrPolyTree;
            function clipToPaths(nativeClipperLib, params) {
                return clipToPathsOrPolyTree(false, nativeClipperLib, params);
            }
            exports.clipToPaths = clipToPaths;
            function clipToPolyTree(nativeClipperLib, params) {
                return clipToPathsOrPolyTree(true, nativeClipperLib, params);
            }
            exports.clipToPolyTree = clipToPolyTree;

            });

            unwrapExports(clipFunctions);
            var clipFunctions_1 = clipFunctions.clipToPathsOrPolyTree;
            var clipFunctions_2 = clipFunctions.clipToPaths;
            var clipFunctions_3 = clipFunctions.clipToPolyTree;

            var constants = createCommonjsModule$1(function (module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            /**
             * Max coordinate value (both positive and negative)
             */
            exports.hiRange = 9007199254740991;

            });

            unwrapExports(constants);
            var constants_1 = constants.hiRange;

            var functions = createCommonjsModule$1(function (module, exports) {
            var __values = (commonjsGlobal$1 && commonjsGlobal$1.__values) || function(o) {
                var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
                if (m) return m.call(o);
                if (o && typeof o.length === "number") return {
                    next: function () {
                        if (o && i >= o.length) o = void 0;
                        return { value: o && o[i++], done: !o };
                    }
                };
                throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            Object.defineProperty(exports, "__esModule", { value: true });




            function tryDelete() {
                var e_1, _a;
                var objs = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    objs[_i] = arguments[_i];
                }
                try {
                    for (var objs_1 = __values(objs), objs_1_1 = objs_1.next(); !objs_1_1.done; objs_1_1 = objs_1.next()) {
                        var obj = objs_1_1.value;
                        if (!obj.isDeleted()) {
                            obj.delete();
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (objs_1_1 && !objs_1_1.done && (_a = objs_1.return)) _a.call(objs_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            function area(path) {
                // we use JS since copying structures is slower than actually doing it
                var cnt = path.length;
                if (cnt < 3) {
                    return 0;
                }
                var a = 0;
                for (var i = 0, j = cnt - 1; i < cnt; ++i) {
                    a += (path[j].x + path[i].x) * (path[j].y - path[i].y);
                    j = i;
                }
                return -a * 0.5;
            }
            exports.area = area;
            function cleanPolygon(nativeLib, path, distance) {
                if (distance === void 0) { distance = 1.1415; }
                var nativePath = PathToNativePath.pathToNativePath(nativeLib, path);
                try {
                    nativeLib.cleanPolygon(nativePath, distance);
                    return PathToNativePath.nativePathToPath(nativeLib, nativePath, true); // frees nativePath
                }
                finally {
                    tryDelete(nativePath);
                }
            }
            exports.cleanPolygon = cleanPolygon;
            function cleanPolygons(nativeLib, paths, distance) {
                if (distance === void 0) { distance = 1.1415; }
                var nativePaths = PathsToNativePaths.pathsToNativePaths(nativeLib, paths);
                try {
                    nativeLib.cleanPolygons(nativePaths, distance);
                    return PathsToNativePaths.nativePathsToPaths(nativeLib, nativePaths, true); // frees nativePath
                }
                finally {
                    tryDelete(nativePaths);
                }
            }
            exports.cleanPolygons = cleanPolygons;
            function addPolyNodeToPaths(polynode, nt, paths) {
                var match = true;
                switch (nt) {
                    case 1 /* Open */:
                        return;
                    case 2 /* Closed */:
                        match = !polynode.isOpen;
                        break;
                }
                if (polynode.contour.length > 0 && match) {
                    paths.push(polynode.contour);
                }
                for (var ii = 0, max = polynode.childs.length; ii < max; ii++) {
                    var pn = polynode.childs[ii];
                    addPolyNodeToPaths(pn, nt, paths);
                }
            }
            function closedPathsFromPolyTree(polyTree) {
                // we do this in JS since copying path is more expensive than just doing it
                var result = [];
                // result.Capacity = polytree.Total;
                addPolyNodeToPaths(polyTree, 2 /* Closed */, result);
                return result;
            }
            exports.closedPathsFromPolyTree = closedPathsFromPolyTree;
            function minkowskiDiff(nativeLib, poly1, poly2) {
                var nativePath1 = PathToNativePath.pathToNativePath(nativeLib, poly1);
                var nativePath2 = PathToNativePath.pathToNativePath(nativeLib, poly2);
                var outNativePaths = new nativeLib.Paths();
                try {
                    nativeLib.minkowskiDiff(nativePath1, nativePath2, outNativePaths);
                    tryDelete(nativePath1, nativePath2);
                    return PathsToNativePaths.nativePathsToPaths(nativeLib, outNativePaths, true); // frees outNativePaths
                }
                finally {
                    tryDelete(nativePath1, nativePath2, outNativePaths);
                }
            }
            exports.minkowskiDiff = minkowskiDiff;
            function minkowskiSumPath(nativeLib, pattern, path, pathIsClosed) {
                var patternNativePath = PathToNativePath.pathToNativePath(nativeLib, pattern);
                var nativePath = PathToNativePath.pathToNativePath(nativeLib, path);
                var outNativePaths = new nativeLib.Paths();
                try {
                    nativeLib.minkowskiSumPath(patternNativePath, nativePath, outNativePaths, pathIsClosed);
                    tryDelete(patternNativePath, nativePath);
                    return PathsToNativePaths.nativePathsToPaths(nativeLib, outNativePaths, true); // frees outNativePaths
                }
                finally {
                    tryDelete(patternNativePath, nativePath, outNativePaths);
                }
            }
            exports.minkowskiSumPath = minkowskiSumPath;
            function minkowskiSumPaths(nativeLib, pattern, paths, pathIsClosed) {
                // TODO: im not sure if for this method we can reuse the input/output path
                var patternNativePath = PathToNativePath.pathToNativePath(nativeLib, pattern);
                var nativePaths = PathsToNativePaths.pathsToNativePaths(nativeLib, paths);
                try {
                    nativeLib.minkowskiSumPaths(patternNativePath, nativePaths, nativePaths, pathIsClosed);
                    tryDelete(patternNativePath);
                    return PathsToNativePaths.nativePathsToPaths(nativeLib, nativePaths, true); // frees nativePaths
                }
                finally {
                    tryDelete(patternNativePath, nativePaths);
                }
            }
            exports.minkowskiSumPaths = minkowskiSumPaths;
            function openPathsFromPolyTree(polyTree) {
                // we do this in JS since copying path is more expensive than just doing it
                var result = [];
                var len = polyTree.childs.length;
                result.length = len;
                var resultLength = 0;
                for (var i = 0; i < len; i++) {
                    if (polyTree.childs[i].isOpen) {
                        result[resultLength++] = polyTree.childs[i].contour;
                    }
                }
                result.length = resultLength;
                return result;
            }
            exports.openPathsFromPolyTree = openPathsFromPolyTree;
            function orientation(path) {
                return area(path) >= 0;
            }
            exports.orientation = orientation;
            function pointInPolygon(point, path) {
                // we do this in JS since copying path is more expensive than just doing it
                // returns 0 if false, +1 if true, -1 if pt ON polygon boundary
                // See "The Point in Polygon Problem for Arbitrary Polygons" by Hormann & Agathos
                // http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf
                var result = 0;
                var cnt = path.length;
                if (cnt < 3) {
                    return 0;
                }
                var ip = path[0];
                for (var i = 1; i <= cnt; ++i) {
                    var ipNext = i === cnt ? path[0] : path[i];
                    if (ipNext.y === point.y) {
                        if (ipNext.x === point.x || (ip.y === point.y && ipNext.x > point.x === ip.x < point.x)) {
                            return -1;
                        }
                    }
                    if (ip.y < point.y !== ipNext.y < point.y) {
                        if (ip.x >= point.x) {
                            if (ipNext.x > point.x) {
                                result = 1 - result;
                            }
                            else {
                                var d = (ip.x - point.x) * (ipNext.y - point.y) - (ipNext.x - point.x) * (ip.y - point.y);
                                if (d === 0) {
                                    return -1;
                                }
                                else if (d > 0 === ipNext.y > ip.y) {
                                    result = 1 - result;
                                }
                            }
                        }
                        else {
                            if (ipNext.x > point.x) {
                                var d = (ip.x - point.x) * (ipNext.y - point.y) - (ipNext.x - point.x) * (ip.y - point.y);
                                if (d === 0) {
                                    return -1;
                                }
                                else if (d > 0 === ipNext.y > ip.y) {
                                    result = 1 - result;
                                }
                            }
                        }
                    }
                    ip = ipNext;
                }
                return result;
            }
            exports.pointInPolygon = pointInPolygon;
            function polyTreeToPaths(polyTree) {
                // we do this in JS since copying path is more expensive than just doing it
                var result = [];
                // result.Capacity = polytree.total;
                addPolyNodeToPaths(polyTree, 0 /* Any */, result);
                return result;
            }
            exports.polyTreeToPaths = polyTreeToPaths;
            function reversePath(path) {
                // we use JS since copying structures is slower than actually doing it
                path.reverse();
            }
            exports.reversePath = reversePath;
            function reversePaths(paths) {
                // we use JS since copying structures is slower than actually doing it
                for (var i = 0, max = paths.length; i < max; i++) {
                    reversePath(paths[i]);
                }
            }
            exports.reversePaths = reversePaths;
            function simplifyPolygon(nativeLib, path, fillType) {
                if (fillType === void 0) { fillType = enums.PolyFillType.EvenOdd; }
                var nativePath = PathToNativePath.pathToNativePath(nativeLib, path);
                var outNativePaths = new nativeLib.Paths();
                try {
                    nativeLib.simplifyPolygon(nativePath, outNativePaths, nativeEnumConversion.polyFillTypeToNative(nativeLib, fillType));
                    tryDelete(nativePath);
                    return PathsToNativePaths.nativePathsToPaths(nativeLib, outNativePaths, true); // frees outNativePaths
                }
                finally {
                    tryDelete(nativePath, outNativePaths);
                }
            }
            exports.simplifyPolygon = simplifyPolygon;
            function simplifyPolygons(nativeLib, paths, fillType) {
                if (fillType === void 0) { fillType = enums.PolyFillType.EvenOdd; }
                var nativePaths = PathsToNativePaths.pathsToNativePaths(nativeLib, paths);
                try {
                    nativeLib.simplifyPolygonsOverwrite(nativePaths, nativeEnumConversion.polyFillTypeToNative(nativeLib, fillType));
                    return PathsToNativePaths.nativePathsToPaths(nativeLib, nativePaths, true); // frees nativePaths
                }
                finally {
                    tryDelete(nativePaths);
                }
            }
            exports.simplifyPolygons = simplifyPolygons;
            function scalePath(path, scale) {
                var sol = [];
                var i = path.length;
                while (i--) {
                    var p = path[i];
                    sol.push({
                        x: Math.round(p.x * scale),
                        y: Math.round(p.y * scale)
                    });
                }
                return sol;
            }
            exports.scalePath = scalePath;
            /**
             * Scales all inner paths by multiplying all its coordinates by a number and then rounding them.
             *
             * @param paths - Paths to scale
             * @param scale - Scale multiplier
             * @return {Paths} - The scaled paths
             */
            function scalePaths(paths, scale) {
                if (scale === 0) {
                    return [];
                }
                var sol = [];
                var i = paths.length;
                while (i--) {
                    var p = paths[i];
                    sol.push(scalePath(p, scale));
                }
                return sol;
            }
            exports.scalePaths = scalePaths;

            });

            unwrapExports(functions);
            var functions_1 = functions.area;
            var functions_2 = functions.cleanPolygon;
            var functions_3 = functions.cleanPolygons;
            var functions_4 = functions.closedPathsFromPolyTree;
            var functions_5 = functions.minkowskiDiff;
            var functions_6 = functions.minkowskiSumPath;
            var functions_7 = functions.minkowskiSumPaths;
            var functions_8 = functions.openPathsFromPolyTree;
            var functions_9 = functions.orientation;
            var functions_10 = functions.pointInPolygon;
            var functions_11 = functions.polyTreeToPaths;
            var functions_12 = functions.reversePath;
            var functions_13 = functions.reversePaths;
            var functions_14 = functions.simplifyPolygon;
            var functions_15 = functions.simplifyPolygons;
            var functions_16 = functions.scalePath;
            var functions_17 = functions.scalePaths;

            var ClipperOffset_1 = createCommonjsModule$1(function (module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });




            /**
             * The ClipperOffset class encapsulates the process of offsetting (inflating/deflating) both open and closed paths using a number of different join types
             * and end types.
             *
             * Preconditions for offsetting:
             * 1. The orientations of closed paths must be consistent such that outer polygons share the same orientation, and any holes have the opposite orientation
             * (ie non-zero filling). Open paths must be oriented with closed outer polygons.
             * 2. Polygons must not self-intersect.
             *
             * Limitations:
             * When offsetting, small artefacts may appear where polygons overlap. To avoid these artefacts, offset overlapping polygons separately.
             */
            var ClipperOffset = /** @class */ (function () {
                /**
                 * The ClipperOffset constructor takes 2 optional parameters: MiterLimit and ArcTolerance. The two parameters corresponds to properties of the same name.
                 * MiterLimit is only relevant when JoinType is Miter, and ArcTolerance is only relevant when JoinType is Round or when EndType is OpenRound.
                 *
                 * @param _nativeLib - Native clipper lib instance to use
                 * @param miterLimit - Miter limit
                 * @param arcTolerance - ArcTolerance (round precision)
                 */
                function ClipperOffset(_nativeLib, miterLimit, arcTolerance) {
                    if (miterLimit === void 0) { miterLimit = 2; }
                    if (arcTolerance === void 0) { arcTolerance = 0.25; }
                    this._nativeLib = _nativeLib;
                    this._clipperOffset = new _nativeLib.ClipperOffset(miterLimit, arcTolerance);
                }
                Object.defineProperty(ClipperOffset.prototype, "arcTolerance", {
                    /**
                     * Firstly, this field/property is only relevant when JoinType = Round and/or EndType = Round.
                     *
                     * Since flattened paths can never perfectly represent arcs, this field/property specifies a maximum acceptable imprecision ('tolerance') when arcs are
                     * approximated in an offsetting operation. Smaller values will increase 'smoothness' up to a point though at a cost of performance and in creating more
                     * vertices to construct the arc.
                     *
                     * The default ArcTolerance is 0.25 units. This means that the maximum distance the flattened path will deviate from the 'true' arc will be no more
                     * than 0.25 units (before rounding).
                     *
                     * Reducing tolerances below 0.25 will not improve smoothness since vertex coordinates will still be rounded to integer values. The only way to achieve
                     * sub-integer precision is through coordinate scaling before and after offsetting (see example below).
                     *
                     * It's important to make ArcTolerance a sensible fraction of the offset delta (arc radius). Large tolerances relative to the offset delta will produce
                     * poor arc approximations but, just as importantly, very small tolerances will substantially slow offsetting performance while providing unnecessary
                     * degrees of precision. This is most likely to be an issue when offsetting polygons whose coordinates have been scaled to preserve floating point precision.
                     *
                     * Example: Imagine a set of polygons (defined in floating point coordinates) that is to be offset by 10 units using round joins, and the solution is to
                     * retain floating point precision up to at least 6 decimal places.
                     * To preserve this degree of floating point precision, and given that Clipper and ClipperOffset both operate on integer coordinates, the polygon
                     * coordinates will be scaled up by 108 (and rounded to integers) prior to offsetting. Both offset delta and ArcTolerance will also need to be scaled
                     * by this same factor. If ArcTolerance was left unscaled at the default 0.25 units, every arc in the solution would contain a fraction of 44 THOUSAND
                     * vertices while the final arc imprecision would be 0.25 × 10-8 units (ie once scaling was reversed). However, if 0.1 units was an acceptable imprecision
                     * in the final unscaled solution, then ArcTolerance should be set to 0.1 × scaling_factor (0.1 × 108 ). Now if scaling is applied equally to both
                     * ArcTolerance and to Delta Offset, then in this example the number of vertices (steps) defining each arc would be a fraction of 23.
                     *
                     * The formula for the number of steps in a full circular arc is ... Pi / acos(1 - arc_tolerance / abs(delta))
                     *
                     * @return {number} - Current arc tolerance
                     */
                    get: function () {
                        return this._clipperOffset.arcTolerance;
                    },
                    /**
                     * Firstly, this field/property is only relevant when JoinType = Round and/or EndType = Round.
                     *
                     * Since flattened paths can never perfectly represent arcs, this field/property specifies a maximum acceptable imprecision ('tolerance') when arcs are
                     * approximated in an offsetting operation. Smaller values will increase 'smoothness' up to a point though at a cost of performance and in creating more
                     * vertices to construct the arc.
                     *
                     * The default ArcTolerance is 0.25 units. This means that the maximum distance the flattened path will deviate from the 'true' arc will be no more
                     * than 0.25 units (before rounding).
                     *
                     * Reducing tolerances below 0.25 will not improve smoothness since vertex coordinates will still be rounded to integer values. The only way to achieve
                     * sub-integer precision is through coordinate scaling before and after offsetting (see example below).
                     *
                     * It's important to make ArcTolerance a sensible fraction of the offset delta (arc radius). Large tolerances relative to the offset delta will produce
                     * poor arc approximations but, just as importantly, very small tolerances will substantially slow offsetting performance while providing unnecessary
                     * degrees of precision. This is most likely to be an issue when offsetting polygons whose coordinates have been scaled to preserve floating point precision.
                     *
                     * Example: Imagine a set of polygons (defined in floating point coordinates) that is to be offset by 10 units using round joins, and the solution is to
                     * retain floating point precision up to at least 6 decimal places.
                     * To preserve this degree of floating point precision, and given that Clipper and ClipperOffset both operate on integer coordinates, the polygon
                     * coordinates will be scaled up by 108 (and rounded to integers) prior to offsetting. Both offset delta and ArcTolerance will also need to be scaled
                     * by this same factor. If ArcTolerance was left unscaled at the default 0.25 units, every arc in the solution would contain a fraction of 44 THOUSAND
                     * vertices while the final arc imprecision would be 0.25 × 10-8 units (ie once scaling was reversed). However, if 0.1 units was an acceptable imprecision
                     * in the final unscaled solution, then ArcTolerance should be set to 0.1 × scaling_factor (0.1 × 108 ). Now if scaling is applied equally to both
                     * ArcTolerance and to Delta Offset, then in this example the number of vertices (steps) defining each arc would be a fraction of 23.
                     *
                     * The formula for the number of steps in a full circular arc is ... Pi / acos(1 - arc_tolerance / abs(delta))
                     *
                     * @param value - Arc tolerance to set.
                     */
                    set: function (value) {
                        this._clipperOffset.arcTolerance = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ClipperOffset.prototype, "miterLimit", {
                    /**
                     * This property sets the maximum distance in multiples of delta that vertices can be offset from their original positions before squaring is applied.
                     * (Squaring truncates a miter by 'cutting it off' at 1 × delta distance from the original vertex.)
                     *
                     * The default value for MiterLimit is 2 (ie twice delta). This is also the smallest MiterLimit that's allowed. If mitering was unrestricted (ie without
                     * any squaring), then offsets at very acute angles would generate unacceptably long 'spikes'.
                     *
                     * @return {number} - Current miter limit
                     */
                    get: function () {
                        return this._clipperOffset.miterLimit;
                    },
                    /**
                     * Sets the current miter limit (see getter docs for more info).
                     *
                     * @param value - Mit limit to set.
                     */
                    set: function (value) {
                        this._clipperOffset.miterLimit = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Adds a Path to a ClipperOffset object in preparation for offsetting.
                 *
                 * Any number of paths can be added, and each has its own JoinType and EndType. All 'outer' Paths must have the same orientation, and any 'hole' paths must
                 * have reverse orientation. Closed paths must have at least 3 vertices. Open paths may have as few as one vertex. Open paths can only be offset
                 * with positive deltas.
                 *
                 * @param path - Path to add
                 * @param joinType - Join type
                 * @param endType - End type
                 */
                ClipperOffset.prototype.addPath = function (path, joinType, endType) {
                    var nativePath = PathToNativePath.pathToNativePath(this._nativeLib, path);
                    try {
                        this._clipperOffset.addPath(nativePath, nativeEnumConversion.joinTypeToNative(this._nativeLib, joinType), nativeEnumConversion.endTypeToNative(this._nativeLib, endType));
                    }
                    finally {
                        nativePath.delete();
                    }
                };
                /**
                 * Adds Paths to a ClipperOffset object in preparation for offsetting.
                 *
                 * Any number of paths can be added, and each path has its own JoinType and EndType. All 'outer' Paths must have the same orientation, and any 'hole'
                 * paths must have reverse orientation. Closed paths must have at least 3 vertices. Open paths may have as few as one vertex. Open paths can only be
                 * offset with positive deltas.
                 *
                 * @param paths - Paths to add
                 * @param joinType - Join type
                 * @param endType - End type
                 */
                ClipperOffset.prototype.addPaths = function (paths, joinType, endType) {
                    var nativePaths = PathsToNativePaths.pathsToNativePaths(this._nativeLib, paths);
                    try {
                        this._clipperOffset.addPaths(nativePaths, nativeEnumConversion.joinTypeToNative(this._nativeLib, joinType), nativeEnumConversion.endTypeToNative(this._nativeLib, endType));
                    }
                    finally {
                        nativePaths.delete();
                    }
                };
                /**
                 * Negative delta values shrink polygons and positive delta expand them.
                 *
                 * This method can be called multiple times, offsetting the same paths by different amounts (ie using different deltas).
                 *
                 * @param delta - Delta
                 * @param cleanDistance - Clean distance over the output, or undefined for no cleaning.
                 * @return {Paths} - Solution paths
                 */
                ClipperOffset.prototype.executeToPaths = function (delta, cleanDistance) {
                    var outNativePaths = new this._nativeLib.Paths();
                    try {
                        this._clipperOffset.executePaths(outNativePaths, delta);
                        if (cleanDistance !== undefined) {
                            this._nativeLib.cleanPolygons(outNativePaths, cleanDistance);
                        }
                        return PathsToNativePaths.nativePathsToPaths(this._nativeLib, outNativePaths, true); // frees outNativePaths
                    }
                    finally {
                        if (!outNativePaths.isDeleted()) {
                            outNativePaths.delete();
                        }
                    }
                };
                /**
                 * This method takes two parameters. The first is the structure that receives the result of the offset operation (a PolyTree structure). The second parameter
                 * is the amount to which the supplied paths will be offset. Negative delta values shrink polygons and positive delta expand them.
                 *
                 * This method can be called multiple times, offsetting the same paths by different amounts (ie using different deltas).
                 *
                 * @param delta - Delta
                 * @return {Paths} - Solution paths
                 */
                ClipperOffset.prototype.executeToPolyTree = function (delta) {
                    var outNativePolyTree = new this._nativeLib.PolyTree();
                    try {
                        this._clipperOffset.executePolyTree(outNativePolyTree, delta);
                        return PolyTree_1.PolyTree.fromNativePolyTree(this._nativeLib, outNativePolyTree, true); // frees outNativePolyTree
                    }
                    finally {
                        if (!outNativePolyTree.isDeleted()) {
                            outNativePolyTree.delete();
                        }
                    }
                };
                /**
                 * This method clears all paths from the ClipperOffset object, allowing new paths to be assigned.
                 */
                ClipperOffset.prototype.clear = function () {
                    this._clipperOffset.clear();
                };
                /**
                 * Checks if the object has been disposed.
                 *
                 * @return {boolean} - true if disposed, false if not
                 */
                ClipperOffset.prototype.isDisposed = function () {
                    return this._clipperOffset === undefined || this._clipperOffset.isDeleted();
                };
                /**
                 * Since this library uses WASM/ASM.JS internally for speed this means that you must dispose objects after you are done using them or mem leaks will occur.
                 */
                ClipperOffset.prototype.dispose = function () {
                    if (this._clipperOffset) {
                        this._clipperOffset.delete();
                        this._clipperOffset = undefined;
                    }
                };
                return ClipperOffset;
            }());
            exports.ClipperOffset = ClipperOffset;

            });

            unwrapExports(ClipperOffset_1);
            var ClipperOffset_2 = ClipperOffset_1.ClipperOffset;

            var offsetFunctions = createCommonjsModule$1(function (module, exports) {
            var __assign = (commonjsGlobal$1 && commonjsGlobal$1.__assign) || function () {
                __assign = Object.assign || function(t) {
                    for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                            t[p] = s[p];
                    }
                    return t;
                };
                return __assign.apply(this, arguments);
            };
            Object.defineProperty(exports, "__esModule", { value: true });


            var addPathOrPaths = function (offset, inputDatas) {
                if (inputDatas === undefined) {
                    return;
                }
                // add each input
                for (var i = 0, maxi = inputDatas.length; i < maxi; i++) {
                    var inputData = inputDatas[i];
                    // add the path/paths
                    var pathOrPaths = inputData.data;
                    if (!pathOrPaths || pathOrPaths.length <= 0) {
                        continue;
                    }
                    // is it a path or paths?
                    if (Array.isArray(pathOrPaths[0])) {
                        // paths
                        offset.addPaths(pathOrPaths, inputData.joinType, inputData.endType);
                    }
                    else {
                        // path
                        offset.addPath(pathOrPaths, inputData.joinType, inputData.endType);
                    }
                }
            };
            function offsetToPathsOrPolyTree(polyTreeMode, nativeClipperLib, params) {
                var filledData = __assign({ arcTolerance: 0.25, miterLimit: 2 }, params);
                var offset = new ClipperOffset_1.ClipperOffset(nativeClipperLib, filledData.miterLimit, filledData.arcTolerance);
                //noinspection UnusedCatchParameterJS
                try {
                    addPathOrPaths(offset, params.offsetInputs);
                    if (!polyTreeMode) {
                        return offset.executeToPaths(params.delta, params.cleanDistance);
                    }
                    else {
                        if (params.cleanDistance !== undefined) {
                            throw new ClipperError_1.ClipperError("cleaning is not available for poly tree results");
                        }
                        return offset.executeToPolyTree(params.delta);
                    }
                }
                catch (err) {
                    return undefined;
                }
                finally {
                    offset.dispose();
                }
            }
            function offsetToPaths(nativeClipperLib, params) {
                return offsetToPathsOrPolyTree(false, nativeClipperLib, params);
            }
            exports.offsetToPaths = offsetToPaths;
            function offsetToPolyTree(nativeClipperLib, params) {
                return offsetToPathsOrPolyTree(true, nativeClipperLib, params);
            }
            exports.offsetToPolyTree = offsetToPolyTree;

            });

            unwrapExports(offsetFunctions);
            var offsetFunctions_1 = offsetFunctions.offsetToPaths;
            var offsetFunctions_2 = offsetFunctions.offsetToPolyTree;

            function init(_moduleOverrides) {
              var Module = {};
              Object.keys(_moduleOverrides).forEach(function (key) {
                Module[key] = _moduleOverrides[key];
              });
            var Module=typeof Module!=="undefined"?Module:{};var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key];}}var arguments_=[];var thisProgram="./this.program";var quit_=function(status,toThrow){throw toThrow};var ENVIRONMENT_IS_WEB=true;var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var readBinary;{if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.lastIndexOf("/")+1);}else {scriptDirectory="";}}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.warn.bind(console);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key];}}moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var asm2wasmImports={"f64-rem":function(x,y){return x%y},"debugger":function(){}};var functionPointers=new Array(0);var setTempRet0=function(value){};var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime;if(Module["noExitRuntime"])noExitRuntime=Module["noExitRuntime"];if(typeof WebAssembly!=="object"){err("no native wasm support detected");}var wasmMemory;var wasmTable;var ABORT=false;var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(u8Array,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(u8Array[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&u8Array.subarray&&UTF8Decoder){return UTF8Decoder.decode(u8Array.subarray(idx,endPtr))}else {var str="";while(idx<endPtr){var u0=u8Array[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2;}else {u0=(u0&7)<<18|u1<<12|u2<<6|u8Array[idx++]&63;}if(u0<65536){str+=String.fromCharCode(u0);}else {var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023);}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023;}if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u;}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63;}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}else {if(outIdx+3>=endIdx)break;outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}}outU8Array[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4;}return len}var UTF16Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf-16le"):undefined;var WASM_PAGE_SIZE=65536;function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple;}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf);}var DYNAMIC_BASE=5264304,DYNAMICTOP_PTR=21392;var INITIAL_TOTAL_MEMORY=Module["TOTAL_MEMORY"]||16777216;if(Module["wasmMemory"]){wasmMemory=Module["wasmMemory"];}else {wasmMemory=new WebAssembly.Memory({"initial":INITIAL_TOTAL_MEMORY/WASM_PAGE_SIZE});}if(wasmMemory){buffer=wasmMemory.buffer;}INITIAL_TOTAL_MEMORY=buffer.byteLength;updateGlobalBufferAndViews(buffer);HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Module["dynCall_v"](func);}else {Module["dynCall_vi"](func,callback.arg);}}else {func(callback.arg===undefined?null:callback.arg);}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift());}}callRuntimeCallbacks(__ATPRERUN__);}function initRuntime(){callRuntimeCallbacks(__ATINIT__);}function preMain(){callRuntimeCallbacks(__ATMAIN__);}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift());}}callRuntimeCallbacks(__ATPOSTRUN__);}function addOnPreRun(cb){__ATPRERUN__.unshift(cb);}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb);}var runDependencies=0;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}if(runDependencies==0){if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback();}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return String.prototype.startsWith?filename.startsWith(dataURIPrefix):filename.indexOf(dataURIPrefix)===0}var wasmBinaryFile="data:application/octet-stream;base64,AGFzbQEAAAABuwIrYAF/AGAEf39/fwF/YAF/AX9gAn9/AX9gAn9/AGABfwF8YAJ/fABgA398fABgAAF/YAN/f38AYAN/f38Bf2ADf398AGAEf39/fwBgBX9/f39/AX9gBn98f39/fwF/YAAAYAZ/f39/f38AYAV/f39/fwBgAn9/AXxgA398fAF/YAZ/f39/f38Bf2ADf35/AX5gBH9/f3wAYA1/f39/f39/f39/f39/AGAIf39/f39/f38AYAp/f39/f39/f39/AGACf34AYAJ/fgF/YAR/f398AX9gA35/fwF/YAJ+fwF/YAJ8fwF8YAJ8fAF8YAJ8fwF/YAN8fH8BfGABfAF8YAd/f39/f39/AX9gB39/f39/f38AYAN/f38BfGAEf398fAF/YAd/f3x/f39/AX9gBH9/fHwAYAV/f39/fAACzgImA2VudgFiABgDZW52AWMADwNlbnYBZAAQA2VudgFlAAADZW52AWYACQNlbnYBZwAJA2VudgFoAAIDZW52AWkAGQNlbnYBagAJA2VudgFrABcDZW52AWwAEQNlbnYBbQAQA2VudgFuAAwDZW52AW8AAwNlbnYBcAADA2VudgFxAAADZW52AXIAAANlbnYBcwAAA2VudgF0AAQDZW52AXUACQNlbnYBdgARA2VudgF3AAMDZW52AXgAAwNlbnYBeQAIA2VudgF6AAADZW52AUEAAgNlbnYBQgAPA2VudgFDAAIDZW52AUQACgNlbnYBRQAIA2VudgFGAAQDZW52AUcACQNlbnYBSAAPA2VudgFJAAQDZW52DF9fdGFibGVfYmFzZQN/AANlbnYBYQN/AANlbnYGbWVtb3J5AgCAAgNlbnYFdGFibGUBcAGuBK4EA6sFqQUEAAQCAwMDAAMEAgoCCgMEBAIEBAoEAAMJEQkJAwQEAwIACQkDAwQDDQMKAwYDAwsCCgoECgIEAwkCHgACCQwMAwICAgMEAgAPBAEKIiACDQQBCQkWEhEKAgwCDQIEAAQfDQwCAAIJBBELCQwECggQAgQJCgMDBAQCAgMDBAwEAwkDAwICAgwJIQENAwQRCxYECggJAQkJCQsJBgAMDxQNEwwDCgAAJAIJBAkDCgMBAwEDAAoEAwMDDAEUBBoJAwoBAQIECQQDAgwCCQMJAwMKAgMDCgAEBAMAAAAAAAAPICMAIh8CAwkC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ACgCADYCACAFIAM2AgQgAiABKQIANwMAIAJBEGoiAyACKQIANwIAIAQgAxCcAQR/IAAgACgCACABKAIEIAEoAgBrajYCAEEBBUEACyEGIAIkAiAGC0UBAX8gACgCACgCECECIAAgASACQf8AcUHaAmoRBAAgACwABUEBRwRAIAAoAgAoAhQhAiAAIAEgAkH/AHFB2gJqEQQACwvzJQEtfyMCIQMjAkHgAmokAiADQcACaiEFIANBuAJqIQYgA0GwAmohByADQagCaiEIIANBoAJqIQkgA0EIaiEEIANBmAJqIQogA0GQAmohCyADQYgCaiEMIANBgAJqIQ0gA0H4AWohDiADQfABaiEPIANB6AFqIRAgA0HgAWohESADQdgBaiESIANB0AFqIRMgA0HIAWohFCADQcABaiEVIANBuAFqIRYgA0GwAWohFyADQagBaiEYIANBoAFqIRkgA0GYAWohGiADQZABaiEbIANBiAFqIRwgA0GAAWohHSADQfgAaiEeIANB8ABqIR8gA0HoAGohICADQeAAaiEhIANB2ABqISIgA0HQAGohIyADQcgAaiEkIANBQGshJSADQThqISYgA0EwaiEnIANBKGohKCADQSBqISkgA0EYaiEqIANBEGohKyADQcgCakGE9AAQIiADQdACaiICIAMpAsgCNwIAIANB2AJqIiwgACACECpBAXE6AAAgACgCBCAAKAIAa0ECSQR/QQAFAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAgAiASwAAEExaw5EEhISEhISEhISExMTExMTExMTExMTExMTExMTABMTExMTExMBExMTExMTExMTExMTAxMEBQYCBxMIExMJCgsMDQ4PEBETCyAAEOkBDBMLIAAQaAwSCwJAAkACQCAAKAIEIAAoAgAiAmtBAUsEfyACLAABBUEAC0EYdEEYdUHMAGsOJQACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgECCyAAKAIEIAAoAgAiAmtBAksEfyACLAACBUEAC0EYdEEYdUFQakEKSQ0ADAELIAAQ5AEMEgsgABCCBAwRCwJAAkACQAJAAkACQAJAAkAgASwAAUHOAGsOLQMHBwcHBAcHBwcHBwcHBwcHBwcABwcBBwcHBwcHBwcHAgcH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ayEADAELCwNAIAAgBUgEQCAAIAE2AgAgAEEEaiEADAELCwsDQCAAIARIBEAgACADOgAAIABBAWohAAwBCwsgBCACawtdAQF/IAEgAEggACABIAJqSHEEQCABIAJqIQEgACIDIAJqIQADQCACQQBKBEAgAkEBayECIABBAWsiACABQQFrIgEsAAA6AAAMAQsLIAMhAAUgACABIAIQLRoLIAALOAAgAEGYLTYCACAAQQc6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEG8NjYCACAAIAEpAgA3AggLDwAgAEHwAmogASACEPUDC4sEAQp/IwIhASMCQUBrJAIgAUEwaiEDIAFBKGohByABQRhqIQQgAUEUaiEIIAFBEGohBiABQQhqIQUCfwJAAkAgACgCBCAAKAIAIgJrQQBLBH8gAiwAAAVBAAtBGHRBGHVBxwBrDg4AAQEBAQEBAQEBAQEBAAELIAAQ7gIMAQsgByAANgIAIAQgABDtAiAIIAAgBBBJIgI2AgAgAgR/IAAgBBDsAgR/QQAFIAcQyQEEfyACBSAGQQA2AgAgBUH0kgEQIiADIAUpAgA3AgACfwJAIAAgAxAqRQ0AIABBCGoiBSICKAIEIAIoAgBrQQJ1IQICQANAIABBxQAQJ0UEQCADIAAQZSIJNgIAIAlFDQIgBSADEDIMAQsLIAMgACACEDwgBiAAQfACaiADEOYCNgIADAELQQAMAQsgA0EANgIAAn8CQCAELAAADQAgBCwAAUUNACADIAAQLiIFNgIAIAUNAEEADAELIABB9gAQJwRAIAFBADYCACABQQA2AgQgACADIAggASAGIARBBGogBEEIahDIAQwBCyAAQQhqIgUiAigCBCACKAIAa0ECdSECAkADQAJAIAEgABAuIgk2AgAgCUUNACAFIAEQMiAHEMkBRQ0BDAILC0EADAELIAEgACACEDwgACADIAggASAGIARBBGogBEEIahDIAQsLCwsFQQALCyEKIAEkAiAKC5UBAQN/IAAoAgggACgCACIDa0EEdSABTwRADwsgAUH/////AEsEQEEIEAYiAhBDIAJBsMQANgIAIAJB0CRB1wAQBAsgACgCBCADayEEIAFBBHQQJSECIARBAEoEQCACIAMgBBAtGgsgACACNgIAIAAgBEEEdUEEdCACajYCBCAAIAFBBHQgAmo2Aggg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KQAANwAAIAhBwMUAKQAANwAIIAhByMUAKQAANwAQIAhB0MUAKQAANwAYIAhBADoAICAEQZATQQkQBAUgBUEEdCAHaikDACEODAELDAELIA5C/////////w9VBEBBEBAGIgRBlCc2AgAgBEIANwIEIARBADYCDCAEQTAQJSIINgIEIARBsICAgHg2AgwgBEEgNgIIIAhBuMUAKQAANwAAIAhBwMUAKQAANwAIIAhByMUAKQAANwAQIAhB0MUAKQAANwAYIAhBADoAICAEQZATQQkQBAsgDkKBgICAgICAcFMgBUEEdCAHaikDCEL/////////D3xC/v///////x9WcgRAQRAQBiIEQZQnNgIAIARCADcCBCAEQQA2AgwgBEEwECUiCDYCBCAEQbCAgIB4NgIMIARBIDYCCCAIQbjFACkAADcAACAIQcDFACkAADcACCAIQcjFACkAADcAECAIQdDFACkAADcAGCAIQQA6ACAgBEGQE0EJEAQFQQEhCgsLIAZCADcDACAGQgA3AwggBkIANwMQIAZCADcDGCAGQgA3AyAgBkIANwMoIAZCADcDMCAGQgA3AzggBkFAa0IANwMAIAZCADcDSCAGQgA3A1AgBkIANwNYIAZCADcDYCAGQgA3A2ggBiAGQfAAajYCUCAGIAVB8ABsIAZqIgQ2AlQgBiAHKQMANwMQIAYgBykDCDcDGCAGQX82AkwgASgCACIHIAVBBHRqIQggBEIANwMAIARCADcDCCAEQgA3AxAgBEIANwMYIARCADcDICAEQgA3AyggBEIANwMwIARCADcDOCAEQUBrQgA3AwAgBEIANwNIIARCADcDUCAEQgA3A1ggBEIANwNgIARCADcDaCAFQfAAbCAGaiAGNgJQIAVB8ABsIAZqIAVBf2oiAUHwAGwgBmo2AlQgBUHwAGwgBmoiBCAIKQMANwMQIAQgCCkDCDcDGCAFQfAAbCAGakF/NgJMIAVBAUoEQAJAIAEhBSAKIQEDQAJAIAVBBHQgB2oiCikDACEOAkACQCABQf8BcQ0AIAVBBHQgB2opAwhC/////wN8Qv7///8HViAOQv////8DfEL+////B1ZyBH8gAEEBOgAUQQEhAQwBBUEACyEBDAELIA5C/////////w9VDQEgDkKBgICAgICAcFMgBUEEdCAHaikDCEL/////////D3xC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//8BSwRAEAELIAIgACgCCCAEayIDQQJ1IgggCCACSRtB/////wEgA0EDdUH/////AEkbIgIEQCACQf////8BSwRAQQgQBiIDEEMgA0GwxAA2AgAgA0HQJEHXABAEBSACQQN0ECUiCSEFCwsgB0EDdCAFaiIDIAEpAwA3AwAgBkEASgRAIAkgBCAGEC0aCyAAIAU2AgAgACADQQhqNgIEIAAgAkEDdCAFajYCCCAERQRADwsgBBAjC54FAgJ/AX4jAiEEIwJBEGokAiABKQMAIgYgAikDAFMhBSAAKQMAIAZTBH8CfyAFBEAgBCAAKQMANwMAIAQgACkDCDcDCCAAIAIpAwA3AwAgACACKQMINwMIIAIgBCkDADcDACACIAQpAwg3AwhBAQwBCyAEIAApAwA3AwAgBCAAKQMINwMIIAAgASkDADcDACAAIAEpAwg3AwggASAEKQMANwMAIAEgBCkDCDcDCCABKQMAIAIpAwBTBH8gBCABKQMANwMAIAQgASkDCDcDCCABIAIpAwA3AwAgASACKQMINwMIIAIgBCkDADcDACACIAQpAwg3AwhBAgVBAQsLBSAFBH8gBCABKQMANwMAIAQgASkDCDcDCCABIAIpAwA3AwAgASACKQMINwMIIAIgBCkDADcDACACIAQpAwg3AwggACkDACABKQMAUwR/IAQgACkDADcDACAEIAApAwg3AwggACABKQMANwMAIAAgASkDCDcDCCABIAQpAwA3AwAgASAEKQMINwMIQQIFQQELBUEACwshBSACKQMAIAMpAwBZBEAgBCQCIAUPCyAEIAIpAwA3AwAgBCACKQMINwMIIAIgAykDADcDACACIAMpAwg3AwggAyAEKQMANwMAIAMgBCkDCDcDCCAFQQFqIQMgASkDACACKQMAWQRAIAQkAiADDwsgBCABKQMANwMAIAQgASkDCDcDCCABIAIpAwA3AwAgASACKQMINwMIIAIgBCkDADcDACACIAQpAwg3AwggBUECaiECIAApAwAgASkDAFkEQCAEJAIgAg8LIAQgACkDADcDACAEIAApAwg3AwggACABKQMANwMAIAAgASkDCDcDCCABIAQpAwA3AwAgASAEKQMINwMIIAQkAiAFQQNqC6EEAwN/AX4FfCMCIQMjAkEQaiQCIAArA0ggACgCNCIEIAJBBHRqKwMAIggg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IwIhDCMCQRBqJAIgDAshAyAAIQQgASEAAkACQAJAAkACQAJAAkADQAJAIAAiCUFwaiEGIABBYGohCyAAIQoCfwJAAn8CQAJAAkADQAJAAkAgCSAEayIFQQR1IgEOBg8PCQsMDQALIAVB8ANIDQ0gAUECbUEEdCAEaiEAAn8gBUHw/ABKBH8gBCABQQRtIgFBBHQgBGoiByAAIAFBBHQgAGoiCBBzIQEgCCkDACAGKQMAWQRAIAEhBSAADAILIAMgCCkDADcDACADIAgpAwg3AwggCCAGKQMANwMAIAggBikDCDcDCCAGIAMpAwA3AwAgBiADKQMINwMIIAFBAWohBSAAKQMAIAgpAwBTBH8gAyAAKQMANwMAIAMgACkDCDcDCCAAIAgpAwA3AwAgACAIKQMINwMIIAggAykDADcDACAIIAMpAwg3AwggAUECaiEFIAcpAwAgACkDAFMEfyADIAcpAwA3AwAgAyAHKQMINwMIIAcgACkDADcDACAHIAApAwg3AwggACADKQMANwMAIAAgAykDCDcDCCABQQNqIQUgBCkDACAHKQMAUwRAIAMgBCkDADcDACADIAQpAwg3AwggBCAHKQMANwMAIAQgBykDCDcDCCAHIAMpAwA3AwAgByADKQMINwMIIAFBBGohBQsgAAUgAAsFIAALBSAAKQMAIg0gBikDAFMhASAEKQMAIA1ZBEAgAUUEQEEAIQUgAAwDCyADIAApAwA3AwAgAyAAKQMINwMIIAAgBikDADcDACAAIAYpAwg3AwggBiADKQMANwMAIAYgAykDCDcDCCAEKQMAIAApAwBZBEBBASEFIAAMAwsgAyAEKQMANwMAIAMgBCkDCDcDCCAEIAApAwA3AwAgBCAAKQMINwMIIAAgAykDADcDACAAIAMpAwg3AwhBAiEFIAAMAgsgAQRAIAMgBCkDADcDACADIAQpAwg3AwggBCAGKQMANwMAIAQgBikDCDcDCCAGIAMpAwA3AwAgBiADKQMINwMIQQEhBSAADAILIAMgBCkDADcDACADIAQpAwg3AwggBCAAKQMANwMAIAQgACkDCDcDCCAAIAMpAwA3AwAgACADKQMINwMIIAApAwAgBikDAFMEQCADIAApAwA3AwAgAyAAKQMINwMIIAAgBikDADcDACAAIAYpAwg3AwggBiADKQMANwMAIAYgAykD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AhggA0EANgIcIANBADYCICADQQA2AiggA0EANgIsIANBADYCMCADQQA2AjggA0EANgI8IANBQGtBADYCACADQgA3AgQgA0IANwIMIANB9CY2AgAgA0IANwJIIANCADcCUCADQgA3AlggA0IANwJgIANBADYCaCADIANB8ABqIgQ2AnAgAyAENgJ0IANBADYCeCADQQA6AIABIANBADoAFCADQQA6AIwBIANBADoAJCADQQA6ACUgA0EBOgCOASAAKAIAIgQgACgCBEcEQAJAQfQmIQUDQCADIAZBDGwgBGpBAEEBIAUoAghBB3FBrgFqEQEAGiAGQQFqIgYgACgCBCAAKAIAIgRrQQxtTw0BIAMoAgAhBQwAAAsACwsgA0EBIAEgAiACEEoaIANB9CY2AgAgA0HwAGohAiADKAJ4BEAgAygCdCIAKAIAIgEgAigCACIEKAIENgIEIAQoAgQgATYCACADQQA2AnggACACRwRAA0AgACgCBCEBIAAQIyABIAJHBEAgASEADAELCwsLIAMoAmAiAARAIAMgADYCZCAAECMLIAMoAlQiAARAIAMgADYCWCAAECMLIAMoAkgiAARAIAMgADYCTCAAECMLIANB2CY2AgAgAyADKAIIIgA2AgwgAyAANgIEIAMoAhwiASADKAIYIgBGBEAgASEABUEAIQIDQCACQQJ0IABqKAIAIgQEQCAEECMgAygCHCEBIAMoAhghAAsgAkEBaiICIAEgAGtBAnVJDQALCyADIAA2AhwgA0EAOgAUIANBADoAJSADKAI4IgAEQCADIAA2AjwgABAjCyADKAIoIgAEQCADIAA2AiwgABAjCyADKAIYIgAEQCADIAA2AhwgABAjCyADKAIIIgBFBEAgAyQCDwsgAyAANgIMIAAQIyADJAILxCUDEX8Efgd8IwIhCCMCQSBqJAIgAEEQaiIOKAIAIgYgACgCFCIDRwRAA0AgA0F0aiICKAIAIgQEQCADQXhqIAQ2AgAgBBAjCyACIAZHBEAgAiEDDAELCwsgACAGNgIUIABBQGsgATkDACABRCNCkgyhnMc7YyABRCNCkgyhnMe7ZHEEQCAOIAAoApQBIAAoApABa0ECdRBIIAAoApQBIAAoApABIgNrQQBMBEAgCCQCDwtBACECA38CfyACQQJ0IANqKAIAIhAoAixFBEACQCAQQQRq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CCAAIAIpAgA3AgwLDQAgAEHwAmogARD5AwsPACAAQfACaiABIAIQ6wMLEQAgAEHwAmogASACIAMQ2wMLEQAgAEHwAmogASACIAMQzAMLwQEBA38jAiECIwJBIGokAiACQQhqQcqFARAiIAJBEGoiASACKQIINwIAIAAgARAqBH8gABBjGiABIABBABA9IABB3wAQJwR/IAAgARDTAQVBAAsFIAJBzYUBECIgASACKQIANwIAIAAgARAqBH8gASAAQQAQPSABKAIAIAEoAgRGBH9BAAUgAEHwABAnBH8gABBjGiABIABBABA9IABB3wAQJwR/IAAgARDTAQVBAAsFQQALCwVBAAsLIQMgAiQCIAMLCwAgAEEIaiABEEALNQEBfyABKAIEIQMgACABKAIAIAIgASgCBCABKAIAayIBQX9qIAEgAksbajYCACAAIAM2AgQLdQEDfyMCIQIjAkEgaiQCIAJBEGoiBEG77gAQIiACQRhqIgMgBCkCADcCACABIAMQJCAAKAIIIAEQKyACQQhqIgRBt+4AECIgAyAEKQIANwIAIAEgAxAkIAIgACkCDDcDACADIAIpAgA3AgAgASADECQgAiQCCxsAIABB8AJqQQwQJiIAIAEoAgBBAEcQiQQgAAuFCQEWfyMCIQIjAkGgAWokAiACQZABaiEBIAJBiAFqIQMgAkGAAWohBCACQfgAaiEFIAJB8ABqIQYgAkHoAGohByACQeAAaiEIIAJB2ABqIQkgAkHQAGohCiACQcgAaiELIAJBQGshDCACQThqIQ0gAkEwaiEOIAJBKGohDyACQSBqIRAgAkEYaiERIAJBEGohEiACQQhqIRMgAEHMABAnBH8CfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIEIAAoAgAiFGtBAEsEfyAULAAABUEAC0EYdEEYdUHUAGsOJgAUFBQUFBQUFBQUExQEAgMREhAUBQgJFAoLDg8UFBQGBxQUAQwNFAtBAAwUCyAAIAAoAgBBAWo2AgAgA0HZ8AAQIiABIAMpAgA3AgAgACABED4MEwsgBEHh8AAQIiABIAQpAgA3AgAgACABECoEQCABQQA2AgAgACABEOgBDBMLIAVB5fAAECIgASAFKQIANwIAQQAgACABECpFDRIaIAFBATYCACAAIAEQ6AEMEgsgACAAKAIAQQFqNgIAIAZBy+kAECIgASAGKQIANwIAIAAgARA+DBELIAAgACgCAEEBajYCACAHQdDpABAiIAEgBykCADcCACAAIAEQPgwQCyAAIAAoAgBBAWo2AgAgCEHc6QAQIiABIAgpAgA3AgAgACABED4MDwsgACAAKAIAQQFqNgIAIAlB6ukAECIgASAJKQIANwIAIAAgARA+DA4LIAAgACgCAEEBajYCACAKQfDpABAiIAEgCikCADcCACAAIAEQPgwNCyAAIAAoAgBBAWo2AgAgC0HVnQEQIiABIAspAgA3AgAgACABED4MDAsgACAAKAIAQQFqNgIAIAxB6fAAECIgASAMKQIANwIAIAAgARA+DAsLIAAgACgCAEEBajYCACANQevwABAiIAEgDSkCADcCACAAIAEQPgwKCyAAIAAoAgBBAWo2AgAgDkHt8AAQIiABIA4pAgA3AgAgACABED4MCQsgACAAKAIAQQFqNgIAIA9B8PAAECIgASAPKQIANwIAIAAgARA+DAgLIAAgACgCAEEBajYCACAQQfPwABAiIAEgECkCADcCACAAIAEQPgwHCyAAIAAoAgBBAWo2AgAgEUGt6gAQIiABIBEpAgA3AgAgACABED4MBgsgACAAKAIAQQFqNgIAIBJBtuoAECIgASASKQIANwIAIAAgARA+DAULIAAgACgCAEEBajYCACAAEJUEDAQLIAAgACgCAEEBajYCACAAEJQEDAMLIAAgACgCAEEBajYCACAAEJMEDAILIBNBiekAECIgASATKQIANwIAQQAgACABECpFDQEaIAAQVyIBBEAgASAAQcUAECcNAhoLQQAMAQsgASAAEC4iAzYCACADBH8gAiAAQQAQPQJ/IAIoAgAgAigCBEYhFSAAQcUAECchBCAVCwR/IANBACAEGwUgBAR/IABB8AJqIAEgAhCSBAVBAAsLBUEACwsFQQALIRYgAiQCIBYLOQEBfyABQfACaiADIAJrIgFBAnUiBEECdBAmIQMgAQRAIAMgAiABEFQaCyAAIAM2AgAgACAENgIEC0oBA38jAiEBIwJBEGokAiABQQhqIQIgACgCCCIALQAEQQdGBH8gAiAAKQIINwIAIAFB9O4AECIgAiABEKEBBUEACyEDIAEkAiADC2QBAn8gACABKAIMIgQ2AgAgACABKAII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Axg3AwggACAAKQMgNwMQIAAgACkDKDcDGCAAIAIpAwA3AyAgACACKQMINwMoIAApAwAgACkDEFkNAyACIAApAwA3AwAgAiAAKQMINwMIIAAgACkDEDcDACAAIAApAxg3AwggACACKQMANwMQIAAgAikDCDcDGAwDCyAAKQMQIgkgAEEgaiIDKQMAIgpTIQQgACkDACILIAlTBEACQCAEBEAgAiAAKQMANwMAIAIgACkDCDcDCCAAIAMpAwA3AwAgACADKQMINwMIIAMgAikDADcDACADIAIpAwg3AwgMAQsgAiAAKQMANwMAIAIgACkDCDcDCCAAIAApAxA3AwAgACAAKQMYNwMIIAAgAikDADcDECAAIAIpAwg3AxggACkDECAKUwRAIAIgACkDEDcDACACIAApAxg3AwggACADKQMANwMQIAAgAykDCDcDGCADIAIpAwA3AwAgAyACKQMINwMICwsFIAQEQCACIAApAxA3AwAgAiAAKQMYNwMIIAAgAykDADcDECAAIAMpAwg3AxggAyACKQMANwMAIAMgAikDCDcDCCALIAApAxBTBEAgAiAAKQMANwMAIAIgACkDCDcDCCAAIAApAxA3AwAgACAAKQMYNwMIIAAgAikDADcDECAAIAIpAwg3AxgLCwsgASAAQTBqIgRGDQIDQAJAIAMpAwAgBCkDACIJUwRAIAIgBCkDCDcDACAEIQUCQAJAA0ACQCAFIAMpAwA3AwAgBSADKQMINwMIIAAgA0YEQCAAIgMhBQwBCyADQXBqIgcpAwAgCVkNAiADIQUgByEDDAELCwwBCyADIQULIAUgCTcDACADIAIpAwA3AwggBkEBaiIDQQhGDQEFIAYhAwsgASAEQRBqIgZGDQQCfyAEIQggBiEEIAMhBiAICyEDDAELCyACJAIgASAEQRBqRg8LIAIgACkDADcDACACIAApAwg3AwggACABKQMANwMAIAAgASkDCDcDCAsgASACKQMANwMAIAEgAikDCDcDCAsgAiQCQQELCgAgACABsDcDCAsIACAAKQMIuQsKACAAIAGwNwMACwgAIAApAwC5C9QFAQJ/IwIhAyMCQZABaiQCIAAgASACQQBBARCKASADQQA2AhggA0EANgIcIANBADYCICADQQA2AiggA0EANgIsIANBADYCMCADQQA2AjggA0EANgI8IANBQGtBADYCACADQgA3AgQgA0IANwIMIANB9CY2AgAgA0IANwJIIANCADcCUCADQgA3AlggA0IANwJgIANBADYCaCADIANB8ABqIgA2AnAgAyAANgJ0IANBADYCeCADQQA6AIABIANBADoAFCADQQA6AIwBIANBADoAjgEgA0EAOgAkIANBADoAJSACKAIAIgAgAigCBEcEQAJAQQAhAUH0JiEEA0AgAyABQQxsIABqQQBBASAEKAIIQQdxQa4BahEBABogAUEBaiIBIAIoAgQgAigCACIAa0EMbU8NASADKAIAIQQMAAALAAsLIANBASACQQFBARBKGiADQfQmNgIAIANB8ABqIQIgAygCeARAIAMoAnQiACgCACIBIAIoAgAiBCgCBDYCBCAEKAIEIAE2AgAgA0EANgJ4IAAgAkcEQANAIAAoAgQhASAAECMgASACRwRAIAEhAAwBCwsLCyADKAJgIgAEQCADIAA2AmQgABAjCyADKAJUIgAEQCADIAA2AlggABAjCyADKAJIIgAEQCADIAA2AkwgABAjCyADQdgmNgIAIAMgAygCCCIANgIMIAMgADYCBCADKAIcIgAgAygCGCIBRgRAIAAhAQVBACECA0AgAkECdCABaigCACIEBEAgBBAjIAMoAhghASADKAIcIQALIAJBAWoiAiAAIAFrQQJ1SQ0ACwsgAyABNgIcIANBADoAFCADQQA6ACUgAygCOCIABEAgAyAANgI8IAAQIwsgAygCKCIABEAgAyAANgIsIAAQIwsgAygCGCIABEAgAyAANgIcIAAQIwsgAygCCCIARQRAIAMkAg8LIAMgADYCDCAAECMgAyQCC+4IAgp/A34jAiEHIwJBsAFqJAIgB0EMaiEIIAdBGGoiBEEANgIYIARBADYCHCAEQQA2AiAgBEEANgIoIARBADYCLCAEQQA2AjAgBEEANgI4IARBADYCPCAEQUBrQQA2AgAgBEIANwIEIARCADcCDCAEQfQmNgIAIARCADcCSCAEQgA3AlAgBEIANwJYIARCADcCYCAEQQA2AmggBCAEQfAAaiIFNgJwIAQgBTYCdCAEQQA2AnggBEEAOgCAASAEQQA6ABQgBEEAOgCMASAEQQA6AI4BIARBADoAJCAEQQA6ACUgASgCACIFIAEoAgRHBEADQCAIQQA2AgAgCEEANgIEIAhBADYC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IgsgAikDCLmioCAEuSALoiAFuSAKoqChIgwgDKIgCyALoiAKIAqioKMgA2MFIAe5IAggBX25IgqiIAa5IAQgAikDCH25IguioCAEuSAKoiAFuSALoqChIgwgDKIgCiAKoiALIAuioKMgA2MLBSAEIAIpAwgiCFMgBCAHVXNFBEAgBbkgByAIfbkiCqIgBLkgAikDACAGfbkiC6KgIAa5IAqiIAe5IAuioKEiDCAMoiAKIAqiIAsgC6KgoyADYw8LIAQgB1MgByAIU3MEfyAGIAV9uSIKIAi5oiAJuSILIAIpAwC5oqAgBLkgCqIgBbkgC6KgoSIMIAyiIAogCqIgCyALoqCjIANjBSAGuSAEIAh9uSIKoiAHuSACKQMAIAV9uSILoqAgBbkgCqIgBLkgC6KgoSIMIAyiIAogCqIgCyALoqCjIANjCwsLCwAgACAAIAEQuwELHAEBfyAAKAIQIgEgACgCFEYEQEEADwsgASgCAAvwBAECfyMCIQMjAkGQAWokAiADQQA2AhggA0EANgIcIANBADYCICADQQA2AiggA0EANgIsIANBADYCMCADQQA2AjggA0EANgI8IANBQGtBADYCACADQgA3AgQgA0IANwIMIANB9CY2AgAgA0IANwJIIANCADcCUCADQgA3AlggA0IANwJgIANBADYCaCADIANB8ABqIgQ2AnAgAyAENgJ0IANBADYCeCADQQA6AIABIANBADoAFCADQQA6AIwBIANBADoAJCADQQA6ACUgA0EBOgCOASADIABBAEEBEGwaIANBASABIAIgAhBKGiADQfQmNgIAIANB8ABqIQIgAygCeARAIAMoAnQiACgCACIBIAIoAgAiBCgCBDYCBCAEKAIEIAE2AgAgA0EANgJ4IAAgAkcEQANAIAAoAgQhASAAECMgASACRwRAIAEhAAwBCwsLCyADKAJgIgAEQCADIAA2AmQgABAjCyADKAJUIgAEQCADIAA2AlggABAjCyADKAJIIgAEQCADIAA2AkwgABAjCyADQdgmNgIAIAMgAygCCCIANgIMIAMgADYCBCADKAIcIgAgAygCGCIBRgRAIAAhAQVBACECA0AgAkECdCABaigCACIEBEAgBBAjIAMoAhghASADKAIcIQALIAJBAWoiAiAAIAFrQQJ1SQ0ACwsgAyABNgIcIANBADoAFCADQQA6ACUgAygCOCIABEAgAyAANgI8IAAQIwsgAygCKCIABEAgAyAANgIsIAAQIwsgAygCGCIABEAgAyAANgIcIAAQIwsgAygCCCIARQRAIAMkAg8LIAMgADYCDCAAECMgAyQCC9ABAQZ/IwIhAyMCQRBqJAIgACgCBCICIAAoAgAiAUYEQCADJAIPCwNAIARBDGwgAWooAgQiBSAEQQxsIAFqKAIAIgZHBEAgBiAFQXBqIgVJBEAgBiEBIAUhAgNAIAMgASkDADcDACADIAEpAwg3AwggASACKQMANwMAIAEgAikDCDcDCCACIAMpAwA3AwAgAiADKQMINwMIIAFBEGoiASACQXBqIgJJDQALIAAoAgAhASAAKAIEIQILCyAEQQFqIgQgAiABa0EMbUkNAAsgAyQCC5AOAg1/CH4jAiEIIwJBsAFqJAIgASgCNCIHIAEoAjAiBkcEQANAIARBAnQgBmooAgAiBQRAIAUgBSgCACgCBEH/AHFByAFqEQAAIAEoAjQhByABKAIwIQYLIARBAWoiBCAHIAZrIgVBAnVJDQALIAUEQCABIAY2AjQLCyABQRBqIgooAgAiBCABKAIURwRAIAEgBDYCFAsgABC9ASAAIAIQvAEgCEEYaiIDQQA2AhggA0EANgIcIANBADYCICADQQA2AiggA0EANgIsIANBADYCMCADQQA2AjggA0EANgI8IANBQGtBADYCACADQgA3AgQgA0IANwIMIANB9CY2AgAgA0IANwJIIANCADcCUCADQgA3AlggA0IANwJgIANBADYCaCADIANB8ABqIgQ2AnAgAyAENgJ0IANBADYCeCADQQA6AIABIANBADoAFCADQQA6AIwBIANBADoAjgEgA0EAOgAkIANBADoAJSAAKAIQIgYgACgCFEcEQAJAQQAhB0H0JiEEA0AgAyAHQQxsIAZqQQBBASAEKAIIQQdxQa4BahEBABogB0EBaiIHIAAoAhQgACgCECIGa0EMbU8NASADKAIAIQQMAAALAAsLIAhBqAFqIQwgCEEIaiEJIAJEAAAAAAAAAABkBEAgA0EBIAFBAkECEH0aBSADKAIIIgAgAygCDCINRgRAIAhCADcDAAUgCCAAKAIIIgYpAwAiEjcDACAGKQMIIhMhFCASIRAgEyEWA0AgFiATUyEOIAAhCyAGIQQgEiERIBAhEgNAIAQpAwAiECARUyEHIAggBCgCWCIABH8gESEXA0AgECARIAcbIREgECASIBAgElUbIRIgACkDACIVIBAgFyAHGyIXUyEHIAAoAlgiBQRAIBUhECAFIQAMAQsLIAggETcDACAABSAEIgALIgUgCCAHGykDACIRNwMAIAUpAwAiECASIBIgEFMbIRUgCCAAKQMgIhAgESAQIBFTGyISNwMAIBAgFSAVIBBTGyEQIAApAygiESAUIBEgFFMbIRQgBCAGRgRAIAsoAgwhBCASIREgECESDAELCyATIBYgDhshESANIAtBEGoiAEcEQCALKAIYIgYpAwghEyARIRYMAQsLCyAJQQA2AgAgCUEANgIEIAlBADYCCCAJQcAAECUiBTYCACAJIAVBQGsiADYCCCAJIAA2AgQgBSASQnZ8IhI3AwAgBSARQgp8IhE3AwggBSAQQgp8IhA3AxAgBSARNwMYIAUgEDcDICAFIBRCdnwiEDcDKCAFIBI3AzAgBSAQNwM4IAMgCUEAQQEQbBogA0EBOgCMASADQQEgAUEDQQMQfRoCQAJ/An8CQCABKAIUIAooAgAiAGtBBEcNACAAKAIAIgQoAhQgBCgCEGsiAEEATA0AIAogAEECdhCOASAKKAIAIAQoAhAoAgA2AgAgCigCACIHKAIAIAQoAhw2AhwgBCgCFCAEKAIQIgBrQQRKBEBBASEGA0AgASgCFCEFIAwgBkECdCAAaigCACIANgIAIAEoAhggBUsEQCAFIAA2AgAgASABKAIUQQRqNgIUBSAKIAwQNAsgACABNgIcIAAgBSAHa0ECdTYCICAGQQFqIgYgBCgCFCAEKAIQIgBrQQJ1SARAIAooAgAhBwwBCwsgCSgCACIABEAgAAwDCwUgBSIADAILDAMLIAEoAjQiBiABKAIwIgBHBEBBACEEA0AgBEECdCAAaigCACIHBEAgByAHKAIAKAIEQf8AcUHIAWoRAAAgASgCNCEGIAEoAjAhAAsgBEEBaiIEIAYgAGsiB0ECdUkNAAsgBwRAIAEgADYCNAsLIAooAgAiACABKAIURwRAIAEgADYCFAsgBSIACyEPIAkgADYCBCAPCxAjCwsgA0H0JjYCACADQfAAaiEEIAMoAngEQCADKAJ0IgAoAgAiASAEKAIAIgUoAgQ2AgQgBSgCBCABNgIAIANBADYCeCAAIARHBEADQCAAKAIEIQEgABAjIAEgBEcEQCABIQAMAQsLCwsgAygCYCIABEAgAyAANgJkIAAQIwsgAygCVCIABEAgAyAANgJYIAAQIwsgAygCSCIABEAgAyAANgJMIAAQIwsgA0HYJjYCACADIAMoAggiADYCDCADIAA2AgQgAygCHCIBIAMoAhgiAEYEQCABIQAFQQAhBgNAIAZBAnQgAGooAgAiBARAIAQQIyADKAIcIQEgAygCGCEACyAGQQFqIgYgASAAa0ECdUkNAAsLIAMgADYCHCADQQA6ABQgA0EAOgAlIAMoAjgiAARAIAMgADYCPCAAECMLIAMoAigiAARAIAMgADYCLCAAECMLIAMoAhgiAARAIAMgADYCHCAAECMLIAMoAggiAEUEQCAIJAIPCyADIAA2AgwgABAjIAgkAguzAQEEfyAAQfQmNgIAIABB8ABqIQMgACgCeARAIAAoAnQiAigCACIEIAMoAgAiASgCBDYCBCABKAIEIAQ2AgAgAEEANgJ4IAIgA0cEQANAIAIoAgQhASACECMgASADRwRAIAEhAgwBCwsLCyAAKAJgIgEEQCAAIAE2AmQgARAjCyAAKAJUIgEEQCAAIAE2AlggARAjCyAAKAJIIgFFBEAgABBdDwsgACABNgJMIAEQIyAAEF0LsQwCCn8IfiMCIQkjAkGwAWokAiABKAIAIgcgASgCBCIERwRAA0AgBEF0aiIFKAIAIgYEQCAEQXhqIAY2AgAgBhAjCyAFIAdHBEAgBSEEDAELCwsgASAHNgIEIAAQvQEgACACELwBIAlBGGoiA0EANgIYIANBADYCHCADQQA2AiAgA0EANgIoIANBADYCLCADQQA2AjAgA0EANgI4IANBADYCPCADQUBrQQA2AgAgA0IANwIEIANCADcCDCADQfQmNgIAIANCADcCSCADQgA3AlAgA0IANwJYIANCADcCYCADQQA2AmggAyADQfAAaiIENgJwIAMgBDYCdCADQQA2AnggA0EAOgCAASADQQA6ABQgA0EAOgCMASADQQA6AI4BIANBADoAJCADQQA6ACUgACgCECIEIAAoAhRHBEACQEH0JiEFA0AgAyAIQQxsIARqQQBBASAFKAIIQQdxQa4BahEBABogCEEBaiIIIAAoAhQgACgCECIEa0EMbU8NASADKAIAIQUMAAALAAsLIAlBCGohCiACRAAAAAAAAAAAZARAIANBASABQQJBAhBKGgUgAygCCCIAIAMoAgwiC0YEQCAJQgA3AwAFIAkgACgCCCIEKQMAIg83AwAgBCkDCCIQIREgDyENIBAhEwNAIBMgEFMhDCAAIQYgBCEFIA8hDiANIQ8DQCAFKQMAIg0gDlMhCCAJIAUoAlgiAAR/IA4hFANAIA0gDiAIGyEOIA0gDyANIA9VGyEPIAApAwAiEiANIBQgCBsiFFMhCCAAKAJYIgcEQCASIQ0gByEADAELCyAJIA43AwAgAAUgBSIACyIHIAkgCBspAwAiDjcDACAHKQMAIg0gDyAPIA1TGyESIAkgACkDICINIA4gDSAOUxsiDzcDACANIBIgEiANUxshDSAAKQMoIg4gESAOIBFTGyERIAQgBUYEQCAGKAIMIQUgDyEOIA0hDwwBCwsgECATIAwbIQ4gCyAGQRBqIgBHBEAgBigCGCIEKQMIIRAgDiETDAELCwsgCkEANgIAIApBADYCBCAKQQA2AgggCkHAABAlIgY2AgAgCiAGQUBrIgA2AgggCiAANgIEIAYgD0J2fCIPNwMAIAYgDkIKfCIONwMIIAYgDUIKfCINNwMQIAYgDjcDGCAGIA03AyAgBiARQnZ8Ig03AyggBiAPNwMwIAYgDTcDOCADIApBAEEBEGwaIANBAToAjAEgA0EBIAFBA0EDEEoaIAEoAgAiBCEAIAEoAgQiBSEHIAQgBUcEQAJAAkAgByAAQQxqIgRGBEAgByEEDAEFA0AgACgCACIFBEAgAEEEaiIIIAU2AgAgBRAjIABBCGoiBUEANgIAIABBADYCBCAAQQA2AgAFIABBCGohBSAAQQRqIQgLIAAgBCgCADYCACAIIAQoAgQ2AgAgBSAEKAIINgIAIARBADYCCCAEQQA2AgQgBEEANgIAIABBDGohACAEQQxqIgQgB0cNAAsgACABKAIEIgRHDQELDAELA0AgBEF0aiIFKAIAIgcEQCAEQXhqIAc2AgAgBxAjCyAAIAVHBEAgBSEEDAELCwsgASAANgIECyAGECMLIANB9CY2AgAgA0HwAGohBCADKAJ4BEAgAygCdCIAKAIAIgEgBCgCACIFKAIENgIEIAUoAgQgATYCACADQQA2AnggACAERwRAA0AgACgCBCEBIAAQIyABIARHBEAgASEADAELCwsLIAMoAmAiAARAIAMgADYCZCAAECMLIAMoAlQiAARAIAMgADYCWCAAECMLIAMoAkgiAARAIAMgADYCTCAAECMLIANB2CY2AgAgAyADKAIIIgA2AgwgAyAANgIEIAMoAhwiASADKAIYIgBGBEAgASEABUEAIQQDQCAEQQJ0IABqKAIAIgUEQCAFECMgAygCHCEBIAMoAhghAAsgBEEBaiIEIAEgAGtBAnVJDQALCyADIAA2AhwgA0EAOgAUIANBADoAJSADKAI4IgAEQCADIAA2AjwgABAjCyADKAIoIgAEQCADIAA2AiwgABAjCyADKAIYIgAEQCADIAA2AhwgABAjCyADKAIIIgBFBEAgCSQCDwsgAyAANgIMIAAQIyAJJAILEAAgACgCBCAAKAIAa0ECdQuMAQECfyMCIQEjAkEQaiQCIAAoAgAiAiAAKAIEIgBGBEAgASQCDwsgAiAAQXBqIgBPBEAgASQCDwsDQCABIAIpAwA3AwAgASACKQMINwMIIAIgACkDADcDACACIAApAwg3AwggACABKQMANwMAIAAgASkDCDcDCCACQRBqIgIgAEFwaiIASQ0ACyABJAILQwECfyABKAIAIgUgASgCBEYEQA8LA0AgACAEQQxsIAVqIAIgAxC+ASAEQQFqIgQgASgCBCABKAIAIgVrQQxtSQ0ACws4AQF/IABByCY2AgAgACgCECIBBEAgACABNgIUIAEQIwsgACgCBCIBRQRADwsgACABNgIIIAEQIwuIAQEEfyAAKAKUASIDIAAoApABIgFrQQBMBEAgACABNgKUASAAQn83A3APCwNAIAJBAnQgAWooAgAiBARAIAQoAgAoAgQhASAEIAFB/wBxQcgBahEAACAAKAKQASEBIAAoApQBIQMLIAJBAWoiAiADIAFrQQJ1SA0ACyAAIAE2ApQBIABCfzcDcAvJAgEGfyAAKAKQASIFIQIgACgClAEiBCAFa0EASgRAA0AgA0ECdCAFaigCACIBBEAgASABKAIAKAIEQf8AcUHIAWoRAAAgACgCkAEiAiEFIAAoApQBIQQLIANBAWoiAyAEIAVrQQJ1SA0ACwsgACAFNgKUASAAQn83A3AgAEHIJjYCgAEgAgRAIAAgAjYClAEgAhAjCyAAKAKEASIBBEAgACABNgKIASABECMLIAAoAjQiAQRAIAAgATYCOCABECML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QQAgABCSAQ0GGkEAIAAQkgENBhogAiAAEFciATYCACABBH8gAEHwAmogAhDcAgVBAAsMBgsgACAAKAIAQQJqNgIAIAIgABAuIgE2AgAgAQR/An8gAyAAQQEQPUEAIAMoAgAgAygCBEYNABogAEHfABAnBH8gAyAAEC4iATYCACABBH8gAEHwAmpBEBAmIgAgAygCACACKAIAEN4CIAAFQQALBUEACwsFQQALDAULIAAgACgCAEECajYCACACIABBABBJIgE2AgAgAQR/IABB9ZMBIAIQ9QEFQQALDAQLIAAgACgCAEECajYCACACIABBABBJIgE2AgAgAQR/IABB8AJqIAIQ3wIFQQALDAMLIAAgACgCAEEBajYCAAJ/IAAoAgQgACgCACIBa0EASwR/IAEsAAAFQQALIQVBACAAEJIBDQMaIAULQf8BcUH2AEYhASACIAAQVyIENgIAIAQEfyABBH8gAEHwAmogAhDgAgUgAEHwAmogAhDhAgsFQQALDAILAkACQAJAIAAoAgQgACgCACIBa0EBSwR/IAEsAAEFQQALQRh0QRh1QdIAaw4FAgEBAQABCyAAIAAoAgBBAmo2AgAgAiAAQQAQSSIBNgIAIAEEfyAAQfACaiACEOMCBUEACwwDC0EADAILIAAgACgCAEECajYCACACIABBABBJIgE2AgAgAQR/IAAgAxDvASAAQd8AECdyBH8gAEHwAmogAhDkAgVBAAsFQQALDAELQQALIQYgAyQCIAYLdQEDfyMCIQIjAkEgaiQCIAAoAgggARArIAJBEGoiBEGFhAEQIiACQRhqIgMgBCkCADcCACABIAMQJCACIAApAgw3AwAgAyACKQIANwIAIAEgAxAkIAJBCGoiAEG37gAQIiADIAApAgA3AgAgASADECQgAiQCC0AAIABBmC02AgAgAEEBOgAEIABBAToABSAAQQE6AAYgAEEBOgAHIABB7MIANgIAIAAgATYCCCAAIAIpAgA3AgwLRgEBfyMCIQMjAkEQaiQCIABBFBAmIQAgASgCACEBIAMgAikCADcDACADQQhqIgIgAykCADcCACAAIAEgAhDwAiADJAIgAAs7AQJ/IwIhAiMCQRBqJAIgAiAAKQIINwMAIAJBCGoiAyACKQIANwIAIAEgAxAkIAAoAhAgARArIAIkAgtBAQF/IwIhAyMCQRBqJAIgAEEUECYhACADIAEQIiACKAIAIQEgA0EIaiICIAMpAgA3AgAgACACIAEQRSADJAIgAAvvAwIHfwF8IwIhBCMCQSBqJAIgACgCNCIDRQRAIAQkAg8LIARBEGohBiAAIAM2AnwgAyECA0AgAiACKAJgNgJoIAIgAigCXCIFNgJkIAIgASACKQMoUQR+IAIpAyAFIAIpAwAgAisDMCABIAIpAwh9uaIiCUQAAAAAAADgv0QAAAAAAADgPyAJRAAAAAAAAAAAYxugsHwLNwMQIAUEQCAFIQIMAQsLIABB4ABqIQcgAyECA0ACQCACKAJkIgUEQEEAIQMDQCAEQgA3AwAgBEIANwMIIAIpAxAgBSkDEFUEQCACIAUgBBCBBSAEKQMIIAFTBEAgBCABIAIpAyhRBH4gAikDIAUgAikDACACKwMwIAEgAikDCH25oiIJRAAAAAAAAOC/RAAAAAAAAOA/IAlEAAAAAAAAAABjG6CwfAs3AwAgBCABNwMICyAGQRgQJSIDNgIAIAMgAjYCACADIAU2AgQgAyAEKQMANwMIIAMgBCkDCDcDECAAKAJkIgggACgCaEYEQCAHIAYQNAUgCCADNgIAIAAgACgCZEEEajYCZAsgACACIAUQygFBASEDBSAFIQILIAIoAmQiBQ0ACwVBACEDCyACKAJoIgJFDQAgAkEANgJkIANFDQAgACgCfCECDAELCyAAQQA2AnwgBCQCCxgBAX4gArAhAyAAIAGwNwMAIAAgAzcDCAtWAQN/IwIhAiMCQSBqJAIgAkEIaiIEQdyRARAiIAJBEGoiAyAEKQIANwIAIAEgAxAkIAAoAgggARArIAJBt+4AECIgAyACKQIANwIAIAEgAxAkIAIkAgtLAQF/IABBDBAmIgIhACABKAIAIQEgAEGYLTYCACAAQRA6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEGUwgA2AgAgACABNgIIIAILPwECfyMCIQIjAkEQaiQCIAJBnJEBECIgAkEIaiIDIAIpAgA3AgAgASADECQgAEEIaiABEEAgAUEpEDUgAiQCC2gBAX8jAiECIwJBEGokAiAAQRAQJiEAIAIgASkCADcDACACIAIpAgA3AgggAEGYLTYCACAAQRE6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEHowQA2AgAgACACKQIINwIIIAIkAiAAC+kCAQV/IwIhBCMCQUBrJAIgBEEgaiEFIARBMGoiAkG77gAQIiAEQThqIgMgAikCADcCACABIAMQJCAAQQxqIAEQQCAEQShqIgJBt+4AECIgAyACKQIANwIAIAEgAxAkIAAoAggiAigCACgCFCEGIAIgASAGQf8AcUHaAmoRBAAgACgCFCICQQFxBEAgBUGajwEQIiADIAUpAgA3AgAgASADECQgACgCFCECCyAEQRhqIQUgAkECcQRAIAVBoY8BECIgAyAFKQIANwIAIAEgAxAkIAAoAhQhAgsgBEEQaiEFIAJBBHEEQCAFQauPARAiIAMgBSkCADcCACABIAMQJAsgBEEIaiECAkACQAJAIAAsABhBAWsOAgABAgsgAkHkkAEQIiADIAIpAgA3AgAgASADECQMAQsgBEHnkAEQIiADIAQpAgA3AgAgASADECQLIAAoAhwEQCABQSAQNSAAKAIcIAEQKwsgBCQCC1ABAn8jAiECIwJBEGokAiAAKAIIIgAoAgAoAhAhAyAAIAEgA0H/AHFB2gJqEQQAIAJBue4AECIgAkEIaiIAIAIpAgA3AgAgASAAECQgAiQCC1UAIABBmC02AgAgAEEPOgAEIABBADoABSAAQQE6AAYgAEEAOgAHIABBvMEANgIAIAAgATYCCCAAIAIpAgA3AgwgACADNgIUIAAgBDoAGCAAIAU2AhwLYQEBfyMCIQYjAkEQaiQCIABBIBAmIQAgASgCACEBIAYgAikCADcDACADKAIAIQIgBCwAACEDIAUoAgAhBCAGQQhqIgUgBikCADcCACAAIAEgBSACIAMgBBD8AiAGJAIgAAt1AQN/IwIhAiMCQSBqJAIgACgCCCABECsgAkEQaiIEQfHvABAiIAJBGGoiAyAEKQIANwIAIAEgAxAkIAIgACkCDDcDACADIAIpAgA3AgAgASADECQgAkEIaiIAQYbvABAiIAMgACkCADcCACABIAMQJCACJAILQAAgAEGYLTYCACAAQQo6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEGQwQA2AgAgACABNgIIIAAgAikCADcCDAtGAQF/IwIhAyMCQRBqJAIgAEEUECYhACABKAIAIQEgAyACKQIANwMAIANBCGoiAiADKQIANwIAIAAgASACEP8CIAMkAiAAC1gBA38jAiECIwJBIGokAiAAKAIIIAEQKyACQQhqIgRBue4AECIgAkEQaiIDIAQpAgA3AgAgASADECQgAiAAKQIMNwMAIAMgAikCADcCACABIAMQJCACJAILQAAgAEGYLTYCACAAQQI6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEHkwAA2AgAgACABNgIIIAAgAikCADcCDAtGAQF/IwIhAyMCQRBqJAIgAEEUECYhACABKAIAIQEgAyACKQIANwMAIANBCGoiAiADKQIANwIAIAAgASACEIIDIAMkAiAAC5sBAQR/IwIhAiMCQSBqJAIgAkEYaiEDIAJBEGohBCAAKAIIIgVBAXEEQCAEQZqPARAiIAMgBCkCADcCACABIAMQJCAAKAIIIQULIAJBCGohBCAFQQJxBEAgBEGhjwEQIiADIAQpAgA3AgAgASADECQgACgCCCEFCyAFQQRxBEAgAkGrjwEQIiADIAIpAgA3AgAgASADECQLIAIkAgskAQF/IAAoAgwiACgCACgCFCECIAAgASACQf8AcUHaAmoRBAALKwECfyAAKAIMIgIoAgAoAhAhAyACIAEgA0H/AHFB2gJqEQQAIAAgARCEAwsLACAAKAIMIAEQSwsLACAAKAIMIAEQRgtUAQN/IAEsAAUhAyABLAAGIQQgASwAByEFIABBmC02AgAgAEEDOgAEIAAgAzoABSAAIAQ6AAYgACAFOgAHIABBuMAANgIAIAAgAjYCCCAAIAE2AgwLOgECfyMCIQEjAkEQaiQCIABBEBAmIQAgAUHZ8AAQIiABQQhqIgIgASkCADcCACAAIAIQVSABJAIgAAs6AQJ/IwIhASMCQRBqJAIgAEEQECYhACABQf2OARAiIAFBCGoiAiABKQIANwIAIAAgAhBVIAEkAiAACzoBAn8jAiEBIwJBEGokAiAAQRAQJiEAIAFB9o4BECIgAUEIaiICIAEpAgA3AgAgACACEFUgASQCIAALOAEBfyMCIQIjAkEQaiQCIABBEBAmIQAgAiABECIgAkEIaiIBIAIpAgA3AgAgACABEFUgAiQCIAALPAEBfyMCIQIjAkEQaiQCIABBEBAmIQAgAiABKQIANwMAIAJBCGoiASACKQIANwIAIAAgARBVIAIkAiAAC3MBA38jAiECIwJBIGokAiACQRBqQaqOARAiIAJBGGoiAyACKQIQNwIAIAEgAxAkIAAoAgwhBCACIAAoAgg2AgggAiAENgIMIAMgAikCCDcCACABIAMQJCACQc3rABAiIAMgAikCADcCACABIAMQJCACJAILgQEBAX8jAiECIwJBIGokAiAAQRAQJiEAIAIgASkCADcDACACQRBqIgEgAikCADcCACACQQhqIAEQkwEgASACKQIINwIAIABBmC02AgAgAEEaOgAEIABBAToABSAAQQE6AAYgAEEBOgAHIABBjMAANgIAIAAgASkCADcCCCACJAIgAAtNAQF/IwIhAyMCQRBqJAIgAEEUECYhACABKAIAIQEgAyACKAIANgIAIANBADYCBCADQQhqIgIgAykCADcCACAAIAEgAhDMASADJAIgAAu7AQEEfyMCIQIjAkEgaiQCIAJBCGohBCAAKAIIIAEQKyACQRBqQfKNARAiIAJBGGoiAyACKQIQNwIAIAEgAxAkIABBDGoiACIFKAIABH8gBSgCBEUFQQALBEAgACgCACABECsFIAAoAgQEfyAAKAIABUEACwRAIAAoAgQhBSAEIAAoAgA2AgAgBCAFNgIEIAMgBCkCADcCACABIAMQJAsLIAJBzesAECIgAyACKQIANwIAIAEgAxAkIAIkAguZAgEFfyMCIQMjAkEwaiQCIANBIGohAiADQRhqIQQgASgCBCIFBH8gASgCACAFQX9qaiwAAAVBAAtB/wFxQd0ARwRAIARBue4AECIgAiAEKQIANwIAIAEgAhAkCyADQQhqIQUgA0EQakHAjQEQIiACIAMpAhA3AgAgASACECQgAEEMaiIEIgYoAgQEfyAGKAIABUEACwRAIAQoAgQhBiAFIAQoAgA2AgAgBSAGNgIEIAIgBSkCADcCACABIAIQJAUgBCgCAAR/IAQoAgRFBUEACwRAIAQoAgAgARArCwsgA0HN6wAQIiACIAMpAgA3AgAgASACECQgACgCCCIAKAIAKAIUIQIgACABIAJB/wBxQdoCahEEACADJAILJAEBfyAAKAIIIgAoAgAoAhAhAiAAIAEgAkH/AHFB2gJqEQQACz8AIABBmC02AgAgAEEOOgAEIABBADoABSAAQQA6AAYgAEEBOgAHIABBtD82AgAgACABNgIIIAAgAikCADcCDAtGAQF/IwIhAyMCQRBqJAIgAEEUECYhACABKAIAIQEgAyACKQIANwMAIANBCGoiAiADKQIANwIAIAAgASACEJUDIAMkAiAAC3ABAn8jAiECIwJBEGokAiACQQhqIQMCQAJAIAAoAgwgARBGDQAgACgCDCABEEsNAAwBCyACQbfuABAiIAMgAikCADcCACABIAMQJAsgACgCDCIDKAIAKAIUIQAgAyABIABB/wBxQdoCahEEACACJAILtwEBBn8jAiECIwJBIGokAiACQRhqIQMgAkEQaiEEIAJBCGohBSAAKAIMIgYoAgAoAhAhByAGIAEgB0H/AHFB2gJqEQQAAkACQCAAKAIMIAEQRg0AIAAoAgwgARBLDQAgBUG57gAQIiADIAUpAgA3AgAgASADECQMAQsgBEG77gAQIiADIAQpAgA3AgAgASADECQLIAAoAgggARArIAJBhI0BECIgAyACKQIANwIAIAEgAxAkIAIkAgtFAQF/IAIsAAUhAyAAQZgtNgIAIABBDToABCAAIAM6AAUgAEEBOgAGIABBAToAByAAQYg/NgIAIAAgATYCCCAAIAI2AgwLPAAgAEGYLTYCACAAQRc6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEHcPjYCACAAIAE2AgggACACNgIMC18AAkACQAJAAkACQAJAAkAgASgCCA4GAAECAwQFBgsgAEGm7AAQIgwFCyAAQbDsABAiDAQLIABBsOwAECIMAwsgAEGMigEQIgwCCyAAQZqKARAiDAELIABBqIoBECILC/oBAQd/IwIhAyMCQUBrJAIgA0EwaiECIANBKGohBCADQSBqIQUgA0EYaiEGIANBEGohByADQQhqIQgCQAJAAkACQAJAAkACQCAAKAIIDgYAAQIDBAUGCyAEQd3sABAiIAIgBCkCADcCACABIAIQJAwFCyAFQezsABAiIAIgBSkCADcCACABIAIQJAwECyAGQbeKARAiIAIgBikCADcCACABIAIQJAwDCyAHQf6KARAiIAIgBykCADcCACABIAIQJAwCCyAIQbCLARAiIAIgCCkCADcCACABIAIQJAwBCyADQeKLARAiIAIgAykCADcCACABIAIQJAsgAyQCC0oBAX8gAEEMECYiAiEAIAEoAgAhASAAQZgtNgIAIABBIzoABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQbA+NgIAIAAgATYCCCACC3EBA38jAiECIwJBIGokAiACQRBqIQMgAkEIaiEEIAAsAAwEQCAEQZj0ABAiIAMgBCkCADcCACABIAMQJAsgACgCCCIAKAIAKAIYIQQgAiAAIARB/wBxQdoCahEEACADIAIpAgA3AgAgASADECQgAiQCC0YAIABBmC02AgAgAEElOgAEIABBAToABSAAQQE6AAYgAEEBOgAHIABBhD42AgAgACABNgIIIAAgAkEBcToADCAAIAM2AhALkwMBBX8jAiEDIwJBEGokAiABKAIAIgQtAARBJEYEQCADIAQoAggiBDYCACAEQX5qQQRJBEAgASAAQfACaiADEJ0DNgIACwsgA0EEaiEEAn8gAEHDABAnBH8gAEHJABAnIQUCQAJAIAAoAgQgACgCACIGa0EASwR/IAYsAAAFQQALIgZBGHRBGHVBMWsOBQEBAQABAAtBAAwCCyADIAZBGHRBGHVBUGo2AgAgACAAKAIAQQFqNgIAIAIEQCACQQE6AAALAn8CQCAFRQ0AIAAgAhBJDQBBAAwBCyAEQQA6AAAgACABIAQgAxDQAQsFIAAoAgQgACgCACIFa0EASwR/IAUsAAAFQQALQf8BcUHEAEYEfwJAAkAgACgCBCAAKAIAIgVrQQFLBH8gBSwAAQVBAAsiBUEYdEEYdUEwaw4GAQEBAAABAAtBAAwDCyADIAVBGHRBGHVBUGo2AgAgACAAKAIAQQJqNgIAIAIEQCACQQE6AAALIARBAToAACAAIAEgBCADENABBUEACwsLIQcgAyQCIAcLPAAgAEGYLTYCACAAQRg6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEHYPTYCACAAIAE2AgggACACNgIMC2wBA38jAiECIwJBIGokAiACQRBqIgRB3IgBECIgAkEYaiIDIAQpAgA3AgAgASADECQgAiAAKQIINwMAIAMgAikCADcCACABIAMQJCACQQhqIgBB5YgBECIgAyAAKQIANwIAIAEgAxAkIAIkAgtnAQF/IwIhAiMCQRBqJAIgAEEQECYhACACIAEpAgA3AwAgAiACKQIANwIIIABBmC02AgAgAEEnOgAEIABBAToABSAAQQE6AAYgAEEBOgAHIABBrD02AgAgACACKQIINwIIIAIkAiAAC5IBAQN/IwIhAiMCQTBqJAIgAkEYaiIEQZ2IARAiIAJBIGoiAyAEKQIANwIAIAEgAxAkIAIgACkCEDcDACADIAIpAgA3AgAgASADECQgAkEQaiIEQaWIARAiIAMgBCkCADcCACABIAMQJCAAQQhqIAEQQCACQQhqIgBBt+4AECIgAyAAKQIANwIAIAEgAxAkIAIkAgtCACAAQZgtNgIAIABBKDoABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQYA9NgIAIAAgASkCADcCCCAAIAIpAgA3AhALWAEBfyMCIQMjAkEgaiQCIABBGBAmIQAgAyABKQIANwMIIAMgAikCADcDACADQRBqIgEgAykCCDcCACADQRhqIgIgAykCADcCACAAIAEgAhClAyADJAIgAAsZACABQdsAEDUgAEEIaiABEEAgAUHdABA1C2cBAX8jAiECIwJBEGokAiAAQRAQJiEAIAIgASkCADcDACACIAIpAgA3AgggAEGYLTYCACAAQSk6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEHUPDYCACAAIAIpAgg3AgggAiQCIAAL5wIBBn8jAiEBIwJBMGokAiABQRhqIQUgAUEIaiEDIAFBEGohBCABQSBqQZSIARAiIAFBKGoiAiABKQIgNwIAIAAgAhAqBEAgAiAAQQAQPSAAQd8AECcEfyAAQfACaiACEKMDBUEACyEABSAFQZeIARAiIAIgBSkCADcCACAAIAIQKgRAIAFBADYCACABQQA2AgQgAyAAQeoCajYCACADIAAsAOoCOgAEIANBAToABSAAQQE6AOoCIARBmogBECIgAiAEKQIANwIAAn8CQCAAIAIQKg0AIABBCGoiBSIEKAIEIAQoAgBrQQJ1IQQCQANAIAIgABAuIgY2AgAgBkUNASAFIAIQMiAAQcUAECdFDQALIAEgACAEEDwMAQtBAAwBCyACIABBABA9IABB3wAQJwR/IABB8AJqIAEgAhCmAwVBAAsLIQAgAywABQRAIAMoAgAgAywABDoAAAsFQQAhAAsLIAEkAiAACzkBAn8jAiECIwJBEGokAiACQZyHARAiIAJBCGoiAyACKQIANwIAIAEgAxAkIAAoAgggARArIAIkAgtKAQF/IABBDBAmIgIhACABKAIAIQEgAEGYLTYCACAAQSI6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEGoPDYCACAAIAE2AgggAguDAQEDfyMCIQIjAkEgaiQCIAJBCGpBlYcBECIgAkEQ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AgA3AwAgAygCACECIAQoAgAhAyAFQQhqIgQgBSkCADcCACAAIAEgBCACIAMQvAMgBSQCIAALnwIBBX8jAiEDIwJBQGskAiADQTBqIQQgA0E4aiICQYbvABAiIABBDGoiBiACEKEBBEAgBEG77gAQIiACIAQpAgA3AgAgASACECQLIANBCGohBCADQShqIgVBu+4AECIgAiAFKQIANwIAIAEgAhAkIAAoAgggARArIANBIGoiBUGChAEQIiACIAUpAgA3AgAgASACECQgAyAGKQIANwMAIAIgAykCADcCACABIAIQJCADQRhqIgVBhYQBECIgAiAFKQIANwIAIAEgAhAkIAAoAhQgARArIANBEGoiAEG37gAQIiACIAApAgA3AgAgASACECQgAkGG7wAQIiAGIAIQoQEEQCAEQbfuABAiIAIgBCkCADcCACABIAIQJAsgAyQCC0YAIABBmC02AgAgAEEqOgAEIABBAToABSAAQQE6AAYgAEEBOgAHIABBzDo2AgAgACABNgIIIAAgAikCADcCDCAAIAM2AhQLTwEBfyMCIQQjAkEQaiQCIABBGBAmIQAgASgCACEBIAQgAikCADcDACADKAIAIQIgBEEIaiIDIAQpAgA3AgAgACABIAMgAhC/AyAEJAIgAAt1AQN/IwIhAiMCQSBqJAIgAiAAKQIINwMAIAJBGGoiAyACKQIANwIAIAEgAxAkIAJBEGoiBEG77gAQIiADIAQpAgA3AgAgASADECQgACgCECABECsgAkEIaiIAQbfuABAiIAMgACkCADcCACABIAMQJCACJAILPwAgAEGYLTYCACAAQTU6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEGgOjYCACAAIAEpAgA3AgggACACNgIQC0YBAX8jAiEDIwJBEGokAiAAQRQQJiEAIAMgASkCADcDACACKAIAIQEgA0EIaiICIAMpAgA3AgAgACACIAEQwgMgAyQCIAALTAECfyMCIQMjAkEQaiQCIABBGBAmIQAgA0HIgwEQIiABKAIAIQEgAigCACECIANBCGoiBCADKQIANwIAIAAgBCABIAIQeyADJAIgAAtfAQN/IwIhAiMCQSBqJAIgACgCCCABECsgAkEIaiIEQbvuABAiIAJBEGoiAyAEKQIANwIAIAEgAxAkIABBDGogARBAIAJBt+4AECIgAyACKQIANwIAIAEgAxAkIAIkAgs/ACAAQZgtNgIAIABBMjoABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQfQ5NgIAIAAgATYCCCAAIAIpAgA3AgwLRgEBfyMCIQMjAkEQaiQCIABBFBAmIQAgASgCACEBIAMgAikCADcDACADQQhqIgIgAykCADcCACAAIAEgAhDGAyADJAIgAAt8AQN/IwIhAiMCQSBqJAIgAkEQaiIEQbvuABAiIAJBGGoiAyAEKQIANwIAIAEgAxAkIAAoAgggARArIAJBCGoiBEHmggEQIiADIAQpAgA3AgAgASADECQgAEEMaiABEEAgAkG37gAQIiADIAIpAgA3AgAgASADECQgAiQCCz8AIABBmC02AgAgAEE3OgAEIABBAToABSAAQQE6AAYgAEEBOgAHIABByDk2AgAgACABNgIIIAAgAikCADcCDAuHAQEDfyMCIQIjAkEgaiQCIAJBGGohAyACQRBqIQQgACwADARAIARBjfwAECIgAyAEKQIANwIAIAEgAxAkCyACQQhqIgRBqYIBECIgAyAEKQIANwIAIAEgAxAkIAAsAA0EQCACQbCCARAiIAMgAikCADcCACABIAMQJAsgACgCCCABECsgAiQCC0kAIABBmC02AgAgAEE0OgAEIABBAToABSAAQQE6AAYgAEEBOgAHIABBnDk2AgAgACABNgIIIAAgAkEBcToADCAAIANBAXE6AA0LJAAgAEEQECYiACABKAIAIAIsAABBAEcgAywAAEEARxDLAyAAC0wBAn8jAiEDIwJBEGokAiAAQRgQJiEAIANBnIIBECIgASgCACEBIAIoAgAhAiADQQhqIgQgAykCADcCACAAIAQgASACEHsgAyQCIAALPAAgAEGYLTYCACAAQRY6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEHwODYCACAAIAE2AgggACACNgIMC1ABAn8jAiECIwJBEGokAiACQZj0ABAiIAJBCGoiAyACKQIANwIAIAEgAxAkIAAoAggiACgCACgCECEDIAAgASADQf8AcUHaAmoRBAAgAiQCC0oBAX8gAEEMECYiAiEAIAEoAgAhASAAQZgtNgIAIABBJjoABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQcQ4NgIAIAAgATYCCCACCzkBAn8jAiECIwJBEGokAiACQfmAARAiIAJBCGoiAyACKQIANwIAIAEgAxAkIAAoAgggARArIAIkAgs1ACAAQZgtNgIAIABBBDoABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQZg4NgIAIAAgATYCCAvRBgESfyMCIQIjAkEQaiQCIABBKGoiCygCACIEIAAoAixGBEAgAiQCDwsgAiEKIAQhAgNAIAxBAnQgAmooAgAiBSgCECIEBEAgBSwABUUEQAJAIAQhAgNAIAQiDSgCGCIBIAJGDQEgDSIPIhAhDiABIQIDQCAPKQMIIAIpAwhRBEAgECkDECACKQMQUQRAIAIoAhggBEcEQCAEIAIiASgCHCIDRgR/IAEFAn8gDigCHCEHIA4gAzYCHCADIAQ2AhggASAHNgIcIAcgATYCGCAFIAQ2AhAgCkEYECUiAzYCACADQQA6AAQgA0EAOgAFIANCADcCCCADQgA3AhAgACgCLCIHIAAoAjBGBEAgCyAKEDQgACgCLCEDBSAHIAM2AgAgACAAKAIsQQRqIgM2AiwLIAooAgAiBiADIAsoAgAiB2tBAnVBf2oiCDYCACAGIAE2AhADQCABIAg2AgAgASgCHCIBIAJHDQALIAUoAhAhCCACIQECQAJAA0AgAUEIaiAIEFAiCUF/Sg0BIAEoAhgiASACRw0ACwwBCyAJRQRAIAghAQJAAkADQCABQQhqIAIQUCIJQX9KDQEgASgCGCIBIAhHDQALIAYgBSwABCICOgAEDAELIAYgBSwABCIBOgAEIAkEfyABBSAGIAUoAgg2AgggBCAALACNAUUNBBogBCADIAdGDQQaIAMgByIIa0ECdSERQQAhAwNAIANBAnQgCGooAgAiCSgCCCIBBEACQAN/IAEoAhANASABKAIIIgENAEEACyEBCwVBACEBCyABIAVGIAkoAhAiB0EAR3EEQAJAIAchAQJAAkADQCABQQhqIAIQUCISQX9KDQEgASgCGCIBIAdHDQALDAELIBJFDQELIAkgBjYCCAsLIANBAWoiAyARSQ0ACyAEDAQLIQILIAUgAkEBczoABCAGIAUoAgg2AgggBSAGNgIIIAQgACwAjQFFDQIaIAAgBSAGEHUgBAwCCwsgBiAFLAAEQQFzOgAEIAYgBTYCCCAALACNAQRAIAAgBiAFEHULIAQLCyECCwsLIAIoAhgiAiAFKAIQRw0ACyANKAIYIgQgAkcNAAsLCwsgDEEBaiIMIAAoAiwgCygCACICa0ECdUkNAAsgCiQCCzoBAn8jAiEBIwJBEGokAiAAQRAQJiEAIAFB6YABECIgAUEIaiICIAEpAgA3AgAgACACEFUgASQCIAALOQECfyMCIQIjAkEQaiQCIAJBqYABECIgAkEIaiIDIAIpAgA3AgAgASADECQgACgCCCABECsgAiQCC0oBAX8gAEEMECYiAiEAIAEoAgAhASAAQZgtNgIAIABBEzoABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQew3NgIAIAAgATYCCCACC2UBA38jAiEBIwJBEGokAiABIAAoAgQgACgCACICa0EASwR/IAIsAAAFQQALQRh0QRh1QVBqQQpJBH8gABB6BSAAEJsBCyICNgIAIAIEfyAAQfACaiABENADBUEACyEDIAEkAiADCzkBAn8jAiECIwJBEGokAiACQY38ABAiIAJBCGoiAyACKQIANwIAIAEgAxAkIAAoAgggARArIAIkAgs1ACAAQZgtNgIAIABBIToABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQcA3NgIAIAAgATYCCAuFBgILfxF+IAFBADYCFCABKAIQIQMgACwAJAR/QQEFIAAsAI4BQQBHCyEJAkACQCADIgJBHGoiBygCACIEIAJGDQAgAyEIIAQhAwJAAkADQCACKAIYIgQgA0YNAgJAAkAgAikDCCISIAQpAwgiGFEiCgRAIAIpAxAgBCkDEFENAQsgEiADKQMIIhdRIgsEQCACKQMQIhAgAykDECIUUQ0BBSACKQMQIRAgAykDECEUCyAEKQMQIRUgFCAQfSEOIBIgGH0hDQJAAkAgACwAFARAQgAgDn0gDiAOQgBTGyIWQiCIIRFCACANfSANIA1CAFMbIhlCIIghGiAXIBJ9Ig9CP4inIBAgFX0iE0I/iKdGIQVCACAPfSAPIA9CAFMbIhxCIIghG0IAIBN9IBMgE0IAUxsiHUIgiCETIBZC/////w+DIg8gGUL/////D4MiFn4iGSARIBZ+IA8gGn58IhZCIIZ8Ig8gGVStIBEgGn4gFkIgiHx8IhFCACARfSARQn+FIA9CAFEbIA5CP4inIA1CP4inRiIMGyAcQv////8PgyIOIB1C/////w+DIg1+IhEgDSAbfiAOIBN+fCINQiCGfCIOIBFUrSATIBt+IA1CIIh8fCINQgAgDX0gDUJ/hSAOQgBRGyAFG1EEfyAOQgAgDn0gBRsgD0IAIA99IAwbUQVBAAsNAQUgDSAOfiAXIBJ9IBAgFX1+UQ0BCwwBCyAJRQ0BIBAgFVEgCnEgFyAYUSIFIBQgFVFxIBAgFFEgC3Fycg0BIAUEQCAUIBBTIBAgFVNzDQIFIBcgElMgEiAYU3MNAgsLIAIgBkYNAyAGIAIgBhshBiAEIQIMAQsgAyAENgIYIAIoAhggBygCADYCHCAHKAIAIQIgCBAjQQAhBgsgAkEcaiIHKAIAIgMgAkcEQCACIQgMAQsLIAIhAwwCCyABIAI2AhAPCwwBCyADBH8gAgUgAUEANgIQDwshAwsgA0EANgIYA0AgAigCGCEAIAIQIyAABEAgACECDAELCyABQQA2AhALSwEBfyMCIQQjAkEQaiQCIABBGBAmIQAgASgCACEBIAQgAhAiIAMoAgAhAiAEQQhqIgMgBCkCADcCACAAIAEgAyACENoBIAQkAiAAC0QBAn8jAiECIwJBEGokAiAAKAIIIAEQKyACIAApAgw3AwAgAkEIaiIDIAIpAgA3AgAgASADECQgACgCFCABECsgAiQCC00BAn8jAiEDIwJBEGokAiAAQRgQJiEAIAEoAgAhASADQdX7ABAiIAIoAgAhAiADQQhqIgQgAykCADcCACAAIAEgBCACENoBIAMkAiAAC3wBA38jAiECIwJBIGokAiACQRBqIgRBu+4AECIgAkEYaiIDIAQpAgA3AgAgASADECQgACgCCCABECsgAkEIaiIEQZv7ABAiIAMgBCkCADcCACABIAMQJCAAKAIMIAEQKyACQc3rABAiIAMgAikCADcCACABIAMQJCACJAILPAAgAEGYLTYCACAAQSs6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEHoNjYCACAAIAE2AgggACACNgIMCwwAIAAgASkCCDcCAAveCwINfwF8IwIhASMCQRBqJAIgACgCSCICIAAoAkxGBEAgASQCDwsgASEKIABBKGohCyACIQEDQCAAKAIoIgMgDEECdCABaigCACIIKAIAKAIAQQJ0aigCACEEA0AgBCgCAEECdCADaigCACIBIARHBEAgASEEDAELCyAIKAIEKAIAQQJ0IANqKAIAIQEDQCABKAIAQQJ0IANqKAIAIgIgAUcEQCACIQEMAQsLIAQiBSgCEARAIAEiBygCEARAIAUsAAVFBEAgASwABUUEQCAAIAggBCABIAVGIgkEfyAFIgMFAn8gBSECA0AgASACKAIIIgJGBEAgASIDDAILIAINAAsgASECA0AgBCACKAIIIgJGBEAgBCEDIAEMAgsgAg0ACyAEIAEQzQEhAyABCwsiAhC0AgRAAkAgCUUEQCAHQQA2AhAgAkEANgIUIAEgBCgCADYCACAEIAMsAAQ6AAQgAyACIgVGBEAgBCAFKAIINgIICyAFIAQ2AgggACwAjQFFDQEgACgCLCICIAsoAgAiAUYNASACIAEiA2tBAnUhCUEAIQIDQCACQQJ0IANqKAIAIgcoAggiAQRAAkADfyABKAIQDQEgASgCCCIBDQBBAAshAQsFQQAhAQsgASAFRiAHKAIQQQBHcQRAIAcgBDYCCAsgAkEBaiICIAlJDQALDAELIAUgCCgCADYCECAEQQA2AhQgCkEYECUiATYCACABQQA6AAQgAUEAOgAFIAFCADcCCCABQgA3AhAgACgCLCICIAAoAjBGBEAgCyAKEDQgACgCLCEHBSACIAE2AgAgACAAKAIsQQRqIgc2AiwLIAooAgAiBiAHIAsoAgAiCWtBAnVBf2oiAzYCACAGIAgoAgQiAjYCECACIQEDQCABIAM2AgAgASgCHCIBIAJHDQALIAUoAhAhAyACIQECQAJAA0AgAUEIaiADEFAiCEF/Sg0BIAEoAhgiASACRw0ACwwBCyAIRQRAIAMhAQJAAkADQCABQQhqIAIQUCINQX9KDQEgAyABKAIYIgFHDQALIAYgBEEEaiIBLAAAIgI6AAQMAQsgBiAEQQRqIgEsAAAiCDoABCANBH8gCAUgBiAEKAIINgIIIAAsAI0BRQ0EIAcgCUYNBCAHIAlrQQJ1IQhBACEDA0AgA0ECdCAJaigCACIHKAIIIgEEQAJAA38gASgCEA0BIAEoAggiAQ0AQQALIQELBUEAIQELIAEgBEYgBygCECIFQQBHcQRAAkAgBSEBAkACQANAIAFBCGogAhBQIg1Bf0oNASABKAIYIgEgBUcNAAsMAQsgDUUNAQsgByAGNgIICwsgA0EBaiIDIAhJDQALDAQLIQILIAEgAkEBcyICOgAAIAYgBCgCCDYCCCAEIAY2AgggACwAjQEEfyAAIAQgBhB1IAEsAAAhAiAFKAIQBSADCyEBIAAsAIwBIQMgAUUiBA0CIAIgA3NB/wFxIQNEAAAAAAAAAAAhDiABIQIDQCAOIAIoAhwiBSkDCCACKQMIfLkgBSkDECACKQMQfbmioCEOIAIoAhgiAiABRw0ACyAEIAMgDkQAAAAAAADgP6JEAAAAAAAAAABkR3INAiABIQIDQCACKAIYIQMgAiACKAIcNgIYIAIgAzYCHCABIANGDQMgAyECDAAACwALCyAGIAQsAARBAXMiAToABCAGIAQ2AgggACwAjQEEQCAAIAYgBBB1IAYsAAQhASAGKAIQIQILIAAsAIwBIAFzQf8BcSEDIAJFIgRFBEBEAAAAAAAAAAAhDiACIQEDQCAOIAEoAhwiBSkDCCABKQMIfLkgBSkDECABKQMQfbmioCEOIAIgASgCGCIBRw0ACyAORAAAAAAAAOA/okQAAAAAAAAAAGQgA0cgBHJFBEAgAiEBA0AgASgCGCEDIAEgASgCHDYCGCABIAM2AhwgAiADRwRAIAMhAQwBCwsLCwsLCwsLCyAMQQFqIgwgACgCTCAAKAJIIgFrQQJ1SQ0ACyAKJAILMgEBfyMCIQIjAkEQaiQCIAIgACkCCDcDACACQQhqIgAgAikCADcCACABIAAQJCACJAILOgECfyMCIQEjAkEQaiQCIABBEBAmIQAgAUHZ+gAQIiABQQhqIgIgASkCADcCACAAIAIQVSABJAIgAAuLAQEDfyMCIQIjAkEQaiQCIAAsABAEQCABQdsAEDUgACgCCCABECsgAUHdABA1BSABQS4QNSAAKAIIIAEQKwsgAkEIaiEDIAAoAgwiBCwABEG/f2pBGHRBGHVB/wFxQQJOBH8gAkHn+QAQIiADIAIpAgA3AgAgASADECQgACgCDAUgBAsgARArIAIkAgtHACAAQZgtNgIAIABBwQA6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEGQNjYCACAAIAE2AgggACACNgIMIAAgA0EBcToAEAuVAQEDfyMCIQIjAkEgaiQCIAFB2wAQNSAAKAIIIAEQKyACQQhqQeH5ABAiIAJBEGoiAyACKQIINwIAIAEgAxAkIAAoAgwgARArIAFB3QAQNSAAKAIQIgQsAARBv39qQRh0QRh1Qf8BcUECTgR/IAJB5/kAECIgAyACKQIANwIAIAEgAxAkIAAoAhAFIAQLIAEQKyACJAILRAAgAEGYLTYCACAAQcIAOgAEIABBAToABSAAQQE6AAYgAEEBOgAHIABB5DU2AgAgACABNgIIIAAgAjYCDCAAIAM2AhALwhIDDH8MfgF8IwIhCSMCQTBqJAIgCUEkaiEKIAlBCGohBSAJQRhqIgsgAEE0aiIEKAIAIgI2AgAgAgR/IABB8ABqIQcgAEH4AGohBiAAQfwAaiEIIABByABqIQwDfwJAAkACQCABIAIpAyhRBEACQCACKAJYRQRAAkACQAJAIAIpAyAiDyACKAJQIgMpAyBRBEAgASADKQMoUQRAIAMoAlhFDQILCyAPIAIoAlQiAykDIFEEQCABIAMpAyhRBEAgAygCWEUNAgsLDAELIAMoAkxBfkcEQCADKAJcIAMoAmBGGiADKwMwRKVcw/EpYz3IYQ0CCwsgACwAjgEEQEEQECUiAyACKQMgNwMIIAMgBzYCBCADIAcoAgAiDTYCACANIAM2AgQgByADNgIAIAYgBigCAEEBajYCAAsgAigCYCEDIAAgAhDXAiADRQRAIAQhAgwDCyADQdwAaiECDAILCyACKAJYIgMEQCADKwMwRKVcw/EpYz3IYQRAIAAgCxBnIAsoAgAiAigCTEF/SgRAIAAgAiACEC8aCyAIKAIAIgMEQCACIAM2AmQgAkEANgJoIAMgAjYCaCAIIAI2AgAFIAggAjYCACACQQA2AmggAkEANgJkCwwFCwsgAikDICEPDAILBSACKQMAIAIrAzAgASACKQMIfbmiIhpEAAAAAAAA4L9EAAAAAAAA4D8gGkQAAAAAAAAAAGMboLB8IQ8MAQsMAgsgAiAPNwMQIAIgATcDGAsgACwAjgEEfyACKAJgIQMgAigCTEF/SgR/IAJBQGsoAgBBAEcgA0EAR3EEfyADKAJMQX9KBH8gAykDECACKQMQUQR/IANBQGsoAgAEfyAFIAIpAxA3AwAgBSACKQMYNwMIIAAgAyAFEC8hAyAAIAIgBRAvIQ0gCkEYECUiAjYCACACIAM2AgAgAiANNgIEIAIgBSkDADcDCCACIAUpAwg3AxAgACgCTCIDIAAoAlBGBEAgDCAKEDQFIAMgAjYCACAAIAAoAkxBBGo2AkwLIAsoAgAFIAILBSACCwUgAgsFIAILBSACCwUgAgtB3ABqIQILIAsgAigCACICNgIAIAINACAGCwUgAEHwAGohByAAQfwAaiEIIABB+ABqCyEDIAkgACgCdDYCICAJIAc2AhwgAygCACECIAUgCSgCIDYCACAKIAkoAhw2AgAgBSAKIAIgCRC2ARogCCgCACICBEADQCACKAJoIgZB5ABqIAggBhsgAigCZCIMNgIAIAwEQCAMIAY2AmgLIAJBADYCZCACQQA2AmggACACEMsBIAgoAgAiAg0ACwsgAygCAARAIAAoAnQiAigCACIIIAAoAnAiBigCBDYCBCAGKAIEIAg2AgAgA0EANgIAIAIgB0cEQANAIAIoAgQhAyACECMgAyAHRwRAIAMhAgwBCwsLCyALIAQoAgAiAjYCACACRQRAIAkkAg8LIABByABqIQgDQCABIAIpAyhRBEAgAigCWARAAkAgAigCTEF/SgR/IAAgAiACQSBqEC8FQQALIQcgACALEGcgCygCACICKAJgIQMgAigCXCEEIAMEQCADKQMQIg4gAikDAFEEQCAHQQBHIAMpAxgiECACKQMIUXEEQCADKAJMQX9KBEAgECADKQMoIhNVBEACQCACKQMQIRIgAikDICERIAIpAxggAikDKH0hDyAOIAMpAyB9IQ4gACwAFARAQgAgD30gDyAPQgBTGyIUQiCIIRVCACAOfSAOIA5CAFMbIhdCIIghFiASIBF9IhJCP4inIBAgE30iEEI/iKdGIQZCACASfSASIBJCAFMbIhhCIIghEkIAIBB9IBAgEEIAUxsiGUIgiCETIBRC/////w+DIhAgF0L/////D4MiEX4iFCARIBV+IBAgFn58IhFCIIZ8IhAgFFStIBUgFn4gEUIgiHx8IhFCACARfSARQn+FIBBCAFEbIA9CP4inIA5CP4inRiIMGyAYQv////8PgyIPIBlC/////w+DIg5+IhEgDiASfiAPIBN+fCIOQiCGfCIPIBFUrSASIBN+IA5CIIh8fCIOQgAgDn0gDkJ/hSAPQgBRGyAGG1EEfyAPQgAgD30gBhsgEEIAIBB9IAwbUQVBAAtFDQEFIA4gD34gEiARfSAQIBN9flINAQsgAkFAaygCAARAIANBQGsoAgAEQCAAIAMgAhAvIQQgBSACKQMgNwMAIAUgAikDKDcDCCAKQRgQJSIDNgIAIAMgBzYCACADIAQ2AgQgAyAFKQMANwMIIAMgBSkDCDcDECAAKAJMIgQgACgCUEYEQCAIIAoQNAUgBCADNgIAIAAgACgCTEEEajYCTAsMCAsLCwsLCwsLIAQEQCAEKQMQIg4gAikDAFEEQCAHQQBHIAQpAxgiECACKQMIUXEEQCAEKAJMQX9KBEAgECAEKQMoIhNVBEAgAikDECESIAIpAyAhESACKQMYIAIpAyh9IQ8gDiAEKQMgfSEOIAAsABQEQEIAIA99IA8gD0IAUxsiFEIgiCEVQgAgDn0gDiAOQgBTGyIXQiCIIRYgEiARfSISQj+IpyAQIBN9IhBCP4inRiEDQgAgEn0gEiASQgBTGyIYQiCIIRJCACAQfSAQIBBCAFMbIhlCIIghEyAUQv////8PgyIQIBdC/////w+DIhF+IhQgESAVfiAQIBZ+fCIRQiCGfCIQIBRUrSAVIBZ+IBFCIIh8fCIRQgAgEX0gEUJ/hSAQQgBRGyAPQj+IpyAOQj+Ip0YiBhsgGEL/////D4MiDyAZQv////8PgyIOfiIRIA4gEn4gDyATfnwiDkIghnwiDyARVK0gEiATfiAOQiCIfHwiDkIAIA59IA5Cf4UgD0IAURsgAxtRBH8gD0IAIA99IAMbIBBCACAQfSAGG1EFQQALRQ0GBSAOIA9+IBIgEX0gECATfX5SDQYLIAJBQGsoAgAEQCAEQUBrKAIABEAgACAEIAIQLyEEIAUgAikDIDcDACAFIAIpAyg3AwggCkEYECUiAzYCACADIAc2AgAgAyAENgIEIAMgBSkDADcDCCADIAUpAwg3AxAgACgCTCIEIAAoAlBGBEAgCCAKEDQFIAQgAzYCACAAIAAoAkxBBGo2AkwLCwsLCwsLCwsLCyALIAIoAlwiAjYCACACDQALIAkkAgs/AQF/IwIhAiMCQRBqJAIgAEEUECYhACACIAEpAgA3AwAgAkEIaiIBIAIpAgA3AgAgAEEAIAEQ3wEgAiQCIAALPwAgAEGYLTYCACAAQSw6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEG4NTYCACAAIAE2AgggACACKQIANwIMC0IBAX8jAiEDIwJBEGokAiAAQRQQJiEAIAEoAgAhASADIAIQIiADQQhqIgIgAykCADcCACAAIAEgAhDqAyADJAIgAAutAgEFfyMCIQMjAkFAayQCIANBOGohAiADQTBqIQQgACwAHARAIARB8/gAECIgAiAEKQIANwIAIAEgAhAkCyADQSBqIQQgA0EoakH/+AAQIiACIAMpAig3AgAgASACECQgACwAHQRAIARBg/kAECIgAiAEKQIANwIAIAEgAhAkCyADQRhqIQQgA0EQaiEFIAFBIBA1IABBCGoiBigCBARAIARBu+4AECIgAiAEKQIANwIAIAEgAhAkIAYgARBAIAVBt+4AECIgAiAFKQIANwIAIAEgAhAkCyADQQhqIQQgACgCECABECsgAEEUaiIAKAIEBEAgBEG77gAQIiACIAQpAgA3AgAgASACECQgACABEEAgA0G37gAQIiACIAMpAgA3AgAgASACECQLIAMkAgtdACAAQZgtNgIAIABBMzoABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQYw1NgIAIAAgASkCADcCCCAAIAI2AhAgACADKQIANwIUIAAgBEEBcToAHCAAIAVBAXE6AB0LYAEDfyMCIQIjAkEgaiQCIABBHBAmIQAgAkEIakHf+AAQIiABKAIAIQEgAkG37gAQIiACQRBqIgMgAikCCDcCACACQRhqIgQgAikCADcCACAAIAMgASAEEJ8BIAIkAiAAC6IBAQN/IwIhAiMCQTBqJAIgAkEYaiIEQbvuABAiIAJBIGoiAyAEKQIANwIAIAEgAxAkIAAoAgggARArIAJBEGoiBEGf+AAQIiADIAQpAgA3AgAgASADECQgACgCDCABECsgAkEIaiIEQaX4ABAiIAMgBCkCADcCACABIAMQJCAAKAIQIAEQKyACQbfuABAiIAMgAikCADcCACABIAMQJCACJAILQwAgAEGYLTYCACAAQS06AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEHgNDYCACAAIAE2AgggACACNgIMIAAgAzYCEAvDAQECfyAAKAI0RQRAQQEPCyAAIAEQ9AICQAJAAkAgACgCZCIDIAAoAmAiAmtBAnUOAgACAQtBAQ8LIAAQ6wIEfyAAKAJkIQMgACgCYAVBAA8LIQILIAIgA0cEQEEAIQMDQCAAIANBAnQgAmooAgAiAigCACACKAIEIAJBCGoQYSAAIAIoAgAgAigCBBCiASACBEAgAhAjCyADQQFqIgMgACgCZCAAKAJgIgJrQQJ1SQ0ACwsgACACNgJkIABBADYCfEEBC0wBAn8jAiEDIwJBEGokAiAAQRgQJiEAIANBjvgAECIgASgCACEBIAIoAgAhAiADQQhqIgQgAykCADcCACAAIAQgASACEHsgAyQCIAALyQEBBH8jAiECIwJBMGokAiACIAApAgg3AwAgAkEgaiIDIAIpAgA3AgAgASADECQgAkEYaiIEQfHvABAiIAMgBCkCADcCACABIAMQJCAAKAIQIgQoAgAoAhAhBSAEIAEgBUH/AHFB2gJqEQQAIAJBEGoiBEHf9wAQIiADIAQpAgA3AgAgASADECQgACgCFCIAKAIAKAIQIQQgACABIARB/wBxQdoCahEEACACQQhqIgBBt+4AECIgAyAAKQIANwIAIAEgAxAkIAIkAgtMAQJ/IwIhAyMCQRBqJAIgAEEYECYhACADQdP3ABAiIAEoAgAhASACKAIAIQIgA0EIaiIEIAMpAgA3AgAgACAEIAEgAhB7IAMkAiAAC14BAn8jAiEDIwJBIGokAiAAQRwQJiEAIANBCGogARAiIAIoAgAhASADQbfuABAiIANBEGoiAiADKQIINwIAIANBGGoiBCADKQIANwIAIAAgAiABIAQQnwEgAyQCIAALYwEDfyMCIQIjAkEwaiQCIAJBGGoiA0HV9gAQIiACQSBqIgQgAykCADcCACABIAQQJCACQQhqIgMgACgCCBCeASADIAEQ3QEgAkG37gAQIiAEIAIpAgA3AgAgASAEECQgAiQCC0oBAX8gAEEMECYiAiEAIAEoAgAhASAAQZgtNgIAIABBMToABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQdwzNgIAIAAgATYCCCACC1UBAn8jAiECIwJBIGokAiACIAApAgg3AwggAkEQaiIDIAIpAgg3AgAgASADECQgACgCECABECsgAiAAKQIUNwMAIAMgAikCADcCACABIAMQJCACJAILYAEDfyMCIQIjAkEgaiQCIABBHBAmIQAgAkEIakGX9gAQIiABKAIAIQEgAkG37gAQIiACQRBqIgMgAikCCDcCACACQRhqIgQgAikCADcCACAAIAMgASAEEJ8BIAIkAiAAC2cBAX8jAiECIwJBEGokAiAAQRAQJiEAIAIgASkCADcDACACIAIpAgA3AgggAEGYLTYCACAAQQA6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEGEMzYCACAAIAIpAgg3AgggAiQC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BCADQbeEARAiIAEgAykCADcCAAJAAkAgACABECoEQCABQb/uABAiDAEFAkAgBEG6hAEQIiABIAQpAgA3AgAgACABECoEQCABQb3uABAiDAMLIAhBvYQBECIgASAIKQIANwIAIAAgARAqBEAgAUGH9AAQIgwDCyAJQcCEARAiIAEgCSkCADcCACAAIAEQKgRAIAFBivQAECIMAwsgCkHDhAEQIiABIAopAgA3AgAgACABECoEQCABQZb0ABAiDAMLIAtBxoQBECIgASALKQIANwIAIAAgARAqBEAgAUGa9AAQIgwDCyAMQcmEARAiIAEgDCkCADcCACAAIAEQKgRAIAFBnfQAECIMAwsgDUHMhAEQIiABIA0pAgA3AgAgACABECoEQCABQZ/0ABAiDAMLIA5Bz4QBECIgASAOKQIANwIAIAAgARAqBEAgAUGi9AAQIgwDCyAPQdKEARAiIAEgDykCADcCACAAIAEQKgRAIAFBpPQAECIMAwsgEEHVhAEQIiABIBApAgA3AgAgACABECoEQCABQaf0ABAiDAMLIBFB2IQBECIgASARKQIANwIAIAAgARAqBEAgAUGq9AAQIgwDCyASQduEARAiIAEgEikCADcCACAAIAEQKgRAIAFBhu8AECIMAwsgE0HehAEQIiABIBMpAgA3AgAgACABECoEQCABQa30ABAiDAMLIBRB4YQBECIgASAUKQIANwIAIAAgARAqBEAgAUGw9AAQIgwDCyAVQeSEARAiIAEgFSkCADcCACAAIAEQKgRAIAFBs/QAECIMAwsgFkHnhAEQIiABIBYpAgA3AgAgACABECoEQCABQfHvABAiDAMLIBdB6oQBECIgASAXKQIANwIAIAAgARAqBEAgAUGW8wAQIgwDCyAYQe2EARAiIAEgGCkCADcCACAAIAEQKgRAIAFBt/QAECIMAwsgGUHwhAEQIiABIBkpAgA3AgAgACABECoEQCABQYDvABAiDAMLIBpB84QBECIgASAaKQIANwIAIAAgARAqBEAgAUG69AAQIgwDCyAbQfaEARAiIAEgGykCADcCACAAIAEQKgRAIAFBwPQAECIMAwsgHEH5hAEQIiABIBwpAgA3AgAgACABECoEQCABQcX0ABAiDAMLIB1B/IQBECIgASAdKQIANwIAIAAgARAqBEAgAUHI9AAQIgwDCyAeQf+E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JAIgAAuYAQEDfyMCIQIjAkEgaiQCIAJBCGohBCACQRBqQfHvABAiIAJBGGoiAyACKQIQNwIAIAEgAxAkIABBCGogARBAIAEoAgQiAAR/IAEoAgAgAEF/amosAAAFQQALQf8BcUE+RgRAIARBue4AECIgAyAEKQIANwIAIAEgAxAkCyACQYbvABAiIAMgAikCADcCACABIAMQJCACJAILZwEBfyMCIQIjAkEQaiQCIABBEBAmIQAgAiABKQIANwMAIAIgAikCADcCCCAAQZgtNgIAIABBHjoABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQaAvNgIAIAAgAikCCDcCCCACJAIgAAuhAgECfyAAKAIAIABBDGpGIQIgASgCACABQQxqRgRAIAJFBEAgACgCABAjIAAgAEEMaiICNgIAIAAgAjYCBCAAIABBLGo2AggLIAEoAgQgASgCACICayIDBEAgACgCACACIAMQVBoLIAAgACgCACABKAIEIAEoAgBrQQJ1QQJ0ajYCBCABIAEoAgA2AgQFIAIEQCAAIAEoAgA2AgAgACABKAIENgIEIAAgASgCCDYCCCABIAFBDGoiADYCACABIAA2AgQgASABQSxqNgIIBSAAKAIAIQIgACABKAIANgIAIAEgAjYCACAAKAIEIQIgACABKAIENgIEIAEgAjYCBCAAKAIIIQIgACABKAIINgIIIAEgAjYCCCABIAEoAgA2AgQLCwuvAQECfyAAIABBDGoiAjYCACAAIAI2AgQgACAAQSxqNgIIIAEoAgAgAUEMakYEQCABKAIEIAEoAgAiAmsiAwRAIAAoAgAgAiADEFQaCyAAIAAoAgAgASgCBCABKAIAa0ECdUECdGo2AgQgASABKAIANgIEBSAAIAEoAgA2AgAgACABKAIENgIEIAAgASgCCDYCCCABIAFBDGoiADYCACABIAA2AgQgASABQSxqNgIICwsUACAAKAIIIAEQKyAAKAIMIAEQKws8ACAAQZgtNgIAIABBIDoABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQfQuNgIAIAAgATYCCCAAIAI2AgwLlgEBA38jAiEDIwJBEGokAiADQQhqIQQCQAJAIAAoAggiAi0ABEEKRw0AIAIQ6wFFBEAgACgCCCECDAELDAELAkACQCACIAEQRg0AIAAoAgggARBLDQAMAQsgA0G37gAQIiAEIAMpAgA3AgAgASAEECQLIAAoAggiACgCACgCFCECIAAgASACQf8AcUHaAmoRBAALIAMkAgvAAgEIfyMCIQMjAkFAayQCIANBMGohAiADQShqIQUgA0EgaiEGIANBGGohByADQRBqIQggA0EIaiEJAkACQCAAKAIIIgQtAARBCkcNACAEEOsBBEAgACgCCCEAIAhBgu8AECIgAiAIKQIANwIAIAEgAhAkIAMgACkCDDcDACACIAMpAgA3AgAgASACECQgCUGG7wAQIiACIAkpAgA3AgAgASACECQFIAAoAgghBAwBCwwBCyAEIAEgBCgCACgCEEH/AHFB2gJqEQQAIAAoAgggARBGBEAgBUG57gAQIiACIAUpAgA3AgAgASACECQLAkACQCAAKAIIIAEQRg0AIAAoAgggARBLDQAMAQsgBkG77gAQIiACIAYpAgA3AgAgASACECQLIAdBgO8AECIgAiAHKQIANwIAIAEgAhAkCyADJAILUQEDfyAAQQwQJiIDIgIhACABKAIAIgEsAAUhBCAAQZgtNgIAIABBCzoABCAAIAQ6AAUgAEEBOgAGIABBAToAByACQcguNgIAIAIgATYCCCADCw4AIAAgASACIAMgAxBKC78BAQV/IwIhAiMCQSBqJAIgAkEYaiEFIAJBEGohAyACQQhqIQYgAEEQaiIELAAARQRAIAMgBDYCACADIAQsAAA6AAQgA0EBOgAFIARBAToAACAGIAAgARDsAQJAAkAgBigCBCIAIAEQRg0AIAAgARBLDQAMAQsgAkG37gAQIiAFIAIpAgA3AgAgASAFECQLIAAgASAAKAIAKAIUQf8AcUHaAmoRBAAgAywABQRAIAMoAgAgAywABDoAAAsLIAIkAguUAgEHfyMCIQIjAkEwaiQCIAJBKGohAyACQRhqIQQgAkEIaiEGIAJBIGohByACQRBqIQggAEEQaiIFLAAARQRAIAQgBTYCACAEIAUsAAA6AAQgBEEBOgAFIAVBAToAACAGIAAgARDsASAGKAIEIgAoAgAoAhAhBSAAIAEgBUH/AHFB2gJqEQQAIAAgARBGBEAgB0G57gAQIiADIAcpAgA3AgAgASADECQLAkACQCAAIAEQRg0AIAAgARBLDQAMAQsgCEG77gAQIiADIAgpAgA3AgAgASADECQLIAJBv+4AQb3uACAGKAIAGxAiIAMgAikCADcCACABIAMQJCAELAAFBEAgBCgCACAELAAEOgAACwsgAiQCC0wBAX8gASwABSEDIABBmC02AgAgAEEMOgAEIAAgAzoABSAAQQE6AAYgAEEBOgAHIABBnC42AgAgACABNgIIIAAgAjYCDCAAQQA6ABALRAECfyMCIQIjAkEQaiQCIABBFBAmIQAgASgCACEBIAJBru4AECIgAkEIaiIDIAIpAgA3AgAgACABIAMQ7gEgAiQCIAALUgEDfyMCIQIjAkEQaiQCIAAoAggiAygCACgCECEEIAMgASAEQf8AcUHaAmoRBAAgAiAAKQIMNwMAIAJBCGoiACACKQIANwIAIAEgABAkIAIkAgtEAQJ/IwIhAiMCQRBqJAIgAEEUECYhACABKAIAIQEgAkHq7QAQIiACQQhqIgMgAikCADcCACAAIAEgAxDuASACJAIgAAtfAAJAAkACQAJAAkACQAJAIAEoAggOBgABAgMEBQYLIABBpuwAECIMBQsgAEGw7AAQIgwECyAAQb3sABAiDAMLIABBxOwAECIMAgsgAEHM7AAQIgwBCyAAQdTsABAiCwv6AQEHfyMCIQMjAkFAayQCIANBMGohAiADQShqIQQgA0EgaiEFIANBGGohBiADQRBqIQcgA0EIaiEIAkACQAJAAkACQAJAAkAgACgCCA4GAAECAwQFBgsgBEHd7AAQIiACIAQpAgA3AgAgASACECQMBQsgBUHs7AAQIiACIAUpAgA3AgAgASACECQMBAsgBkH+7AAQIiACIAYpAgA3AgAgASACECQMAwsgB0GK7QAQIiACIAcpAgA3AgAgASACECQMAgsgCEGX7QAQIiACIAgpAgA3AgAgASACECQMAQsgA0Gk7QAQIiACIAMpAgA3AgAgASACECQLIAMkAgtKAQF/IABBDBAmIgIhACABKAIAIQEgAEGYLTYCACAAQSQ6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEHELTYCACAAIAE2AgggAgsvAQF/QYAgEEIiAQRAIAEgAEGAIGoiACgCADYCACABQQA2AgQgACABNgIABRBqCws6ACABQQhqEEIiAQRAIAEgAEGAIGooAgAiACgCADYCACABQQA2AgQgACABNgIAIAFBCGoPBRBqC0EACwQAEBoLEAAgAEEANgIAIABB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QQF1aiEAIAFBAXEEQCAFIAAoAgBqKAIAIQULIAQgAzYCACAAIAIgBCAFQR9xQeoDahEJACAEJAILVgECfyMCIQMjAkEQaiQCIAAoAgAhBCABIAAoAgQiAUEBdWohACABQQFxBEAgBCAAKAIAaigCACEECyADIAI2AgAgACADIARB/wBxQdoCahEEACADJAILBQBBiBYLwgIBBX8gACgCCCIEIAAoAgQiA2tBAnUgAU8EQANAIAMgAigCADYCACAAIAAoAgRBBGoiAzYCBCABQX9qIgENAAsPCyABIAMgACgCACIDa0ECdSIFaiIGQf////8DSwRAEAELIAYgBCADayIDQQF1IgQgBCAGSRtB/////wMgA0ECdUH/////AUkbIgQEQCAEQf////8DSwRAQQgQBiIDEEMgA0GwxAA2AgAgA0HQJEHXABAEBSAEQQJ0ECUhBwsLIAVBAnQgB2oiBSEDA0AgAyACKAIANgIAIANBBGohAyABQX9qIgENAAtBACAAKAIEIAAoAgAiAWsiAkECdWtBAnQgBWohAyACQQBKBEAgAyABIAIQLRoLIAAgAzYCACAAIAZBAnQgB2o2AgQgACAEQQJ0IAdqNgIIIAFFBEAPCyABECMLFwAgACgCACABQQJ0aiACKAIANgIAQQELUQEBfyMCIQMjAkEQaiQCIAEoAgQgASgCACIBa0ECdSACTQRAIABBATYCACADJAIPCyADIAJBAnQgAWooAgA2AgAgAEHQFSADEA02AgAgAyQCCz8BAn8gACgCBCAAKAIAIgRrQQJ1IgMgAUkEQCAAIAEgA2sgAhCNBQ8LIAMgAU0EQA8LIAAgAUECdCAEajYCBAvUAgEGfyAAKAIAIgQhByACIAEiBWsiBkECdSIDIAAoAggiASAEa0ECdU0EQCADIAAoAgQgBGtBAnUiA0shASADQQJ0IAVqIAIgARsiBiIIIAVrIgMEQCAEIAUgAxBUGgsgA0ECdSEFIAFFBEAgACAFQQJ0IAdqNgIEDwsgAiAIayIBQQBMBEAPCyAAKAIEIAYgARAtGiAAIAAoAgQgAUECdkECdGo2AgQPCyAEBEAgACAENgIEIAQQIyAAQQA2AgggAEEANgIEIABBADYCAEEAIQELIANB/////wNLBEAQAQsgAyABQQF1IgIgAiADSRtB/////wMgAUECdUH/////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AAABAAAAAgAAAAMAAAAEAAAAAQAAAAIAAAADAAAAEgAAABMAAAAAAAAAGA4AAAEAAAACAAAAAwAAAAQAAAABAAAAAgAAAAMAAAASAAAAFAAAAAAAAAAgDgAAAQAAAAIAAAADAAAABAAAAAQAAAACAAAABQAAABIAAAAVAAAAAAAAADAOAAABAAAAAgAAAAMAAAAEAAAABgAAAAIAAAADAAAAEgAAABYAAAAAAAAAQA4AAAUAAAACAAAAAwAAAAQAAAAHAAAACAAAAAMAAAASAAAAFwAAAAAAAABQDgAABgAAAAIAAAADAAAABAAAAAkAAAAKAAAAAwAAABIAAAAYAAAAAAAAAGAOAAABAAAAAgAAAAMAAAAEAAAACwAAAAIAAAAMAAAAEgAAABkAAAAAAAAAcA4AAAEAAAACAAAAAwAAAAQAAAANAAAAAgAAAAMAAAASAAAAGgAAAAAAAACADgAABwAAAAgAAAAJAAAACgAAAA4AAAAPAAAAAwAAABIAAAAbAAAAAAAAAJAOAAABAAAAAgAAAAMAAAAEAAAAEAAAAAIAAAADAAAAEgAAABwAAAAAAAAAoA4AAAEAAAACAAAAAwAAAAQAAAARAAAAAgAAAAMAAAASAAAAHQAAAAAAAACwDgAAAQAAAAIAAAADAAAABAAAABIAAAACAAAAAwAAABIAAAAeAAAAAAAAAMAOAAABAAAAAgAAAAMAAAAEAAAAEwAAAAIAAAADAAAAEgAAAB8AAAAAAAAA0A4AAAEAAAACAAAAAwAAAAQAAAAUAAAAAgAAAAMAAAASAAAAIAAAAAAAAADgDgAAAQAAAAIAAAADAAAABAAAABUAAAACAAAAAwAAABIAAAAhAAAAAAAAAPAOAAABAAAAAgAAAAMAAAAEAAAAFgAAAAIAAAADAAAAEgAAACIAQakyC7gFDwAAAQAAAAIAAAADAAAABAAAABcAAAACAAAAAwAAABIAAAAjAAAAAAAAABAPAAABAAAAAgAAAAMAAAAEAAAAGAAAAAIAAAADAAAAEgAAACQAAAAAAAAAIA8AAAEAAAACAAAAAwAAAAQAAAAZAAAAAgAAAAMAAAASAAAAJQAAAAAAAAAwDwAAAQAAAAIAAAADAAAABAAAABoAAAACAAAAAwAAABIAAAAmAAAAAAAAAEAPAAABAAAAAgAAAAMAAAAEAAAAGwAAAAIAAAADAAAAEgAAACcAAAAAAAAAUA8AAAEAAAACAAAAAwAAAAQAAAAcAAAAAgAAAAMAAAASAAAAKAAAAAAAAABgDwAAAQAAAAIAAAADAAAABAAAAB0AAAACAAAAAwAAABIAAAApAAAAAAAAAHAPAAABAAAAAgAAAAMAAAAEAAAAHgAAAAIAAAADAAAAEgAAACoAAAAAAAAAgA8AAAEAAAACAAAAAwAAAAQAAAAfAAAAAgAAAAMAAAASAAAAKwAAAAAAAACQDwAAAQAAAAIAAAADAAAABAAAACAAAAACAAAAAwAAABIAAAAsAAAAAAAAAKAPAAABAAAAAgAAAAMAAAAEAAAAIQAAAAIAAAADAAAAEgAAAC0AAAAAAAAAsA8AAAEAAAACAAAAAwAAAAQAAAAiAAAAAgAAAAMAAAASAAAALgAAAAAAAADADwAAAQAAAAIAAAADAAAABAAAACMAAAACAAAAJAAAABIAAAAvAAAAAAAAANAPAAABAAAAAgAAAAMAAAAEAAAAJQAAAAIAAAADAAAAEgAAADAAAAAAAAAA4A8AAAEAAAACAAAAAwAAAAQAAAAmAAAAAgAAAAMAAAASAAAAMQAAAAAAAADwDwAAAQAAAAIAAAADAAAABAAAACcAAAACAAAAKAAAABIAAAAyAEHpNwu4BRAAAAEAAAACAAAAAwAAAAQAAAApAAAAAgAAAAMAAAASAAAAMwAAAAAAAAAQEAAAAQAAAAIAAAADAAAABAAAACoAAAACAAAAAwAAABIAAAA0AAAAAAAAACAQAAABAAAAAgAAAAMAAAAEAAAAKwAAAAIAAAADAAAAEgAAADUAAAAAAAAAMBAAAAEAAAACAAAAAwAAAAQAAAAsAAAAAgAAAC0AAAASAAAANgAAAAAAAABAEAAAAQAAAAIAAAADAAAABAAAAC4AAAACAAAAAwAAABIAAAA3AAAAAAAAAFAQAAABAAAAAgAAAAMAAAAEAAAALwAAAAIAAAADAAAAEgAAADgAAAAAAAAAYBAAAAEAAAACAAAAAwAAAAQAAAAwAAAAAgAAAAMAAAASAAAAOQAAAAAAAABwEAAAAQAAAAIAAAADAAAABAAAADEAAAACAAAAAwAAABIAAAA6AAAAAAAAAIAQAAABAAAAAgAAAAMAAAAEAAAAMgAAAAIAAAADAAAAEgAAADsAAAAAAAAAkBAAAAEAAAACAAAAAwAAAAQAAAAzAAAAAgAAAAMAAAASAAAAPAAAAAAAAACgEAAAAQAAAAIAAAADAAAABAAAADQAAAACAAAAAwAAABIAAAA9AAAAAAAAALAQAAALAAAADAAAAA0AAAAOAAAANQAAADYAAAADAAAAEgAAAD4AAAAAAAAAwBAAAAEAAAACAAAAAwAAAAQAAAA3AAAAAgAAAAMAAAASAAAAPwAAAAAAAADQEAAAAQAAAAIAAAADAAAABAAAADgAAAACAAAAOQAAABIAAABAAAAAAAAAAOAQAAABAAAAAgAAAAMAAAAEAAAAOgAAAAIAAAADAAAAEgAAAEEAAAAAAAAA8BAAAAEAAAACAAAAAwAAAAQAAAA7AAAAAgAAAAMAAAASAAAAQgBBqT0LuAURAAABAAAAAgAAAAMAAAAEAAAAPAAAAAIAAAADAAAAEgAAAEMAAAAAAAAAEBEAAAEAAAACAAAAAwAAAAQAAAA9AAAAAgAAAAMAAAASAAAARAAAAAAAAAAgEQAAAQAAAAIAAAADAAAABAAAAD4AAAACAAAAAwAAABIAAABFAAAAAAAAADARAAABAAAAAgAAAAMAAAAEAAAAPwAAAAIAAABAAAAAEgAAAEYAAAAAAAAAQBEAAAEAAAACAAAAAwAAAAQAAABBAAAAAgAAAEIAAAASAAAARwAAAAAAAABQEQAADwAAAAIAAAADAAAABAAAAEMAAABEAAAAAwAAABIAAABIAAAAAAAAAGARAAAQAAAAEQAAAAMAAAAEAAAARQAAAEYAAAADAAAAEgAAAEkAAAAAAAAAcBEAAAEAAAACAAAAAwAAAAQAAABHAAAAAgAAAAMAAAASAAAASgAAAAAAAACAEQAAAQAAAAIAAAADAAAABAAAAEgAAAACAAAAAwAAABIAAABLAAAAAAAAAJARAAASAAAAEwAAABQAAAAEAAAASQAAAEoAAAADAAAAEgAAAEwAAAAAAAAAoBEAAAEAAAACAAAAAwAAAAQAAABLAAAAAgAAAAMAAAASAAAATQAAAAAAAACwEQAAAQAAAAIAAAADAAAABAAAAEwAAAACAAAAAwAAABIAAABOAAAAAAAAAMARAAAVAAAAAgAAABYAAAAEAAAATQAAAE4AAAADAAAAEgAAAE8AAAAAAAAA0BEAAAEAAAACAAAAAwAAAAQAAABPAAAAAgAAAAMAAAASAAAAUAAAAAAAAADgEQAAAQAAAAIAAAADAAAABAAAAFAAAAACAAAAAwAAABIAAABRAAAAAAAAAPARAAABAAAAAgAAAAMAAAAEAAAAUQAAAAIAAAADAAAAEgAAAFIAQenCAAuYVhIAAAEAAAACAAAAAwAAAAQAAABSAAAAAgAAAAMAAAASAAAAUwAAAAAAAAAQEgAAFwAAAAIAAAAYAAAABAAAAFMAAABUAAAAAwAAABIAAABUAAAAAAAAACASAAABAAAAAgAAAAMAAAAEAAAAVQAAAAIAAAADAAAAEgAAAFUAAAAAAAAAMBIAAAEAAAACAAAAAwAAAAQAAABWAAAAAgAAAAMAAAASAAAAVgAAAAAAAABAEgAAVwAAAFgAAAAEAAAAAAAAAFASAABXAAAAWQAAAAQAAAAAAAAAoBIAAA0AAABaAAAADwAAABAAAAAEAAAAAAAAAHASAAANAAAAWwAAAA8AAAAQAAAABQAAAAAAAAAgEwAADQAAAFwAAAAPAAAAEAAAAAYAAAAAAAAAMBMAAA0AAABdAAAADwAAABAAAAADAAAAAwAAAAMAAAADAAAAQ29vcmRpbmF0ZSBvdXRzaWRlIGFsbG93ZWQgcmFuZ2UATjEwQ2xpcHBlckxpYjE2Y2xpcHBlckV4Y2VwdGlvbkUAQWRkUGF0aDogT3BlbiBwYXRocyBtdXN0IGJlIHN1YmplY3QuAFVwZGF0ZUVkZ2VJbnRvQUVMOiBpbnZhbGlkIGNhbGwARXJyb3I6IFBvbHlUcmVlIHN0cnVjdCBpcyBuZWVkZWQgZm9yIG9wZW4gcGF0aCBjbGlwcGluZy4ARG9NYXhpbWEgZXJyb3IAdG9QYXRoAHRvUGF0aHMAZnJvbVBhdGgAZnJvbVBhdGhzAENsaXBUeXBlAEludGVyc2VjdGlvbgBVbmlvbgBEaWZmZXJlbmNlAFhvcgBQb2x5VHlwZQBTdWJqZWN0AENsaXAAUG9seUZpbGxUeXBlAEV2ZW5PZGQATm9uWmVybwBQb3NpdGl2ZQBOZWdhdGl2ZQBJbnRQb2ludAB4AHkAbmV3SW50UG9pbnQAUGF0aABQYXRocwBJbml0T3B0aW9ucwBSZXZlcnNlU29sdXRpb24AU3RyaWN0bHlTaW1wbGUAUHJlc2VydmVDb2xsaW5lYXIASm9pblR5cGUAU3F1YXJlAFJvdW5kAE1pdGVyAEVuZFR5cGUAQ2xvc2VkUG9seWdvbgBDbG9zZWRMaW5lAE9wZW5CdXR0AE9wZW5TcXVhcmUAT3BlblJvdW5kAFBvbHlOb2RlAGNvbnRvdXIAY2hpbGRzAGdldFBhcmVudABnZXROZXh0AGlzSG9sZQBpc09wZW4AY2hpbGRDb3VudABQb2x5Tm9kZXMAUG9seVRyZWUAZ2V0Rmlyc3QAY2xlYXIAdG90YWwAb3JpZW50YXRpb24AYXJlYQBwb2ludEluUG9seWdvbgBzaW1wbGlmeVBvbHlnb24Ac2ltcGxpZnlQb2x5Z29uc0luT3V0AHNpbXBsaWZ5UG9seWdvbnNPdmVyd3JpdGUAY2xlYW5Qb2x5Z29uAGNsZWFuUG9seWdvbnMAbWlua293c2tpU3VtUGF0aABtaW5rb3dza2lTdW1QYXRocwBtaW5rb3dza2lEaWZmAHBvbHlUcmVlVG9QYXRocwBjbG9zZWRQYXRoc0Zyb21Qb2x5VHJlZQBvcGVuUGF0aHNGcm9tUG9seVRyZWUAcmV2ZXJzZVBhdGgAcmV2ZXJzZVBhdGhzAEludFJlY3QAbGVmdAB0b3AAcmlnaHQAYm90dG9tAENsaXBwZXJCYXNlAGFkZFBhdGgAYWRkUGF0aHMAZ2V0Qm91bmRzAHByZXNlcnZlQ29sbGluZWFyAENsaXBwZXIAZXhlY3V0ZVBhdGhzAGV4ZWN1dGVQYXRoc1dpdGhGaWxsVHlwZXMAZXhlY3V0ZVBvbHlUcmVlAGV4ZWN1dGVQb2x5VHJlZVdpdGhGaWxsVHlwZXMAcmV2ZXJzZVNvbHV0aW9uAHN0cmljdGx5U2ltcGxlAENsaXBwZXJPZmZzZXQAbWl0ZXJMaW1pdABhcmNUb2xlcmFuY2UATjEwQ2xpcHBlckxpYjExQ2xpcHBlckJhc2VFAE4xMENsaXBwZXJMaWI3Q2xpcHBlckUATjEwQ2xpcHBlckxpYjhQb2x5Tm9kZUUAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lkRUUATlN0M19fMjZ2ZWN0b3JJTjEwQ2xpcHBlckxpYjhJbnRQb2ludEVOU185YWxsb2NhdG9ySVMyX0VFRUUATlN0M19fMjEzX192ZWN0b3JfYmFzZUlOMTBDbGlwcGVyTGliOEludFBvaW50RU5TXzlhbGxvY2F0b3JJUzJfRUVFRQBOU3QzX18yMjBfX3ZlY3Rvcl9iYXNlX2NvbW1vbklMYjFFRUUAdmlpaQBOU3QzX18yNnZlY3RvcklOUzBfSU4xMENsaXBwZXJMaWI4SW50UG9pbnRFTlNfOWFsbG9jYXRvcklTMl9FRUVFTlMzX0lTNV9FRUVFAE5TdDNfXzIxM19fdmVjdG9yX2Jhc2VJTlNfNnZlY3RvcklOMTBDbGlwcGVyTGliOEludFBvaW50RU5TXzlhbGxvY2F0b3JJUzNfRUVFRU5TNF9JUzZfRUVFRQBOMTBlbXNjcmlwdGVuM3ZhbEUAaWlpAE4xMENsaXBwZXJMaWI4Q2xpcFR5cGVFAE4xMENsaXBwZXJMaWI4UG9seVR5cGVFAE4xMENsaXBwZXJMaWIxMlBvbHlGaWxsVHlwZUUATjEwQ2xpcHBlckxpYjhJbnRQb2ludEUAUE4xMENsaXBwZXJMaWI4SW50UG9pbnRFAFBLTjEwQ2xpcHBlckxpYjhJbnRQb2ludEUAaWkAdgB2aQBkaWkAdmlpZABpaWRkAHB1c2hfYmFjawByZXNpemUAc2l6ZQBnZXQAc2V0AFBOU3QzX18yNnZlY3RvcklOMTBDbGlwcGVyTGliOEludFBvaW50RU5TXzlhbGxvY2F0b3JJUzJfRUVFRQBQS05TdDNfXzI2dmVjdG9ySU4xMENsaXBwZXJMaWI4SW50UG9pbnRFTlNfOWFsbG9jYXRvcklTMl9FRUVFAHZpaWlpAGlpaWkAaWlpaWkAUE5TdDNfXzI2dmVjdG9ySU5TMF9JTjEwQ2xpcHBlckxpYjhJbnRQb2ludEVOU185YWxsb2NhdG9ySVMyX0VFRUVOUzNfSVM1X0VFRUUAUEtOU3QzX18yNnZlY3RvcklOUzBfSU4xMENsaXBwZXJMaWI4SW50UG9pbnRFTlNfOWFsbG9jYXRvcklTMl9FRUVFTlMzX0lTNV9FRUVFAE4xMENsaXBwZXJMaWIxMUluaXRPcHRpb25zRQBOMTBDbGlwcGVyTGliOEpvaW5UeXBlRQBOMTBDbGlwcGVyTGliN0VuZFR5cGVFAFBOMTBDbGlwcGVyTGliOFBvbHlOb2RlRQBQS04xMENsaXBwZXJMaWI4UG9seU5vZGVFAE5TdDNfXzI2dmVjdG9ySVBOMTBDbGlwcGVyTGliOFBvbHlOb2RlRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQBOU3QzX18yMTNfX3ZlY3Rvcl9iYXNlSVBOMTBDbGlwcGVyTGliOFBvbHlOb2RlRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQBQTlN0M19fMjZ2ZWN0b3JJUE4xMENsaXBwZXJMaWI4UG9seU5vZGVFTlNfOWFsbG9jYXRvcklTM19FRUVFAFBLTlN0M19fMjZ2ZWN0b3JJUE4xMENsaXBwZXJMaWI4UG9seU5vZGVFTlNfOWFsbG9jYXRvcklTM19FRUVFAE4xMENsaXBwZXJMaWI4UG9seVRyZWVFAFBOMTBDbGlwcGVyTGliOFBvbHlUcmVlRQBQS04xMENsaXBwZXJMaWI4UG9seVRyZWVFAHZpaQB2aWlpZAB2aWlpaWkATjEwQ2xpcHBlckxpYjdJbnRSZWN0RQBQTjEwQ2xpcHBlckxpYjdJbnRSZWN0RQBQS04xMENsaXBwZXJMaWI3SW50UmVjdEUAUE4xMENsaXBwZXJMaWIxMUNsaXBwZXJCYXNlRQBQS04xMENsaXBwZXJMaWIxMUNsaXBwZXJCYXNlRQBpaWlpaWkAUE4xMENsaXBwZXJMaWI3Q2xpcHBlckUAUEtOMTBDbGlwcGVyTGliN0NsaXBwZXJFAGlpaWlpaWkATjEwQ2xpcHBlckxpYjEzQ2xpcHBlck9mZnNldEUAUE4xMENsaXBwZXJMaWIxM0NsaXBwZXJPZmZzZXRFAFBLTjEwQ2xpcHBlckxpYjEzQ2xpcHBlck9mZnNldEUALSsgICAwWDB4AChudWxsKQAtMFgrMFggMFgtMHgrMHggMHgAaW5mAElORgBuYW4ATkFOAHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AHN0ZDo6d3N0cmluZwBlbXNjcmlwdGVuOjp2YWwAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZG91YmxlPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nIGRvdWJsZT4ATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZUVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWZFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ltRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWpFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lpRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXNFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJYUVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWNFRQBOU3QzX18yMTJiYXNpY19zdHJpbmdJd05TXzExY2hhcl90cmFpdHNJd0VFTlNfOWFsbG9jYXRvckl3RUVFRQBOU3QzX18yMjFfX2Jhc2ljX3N0cmluZ19jb21tb25JTGIxRUVFAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0loTlNfMTFjaGFyX3RyYWl0c0loRUVOU185YWxsb2NhdG9ySWhFRUVFAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0ljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFAHRlcm1pbmF0aW5nIHdpdGggJXMgZXhjZXB0aW9uIG9mIHR5cGUgJXM6ICVzAHRlcm1pbmF0aW5nIHdpdGggJXMgZXhjZXB0aW9uIG9mIHR5cGUgJXMAdGVybWluYXRpbmcgd2l0aCAlcyBmb3JlaWduIGV4Y2VwdGlvbgB0ZXJtaW5hdGluZwB1bmNhdWdodABTdDlleGNlcHRpb24ATjEwX19jeHhhYml2MTE2X19zaGltX3R5cGVfaW5mb0UAU3Q5dHlwZV9pbmZvAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAdGVybWluYXRlX2hhbmRsZXIgdW5leHBlY3RlZGx5IHJldHVybmVkAF9aAF9fX1oAX2Jsb2NrX2ludm9rZQBpbnZvY2F0aW9uIGZ1bmN0aW9uIGZvciBibG9jayBpbiAAdm9pZABib29sAGNoYXIAc2lnbmVkIGNoYXIAdW5zaWduZWQgY2hhcgBzaG9ydAB1bnNpZ25lZCBzaG9ydABpbnQAdW5zaWduZWQgaW50AGxvbmcAdW5zaWduZWQgbG9uZwBsb25nIGxvbmcAX19pbnQxMjgAdW5zaWduZWQgX19pbnQxMjgAZmxvYXQAbG9uZyBkb3VibGUAX19mbG9hdDEyOAAuLi4AZGVjaW1hbDY0AGRlY2ltYWwxMjgAZGVjaW1hbDMyAGRlY2ltYWwxNgBjaGFyMzJfdABjaGFyMTZfdABhdXRvAGRlY2x0eXBlKGF1dG8pAHN0ZDo6bnVsbHB0cl90AFthYmk6AF0ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTBBYmlUYWdBdHRyRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU0Tm9kZUUAYWxsb2NhdG9yAGJhc2ljX3N0cmluZwBzdHJpbmcAaXN0cmVhbQBvc3RyZWFtAGlvc3RyZWFtAHN0ZDo6YWxsb2NhdG9yAHN0ZDo6YmFzaWNfc3RyaW5nAHN0ZDo6c3RyaW5nAHN0ZDo6aXN0cmVhbQBzdGQ6Om9zdHJlYW0Ac3RkOjppb3N0cmVhbQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxOVNwZWNpYWxTdWJzdGl0dXRpb25FACBpbWFnaW5hcnkATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjBQb3N0Zml4UXVhbGlmaWVkVHlwZUUAIGNvbXBsZXgAKQAgACgAJgAmJgBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxM1JlZmVyZW5jZVR5cGVFAG9iamNfb2JqZWN0ACoAaWQ8AD4ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTFQb2ludGVyVHlwZUUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjBOYW1lV2l0aFRlbXBsYXRlQXJnc0UAPAAsIABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMlRlbXBsYXRlQXJnc0UATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNQYXJhbWV0ZXJQYWNrRQB3Y2hhcl90AGIwRQBiMUUAdQBsAHVsAGxsAHVsbABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNUludGVnZXJDYXN0RXhwckUAJUxhTABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNkZsb2F0TGl0ZXJhbEltcGxJZUVFACVhAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE2RmxvYXRMaXRlcmFsSW1wbElkRUUAJWFmAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE2RmxvYXRMaXRlcmFsSW1wbElmRUUAdHJ1ZQBmYWxzZQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU4Qm9vbEV4cHJFAC0ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTRJbnRlZ2VyTGl0ZXJhbEUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjBUZW1wbGF0ZUFyZ3VtZW50UGFja0UAZ3MAJj0APQBhbGlnbm9mICgALAB+AC4qAC8ALz0AXgBePQA9PQA+PQA8PQA8PAA8PD0ALT0AKj0ALS0AIT0AIQB8fAB8AHw9AC0+KgArACs9ACsrAC0+ACUAJT0APj4APj49AHNpemVvZiAoAHR5cGVpZCAoAHRocm93AHRocm93IABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU5VGhyb3dFeHByRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMkluaXRMaXN0RXhwckUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNOb2RlQXJyYXlOb2RlRQBzaXplb2YuLi4gKABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxM0VuY2xvc2luZ0V4cHJFAHNpemVvZi4uLigATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjJQYXJhbWV0ZXJQYWNrRXhwYW5zaW9uRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxOVNpemVvZlBhcmFtUGFja0V4cHJFAHN0YXRpY19jYXN0AD4oAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZThDYXN0RXhwckUAcmVpbnRlcnByZXRfY2FzdAApID8gKAApIDogKABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNUNvbmRpdGlvbmFsRXhwckUAbm9leGNlcHQgKABudwBuYQBwaQA6Om9wZXJhdG9yIABuZXcAW10ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlN05ld0V4cHJFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTExUG9zdGZpeEV4cHJFACAuLi4gACA9IABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNUJyYWNlZFJhbmdlRXhwckUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTBCcmFjZWRFeHByRQBfR0xPQkFMX19OAChhbm9ueW1vdXMgbmFtZXNwYWNlKQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU4TmFtZVR5cGVFAClbAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE4QXJyYXlTdWJzY3JpcHRFeHByRQAuAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwTWVtYmVyRXhwckUAc3JOAHNyADo6AE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE5R2xvYmFsUXVhbGlmaWVkTmFtZUUAZG4Ab24Ab3BlcmF0b3ImJgBvcGVyYXRvciYAb3BlcmF0b3ImPQBvcGVyYXRvcj0Ab3BlcmF0b3IoKQBvcGVyYXRvciwAb3BlcmF0b3J+AG9wZXJhdG9yIGRlbGV0ZVtdAG9wZXJhdG9yKgBvcGVyYXRvci8Ab3BlcmF0b3IvPQBvcGVyYXRvcl4Ab3BlcmF0b3JePQBvcGVyYXRvcj09AG9wZXJhdG9yPj0Ab3BlcmF0b3I+AG9wZXJhdG9yW10Ab3BlcmF0b3I8PQBvcGVyYXRvcjw8AG9wZXJhdG9yPDw9AG9wZXJhdG9yPABvcGVyYXRvci0Ab3BlcmF0b3ItPQBvcGVyYXRvcio9AG9wZXJhdG9yLS0Ab3BlcmF0b3IgbmV3W10Ab3BlcmF0b3IhPQBvcGVyYXRvciEAb3BlcmF0b3IgbmV3AG9wZXJhdG9yfHwAb3BlcmF0b3J8AG9wZXJhdG9yfD0Ab3BlcmF0b3ItPioAb3BlcmF0b3IrAG9wZXJhdG9yKz0Ab3BlcmF0b3IrKwBvcGVyYXRvci0+AG9wZXJhdG9yPwBvcGVyYXRvciUAb3BlcmF0b3IlPQBvcGVyYXRvcj4+AG9wZXJhdG9yPj49AG9wZXJhdG9yPD0+AG9wZXJhdG9yIiIgAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE1TGl0ZXJhbE9wZXJhdG9yRQBvcGVyYXRvciBkZWxldGUAb3BlcmF0b3IgAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTIyQ29udmVyc2lvbk9wZXJhdG9yVHlwZUUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOER0b3JOYW1lRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxM1F1YWxpZmllZE5hbWVFAGR5bmFtaWNfY2FzdABkZWxldGUAW10gAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwRGVsZXRlRXhwckUAY3YAKSgATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTRDb252ZXJzaW9uRXhwckUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOENhbGxFeHByRQBjb25zdF9jYXN0AE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwUHJlZml4RXhwckUAKSAAICgATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTBCaW5hcnlFeHByRQBhYQBhbgBhTgBhUwBjbQBkcwBkdgBkVgBlbwBlTwBlcQBnZQBndABsZQBscwBsUwBsdABtaQBtSQBtbABtTABuZQBvbwBvcgBvUgBwbABwTABybQByTQBycwByUwAuLi4gACAuLi4ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOEZvbGRFeHByRQBmcABmTABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxM0Z1bmN0aW9uUGFyYW1FAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTI0Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlRQBUcwBzdHJ1Y3QAVHUAdW5pb24AVGUAZW51bQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyMkVsYWJvcmF0ZWRUeXBlU3BlZlR5cGVFAFN0TABTdABzdGQ6OgBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNlN0ZFF1YWxpZmllZE5hbWVFAERDAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTIxU3RydWN0dXJlZEJpbmRpbmdOYW1lRQBVdABVbAB2RQAnbGFtYmRhACcoAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE1Q2xvc3VyZVR5cGVOYW1lRQAndW5uYW1lZAAnAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE1VW5uYW1lZFR5cGVOYW1lRQBzdHJpbmcgbGl0ZXJhbABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU5TG9jYWxOYW1lRQBzdGQATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTJDdG9yRHRvck5hbWVFAGJhc2ljX2lzdHJlYW0AYmFzaWNfb3N0cmVhbQBiYXNpY19pb3N0cmVhbQBzdGQ6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6OmFsbG9jYXRvcjxjaGFyPiA+AHN0ZDo6YmFzaWNfaXN0cmVhbTxjaGFyLCBzdGQ6OmNoYXJfdHJhaXRzPGNoYXI+ID4Ac3RkOjpiYXNpY19vc3RyZWFtPGNoYXIsIHN0ZDo6Y2hhcl90cmFpdHM8Y2hhcj4gPgBzdGQ6OmJhc2ljX2lvc3RyZWFtPGNoYXIsIHN0ZDo6Y2hhcl90cmFpdHM8Y2hhcj4gPgBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyN0V4cGFuZGVkU3BlY2lhbFN1YnN0aXR1dGlvbkUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTBOZXN0ZWROYW1lRQA6OioATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTlQb2ludGVyVG9NZW1iZXJUeXBlRQBbAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTlBcnJheVR5cGVFAER2ACB2ZWN0b3JbAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwVmVjdG9yVHlwZUUAcGl4ZWwgdmVjdG9yWwBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNVBpeGVsVmVjdG9yVHlwZUUAZGVjbHR5cGUoAGRvdWJsZQB1bnNpZ25lZCBsb25nIGxvbmcAb2JqY3Byb3RvACBjb25zdAAgdm9sYXRpbGUAIHJlc3RyaWN0AE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZThRdWFsVHlwZUUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTdWZW5kb3JFeHRRdWFsVHlwZUUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNPYmpDUHJvdG9OYW1lRQBEbwBub2V4Y2VwdABETwBEdwBEeABSRQBPRQAgJgAgJiYATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTJGdW5jdGlvblR5cGVFAHRocm93KABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyMER5bmFtaWNFeGNlcHRpb25TcGVjRQBub2V4Y2VwdCgATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTJOb2V4Y2VwdFNwZWNFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTExU3BlY2lhbE5hbWVFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTlEb3RTdWZmaXhFAFVhOWVuYWJsZV9pZkkATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTZGdW5jdGlvbkVuY29kaW5nRQAgW2VuYWJsZV9pZjoATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTJFbmFibGVJZkF0dHJFAHRocmVhZC1sb2NhbCB3cmFwcGVyIHJvdXRpbmUgZm9yIAByZWZlcmVuY2UgdGVtcG9yYXJ5IGZvciAAZ3VhcmQgdmFyaWFibGUgZm9yIABub24tdmlydHVhbCB0aHVuayB0byAAdmlydHVhbCB0aHVuayB0byAAdGhyZWFkLWxvY2FsIGluaXRpYWxpemF0aW9uIHJvdXRpbmUgZm9yIABjb25zdHJ1Y3Rpb24gdnRhYmxlIGZvciAALWluLQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyMUN0b3JWdGFibGVTcGVjaWFsTmFtZUUAY292YXJpYW50IHJldHVybiB0aHVuayB0byAAdHlwZWluZm8gbmFtZSBmb3IgAHR5cGVpbmZvIGZvciAAVlRUIGZvciAAdnRhYmxlIGZvciAAU3QxMWxvZ2ljX2Vycm9yAFN0MTJsZW5ndGhfZXJyb3IATjEwX19jeHhhYml2MTE3X19wYmFzZV90eXBlX2luZm9FAE4xMF9fY3h4YWJpdjExOV9fcG9pbnRlcl90eXBlX2luZm9FAE4xMF9fY3h4YWJpdjEyMF9fZnVuY3Rpb25fdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMjlfX3BvaW50ZXJfdG9fbWVtYmVyX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTIzX19mdW5kYW1lbnRhbF90eXBlX2luZm9FAHYARG4AYgBjAGgAYQBzAHQAaQBqAG0AZgBkAE4xMF9fY3h4YWJpdjExNl9fZW51bV90eXBlX2luZm9FAE4xMF9fY3h4YWJpdjEyMV9fdm1pX2NsYXNzX3R5cGVfaW5mb0U=";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile);}function getBinary(){try{if(wasmBinary){return new Uint8Array(wasmBinary)}var binary=tryParseAsDataURI(wasmBinaryFile);if(binary){return binary}if(readBinary){return readBinary(wasmBinaryFile)}else {throw "both async and sync fetching of the wasm failed"}}catch(err){abort(err);}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB)&&typeof fetch==="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response["ok"]){throw "failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()}).catch(function(){return getBinary()})}return new Promise(function(resolve,reject){resolve(getBinary());})}function createWasm(env){var info={"env":env,"global":{"NaN":NaN,Infinity:Infinity},"global.Math":Math,"asm2wasm":asm2wasmImports};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;removeRunDependency();}addRunDependency();function receiveInstantiatedSource(output){receiveInstance(output["instance"]);}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason);})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming==="function"&&!isDataURI(wasmBinaryFile)&&typeof fetch==="function"){fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiatedSource,function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");instantiateArrayBuffer(receiveInstantiatedSource);})});}else {return instantiateArrayBuffer(receiveInstantiatedSource)}}if(Module["instantiateWasm"]){try{var exports=Module["instantiateWasm"](info,receiveInstance);return exports}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync();return {}}Module["asm"]=function(global,env,providedBuffer){env["memory"]=wasmMemory;env["table"]=wasmTable=new WebAssembly.Table({"initial":558,"maximum":558,"element":"anyfunc"});env["__memory_base"]=1024;env["__table_base"]=0;var exports=createWasm(env);return exports};__ATINIT__.push({func:function(){globalCtors();}});function ___cxa_allocate_exception(size){return _malloc(size)}function ___cxa_pure_virtual(){ABORT=true;throw "Pure virtual function called!"}function ___cxa_throw(ptr,type,destructor){if(!("uncaught_exception"in __ZSt18uncaught_exceptionv)){__ZSt18uncaught_exceptionv.uncaught_exceptions=1;}else {__ZSt18uncaught_exceptionv.uncaught_exceptions++;}throw ptr}function ___cxa_uncaught_exceptions(){return __ZSt18uncaught_exceptionv.uncaught_exceptions}var SYSCALLS={buffers:[null,[],[]],printChar:function(stream,curr){var buffer=SYSCALLS.buffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0;}else {buffer.push(curr);}},varargs:0,get:function(varargs){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(){var ret=UTF8ToString(SYSCALLS.get());return ret},get64:function(){var low=SYSCALLS.get(),high=SYSCALLS.get();return low},getZero:function(){SYSCALLS.get();}};function ___syscall140(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),offset_high=SYSCALLS.get(),offset_low=SYSCALLS.get(),result=SYSCALLS.get(),whence=SYSCALLS.get();return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall146(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.get(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];for(var j=0;j<len;j++){SYSCALLS.printChar(stream,HEAPU8[ptr+j]);}ret+=len;}return ret}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall6(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD();return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function getShiftFromSize(size){switch(size){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError("Unknown type size: "+size)}}function embind_init_charCodes(){var codes=new Array(256);for(var i=0;i<256;++i){codes[i]=String.fromCharCode(i);}embind_charCodes=codes;}var embind_charCodes=undefined;function readLatin1String(ptr){var ret="";var c=ptr;while(HEAPU8[c]){ret+=embind_charCodes[HEAPU8[c++]];}return ret}var awaitingDependencies={};var registeredTypes={};var typeDependencies={};var char_0=48;var char_9=57;function makeLegalFunctionName(name){if(undefined===name){return "_unknown"}name=name.replace(/[^a-zA-Z0-9_]/g,"$");var f=name.charCodeAt(0);if(f>=char_0&&f<=char_9){return "_"+name}else {return name}}function createNamedFunction(name,body){name=makeLegalFunctionName(name);return new Function("body","return function "+name+"() {\n"+'    "use strict";'+"    return body.apply(this, arguments);\n"+"};\n")(body)}function extendError(baseErrorType,errorName){var errorClass=createNamedFunction(errorName,function(message){this.name=errorName;this.message=message;var stack=new Error(message).stack;if(stack!==undefined){this.stack=this.toString()+"\n"+stack.replace(/^Error(:[^\n]*)?\n/,"");}});errorClass.prototype=Object.create(baseErrorType.prototype);errorClass.prototype.constructor=errorClass;errorClass.prototype.toString=function(){if(this.message===undefined){return this.name}else {return this.name+": "+this.message}};return errorClass}var BindingError=undefined;function throwBindingError(message){throw new BindingError(message)}var InternalError=undefined;function throwInternalError(message){throw new InternalError(message)}function whenDependentTypesAreResolved(myTypes,dependentTypes,getTypeConverters){myTypes.forEach(function(type){typeDependencies[type]=dependentTypes;});function onComplete(typeConverters){var myTypeConverters=getTypeConverters(typeConverters);if(myTypeConverters.length!==myTypes.length){throwInternalError("Mismatched type converter count");}for(var i=0;i<myTypes.length;++i){registerType(myTypes[i],myTypeConverters[i]);}}var typeConverters=new Array(dependentTypes.length);var unregisteredTypes=[];var registered=0;dependentTypes.forEach(function(dt,i){if(registeredTypes.hasOwnProperty(dt)){typeConverters[i]=registeredTypes[dt];}else {unregisteredTypes.push(dt);if(!awaitingDependencies.hasOwnProperty(dt)){awaitingDependencies[dt]=[];}awaitingDependencies[dt].push(function(){typeConverters[i]=registeredTypes[dt];++registered;if(registered===unregisteredTypes.length){onComplete(typeConverters);}});}});if(0===unregisteredTypes.length){onComplete(typeConverters);}}function registerType(rawType,registeredInstance,options){options=options||{};if(!("argPackAdvance"in registeredInstance)){throw new TypeError("registerType registeredInstance requires argPackAdvance")}var name=registeredInstance.name;if(!rawType){throwBindingError('type "'+name+'" must have a positive integer typeid pointer');}if(registeredTypes.hasOwnProperty(rawType)){if(options.ignoreDuplicateRegistrations){return}else {throwBindingError("Cannot register type '"+name+"' twice");}}registeredTypes[rawType]=registeredInstance;delete typeDependencies[rawType];if(awaitingDependencies.hasOwnProperty(rawType)){var callbacks=awaitingDependencies[rawType];delete awaitingDependencies[rawType];callbacks.forEach(function(cb){cb();});}}function __embind_register_bool(rawType,name,size,trueValue,falseValue){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(wt){return !!wt},"toWireType":function(destructors,o){return o?trueValue:falseValue},"argPackAdvance":8,"readValueFromPointer":function(pointer){var heap;if(size===1){heap=HEAP8;}else if(size===2){heap=HEAP16;}else if(size===4){heap=HEAP32;}else {throw new TypeError("Unknown boolean type size: "+name)}return this["fromWireType"](heap[pointer>>shift])},destructorFunction:null});}function ClassHandle_isAliasOf(other){if(!(this instanceof ClassHandle)){return false}if(!(other instanceof ClassHandle)){return false}var leftClass=this.$$.ptrType.registeredClass;var left=this.$$.ptr;var rightClass=other.$$.ptrType.registeredClass;var right=other.$$.ptr;while(leftClass.baseClass){left=leftClass.upcast(left);leftClass=leftClass.baseClass;}while(rightClass.baseClass){right=rightClass.upcast(right);rightClass=rightClass.baseClass;}return leftClass===rightClass&&left===right}function shallowCopyInternalPointer(o){return {count:o.count,deleteScheduled:o.deleteScheduled,preservePointerOnDelete:o.preservePointerOnDelete,ptr:o.ptr,ptrType:o.ptrType,smartPtr:o.smartPtr,smartPtrType:o.smartPtrType}}function throwInstanceAlreadyDeleted(obj){function getInstanceTypeName(handle){return handle.$$.ptrType.registeredClass.name}throwBindingError(getInstanceTypeName(obj)+" instance already deleted");}var finalizationGroup=false;function detachFinalizer(handle){}function runDestructor($$){if($$.smartPtr){$$.smartPtrType.rawDestructor($$.smartPtr);}else {$$.ptrType.registeredClass.rawDestructor($$.ptr);}}function releaseClassHandle($$){$$.count.value-=1;var toDelete=0===$$.count.value;if(toDelete){runDestructor($$);}}function attachFinalizer(handle){if("undefined"===typeof FinalizationGroup){attachFinalizer=function(handle){return handle};return handle}finalizationGroup=new FinalizationGroup(function(iter){for(var result=iter.next();!result.done;result=iter.next()){var $$=result.value;if(!$$.ptr){console.warn("object already deleted: "+$$.ptr);}else {releaseClassHandle($$);}}});attachFinalizer=function(handle){finalizationGroup.register(handle,handle.$$,handle.$$);return handle};detachFinalizer=function(handle){finalizationGroup.unregister(handle.$$);};return attachFinalizer(handle)}function ClassHandle_clone(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this);}if(this.$$.preservePointerOnDelete){this.$$.count.value+=1;return this}else {var clone=attachFinalizer(Object.create(Object.getPrototypeOf(this),{$$:{value:shallowCopyInternalPointer(this.$$)}}));clone.$$.count.value+=1;clone.$$.deleteScheduled=false;return clone}}function ClassHandle_delete(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this);}if(this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete){throwBindingError("Object already scheduled for deletion");}detachFinalizer(this);releaseClassHandle(this.$$);if(!this.$$.preservePointerOnDelete){this.$$.smartPtr=undefined;this.$$.ptr=undefined;}}function ClassHandle_isDeleted(){return !this.$$.ptr}var delayFunction=undefined;var deletionQueue=[];function flushPendingDeletes(){while(deletionQueue.length){var obj=deletionQueue.pop();obj.$$.deleteScheduled=false;obj["delete"]();}}function ClassHandle_deleteLater(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this);}if(this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete){throwBindingError("Object already scheduled for deletion");}deletionQueue.push(this);if(deletionQueue.length===1&&delayFunction){delayFunction(flushPendingDeletes);}this.$$.deleteScheduled=true;return this}function init_ClassHandle(){ClassHandle.prototype["isAliasOf"]=ClassHandle_isAliasOf;ClassHandle.prototype["clone"]=ClassHandle_clone;ClassHandle.prototype["delete"]=ClassHandle_delete;ClassHandle.prototype["isDeleted"]=ClassHandle_isDeleted;ClassHandle.prototype["deleteLater"]=ClassHandle_deleteLater;}function ClassHandle(){}var registeredPointers={};function ensureOverloadTable(proto,methodName,humanName){if(undefined===proto[methodName].overloadTable){var prevFunc=proto[methodName];proto[methodName]=function(){if(!proto[methodName].overloadTable.hasOwnProperty(arguments.length)){throwBindingError("Function '"+humanName+"' called with an invalid number of arguments ("+arguments.length+") - expects one of ("+proto[methodName].overloadTable+")!");}return proto[methodName].overloadTable[arguments.length].apply(this,arguments)};proto[methodName].overloadTable=[];proto[methodName].overloadTable[prevFunc.argCount]=prevFunc;}}function exposePublicSymbol(name,value,numArguments){if(Module.hasOwnProperty(name)){if(undefined===numArguments||undefined!==Module[name].overloadTable&&undefined!==Module[name].overloadTable[numArguments]){throwBindingError("Cannot register public name '"+name+"' twice");}ensureOverloadTable(Module,name,name);if(Module.hasOwnProperty(numArguments)){throwBindingError("Cannot register multiple overloads of a function with the same number of arguments ("+numArguments+")!");}Module[name].overloadTable[numArguments]=value;}else {Module[name]=value;if(undefined!==numArguments){Module[name].numArguments=numArguments;}}}function RegisteredClass(name,constructor,instancePrototype,rawDestructor,baseClass,getActualType,upcast,downcast){this.name=name;this.constructor=constructor;this.instancePrototype=instancePrototype;this.rawDestructor=rawDestructor;this.baseClass=baseClass;this.getActualType=getActualType;this.upcast=upcast;this.downcast=downcast;this.pureVirtualFunctions=[];}function upcastPointer(ptr,ptrClass,desiredClass){while(ptrClass!==desiredClass){if(!ptrClass.upcast){throwBindingError("Expected null or instance of "+desiredClass.name+", got an instance of "+ptrClass.name);}ptr=ptrClass.upcast(ptr);ptrClass=ptrClass.baseClass;}return ptr}function constNoSmartPtrRawPointerToWireType(destructors,handle){if(handle===null){if(this.isReference){throwBindingError("null is not a valid "+this.name);}return 0}if(!handle.$$){throwBindingError('Cannot pass "'+_embind_repr(handle)+'" as a '+this.name);}if(!handle.$$.ptr){throwBindingError("Cannot pass deleted object as a pointer of type "+this.name);}var handleClass=handle.$$.ptrType.registeredClass;var ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);return ptr}function genericPointerToWireType(destructors,handle){var ptr;if(handle===null){if(this.isReference){throwBindingError("null is not a valid "+this.name);}if(this.isSmartPointer){ptr=this.rawConstructor();if(destructors!==null){destructors.push(this.rawDestructor,ptr);}return ptr}else {return 0}}if(!handle.$$){throwBindingError('Cannot pass "'+_embind_repr(handle)+'" as a '+this.name);}if(!handle.$$.ptr){throwBindingError("Cannot pass deleted object as a pointer of type "+this.name);}if(!this.isConst&&handle.$$.ptrType.isConst){throwBindingError("Cannot convert argument of type "+(handle.$$.smartPtrType?handle.$$.smartPtrType.name:handle.$$.ptrType.name)+" to parameter type "+this.name);}var handleClass=handle.$$.ptrType.registeredClass;ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);if(this.isSmartPointer){if(undefined===handle.$$.smartPtr){throwBindingError("Passing raw pointer to smart pointer is illegal");}switch(this.sharingPolicy){case 0:if(handle.$$.smartPtrType===this){ptr=handle.$$.smartPtr;}else {throwBindingError("Cannot convert argument of type "+(handle.$$.smartPtrType?handle.$$.smartPtrType.name:handle.$$.ptrType.name)+" to parameter type "+this.name);}break;case 1:ptr=handle.$$.smartPtr;break;case 2:if(handle.$$.smartPtrType===this){ptr=handle.$$.smartPtr;}else {var clonedHandle=handle["clone"]();ptr=this.rawShare(ptr,__emval_register(function(){clonedHandle["delete"]();}));if(destructors!==null){destructors.push(this.rawDestructor,ptr);}}break;default:throwBindingError("Unsupporting sharing policy");}}return ptr}function nonConstNoSmartPtrRawPointerToWireType(destructors,handle){if(handle===null){if(this.isReference){throwBindingError("null is not a valid "+this.name);}return 0}if(!handle.$$){throwBindingError('Cannot pass "'+_embind_repr(handle)+'" as a '+this.name);}if(!handle.$$.ptr){throwBindingError("Cannot pass deleted object as a pointer of type "+this.name);}if(handle.$$.ptrType.isConst){throwBindingError("Cannot convert argument of type "+handle.$$.ptrType.name+" to parameter type "+this.name);}var handleClass=handle.$$.ptrType.registeredClass;var ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);return ptr}function simpleReadValueFromPointer(pointer){return this["fromWireType"](HEAPU32[pointer>>2])}function RegisteredPointer_getPointee(ptr){if(this.rawGetPointee){ptr=this.rawGetPointee(ptr);}return ptr}function RegisteredPointer_destructor(ptr){if(this.rawDestructor){this.rawDestructor(ptr);}}function RegisteredPointer_deleteObject(handle){if(handle!==null){handle["delete"]();}}function downcastPointer(ptr,ptrClass,desiredClass){if(ptrClass===desiredClass){return ptr}if(undefined===desiredClass.baseClass){return null}var rv=downcastPointer(ptr,ptrClass,desiredClass.baseClass);if(rv===null){return null}return desiredClass.downcast(rv)}function getInheritedInstanceCount(){return Object.keys(registeredInstances).length}function getLiveInheritedInstances(){var rv=[];for(var k in registeredInstances){if(registeredInstances.hasOwnProperty(k)){rv.push(registeredInstances[k]);}}return rv}function setDelayFunction(fn){delayFunction=fn;if(deletionQueue.length&&delayFunction){delayFunction(flushPendingDeletes);}}function init_embind(){Module["getInheritedInstanceCount"]=getInheritedInstanceCount;Module["getLiveInheritedInstances"]=getLiveInheritedInstances;Module["flushPendingDeletes"]=flushPendingDeletes;Module["setDelayFunction"]=setDelayFunction;}var registeredInstances={};function getBasestPointer(class_,ptr){if(ptr===undefined){throwBindingError("ptr should not be undefined");}while(class_.baseClass){ptr=class_.upcast(ptr);class_=class_.baseClass;}return ptr}function getInheritedInstance(class_,ptr){ptr=getBasestPointer(class_,ptr);return registeredInstances[ptr]}function makeClassHandle(prototype,record){if(!record.ptrType||!record.ptr){throwInternalError("makeClassHandle requires ptr and ptrType");}var hasSmartPtrType=!!record.smartPtrType;var hasSmartPtr=!!record.smartPtr;if(hasSmartPtrType!==hasSmartPtr){throwInternalError("Both smartPtrType and smartPtr must be specified");}record.count={value:1};return attachFinalizer(Object.create(prototype,{$$:{value:record}}))}function RegisteredPointer_fromWireType(ptr){var rawPointer=this.getPointee(ptr);if(!rawPointer){this.destructor(ptr);return null}var registeredInstance=getInheritedInstance(this.registeredClass,rawPointer);if(undefined!==registeredInstance){if(0===registeredInstance.$$.count.value){registeredInstance.$$.ptr=rawPointer;registeredInstance.$$.smartPtr=ptr;return registeredInstance["clone"]()}else {var rv=registeredInstance["clone"]();this.destructor(ptr);return rv}}function makeDefaultHandle(){if(this.isSmartPointer){return makeClassHandle(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:rawPointer,smartPtrType:this,smartPtr:ptr})}else {return makeClassHandle(this.registeredClass.instancePrototype,{ptrType:this,ptr:ptr})}}var actualType=this.registeredClass.getActualType(rawPointer);var registeredPointerRecord=registeredPointers[actualType];if(!registeredPointerRecord){return makeDefaultHandle.call(this)}var toType;if(this.isConst){toType=registeredPointerRecord.constPointerType;}else {toType=registeredPointerRecord.pointerType;}var dp=downcastPointer(rawPointer,this.registeredClass,toType.registeredClass);if(dp===null){return makeDefaultHandle.call(this)}if(this.isSmartPointer){return makeClassHandle(toType.registeredClass.instancePrototype,{ptrType:toType,ptr:dp,smartPtrType:this,smartPtr:ptr})}else {return makeClassHandle(toType.registeredClass.instancePrototype,{ptrType:toType,ptr:dp})}}function init_RegisteredPointer(){RegisteredPointer.prototype.getPointee=RegisteredPointer_getPointee;RegisteredPointer.prototype.destructor=RegisteredPointer_destructor;RegisteredPointer.prototype["argPackAdvance"]=8;RegisteredPointer.prototype["readValueFromPointer"]=simpleReadValueFromPointer;RegisteredPointer.prototype["deleteObject"]=RegisteredPointer_deleteObject;RegisteredPointer.prototype["fromWireType"]=RegisteredPointer_fromWireType;}function RegisteredPointer(name,registeredClass,isReference,isConst,isSmartPointer,pointeeType,sharingPolicy,rawGetPointee,rawConstructor,rawShare,rawDestructor){this.name=name;this.registeredClass=registeredClass;this.isReference=isReference;this.isConst=isConst;this.isSmartPointer=isSmartPointer;this.pointeeType=pointeeType;this.sharingPolicy=sharingPolicy;this.rawGetPointee=rawGetPointee;this.rawConstructor=rawConstructor;this.rawShare=rawShare;this.rawDestructor=rawDestructor;if(!isSmartPointer&&registeredClass.baseClass===undefined){if(isConst){this["toWireType"]=constNoSmartPtrRawPointerToWireType;this.destructorFunction=null;}else {this["toWireType"]=nonConstNoSmartPtrRawPointerToWireType;this.destructorFunction=null;}}else {this["toWireType"]=genericPointerToWireType;}}function replacePublicSymbol(name,value,numArguments){if(!Module.hasOwnProperty(name)){throwInternalError("Replacing nonexistant public symbol");}if(undefined!==Module[name].overloadTable&&undefined!==numArguments){Module[name].overloadTable[numArguments]=value;}else {Module[name]=value;Module[name].argCount=numArguments;}}function embind__requireFunction(signature,rawFunction){signature=readLatin1String(signature);function makeDynCaller(dynCall){var args=[];for(var i=1;i<signature.length;++i){args.push("a"+i);}var name="dynCall_"+signature+"_"+rawFunction;var body="return function "+name+"("+args.join(", ")+") {\n";body+="    return dynCall(rawFunction"+(args.length?", ":"")+args.join(", ")+");\n";body+="};\n";return new Function("dynCall","rawFunction",body)(dynCall,rawFunction)}var fp;if(Module["FUNCTION_TABLE_"+signature]!==undefined){fp=Module["FUNCTION_TABLE_"+signature][rawFunction];}else if(typeof FUNCTION_TABLE!=="undefined"){fp=FUNCTION_TABLE[rawFunction];}else {var dc=Module["dynCall_"+signature];if(dc===undefined){dc=Module["dynCall_"+signature.replace(/f/g,"d")];if(dc===undefined){throwBindingError("No dynCall invoker for signature: "+signature);}}fp=makeDynCaller(dc);}if(typeof fp!=="function"){throwBindingError("unknown function pointer with signature "+signature+": "+rawFunction);}return fp}var UnboundTypeError=undefined;function getTypeName(type){var ptr=___getTypeName(type);var rv=readLatin1String(ptr);_free(ptr);return rv}function throwUnboundTypeError(message,types){var unboundTypes=[];var seen={};function visit(type){if(seen[type]){return}if(registeredTypes[type]){return}if(typeDependencies[type]){typeDependencies[type].forEach(visit);return}unboundTypes.push(type);seen[type]=true;}types.forEach(visit);throw new UnboundTypeError(message+": "+unboundTypes.map(getTypeName).join([", "]))}function __embind_register_class(rawType,rawPointerType,rawConstPointerType,baseClassRawType,getActualTypeSignature,getActualType,upcastSignature,upcast,downcastSignature,downcast,name,destructorSignature,rawDestructor){name=readLatin1String(name);getActualType=embind__requireFunction(getActualTypeSignature,getActualType);if(upcast){upcast=embind__requireFunction(upcastSignature,upcast);}if(downcast){downcast=embind__requireFunction(downcastSignature,downcast);}rawDestructor=embind__requireFunction(destructorSignature,rawDestructor);var legalFunctionName=makeLegalFunctionName(name);exposePublicSymbol(legalFunctionName,function(){throwUnboundTypeError("Cannot construct "+name+" due to unbound types",[baseClassRawType]);});whenDependentTypesAreResolved([rawType,rawPointerType,rawConstPointerType],baseClassRawType?[baseClassRawType]:[],function(base){base=base[0];var baseClass;var basePrototype;if(baseClassRawType){baseClass=base.registeredClass;basePrototype=baseClass.instancePrototype;}else {basePrototype=ClassHandle.prototype;}var constructor=createNamedFunction(legalFunctionName,function(){if(Object.getPrototypeOf(this)!==instancePrototype){throw new BindingError("Use 'new' to construct "+name)}if(undefined===registeredClass.constructor_body){throw new BindingError(name+" has no accessible constructor")}var body=registeredClass.constructor_body[arguments.length];if(undefined===body){throw new BindingError("Tried to invoke ctor of "+name+" with invalid number of parameters ("+arguments.length+") - expected ("+Object.keys(registeredClass.constructor_body).toString()+") parameters instead!")}return body.apply(this,arguments)});var instancePrototype=Object.create(basePrototype,{constructor:{value:constructor}});constructor.prototype=instancePrototype;var registeredClass=new RegisteredClass(name,constructor,instancePrototype,rawDestructor,baseClass,getActualType,upcast,downcast);var referenceConverter=new RegisteredPointer(name,registeredClass,true,false,false);var pointerConverter=new RegisteredPointer(name+"*",registeredClass,false,false,false);var constPointerConverter=new RegisteredPointer(name+" const*",registeredClass,false,true,false);registeredPointers[rawType]={pointerType:pointerConverter,constPointerType:constPointerConverter};replacePublicSymbol(legalFunctionName,constructor);return [referenceConverter,pointerConverter,constPointerConverter]});}function heap32VectorToArray(count,firstElement){var array=[];for(var i=0;i<count;i++){array.push(HEAP32[(firstElement>>2)+i]);}return array}function runDestructors(destructors){while(destructors.length){var ptr=destructors.pop();var del=destructors.pop();del(ptr);}}function __embind_register_class_constructor(rawClassType,argCount,rawArgTypesAddr,invokerSignature,invoker,rawConstructor){var rawArgTypes=heap32VectorToArray(argCount,rawArgTypesAddr);invoker=embind__requireFunction(invokerSignature,invoker);whenDependentTypesAreResolved([],[rawClassType],function(classType){classType=classType[0];var humanName="constructor "+classType.name;if(undefined===classType.registeredClass.constructor_body){classType.registeredClass.constructor_body=[];}if(undefined!==classType.registeredClass.constructor_body[argCount-1]){throw new BindingError("Cannot register multiple constructors with identical number of parameters ("+(argCount-1)+") for class '"+classType.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!")}classType.registeredClass.constructor_body[argCount-1]=function unboundTypeHandler(){throwUnboundTypeError("Cannot construct "+classType.name+" due to unbound types",rawArgTypes);};whenDependentTypesAreResolved([],rawArgTypes,function(argTypes){classType.registeredClass.constructor_body[argCount-1]=function constructor_body(){if(arguments.length!==argCount-1){throwBindingError(humanName+" called with "+arguments.length+" arguments, expected "+(argCount-1));}var destructors=[];var args=new Array(argCount);args[0]=rawConstructor;for(var i=1;i<argCount;++i){args[i]=argTypes[i]["toWireType"](destructors,arguments[i-1]);}var ptr=invoker.apply(null,args);runDestructors(destructors);return argTypes[0]["fromWireType"](ptr)};return []});return []});}function new_(constructor,argumentList){if(!(constructor instanceof Function)){throw new TypeError("new_ called with constructor type "+typeof constructor+" which is not a function")}var dummy=createNamedFunction(constructor.name||"unknownFunctionName",function(){});dummy.prototype=constructor.prototype;var obj=new dummy;var r=constructor.apply(obj,argumentList);return r instanceof Object?r:obj}function craftInvokerFunction(humanName,argTypes,classType,cppInvokerFunc,cppTargetFunc){var argCount=argTypes.length;if(argCount<2){throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");}var isClassMethodFunc=argTypes[1]!==null&&classType!==null;var needsDestructorStack=false;for(var i=1;i<argTypes.length;++i){if(argTypes[i]!==null&&argTypes[i].destructorFunction===undefined){needsDestructorStack=true;break}}var returns=argTypes[0].name!=="void";var argsList="";var argsListWired="";for(var i=0;i<argCount-2;++i){argsList+=(i!==0?", ":"")+"arg"+i;argsListWired+=(i!==0?", ":"")+"arg"+i+"Wired";}var invokerFnBody="return function "+makeLegalFunctionName(humanName)+"("+argsList+") {\n"+"if (arguments.length !== "+(argCount-2)+") {\n"+"throwBindingError('function "+humanName+" called with ' + arguments.length + ' arguments, expected "+(argCount-2)+" args!');\n"+"}\n";if(needsDestructorStack){invokerFnBody+="var destructors = [];\n";}var dtorStack=needsDestructorStack?"destructors":"null";var args1=["throwBindingError","invoker","fn","runDestructors","retType","classParam"];var args2=[throwBindingError,cppInvokerFunc,cppTargetFunc,runDestructors,argTypes[0],argTypes[1]];if(isClassMethodFunc){invokerFnBody+="var thisWired = classParam.toWireType("+dtorStack+", this);\n";}for(var i=0;i<argCount-2;++i){invokerFnBody+="var arg"+i+"Wired = argType"+i+".toWireType("+dtorStack+", arg"+i+"); // "+argTypes[i+2].name+"\n";args1.push("argType"+i);args2.push(argTypes[i+2]);}if(isClassMethodFunc){argsListWired="thisWired"+(argsListWired.length>0?", ":"")+argsListWired;}invokerFnBody+=(returns?"var rv = ":"")+"invoker(fn"+(argsListWired.length>0?", ":"")+argsListWired+");\n";if(needsDestructorStack){invokerFnBody+="runDestructors(destructors);\n";}else {for(var i=isClassMethodFunc?1:2;i<argTypes.length;++i){var paramName=i===1?"thisWired":"arg"+(i-2)+"Wired";if(argTypes[i].destructorFunction!==null){invokerFnBody+=paramName+"_dtor("+paramName+"); // "+argTypes[i].name+"\n";args1.push(paramName+"_dtor");args2.push(argTypes[i].destructorFunction);}}}if(returns){invokerFnBody+="var ret = retType.fromWireType(rv);\n"+"return ret;\n";}invokerFnBody+="}\n";args1.push(invokerFnBody);var invokerFunction=new_(Function,args1).apply(null,args2);return invokerFunction}function __embind_register_class_function(rawClassType,methodName,argCount,rawArgTypesAddr,invokerSignature,rawInvoker,context,isPureVirtual){var rawArgTypes=heap32VectorToArray(argCount,rawArgTypesAddr);methodName=readLatin1String(methodName);rawInvoker=embind__requireFunction(invokerSignature,rawInvoker);whenDependentTypesAreResolved([],[rawClassType],function(classType){classType=classType[0];var humanName=classType.name+"."+methodName;if(isPureVirtual){classType.registeredClass.pureVirtualFunctions.push(methodName);}function unboundTypesHandler(){throwUnboundTypeError("Cannot call "+humanName+" due to unbound types",rawArgTypes);}var proto=classType.registeredClass.instancePrototype;var method=proto[methodName];if(undefined===method||undefined===method.overloadTable&&method.className!==classType.name&&method.argCount===argCount-2){unboundTypesHandler.argCount=argCount-2;unboundTypesHandler.className=classType.name;proto[methodName]=unboundTypesHandler;}else {ensureOverloadTable(proto,methodName,humanName);proto[methodName].overloadTable[argCount-2]=unboundTypesHandler;}whenDependentTypesAreResolved([],rawArgTypes,function(argTypes){var memberFunction=craftInvokerFunction(humanName,argTypes,classType,rawInvoker,context);if(undefined===proto[methodName].overloadTable){memberFunction.argCount=argCount-2;proto[methodName]=memberFunction;}else {proto[methodName].overloadTable[argCount-2]=memberFunction;}return []});return []});}function validateThis(this_,classType,humanName){if(!(this_ instanceof Object)){throwBindingError(humanName+' with invalid "this": '+this_);}if(!(this_ instanceof classType.registeredClass.constructor)){throwBindingError(humanName+' incompatible with "this" of type '+this_.constructor.name);}if(!this_.$$.ptr){throwBindingError("cannot call emscripten binding method "+humanName+" on deleted object");}return upcastPointer(this_.$$.ptr,this_.$$.ptrType.registeredClass,classType.registeredClass)}function __embind_register_class_property(classType,fieldName,getterReturnType,getterSignature,getter,getterContext,setterArgumentType,setterSignature,setter,setterContext){fieldName=readLatin1String(fieldName);getter=embind__requireFunction(getterSignature,getter);whenDependentTypesAreResolved([],[classType],function(classType){classType=classType[0];var humanName=classType.name+"."+fieldName;var desc={get:function(){throwUnboundTypeError("Cannot access "+humanName+" due to unbound types",[getterReturnType,setterArgumentType]);},enumerable:true,configurable:true};if(setter){desc.set=function(){throwUnboundTypeError("Cannot access "+humanName+" due to unbound types",[getterReturnType,setterArgumentType]);};}else {desc.set=function(v){throwBindingError(humanName+" is a read-only property");};}Object.defineProperty(classType.registeredClass.instancePrototype,fieldName,desc);whenDependentTypesAreResolved([],setter?[getterReturnType,setterArgumentType]:[getterReturnType],function(types){var getterReturnType=types[0];var desc={get:function(){var ptr=validateThis(this,classType,humanName+" getter");return getterReturnType["fromWireType"](getter(getterContext,ptr))},enumerable:true};if(setter){setter=embind__requireFunction(setterSignature,setter);var setterArgumentType=types[1];desc.set=function(v){var ptr=validateThis(this,classType,humanName+" setter");var destructors=[];setter(setterContext,ptr,setterArgumentType["toWireType"](destructors,v));runDestructors(destructors);};}Object.defineProperty(classType.registeredClass.instancePrototype,fieldName,desc);return []});return []});}var emval_free_list=[];var emval_handle_array=[{},{value:undefined},{value:null},{value:true},{value:false}];function __emval_decref(handle){if(handle>4&&0===--emval_handle_array[handle].refcount){emval_handle_array[handle]=undefined;emval_free_list.push(handle);}}function count_emval_handles(){var count=0;for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){++count;}}return count}function get_first_emval(){for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){return emval_handle_array[i]}}return null}function init_emval(){Module["count_emval_handles"]=count_emval_handles;Module["get_first_emval"]=get_first_emval;}function __emval_register(value){switch(value){case undefined:{return 1}case null:{return 2}case true:{return 3}case false:{return 4}default:{var handle=emval_free_list.length?emval_free_list.pop():emval_handle_array.length;emval_handle_array[handle]={refcount:1,value:value};return handle}}}function __embind_register_emval(rawType,name){name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(handle){var rv=emval_handle_array[handle].value;__emval_decref(handle);return rv},"toWireType":function(destructors,value){return __emval_register(value)},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:null});}function enumReadValueFromPointer(name,shift,signed){switch(shift){case 0:return function(pointer){var heap=signed?HEAP8:HEAPU8;return this["fromWireType"](heap[pointer])};case 1:return function(pointer){var heap=signed?HEAP16:HEAPU16;return this["fromWireType"](heap[pointer>>1])};case 2:return function(pointer){var heap=signed?HEAP32:HEAPU32;return this["fromWireType"](heap[pointer>>2])};default:throw new TypeError("Unknown integer type: "+name)}}function __embind_register_enum(rawType,name,size,isSigned){var shift=getShiftFromSize(size);name=readLatin1String(name);function ctor(){}ctor.values={};registerType(rawType,{name:name,constructor:ctor,"fromWireType":function(c){return this.constructor.values[c]},"toWireType":function(destructors,c){return c.value},"argPackAdvance":8,"readValueFromPointer":enumReadValueFromPointer(name,shift,isSigned),destructorFunction:null});exposePublicSymbol(name,ctor);}function requireRegisteredType(rawType,humanName){var impl=registeredTypes[rawType];if(undefined===impl){throwBindingError(humanName+" has unknown type "+getTypeName(rawType));}return impl}function __embind_register_enum_value(rawEnumType,name,enumValue){var enumType=requireRegisteredType(rawEnumType,"enum");name=readLatin1String(name);var Enum=enumType.constructor;var Value=Object.create(enumType.constructor.prototype,{value:{value:enumValue},constructor:{value:createNamedFunction(enumType.name+"_"+name,function(){})}});Enum.values[enumValue]=Value;Enum[name]=Value;}function _embind_repr(v){if(v===null){return "null"}var t=typeof v;if(t==="object"||t==="array"||t==="function"){return v.toString()}else {return ""+v}}function floatReadValueFromPointer(name,shift){switch(shift){case 2:return function(pointer){return this["fromWireType"](HEAPF32[pointer>>2])};case 3:return function(pointer){return this["fromWireType"](HEAPF64[pointer>>3])};default:throw new TypeError("Unknown float type: "+name)}}function __embind_register_float(rawType,name,size){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(value){return value},"toWireType":function(destructors,value){if(typeof value!=="number"&&typeof value!=="boolean"){throw new TypeError('Cannot convert "'+_embind_repr(value)+'" to '+this.name)}return value},"argPackAdvance":8,"readValueFromPointer":floatReadValueFromPointer(name,shift),destructorFunction:null});}function __embind_register_function(name,argCount,rawArgTypesAddr,signature,rawInvoker,fn){var argTypes=heap32VectorToArray(argCount,rawArgTypesAddr);name=readLatin1String(name);rawInvoker=embind__requireFunction(signature,rawInvoker);exposePublicSymbol(name,function(){throwUnboundTypeError("Cannot call "+name+" due to unbound types",argTypes);},argCount-1);whenDependentTypesAreResolved([],argTypes,function(argTypes){var invokerArgsArray=[argTypes[0],null].concat(argTypes.slice(1));replacePublicSymbol(name,craftInvokerFunction(name,invokerArgsArray,null,rawInvoker,fn),argCount-1);return []});}function integerReadValueFromPointer(name,shift,signed){switch(shift){case 0:return signed?function readS8FromPointer(pointer){return HEAP8[pointer]}:function readU8FromPointer(pointer){return HEAPU8[pointer]};case 1:return signed?function readS16FromPointer(pointer){return HEAP16[pointer>>1]}:function readU16FromPointer(pointer){return HEAPU16[pointer>>1]};case 2:return signed?function readS32FromPointer(pointer){return HEAP32[pointer>>2]}:function readU32FromPointer(pointer){return HEAPU32[pointer>>2]};default:throw new TypeError("Unknown integer type: "+name)}}function __embind_register_integer(primitiveType,name,size,minRange,maxRange){name=readLatin1String(name);if(maxRange===-1){maxRange=4294967295;}var shift=getShiftFromSize(size);var fromWireType=function(value){return value};if(minRange===0){var bitshift=32-8*size;fromWireType=function(value){return value<<bitshift>>>bitshift};}var isUnsignedType=name.indexOf("unsigned")!=-1;registerType(primitiveType,{name:name,"fromWireType":fromWireType,"toWireType":function(destructors,value){if(typeof value!=="number"&&typeof value!=="boolean"){throw new TypeError('Cannot convert "'+_embind_repr(value)+'" to '+this.name)}if(value<minRange||value>maxRange){throw new TypeError('Passing a number "'+_embind_repr(value)+'" from JS side to C/C++ side to an argument of type "'+name+'", which is outside the valid range ['+minRange+", "+maxRange+"]!")}return isUnsignedType?value>>>0:value|0},"argPackAdvance":8,"readValueFromPointer":integerReadValueFromPointer(name,shift,minRange!==0),destructorFunction:null});}function __embind_register_memory_view(rawType,dataTypeIndex,name){var typeMapping=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];var TA=typeMapping[dataTypeIndex];function decodeMemoryView(handle){handle=handle>>2;var heap=HEAPU32;var size=heap[handle];var data=heap[handle+1];return new TA(heap["buffer"],data,size)}name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":decodeMemoryView,"argPackAdvance":8,"readValueFromPointer":decodeMemoryView},{ignoreDuplicateRegistrations:true});}function __embind_register_std_string(rawType,name){name=readLatin1String(name);var stdStringIsUTF8=name==="std::string";registerType(rawType,{name:name,"fromWireType":function(value){var length=HEAPU32[value>>2];var str;if(stdStringIsUTF8){var endChar=HEAPU8[value+4+length];var endCharSwap=0;if(endChar!=0){endCharSwap=endChar;HEAPU8[value+4+length]=0;}var decodeStartPtr=value+4;for(var i=0;i<=length;++i){var currentBytePtr=value+4+i;if(HEAPU8[currentBytePtr]==0){var stringSegment=UTF8ToString(decodeStartPtr);if(str===undefined)str=stringSegment;else {str+=String.fromCharCode(0);str+=stringSegment;}decodeStartPtr=currentBytePtr+1;}}if(endCharSwap!=0)HEAPU8[value+4+length]=endCharSwap;}else {var a=new Array(length);for(var i=0;i<length;++i){a[i]=String.fromCharCode(HEAPU8[value+4+i]);}str=a.join("");}_free(value);return str},"toWireType":function(destructors,value){if(value instanceof ArrayBuffer){value=new Uint8Array(value);}var getLength;var valueIsOfTypeString=typeof value==="string";if(!(valueIsOfTypeString||value instanceof Uint8Array||value instanceof Uint8ClampedArray||value instanceof Int8Array)){throwBindingError("Cannot pass non-string to std::string");}if(stdStringIsUTF8&&valueIsOfTypeString){getLength=function(){return lengthBytesUTF8(value)};}else {getLength=function(){return value.length};}var length=getLength();var ptr=_malloc(4+length+1);HEAPU32[ptr>>2]=length;if(stdStringIsUTF8&&valueIsOfTypeString){stringToUTF8(value,ptr+4,length+1);}else {if(valueIsOfTypeString){for(var i=0;i<length;++i){var charCode=value.charCodeAt(i);if(charCode>255){_free(ptr);throwBindingError("String has UTF-16 code units that do not fit in 8 bits");}HEAPU8[ptr+4+i]=charCode;}}else {for(var i=0;i<length;++i){HEAPU8[ptr+4+i]=value[i];}}}if(destructors!==null){destructors.push(_free,ptr);}return ptr},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr);}});}function __embind_register_std_wstring(rawType,charSize,name){name=readLatin1String(name);var getHeap,shift;if(charSize===2){getHeap=function(){return HEAPU16};shift=1;}else if(charSize===4){getHeap=function(){return HEAPU32};shift=2;}registerType(rawType,{name:name,"fromWireType":function(value){var HEAP=getHeap();var length=HEAPU32[value>>2];var a=new Array(length);var start=value+4>>shift;for(var i=0;i<length;++i){a[i]=String.fromCharCode(HEAP[start+i]);}_free(value);return a.join("")},"toWireType":function(destructors,value){var HEAP=getHeap();var length=value.length;var ptr=_malloc(4+length*charSize);HEAPU32[ptr>>2]=length;var start=ptr+4>>shift;for(var i=0;i<length;++i){HEAP[start+i]=value.charCodeAt(i);}if(destructors!==null){destructors.push(_free,ptr);}return ptr},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr);}});}function __embind_register_void(rawType,name){name=readLatin1String(name);registerType(rawType,{isVoid:true,name:name,"argPackAdvance":0,"fromWireType":function(){return undefined},"toWireType":function(destructors,o){return undefined}});}function __emval_incref(handle){if(handle>4){emval_handle_array[handle].refcount+=1;}}function __emval_take_value(type,argv){type=requireRegisteredType(type,"_emval_take_value");var v=type["readValueFromPointer"](argv);return __emval_register(v)}function _abort(){Module["abort"]();}function _emscripten_get_heap_size(){return HEAP8.length}function _llvm_trap(){abort("trap!");}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);}function ___setErrNo(value){if(Module["___errno_location"])HEAP32[Module["___errno_location"]()>>2]=value;return value}function abortOnCannotGrowMemory(requestedSize){abort("OOM");}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=_emscripten_get_heap_size();var PAGE_MULTIPLE=65536;var LIMIT=2147483648-PAGE_MULTIPLE;if(requestedSize>LIMIT){return false}var MIN_TOTAL_MEMORY=16777216;var newSize=Math.max(oldSize,MIN_TOTAL_MEMORY);while(newSize<requestedSize){if(newSize<=536870912){newSize=alignUp(2*newSize,PAGE_MULTIPLE);}else {newSize=Math.min(alignUp((3*newSize+2147483648)/4,PAGE_MULTIPLE),LIMIT);}}var replacement=emscripten_realloc_buffer(newSize);if(!replacement){return false}return true}embind_init_charCodes();BindingError=Module["BindingError"]=extendError(Error,"BindingError");InternalError=Module["InternalError"]=extendError(Error,"InternalError");init_ClassHandle();init_RegisteredPointer();init_embind();UnboundTypeError=Module["UnboundTypeError"]=extendError(Error,"UnboundTypeError");init_emval();var decodeBase64=typeof atob==="function"?atob:function(input){var keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var output="";var chr1,chr2,chr3;var enc1,enc2,enc3,enc4;var i=0;input=input.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{enc1=keyStr.indexOf(input.charAt(i++));enc2=keyStr.indexOf(input.charAt(i++));enc3=keyStr.indexOf(input.charAt(i++));enc4=keyStr.indexOf(input.charAt(i++));chr1=enc1<<2|enc2>>4;chr2=(enc2&15)<<4|enc3>>2;chr3=(enc3&3)<<6|enc4;output=output+String.fromCharCode(chr1);if(enc3!==64){output=output+String.fromCharCode(chr2);}if(enc4!==64){output=output+String.fromCharCode(chr3);}}while(i<input.length);return output};function intArrayFromBase64(s){try{var decoded=decodeBase64(s);var bytes=new Uint8Array(decoded.length);for(var i=0;i<decoded.length;++i){bytes[i]=decoded.charCodeAt(i);}return bytes}catch(_){throw new Error("Converting base64 string to bytes failed.")}}function tryParseAsDataURI(filename){if(!isDataURI(filename)){return}return intArrayFromBase64(filename.slice(dataURIPrefix.length))}var asmGlobalArg={};var asmLibraryArg={"e":abort,"z":setTempRet0,"h":___cxa_allocate_exception,"H":___cxa_pure_virtual,"f":___cxa_throw,"y":___cxa_uncaught_exceptions,"q":___setErrNo,"x":___syscall140,"p":___syscall146,"w":___syscall6,"v":__embind_register_bool,"k":__embind_register_class,"m":__embind_register_class_constructor,"b":__embind_register_class_function,"i":__embind_register_class_property,"I":__embind_register_emval,"n":__embind_register_enum,"g":__embind_register_enum_value,"u":__embind_register_float,"d":__embind_register_function,"l":__embind_register_integer,"j":__embind_register_memory_view,"t":__embind_register_std_string,"G":__embind_register_std_wstring,"F":__embind_register_void,"s":__emval_decref,"r":__emval_incref,"o":__emval_take_value,"c":_abort,"E":_emscripten_get_heap_size,"D":_emscripten_memcpy_big,"C":_emscripten_resize_heap,"B":_llvm_trap,"A":abortOnCannotGrowMemory,"a":DYNAMICTOP_PTR};var asm=Module["asm"](asmGlobalArg,asmLibraryArg,buffer);Module["asm"]=asm;var __ZSt18uncaught_exceptionv=Module["__ZSt18uncaught_exceptionv"]=function(){return Module["asm"]["J"].apply(null,arguments)};var ___embind_register_native_and_builtin_types=Module["___embind_register_native_and_builtin_types"]=function(){return Module["asm"]["K"].apply(null,arguments)};var ___getTypeName=Module["___getTypeName"]=function(){return Module["asm"]["L"].apply(null,arguments)};var _free=Module["_free"]=function(){return Module["asm"]["M"].apply(null,arguments)};var _malloc=Module["_malloc"]=function(){return Module["asm"]["N"].apply(null,arguments)};var globalCtors=Module["globalCtors"]=function(){return Module["asm"]["ja"].apply(null,arguments)};var dynCall_di=Module["dynCall_di"]=function(){return Module["asm"]["O"].apply(null,arguments)};var dynCall_dii=Module["dynCall_dii"]=function(){return Module["asm"]["P"].apply(null,arguments)};var dynCall_i=Module["dynCall_i"]=function(){return Module["asm"]["Q"].apply(null,arguments)};var dynCall_ii=Module["dynCall_ii"]=function(){return Module["asm"]["R"].apply(null,arguments)};var dynCall_iidd=Module["dynCall_iidd"]=function(){return Module["asm"]["S"].apply(null,arguments)};var dynCall_iidiiii=Module["dynCall_iidiiii"]=function(){return Module["asm"]["T"].apply(null,arguments)};var dynCall_iii=Module["dynCall_iii"]=function(){return Module["asm"]["U"].apply(null,arguments)};var dynCall_iiii=Module["dynCall_iiii"]=function(){return Module["asm"]["V"].apply(null,arguments)};var dynCall_iiiii=Module["dynCall_iiiii"]=function(){return Module["asm"]["W"].apply(null,arguments)};var dynCall_iiiiii=Module["dynCall_iiiiii"]=function(){return Module["asm"]["X"].apply(null,arguments)};var dynCall_iiiiiii=Module["dynCall_iiiiiii"]=function(){return Module["asm"]["Y"].apply(null,arguments)};var dynCall_jiji=Module["dynCall_jiji"]=function(){return Module["asm"]["Z"].apply(null,arguments)};var dynCall_v=Module["dynCall_v"]=function(){return Module["asm"]["_"].apply(null,arguments)};var dynCall_vi=Module["dynCall_vi"]=function(){return Module["asm"]["$"].apply(null,arguments)};var dynCall_vid=Module["dynCall_vid"]=function(){return Module["asm"]["aa"].apply(null,arguments)};var dynCall_vidd=Module["dynCall_vidd"]=function(){return Module["asm"]["ba"].apply(null,arguments)};var dynCall_vii=Module["dynCall_vii"]=function(){return Module["asm"]["ca"].apply(null,arguments)};var dynCall_viid=Module["dynCall_viid"]=function(){return Module["asm"]["da"].apply(null,arguments)};var dynCall_viii=Module["dynCall_viii"]=function(){return Module["asm"]["ea"].apply(null,arguments)};var dynCall_viiid=Module["dynCall_viiid"]=function(){return Module["asm"]["fa"].apply(null,arguments)};var dynCall_viiii=Module["dynCall_viiii"]=function(){return Module["asm"]["ga"].apply(null,arguments)};var dynCall_viiiii=Module["dynCall_viiiii"]=function(){return Module["asm"]["ha"].apply(null,arguments)};var dynCall_viiiiii=Module["dynCall_viiiiii"]=function(){return Module["asm"]["ia"].apply(null,arguments)};Module["asm"]=asm;var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller;};function run(args){if(runDependencies>0){return}preRun();if(runDependencies>0)return;function doRun(){if(calledRun)return;calledRun=true;if(ABORT)return;initRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun();}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("");},1);doRun();},1);}else {doRun();}}Module["run"]=run;function abort(what){if(Module["onAbort"]){Module["onAbort"](what);}what+="";out(what);err(what);ABORT=true;throw "abort("+what+"). Build with -s ASSERTIONS=1 for more info."}Module["abort"]=abort;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()();}}noExitRuntime=true;run();

              return Module;
            }

            var clipperWasm = { init: init };

            function init$1(_moduleOverrides) {
              var Module = {};
              Object.keys(_moduleOverrides).forEach(function (key) {
                Module[key] = _moduleOverrides[key];
              });
            var Module=typeof Module!=="undefined"?Module:{};var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key];}}var arguments_=[];var thisProgram="./this.program";var quit_=function(status,toThrow){throw toThrow};var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var readAsync;{if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.lastIndexOf("/")+1);}else {scriptDirectory="";}readAsync=function readAsync(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function xhr_onload(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}var data=tryParseAsDataURI(url);if(data){onload(data.buffer);return}onerror();};xhr.onerror=onerror;xhr.send(null);};}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.warn.bind(console);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key];}}moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var functionPointers=new Array(0);var tempRet0=0;var setTempRet0=function(value){tempRet0=value;};var getTempRet0=function(){return tempRet0};var GLOBAL_BASE=8;var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime;if(Module["noExitRuntime"])noExitRuntime=Module["noExitRuntime"];var ABORT=false;var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(u8Array,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(u8Array[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&u8Array.subarray&&UTF8Decoder){return UTF8Decoder.decode(u8Array.subarray(idx,endPtr))}else {var str="";while(idx<endPtr){var u0=u8Array[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2;}else {u0=(u0&7)<<18|u1<<12|u2<<6|u8Array[idx++]&63;}if(u0<65536){str+=String.fromCharCode(u0);}else {var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023);}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023;}if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u;}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63;}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}else {if(outIdx+3>=endIdx)break;outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}}outU8Array[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4;}return len}var UTF16Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf-16le"):undefined;function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple;}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf);}var DYNAMIC_BASE=5261872,DYNAMICTOP_PTR=18960;var INITIAL_TOTAL_MEMORY=Module["TOTAL_MEMORY"]||16777216;if(Module["buffer"]){buffer=Module["buffer"];}else {buffer=new ArrayBuffer(INITIAL_TOTAL_MEMORY);}INITIAL_TOTAL_MEMORY=buffer.byteLength;updateGlobalBufferAndViews(buffer);HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Module["dynCall_v"](func);}else {Module["dynCall_vi"](func,callback.arg);}}else {func(callback.arg===undefined?null:callback.arg);}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift());}}callRuntimeCallbacks(__ATPRERUN__);}function initRuntime(){callRuntimeCallbacks(__ATINIT__);}function preMain(){callRuntimeCallbacks(__ATMAIN__);}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift());}}callRuntimeCallbacks(__ATPOSTRUN__);}function addOnPreRun(cb){__ATPRERUN__.unshift(cb);}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb);}var runDependencies=0;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}if(runDependencies==0){if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback();}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};var memoryInitializer=null;var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return String.prototype.startsWith?filename.startsWith(dataURIPrefix):filename.indexOf(dataURIPrefix)===0}__ATINIT__.push({func:function(){globalCtors();}});memoryInitializer="data:application/octet-stream;base64,AAAAAAAAAAAgDQAA6AQAAHgNAADABAAAMA0AAFgEAAB4DQAAwAQAACANAAAIBQAAeA0AAFgEAAAwDQAAiAQAAHgNAABYBAAAIA0AAJAFAAB4DQAAQAUAADANAAB4BQAAeA0AAEAFAAAgDQAAWAQAAIgEAAC4BAAAIA0AAIgEAACIBAAAuAQAACANAABYBAAAWAQAAIgNAAAgDQAAiAQAAIgEAACIDQAAIA0AAFgEAABYBAAAiAQAADANAAAAAAAAAAAAAAAAAAAgDQAAWAQAAIgEAACIBAAAMA0AAAAAAAAAAAAAAAAAACANAABYBAAAWAQAAIgEAAAwDQAACAYAAFgEAACwBAAAMA0AAAAAAAAAAAAAAAAAADANAAAIBgAAiAQAALAEAAAwDQAAAAAAAAAAAAAAAAAAMA0AACgGAACoBAAAiAQAALgEAAAAAAAAAAAAAAAAAAAwDQAAKAYAAKgEAACIBAAAuAQAALgEAAAAAAAAAAAAADANAAAoBgAAqAQAALAFAAC4BAAAAAAAAAAAAAAAAAAAMA0AACgGAACoBAAAsAUAALgEAAC4BAAAAAAAAAAAAAAgDQAAUAYAAFgEAAAwBQAAOAUAAAAAAAAAAAAAAAAAACANAABQBgAAiAQAADAFAAA4BQAAAAAAAAAAAAAAAAAAIA0AAFAGAACIBAAAiA0AACANAABQBgAAsAUAAIgNAAARAAoAERERAAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABEADwoREREDCgcAARMJCwsAAAkGCwAACwAGEQAAABEREQAAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAARAAoKERERAAoAAAIACQsAAAAJAAsAAAsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAMAAAAAAkMAAAAAAAMAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAA0AAAAEDQAAAAAJDgAAAAAADgAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAPAAAAAA8AAAAACRAAAAAAABAAABAAABIAAAASEhIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAABISEgAAAAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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aA0AACANAACIBAAAaA0AAKAEAABYBAAAoAQAAIgEAADABAAAiA0AAIgNAADoBAAAIA0AAOgEAADABAAAeA0AAPgEAACgBAAAWAQAAHgNAAAIBQAAIA0AAAgFAABYBAAAeA0AABgFAACgBAAAiAQAAHgNAABABQAAQAUAAFAFAAAwDQAAUAUAAGANAABQBQAAkAUAACANAACQBQAAQAUAAHgNAACgBQAAoAQAAHgFAAB4DQAAwAUAAAAAAACwBQAACwAAAAwAAABABQAA0AUAACANAADABQAAYA0AANAFAAAwDQAAWAQAAIgNAABYBAAAYA0AAMAEAABYBAAAIA0AAIgEAAC4BAAAIA0AAFgEAACIDQAAIA0AAIgEAACIDQAAIA0AALAFAACIBAAAIA0AALAFAACIBAAAIA0AAFgEAAAgDQAAiAQAACANAAAIBgAA4AUAAAgGAAAoBgAAYA0AAFAGAACIDQAAiA0AACANAABQBgAAcAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKEcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAgAAA0AAAAOAAAADwAAABAAAAADAAAAAQAAAAEAAAABAAAAAAAAAGgIAAANAAAAEQAAAA8AAAAQAAAAAwAAAAIAAAACAAAAAgAAAAAAAAB4CAAAAQAAAAIAAAADAAAABAAAAAEAAAACAAAAAwAAABIAAAATAAAAAAAAAIgIAAABAAAAAgAAAAMAAAAEAAAAAQAAAAIAAAADAAAAEgAAABQAAAAAAAAAkAgAAAEAAAACAAAAAwAAAAQAAAAEAAAAAgAAAAUAAAASAAAAFQAAAAAAAACgCAAAAQAAAAIAAAADAAAABAAAAAYAAAACAAAAAwAAABIAAAAWAAAAAAAAALAIAAAFAAAAAgAAAAMAAAAEAAAABwAAAAgAAAADAAAAEgAAABcAAAAAAAAAwAgAAAYAAAACAAAAAwAAAAQAAAAJAAAACgAAAAMAAAASAAAAGAAAAAAAAADQCAAAAQAAAAIAAAADAAAABAAAAAsAAAACAAAADAAAABIAAAAZAAAAAAAAAOAIAAABAAAAAgAAAAMAAAAEAAAADQAAAAIAAAADAAAAEgAAABoAAAAAAAAA8AgAAAcAAAAIAAAACQAAAAoAAAAOAAAADwAAAAMAAAASAAAAGwAAAAAAAAAACQAAAQAAAAIAAAADAAAABAAAABAAAAACAAAAAwAAABIAAAAcAAAAAAAAABAJAAABAAAAAgAAAAMAAAAEAAAAEQAAAAIAAAADAAAAEgAAAB0AAAAAAAAAIAkAAAEAAAACAAAAAwAAAAQAAAASAAAAAgAAAAMAAAASAAAAHgAAAAAAAAAwCQAAAQAAAAIAAAADAAAABAAAABMAAAACAAAAAwAAABIAAAAfAAAAAAAAAEAJAAABAAAAAgAAAAMAAAAEAAAAFAAAAAIAAAADAAAAEgAAACAAAAAAAAAAUAkAAAEAAAACAAAAAwAAAAQAAAAVAAAAAgAAAAMAAAASAAAAIQAAAAAAAABgCQAAAQAAAAIAAAADAAAABAAAABYAAAACAAAAAwAAABIAAAAiAAAAAAAAAHAJAAABAAAAAgAAAAMAAAAEAAAAFwAAAAIAAAADAAAAEgAAACMAAAAAAAAAgAkAAAEAAAACAAAAAwAAAAQAAAAYAAAAAgAAAAMAAAASAAAAJAAAAAAAAACQCQAAAQAAAAIAAAADAAAABAAAABkAAAACAAAAAwAAABIAAAAlAAAAAAAAAKAJAAABAAAAAgAAAAMAAAAEAAAAGgAAAAIAAAADAAAAEgAAACYAAAAAAAAAsAkAAAEAAAACAAAAAwAAAAQAAAAbAAAAAgAAAAMAAAASAAAAJwAAAAAAAADACQAAAQAAAAIAAAADAAAABAAAABwAAAACAAAAAwAAABIAAAAoAAAAAAAAANAJAAABAAAAAgAAAAMAAAAEAAAAHQAAAAIAAAADAAAAEgAAACkAAAAAAAAA4AkAAAEAAAACAAAAAwAAAAQAAAAeAAAAAgAAAAMAAAASAAAAKgAAAAAAAADwCQAAAQAAAAIAAAADAAAABAAAAB8AAAACAAAAAwAAABIAAAArAAAAAAAAAAAKAAABAAAAAgAAAAMAAAAEAAAAIAAAAAIAAAADAAAAEgAAACwAAAAAAAAAEAoAAAEAAAACAAAAAwAAAAQAAAAhAAAAAgAAAAMAAAASAAAALQAAAAAAAAAgCgAAAQAAAAIAAAADAAAABAAAACIAAAACAAAAAwAAABIAAAAuAAAAAAAAADAKAAABAAAAAgAAAAMAAAAEAAAAIwAAAAIAAAAkAAAAEgAAAC8AAAAAAAAAQAoAAAEAAAACAAAAAwAAAAQAAAAlAAAAAgAAAAMAAAASAAAAMAAAAAAAAABQCgAAAQAAAAIAAAADAAAABAAAACYAAAACAAAAAwAAABIAAAAxAAAAAAAAAGAKAAABAAAAAgAAAAMAAAAEAAAAJwAAAAIAAAAoAAAAEgAAADIAAAAAAAAAcAoAAAEAAAACAAAAAwAAAAQAAAApAAAAAgAAAAMAAAASAAAAMwAAAAAAAACACgAAAQAAAAIAAAADAAAABAAAACoAAAACAAAAAwAAABIAAAA0AAAAAAAAAJAKAAABAAAAAgAAAAMAAAAEAAAAKwAAAAIAAAADAAAAEgAAADUAAAAAAAAAoAoAAAEAAAACAAAAAwAAAAQAAAAsAAAAAgAAAC0AAAASAAAANgAAAAAAAACwCgAAAQAAAAIAAAADAAAABAAAAC4AAAACAAAAAwAAABIAAAA3AAAAAAAAAMAKAAABAAAAAgAAAAMAAAAEAAAALwAAAAIAAAADAAAAEgAAADgAAAAAAAAA0AoAAAEAAAACAAAAAwAAAAQAAAAwAAAAAgAAAAMAAAASAAAAOQAAAAAAAADgCgAAAQAAAAIAAAADAAAABAAAADEAAAACAAAAAwAAABIAAAA6AAAAAAAAAPAKAAABAAAAAgAAAAMAAAAEAAAAMgAAAAIAAAADAAAAEgAAADsAAAAAAAAAAAsAAAEAAAACAAAAAwAAAAQAAAAzAAAAAgAAAAMAAAASAAAAPAAAAAAAAAAQCwAAAQAAAAIAAAADAAAABAAAADQAAAACAAAAAwAAABIAAAA9AAAAAAAAACALAAALAAAADAAAAA0AAAAOAAAANQAAADYAAAADAAAAEgAAAD4AAAAAAAAAMAsAAAEAAAACAAAAAwAAAAQAAAA3AAAAAgAAAAMAAAASAAAAPwAAAAAAAABACwAAAQAAAAIAAAADAAAABAAAADgAAAACAAAAOQAAABIAAABAAAAAAAAAAFALAAABAAAAAgAAAAMAAAAEAAAAOgAAAAIAAAADAAAAEgAAAEEAAAAAAAAAYAsAAAEAAAACAAAAAwAAAAQAAAA7AAAAAgAAAAMAAAASAAAAQgAAAAAAAABwCwAAAQAAAAIAAAADAAAABAAAADwAAAACAAAAAwAAABIAAABDAAAAAAAAAIALAAABAAAAAgAAAAMAAAAEAAAAPQAAAAIAAAADAAAAEgAAAEQAAAAAAAAAkAsAAAEAAAACAAAAAwAAAAQAAAA+AAAAAgAAAAMAAAASAAAARQAAAAAAAACgCwAAAQAAAAIAAAADAAAABAAAAD8AAAACAAAAQAAAABIAAABGAAAAAAAAALALAAABAAAAAgAAAAMAAAAEAAAAQQAAAAIAAABCAAAAEgAAAEcAAAAAAAAAwAsAAA8AAAACAAAAAwAAAAQAAABDAAAARAAAAAMAAAASAAAASAAAAAAAAADQCwAAEAAAABEAAAADAAAABAAAAEUAAABGAAAAAwAAABIAAABJAAAAAAAAAOALAAABAAAAAgAAAAMAAAAEAAAARwAAAAIAAAADAAAAEgAAAEoAAAAAAAAA8AsAAAEAAAACAAAAAwAAAAQAAABIAAAAAgAAAAMAAAASAAAASwAAAAAAAAAADAAAEgAAABMAAAAUAAAABAAAAEkAAABKAAAAAwAAABIAAABMAAAAAAAAABAMAAABAAAAAgAAAAMAAAAEAAAASwAAAAIAAAADAAAAEgAAAE0AAAAAAAAAIAwAAAEAAAACAAAAAwAAAAQAAABMAAAAAgAAAAMAAAASAAAATgAAAAAAAAAwDAAAFQAAAAIAAAAWAAAABAAAAE0AAABOAAAAAwAAABIAAABPAAAAAAAAAEAMAAABAAAAAgAAAAMAAAAEAAAATwAAAAIAAAADAAAAEgAAAFAAAAAAAAAAUAwAAAEAAAACAAAAAwAAAAQAAABQAAAAAgAAAAMAAAASAAAAUQAAAAAAAABgDAAAAQAAAAIAAAADAAAABAAAAFEAAAACAAAAAwAAABIAAABSAAAAAAAAAHAMAAABAAAAAgAAAAMAAAAEAAAAUgAAAAIAAAADAAAAEgAAAFMAAAAAAAAAgAwAABcAAAACAAAAGAAAAAQAAABTAAAAVAAAAAMAAAASAAAAVAAAAAAAAACQDAAAAQAAAAIAAAADAAAABAAAAFUAAAACAAAAAwAAABIAAABVAAAAAAAAAKAMAAABAAAAAgAAAAMAAAAEAAAAVgAAAAIAAAADAAAAEgAAAFYAAAAAAAAAsAwAAFcAAABYAAAABAAAAAAAAADADAAAVwAAAFkAAAAEAAAAAAAAABANAAANAAAAWgAAAA8AAAAQAAAABAAAAAAAAADgDAAADQAAAFsAAAAPAAAAEAAAAAUAAAAAAAAAkA0AAA0AAABcAAAADwAAABAAAAAGAAAAAAAAAKANAAANAAAAXQAAAA8AAAAQAAAAAwAAAAMAAAADAAAAAwAAAENvb3JkaW5hdGUgb3V0c2lkZSBhbGxvd2VkIHJhbmdlAE4xMENsaXBwZXJMaWIxNmNsaXBwZXJFeGNlcHRpb25FAEFkZFBhdGg6IE9wZW4gcGF0aHMgbXVzdCBiZSBzdWJqZWN0LgBVcGRhdGVFZGdlSW50b0FFTDogaW52YWxpZCBjYWxsAEVycm9yOiBQb2x5VHJlZSBzdHJ1Y3QgaXMgbmVlZGVkIGZvciBvcGVuIHBhdGggY2xpcHBpbmcuAERvTWF4aW1hIGVycm9yAHRvUGF0aAB0b1BhdGhzAGZyb21QYXRoAGZyb21QYXRocwBDbGlwVHlwZQBJbnRlcnNlY3Rpb24AVW5pb24ARGlmZmVyZW5jZQBYb3IAUG9seVR5cGUAU3ViamVjdABDbGlwAFBvbHlGaWxsVHlwZQBFdmVuT2RkAE5vblplcm8AUG9zaXRpdmUATmVnYXRpdmUASW50UG9pbnQAeAB5AG5ld0ludFBvaW50AFBhdGgAUGF0aHMASW5pdE9wdGlvbnMAUmV2ZXJzZVNvbHV0aW9uAFN0cmljdGx5U2ltcGxlAFByZXNlcnZlQ29sbGluZWFyAEpvaW5UeXBlAFNxdWFyZQBSb3VuZABNaXRlcgBFbmRUeXBlAENsb3NlZFBvbHlnb24AQ2xvc2VkTGluZQBPcGVuQnV0dABPcGVuU3F1YXJlAE9wZW5Sb3VuZABQb2x5Tm9kZQBjb250b3VyAGNoaWxkcwBnZXRQYXJlbnQAZ2V0TmV4dABpc0hvbGUAaXNPcGVuAGNoaWxkQ291bnQAUG9seU5vZGVzAFBvbHlUcmVlAGdldEZpcnN0AGNsZWFyAHRvdGFsAG9yaWVudGF0aW9uAGFyZWEAcG9pbnRJblBvbHlnb24Ac2ltcGxpZnlQb2x5Z29uAHNpbXBsaWZ5UG9seWdvbnNJbk91dABzaW1wbGlmeVBvbHlnb25zT3ZlcndyaXRlAGNsZWFuUG9seWdvbgBjbGVhblBvbHlnb25zAG1pbmtvd3NraVN1bVBhdGgAbWlua293c2tpU3VtUGF0aHMAbWlua293c2tpRGlmZgBwb2x5VHJlZVRvUGF0aHMAY2xvc2VkUGF0aHNGcm9tUG9seVRyZWUAb3BlblBhdGhzRnJvbVBvbHlUcmVlAHJldmVyc2VQYXRoAHJldmVyc2VQYXRocwBJbnRSZWN0AGxlZnQAdG9wAHJpZ2h0AGJvdHRvbQBDbGlwcGVyQmFzZQBhZGRQYXRoAGFkZFBhdGhzAGdldEJvdW5kcwBwcmVzZXJ2ZUNvbGxpbmVhcgBDbGlwcGVyAGV4ZWN1dGVQYXRocwBleGVjdXRlUGF0aHNXaXRoRmlsbFR5cGVzAGV4ZWN1dGVQb2x5VHJlZQBleGVjdXRlUG9seVRyZWVXaXRoRmlsbFR5cGVzAHJldmVyc2VTb2x1dGlvbgBzdHJpY3RseVNpbXBsZQBDbGlwcGVyT2Zmc2V0AG1pdGVyTGltaXQAYXJjVG9sZXJhbmNlAE4xMENsaXBwZXJMaWIxMUNsaXBwZXJCYXNlRQBOMTBDbGlwcGVyTGliN0NsaXBwZXJFAE4xMENsaXBwZXJMaWI4UG9seU5vZGVFAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZEVFAE5TdDNfXzI2dmVjdG9ySU4xMENsaXBwZXJMaWI4SW50UG9pbnRFTlNfOWFsbG9jYXRvcklTMl9FRUVFAE5TdDNfXzIxM19fdmVjdG9yX2Jhc2VJTjEwQ2xpcHBlckxpYjhJbnRQb2ludEVOU185YWxsb2NhdG9ySVMyX0VFRUUATlN0M19fMjIwX192ZWN0b3JfYmFzZV9jb21tb25JTGIxRUVFAHZpaWkATlN0M19fMjZ2ZWN0b3JJTlMwX0lOMTBDbGlwcGVyTGliOEludFBvaW50RU5TXzlhbGxvY2F0b3JJUzJfRUVFRU5TM19JUzVfRUVFRQBOU3QzX18yMTNfX3ZlY3Rvcl9iYXNlSU5TXzZ2ZWN0b3JJTjEwQ2xpcHBlckxpYjhJbnRQb2ludEVOU185YWxsb2NhdG9ySVMzX0VFRUVOUzRfSVM2X0VFRUUATjEwZW1zY3JpcHRlbjN2YWxFAGlpaQBOMTBDbGlwcGVyTGliOENsaXBUeXBlRQBOMTBDbGlwcGVyTGliOFBvbHlUeXBlRQBOMTBDbGlwcGVyTGliMTJQb2x5RmlsbFR5cGVFAE4xMENsaXBwZXJMaWI4SW50UG9pbnRFAFBOMTBDbGlwcGVyTGliOEludFBvaW50RQBQS04xMENsaXBwZXJMaWI4SW50UG9pbnRFAGlpAHYAdmkAZGlpAHZpaWQAaWlkZABwdXNoX2JhY2sAcmVzaXplAHNpemUAZ2V0AHNldABQTlN0M19fMjZ2ZWN0b3JJTjEwQ2xpcHBlckxpYjhJbnRQb2ludEVOU185YWxsb2NhdG9ySVMyX0VFRUUAUEtOU3QzX18yNnZlY3RvcklOMTBDbGlwcGVyTGliOEludFBvaW50RU5TXzlhbGxvY2F0b3JJUzJfRUVFRQB2aWlpaQBpaWlpAGlpaWlpAFBOU3QzX18yNnZlY3RvcklOUzBfSU4xMENsaXBwZXJMaWI4SW50UG9pbnRFTlNfOWFsbG9jYXRvcklTMl9FRUVFTlMzX0lTNV9FRUVFAFBLTlN0M19fMjZ2ZWN0b3JJTlMwX0lOMTBDbGlwcGVyTGliOEludFBvaW50RU5TXzlhbGxvY2F0b3JJUzJfRUVFRU5TM19JUzVfRUVFRQBOMTBDbGlwcGVyTGliMTFJbml0T3B0aW9uc0UATjEwQ2xpcHBlckxpYjhKb2luVHlwZUUATjEwQ2xpcHBlckxpYjdFbmRUeXBlRQBQTjEwQ2xpcHBlckxpYjhQb2x5Tm9kZUUAUEtOMTBDbGlwcGVyTGliOFBvbHlOb2RlRQBOU3QzX18yNnZlY3RvcklQTjEwQ2xpcHBlckxpYjhQb2x5Tm9kZUVOU185YWxsb2NhdG9ySVMzX0VFRUUATlN0M19fMjEzX192ZWN0b3JfYmFzZUlQTjEwQ2xpcHBlckxpYjhQb2x5Tm9kZUVOU185YWxsb2NhdG9ySVMzX0VFRUUAUE5TdDNfXzI2dmVjdG9ySVBOMTBDbGlwcGVyTGliOFBvbHlOb2RlRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQBQS05TdDNfXzI2dmVjdG9ySVBOMTBDbGlwcGVyTGliOFBvbHlOb2RlRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQBOMTBDbGlwcGVyTGliOFBvbHlUcmVlRQBQTjEwQ2xpcHBlckxpYjhQb2x5VHJlZUUAUEtOMTBDbGlwcGVyTGliOFBvbHlUcmVlRQB2aWkAdmlpaWQAdmlpaWlpAE4xMENsaXBwZXJMaWI3SW50UmVjdEUAUE4xMENsaXBwZXJMaWI3SW50UmVjdEUAUEtOMTBDbGlwcGVyTGliN0ludFJlY3RFAFBOMTBDbGlwcGVyTGliMTFDbGlwcGVyQmFzZUUAUEtOMTBDbGlwcGVyTGliMTFDbGlwcGVyQmFzZUUAaWlpaWlpAFBOMTBDbGlwcGVyTGliN0NsaXBwZXJFAFBLTjEwQ2xpcHBlckxpYjdDbGlwcGVyRQBpaWlpaWlpAE4xMENsaXBwZXJMaWIxM0NsaXBwZXJPZmZzZXRFAFBOMTBDbGlwcGVyTGliMTNDbGlwcGVyT2Zmc2V0RQBQS04xMENsaXBwZXJMaWIxM0NsaXBwZXJPZmZzZXRFAC0rICAgMFgweAAobnVsbCkALTBYKzBYIDBYLTB4KzB4IDB4AGluZgBJTkYAbmFuAE5BTgBzdGQ6OmJhc2ljX3N0cmluZzx1bnNpZ25lZCBjaGFyPgBzdGQ6OndzdHJpbmcAZW1zY3JpcHRlbjo6dmFsAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgc2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGRvdWJsZT4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZyBkb3VibGU+AE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWVFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lmRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbUVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWxFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaUVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXRFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ljRUUATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUATlN0M19fMjIxX19iYXNpY19zdHJpbmdfY29tbW9uSUxiMUVFRQBOU3QzX18yMTJiYXNpY19zdHJpbmdJaE5TXzExY2hhcl90cmFpdHNJaEVFTlNfOWFsbG9jYXRvckloRUVFRQBOU3QzX18yMTJiYXNpY19zdHJpbmdJY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQB0ZXJtaW5hdGluZyB3aXRoICVzIGV4Y2VwdGlvbiBvZiB0eXBlICVzOiAlcwB0ZXJtaW5hdGluZyB3aXRoICVzIGV4Y2VwdGlvbiBvZiB0eXBlICVzAHRlcm1pbmF0aW5nIHdpdGggJXMgZm9yZWlnbiBleGNlcHRpb24AdGVybWluYXRpbmcAdW5jYXVnaHQAU3Q5ZXhjZXB0aW9uAE4xMF9fY3h4YWJpdjExNl9fc2hpbV90eXBlX2luZm9FAFN0OXR5cGVfaW5mbwBOMTBfX2N4eGFiaXYxMjBfX3NpX2NsYXNzX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTE3X19jbGFzc190eXBlX2luZm9FAHRlcm1pbmF0ZV9oYW5kbGVyIHVuZXhwZWN0ZWRseSByZXR1cm5lZABfWgBfX19aAF9ibG9ja19pbnZva2UAaW52b2NhdGlvbiBmdW5jdGlvbiBmb3IgYmxvY2sgaW4gAHZvaWQAYm9vbABjaGFyAHNpZ25lZCBjaGFyAHVuc2lnbmVkIGNoYXIAc2hvcnQAdW5zaWduZWQgc2hvcnQAaW50AHVuc2lnbmVkIGludABsb25nAHVuc2lnbmVkIGxvbmcAbG9uZyBsb25nAF9faW50MTI4AHVuc2lnbmVkIF9faW50MTI4AGZsb2F0AGxvbmcgZG91YmxlAF9fZmxvYXQxMjgALi4uAGRlY2ltYWw2NABkZWNpbWFsMTI4AGRlY2ltYWwzMgBkZWNpbWFsMTYAY2hhcjMyX3QAY2hhcjE2X3QAYXV0bwBkZWNsdHlwZShhdXRvKQBzdGQ6Om51bGxwdHJfdABbYWJpOgBdAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwQWJpVGFnQXR0ckUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlNE5vZGVFAGFsbG9jYXRvcgBiYXNpY19zdHJpbmcAc3RyaW5nAGlzdHJlYW0Ab3N0cmVhbQBpb3N0cmVhbQBzdGQ6OmFsbG9jYXRvcgBzdGQ6OmJhc2ljX3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OmlzdHJlYW0Ac3RkOjpvc3RyZWFtAHN0ZDo6aW9zdHJlYW0ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTlTcGVjaWFsU3Vic3RpdHV0aW9uRQAgaW1hZ2luYXJ5AE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTIwUG9zdGZpeFF1YWxpZmllZFR5cGVFACBjb21wbGV4ACkAIAAoACYAJiYATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNSZWZlcmVuY2VUeXBlRQBvYmpjX29iamVjdAAqAGlkPAA+AE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTExUG9pbnRlclR5cGVFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTIwTmFtZVdpdGhUZW1wbGF0ZUFyZ3NFADwALCAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTJUZW1wbGF0ZUFyZ3NFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEzUGFyYW1ldGVyUGFja0UAd2NoYXJfdABiMEUAYjFFAHUAbAB1bABsbAB1bGwATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTVJbnRlZ2VyQ2FzdEV4cHJFACVMYUwATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTZGbG9hdExpdGVyYWxJbXBsSWVFRQAlYQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNkZsb2F0TGl0ZXJhbEltcGxJZEVFACVhZgBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNkZsb2F0TGl0ZXJhbEltcGxJZkVFAHRydWUAZmFsc2UATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOEJvb2xFeHByRQAtAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE0SW50ZWdlckxpdGVyYWxFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTIwVGVtcGxhdGVBcmd1bWVudFBhY2tFAGdzACY9AD0AYWxpZ25vZiAoACwAfgAuKgAvAC89AF4AXj0APT0APj0APD0APDwAPDw9AC09ACo9AC0tACE9ACEAfHwAfAB8PQAtPioAKwArPQArKwAtPgAlACU9AD4+AD4+PQBzaXplb2YgKAB0eXBlaWQgKAB0aHJvdwB0aHJvdyAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOVRocm93RXhwckUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTJJbml0TGlzdEV4cHJFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEzTm9kZUFycmF5Tm9kZUUAc2l6ZW9mLi4uICgATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNFbmNsb3NpbmdFeHByRQBzaXplb2YuLi4oAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTIyUGFyYW1ldGVyUGFja0V4cGFuc2lvbkUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTlTaXplb2ZQYXJhbVBhY2tFeHByRQBzdGF0aWNfY2FzdAA+KABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU4Q2FzdEV4cHJFAHJlaW50ZXJwcmV0X2Nhc3QAKSA/ICgAKSA6ICgATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTVDb25kaXRpb25hbEV4cHJFAG5vZXhjZXB0ICgAbncAbmEAcGkAOjpvcGVyYXRvciAAbmV3AFtdAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTdOZXdFeHByRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMVBvc3RmaXhFeHByRQAgLi4uIAAgPSAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTVCcmFjZWRSYW5nZUV4cHJFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwQnJhY2VkRXhwckUAX0dMT0JBTF9fTgAoYW5vbnltb3VzIG5hbWVzcGFjZSkATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOE5hbWVUeXBlRQApWwBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxOEFycmF5U3Vic2NyaXB0RXhwckUALgBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxME1lbWJlckV4cHJFAHNyTgBzcgA6OgBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxOUdsb2JhbFF1YWxpZmllZE5hbWVFAGRuAG9uAG9wZXJhdG9yJiYAb3BlcmF0b3ImAG9wZXJhdG9yJj0Ab3BlcmF0b3I9AG9wZXJhdG9yKCkAb3BlcmF0b3IsAG9wZXJhdG9yfgBvcGVyYXRvciBkZWxldGVbXQBvcGVyYXRvcioAb3BlcmF0b3IvAG9wZXJhdG9yLz0Ab3BlcmF0b3JeAG9wZXJhdG9yXj0Ab3BlcmF0b3I9PQBvcGVyYXRvcj49AG9wZXJhdG9yPgBvcGVyYXRvcltdAG9wZXJhdG9yPD0Ab3BlcmF0b3I8PABvcGVyYXRvcjw8PQBvcGVyYXRvcjwAb3BlcmF0b3ItAG9wZXJhdG9yLT0Ab3BlcmF0b3IqPQBvcGVyYXRvci0tAG9wZXJhdG9yIG5ld1tdAG9wZXJhdG9yIT0Ab3BlcmF0b3IhAG9wZXJhdG9yIG5ldwBvcGVyYXRvcnx8AG9wZXJhdG9yfABvcGVyYXRvcnw9AG9wZXJhdG9yLT4qAG9wZXJhdG9yKwBvcGVyYXRvcis9AG9wZXJhdG9yKysAb3BlcmF0b3ItPgBvcGVyYXRvcj8Ab3BlcmF0b3IlAG9wZXJhdG9yJT0Ab3BlcmF0b3I+PgBvcGVyYXRvcj4+PQBvcGVyYXRvcjw9PgBvcGVyYXRvciIiIABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNUxpdGVyYWxPcGVyYXRvckUAb3BlcmF0b3IgZGVsZXRlAG9wZXJhdG9yIABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyMkNvbnZlcnNpb25PcGVyYXRvclR5cGVFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZThEdG9yTmFtZUUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNRdWFsaWZpZWROYW1lRQBkeW5hbWljX2Nhc3QAZGVsZXRlAFtdIABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMERlbGV0ZUV4cHJFAGN2ACkoAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE0Q29udmVyc2lvbkV4cHJFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZThDYWxsRXhwckUAY29uc3RfY2FzdABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMFByZWZpeEV4cHJFACkgACAoAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwQmluYXJ5RXhwckUAYWEAYW4AYU4AYVMAY20AZHMAZHYAZFYAZW8AZU8AZXEAZ2UAZ3QAbGUAbHMAbFMAbHQAbWkAbUkAbWwAbUwAbmUAb28Ab3IAb1IAcGwAcEwAcm0Ack0AcnMAclMALi4uIAAgLi4uAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZThGb2xkRXhwckUAZnAAZkwATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNGdW5jdGlvblBhcmFtRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyNEZvcndhcmRUZW1wbGF0ZVJlZmVyZW5jZUUAVHMAc3RydWN0AFR1AHVuaW9uAFRlAGVudW0ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjJFbGFib3JhdGVkVHlwZVNwZWZUeXBlRQBTdEwAU3QAc3RkOjoATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTZTdGRRdWFsaWZpZWROYW1lRQBEQwBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyMVN0cnVjdHVyZWRCaW5kaW5nTmFtZUUAVXQAVWwAdkUAJ2xhbWJkYQAnKABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNUNsb3N1cmVUeXBlTmFtZUUAJ3VubmFtZWQAJwBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNVVubmFtZWRUeXBlTmFtZUUAc3RyaW5nIGxpdGVyYWwATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOUxvY2FsTmFtZUUAc3RkAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEyQ3RvckR0b3JOYW1lRQBiYXNpY19pc3RyZWFtAGJhc2ljX29zdHJlYW0AYmFzaWNfaW9zdHJlYW0Ac3RkOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjphbGxvY2F0b3I8Y2hhcj4gPgBzdGQ6OmJhc2ljX2lzdHJlYW08Y2hhciwgc3RkOjpjaGFyX3RyYWl0czxjaGFyPiA+AHN0ZDo6YmFzaWNfb3N0cmVhbTxjaGFyLCBzdGQ6OmNoYXJfdHJhaXRzPGNoYXI+ID4Ac3RkOjpiYXNpY19pb3N0cmVhbTxjaGFyLCBzdGQ6OmNoYXJfdHJhaXRzPGNoYXI+ID4ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjdFeHBhbmRlZFNwZWNpYWxTdWJzdGl0dXRpb25FAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwTmVzdGVkTmFtZUUAOjoqAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE5UG9pbnRlclRvTWVtYmVyVHlwZUUAWwBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU5QXJyYXlUeXBlRQBEdgAgdmVjdG9yWwBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMFZlY3RvclR5cGVFAHBpeGVsIHZlY3RvclsATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTVQaXhlbFZlY3RvclR5cGVFAGRlY2x0eXBlKABkb3VibGUAdW5zaWduZWQgbG9uZyBsb25nAG9iamNwcm90bwAgY29uc3QAIHZvbGF0aWxlACByZXN0cmljdABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU4UXVhbFR5cGVFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE3VmVuZG9yRXh0UXVhbFR5cGVFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEzT2JqQ1Byb3RvTmFtZUUARG8Abm9leGNlcHQARE8ARHcARHgAUkUAT0UAICYAICYmAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEyRnVuY3Rpb25UeXBlRQB0aHJvdygATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjBEeW5hbWljRXhjZXB0aW9uU3BlY0UAbm9leGNlcHQoAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEyTm9leGNlcHRTcGVjRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMVNwZWNpYWxOYW1lRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU5RG90U3VmZml4RQBVYTllbmFibGVfaWZJAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE2RnVuY3Rpb25FbmNvZGluZ0UAIFtlbmFibGVfaWY6AE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEyRW5hYmxlSWZBdHRyRQB0aHJlYWQtbG9jYWwgd3JhcHBlciByb3V0aW5lIGZvciAAcmVmZXJlbmNlIHRlbXBvcmFyeSBmb3IgAGd1YXJkIHZhcmlhYmxlIGZvciAAbm9uLXZpcnR1YWwgdGh1bmsgdG8gAHZpcnR1YWwgdGh1bmsgdG8gAHRocmVhZC1sb2NhbCBpbml0aWFsaXphdGlvbiByb3V0aW5lIGZvciAAY29uc3RydWN0aW9uIHZ0YWJsZSBmb3IgAC1pbi0ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjFDdG9yVnRhYmxlU3BlY2lhbE5hbWVFAGNvdmFyaWFudCByZXR1cm4gdGh1bmsgdG8gAHR5cGVpbmZvIG5hbWUgZm9yIAB0eXBlaW5mbyBmb3IgAFZUVCBmb3IgAHZ0YWJsZSBmb3IgAFN0MTFsb2dpY19lcnJvcgBTdDEybGVuZ3RoX2Vycm9yAE4xMF9fY3h4YWJpdjExN19fcGJhc2VfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMjBfX2Z1bmN0aW9uX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTI5X19wb2ludGVyX3RvX21lbWJlcl90eXBlX2luZm9FAE4xMF9fY3h4YWJpdjEyM19fZnVuZGFtZW50YWxfdHlwZV9pbmZvRQB2AERuAGIAYwBoAGEAcwB0AGkAagBtAGYAZABOMTBfX2N4eGFiaXYxMTZfX2VudW1fdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMjFfX3ZtaV9jbGFzc190eXBlX2luZm9F";var tempDoublePtr=18976;function demangle(func){return func}function demangleAll(text){var regex=/\b__Z[\w\d_]+/g;return text.replace(regex,function(x){var y=demangle(x);return x===y?x:y+" ["+x+"]"})}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e;}if(!err.stack){return "(no stack trace available)"}}return err.stack.toString()}function stackTrace(){var js=jsStackTrace();if(Module["extraStackTrace"])js+="\n"+Module["extraStackTrace"]();return demangleAll(js)}function ___cxa_allocate_exception(size){return _malloc(size)}var ___exception_infos={};function ___exception_addRef(ptr){if(!ptr)return;var info=___exception_infos[ptr];info.refcount++;}function ___exception_deAdjust(adjusted){if(!adjusted||___exception_infos[adjusted])return adjusted;for(var key in ___exception_infos){var ptr=+key;var adj=___exception_infos[ptr].adjusted;var len=adj.length;for(var i=0;i<len;i++){if(adj[i]===adjusted){return ptr}}}return adjusted}function ___cxa_begin_catch(ptr){var info=___exception_infos[ptr];if(info&&!info.caught){info.caught=true;__ZSt18uncaught_exceptionv.uncaught_exceptions--;}if(info)info.rethrown=false;___exception_addRef(___exception_deAdjust(ptr));return ptr}function ___cxa_pure_virtual(){ABORT=true;throw "Pure virtual function called!"}function ___cxa_throw(ptr,type,destructor){___exception_infos[ptr]={ptr:ptr,adjusted:[ptr],type:type,destructor:destructor,refcount:0,caught:false,rethrown:false};if(!("uncaught_exception"in __ZSt18uncaught_exceptionv)){__ZSt18uncaught_exceptionv.uncaught_exceptions=1;}else {__ZSt18uncaught_exceptionv.uncaught_exceptions++;}throw ptr}function ___cxa_uncaught_exceptions(){return __ZSt18uncaught_exceptionv.uncaught_exceptions}function ___gxx_personality_v0(){}var SYSCALLS={buffers:[null,[],[]],printChar:function(stream,curr){var buffer=SYSCALLS.buffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0;}else {buffer.push(curr);}},varargs:0,get:function(varargs){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(){var ret=UTF8ToString(SYSCALLS.get());return ret},get64:function(){var low=SYSCALLS.get(),high=SYSCALLS.get();return low},getZero:function(){SYSCALLS.get();}};function ___syscall140(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),offset_high=SYSCALLS.get(),offset_low=SYSCALLS.get(),result=SYSCALLS.get(),whence=SYSCALLS.get();return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function flush_NO_FILESYSTEM(){var fflush=Module["_fflush"];if(fflush)fflush(0);var buffers=SYSCALLS.buffers;if(buffers[1].length)SYSCALLS.printChar(1,10);if(buffers[2].length)SYSCALLS.printChar(2,10);}function ___syscall146(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.get(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];for(var j=0;j<len;j++){SYSCALLS.printChar(stream,HEAPU8[ptr+j]);}ret+=len;}return ret}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall6(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD();return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function getShiftFromSize(size){switch(size){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError("Unknown type size: "+size)}}function embind_init_charCodes(){var codes=new Array(256);for(var i=0;i<256;++i){codes[i]=String.fromCharCode(i);}embind_charCodes=codes;}var embind_charCodes=undefined;function readLatin1String(ptr){var ret="";var c=ptr;while(HEAPU8[c]){ret+=embind_charCodes[HEAPU8[c++]];}return ret}var awaitingDependencies={};var registeredTypes={};var typeDependencies={};var char_0=48;var char_9=57;function makeLegalFunctionName(name){if(undefined===name){return "_unknown"}name=name.replace(/[^a-zA-Z0-9_]/g,"$");var f=name.charCodeAt(0);if(f>=char_0&&f<=char_9){return "_"+name}else {return name}}function createNamedFunction(name,body){name=makeLegalFunctionName(name);return new Function("body","return function "+name+"() {\n"+'    "use strict";'+"    return body.apply(this, arguments);\n"+"};\n")(body)}function extendError(baseErrorType,errorName){var errorClass=createNamedFunction(errorName,function(message){this.name=errorName;this.message=message;var stack=new Error(message).stack;if(stack!==undefined){this.stack=this.toString()+"\n"+stack.replace(/^Error(:[^\n]*)?\n/,"");}});errorClass.prototype=Object.create(baseErrorType.prototype);errorClass.prototype.constructor=errorClass;errorClass.prototype.toString=function(){if(this.message===undefined){return this.name}else {return this.name+": "+this.message}};return errorClass}var BindingError=undefined;function throwBindingError(message){throw new BindingError(message)}var InternalError=undefined;function throwInternalError(message){throw new InternalError(message)}function whenDependentTypesAreResolved(myTypes,dependentTypes,getTypeConverters){myTypes.forEach(function(type){typeDependencies[type]=dependentTypes;});function onComplete(typeConverters){var myTypeConverters=getTypeConverters(typeConverters);if(myTypeConverters.length!==myTypes.length){throwInternalError("Mismatched type converter count");}for(var i=0;i<myTypes.length;++i){registerType(myTypes[i],myTypeConverters[i]);}}var typeConverters=new Array(dependentTypes.length);var unregisteredTypes=[];var registered=0;dependentTypes.forEach(function(dt,i){if(registeredTypes.hasOwnProperty(dt)){typeConverters[i]=registeredTypes[dt];}else {unregisteredTypes.push(dt);if(!awaitingDependencies.hasOwnProperty(dt)){awaitingDependencies[dt]=[];}awaitingDependencies[dt].push(function(){typeConverters[i]=registeredTypes[dt];++registered;if(registered===unregisteredTypes.length){onComplete(typeConverters);}});}});if(0===unregisteredTypes.length){onComplete(typeConverters);}}function registerType(rawType,registeredInstance,options){options=options||{};if(!("argPackAdvance"in registeredInstance)){throw new TypeError("registerType registeredInstance requires argPackAdvance")}var name=registeredInstance.name;if(!rawType){throwBindingError('type "'+name+'" must have a positive integer typeid pointer');}if(registeredTypes.hasOwnProperty(rawType)){if(options.ignoreDuplicateRegistrations){return}else {throwBindingError("Cannot register type '"+name+"' twice");}}registeredTypes[rawType]=registeredInstance;delete typeDependencies[rawType];if(awaitingDependencies.hasOwnProperty(rawType)){var callbacks=awaitingDependencies[rawType];delete awaitingDependencies[rawType];callbacks.forEach(function(cb){cb();});}}function __embind_register_bool(rawType,name,size,trueValue,falseValue){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(wt){return !!wt},"toWireType":function(destructors,o){return o?trueValue:falseValue},"argPackAdvance":8,"readValueFromPointer":function(pointer){var heap;if(size===1){heap=HEAP8;}else if(size===2){heap=HEAP16;}else if(size===4){heap=HEAP32;}else {throw new TypeError("Unknown boolean type size: "+name)}return this["fromWireType"](heap[pointer>>shift])},destructorFunction:null});}function ClassHandle_isAliasOf(other){if(!(this instanceof ClassHandle)){return false}if(!(other instanceof ClassHandle)){return false}var leftClass=this.$$.ptrType.registeredClass;var left=this.$$.ptr;var rightClass=other.$$.ptrType.registeredClass;var right=other.$$.ptr;while(leftClass.baseClass){left=leftClass.upcast(left);leftClass=leftClass.baseClass;}while(rightClass.baseClass){right=rightClass.upcast(right);rightClass=rightClass.baseClass;}return leftClass===rightClass&&left===right}function shallowCopyInternalPointer(o){return {count:o.count,deleteScheduled:o.deleteScheduled,preservePointerOnDelete:o.preservePointerOnDelete,ptr:o.ptr,ptrType:o.ptrType,smartPtr:o.smartPtr,smartPtrType:o.smartPtrType}}function throwInstanceAlreadyDeleted(obj){function getInstanceTypeName(handle){return handle.$$.ptrType.registeredClass.name}throwBindingError(getInstanceTypeName(obj)+" instance already deleted");}var finalizationGroup=false;function detachFinalizer(handle){}function runDestructor($$){if($$.smartPtr){$$.smartPtrType.rawDestructor($$.smartPtr);}else {$$.ptrType.registeredClass.rawDestructor($$.ptr);}}function releaseClassHandle($$){$$.count.value-=1;var toDelete=0===$$.count.value;if(toDelete){runDestructor($$);}}function attachFinalizer(handle){if("undefined"===typeof FinalizationGroup){attachFinalizer=function(handle){return handle};return handle}finalizationGroup=new FinalizationGroup(function(iter){for(var result=iter.next();!result.done;result=iter.next()){var $$=result.value;if(!$$.ptr){console.warn("object already deleted: "+$$.ptr);}else {releaseClassHandle($$);}}});attachFinalizer=function(handle){finalizationGroup.register(handle,handle.$$,handle.$$);return handle};detachFinalizer=function(handle){finalizationGroup.unregister(handle.$$);};return attachFinalizer(handle)}function ClassHandle_clone(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this);}if(this.$$.preservePointerOnDelete){this.$$.count.value+=1;return this}else {var clone=attachFinalizer(Object.create(Object.getPrototypeOf(this),{$$:{value:shallowCopyInternalPointer(this.$$)}}));clone.$$.count.value+=1;clone.$$.deleteScheduled=false;return clone}}function ClassHandle_delete(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this);}if(this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete){throwBindingError("Object already scheduled for deletion");}detachFinalizer(this);releaseClassHandle(this.$$);if(!this.$$.preservePointerOnDelete){this.$$.smartPtr=undefined;this.$$.ptr=undefined;}}function ClassHandle_isDeleted(){return !this.$$.ptr}var delayFunction=undefined;var deletionQueue=[];function flushPendingDeletes(){while(deletionQueue.length){var obj=deletionQueue.pop();obj.$$.deleteScheduled=false;obj["delete"]();}}function ClassHandle_deleteLater(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this);}if(this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete){throwBindingError("Object already scheduled for deletion");}deletionQueue.push(this);if(deletionQueue.length===1&&delayFunction){delayFunction(flushPendingDeletes);}this.$$.deleteScheduled=true;return this}function init_ClassHandle(){ClassHandle.prototype["isAliasOf"]=ClassHandle_isAliasOf;ClassHandle.prototype["clone"]=ClassHandle_clone;ClassHandle.prototype["delete"]=ClassHandle_delete;ClassHandle.prototype["isDeleted"]=ClassHandle_isDeleted;ClassHandle.prototype["deleteLater"]=ClassHandle_deleteLater;}function ClassHandle(){}var registeredPointers={};function ensureOverloadTable(proto,methodName,humanName){if(undefined===proto[methodName].overloadTable){var prevFunc=proto[methodName];proto[methodName]=function(){if(!proto[methodName].overloadTable.hasOwnProperty(arguments.length)){throwBindingError("Function '"+humanName+"' called with an invalid number of arguments ("+arguments.length+") - expects one of ("+proto[methodName].overloadTable+")!");}return proto[methodName].overloadTable[arguments.length].apply(this,arguments)};proto[methodName].overloadTable=[];proto[methodName].overloadTable[prevFunc.argCount]=prevFunc;}}function exposePublicSymbol(name,value,numArguments){if(Module.hasOwnProperty(name)){if(undefined===numArguments||undefined!==Module[name].overloadTable&&undefined!==Module[name].overloadTable[numArguments]){throwBindingError("Cannot register public name '"+name+"' twice");}ensureOverloadTable(Module,name,name);if(Module.hasOwnProperty(numArguments)){throwBindingError("Cannot register multiple overloads of a function with the same number of arguments ("+numArguments+")!");}Module[name].overloadTable[numArguments]=value;}else {Module[name]=value;if(undefined!==numArguments){Module[name].numArguments=numArguments;}}}function RegisteredClass(name,constructor,instancePrototype,rawDestructor,baseClass,getActualType,upcast,downcast){this.name=name;this.constructor=constructor;this.instancePrototype=instancePrototype;this.rawDestructor=rawDestructor;this.baseClass=baseClass;this.getActualType=getActualType;this.upcast=upcast;this.downcast=downcast;this.pureVirtualFunctions=[];}function upcastPointer(ptr,ptrClass,desiredClass){while(ptrClass!==desiredClass){if(!ptrClass.upcast){throwBindingError("Expected null or instance of "+desiredClass.name+", got an instance of "+ptrClass.name);}ptr=ptrClass.upcast(ptr);ptrClass=ptrClass.baseClass;}return ptr}function constNoSmartPtrRawPointerToWireType(destructors,handle){if(handle===null){if(this.isReference){throwBindingError("null is not a valid "+this.name);}return 0}if(!handle.$$){throwBindingError('Cannot pass "'+_embind_repr(handle)+'" as a '+this.name);}if(!handle.$$.ptr){throwBindingError("Cannot pass deleted object as a pointer of type "+this.name);}var handleClass=handle.$$.ptrType.registeredClass;var ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);return ptr}function genericPointerToWireType(destructors,handle){var ptr;if(handle===null){if(this.isReference){throwBindingError("null is not a valid "+this.name);}if(this.isSmartPointer){ptr=this.rawConstructor();if(destructors!==null){destructors.push(this.rawDestructor,ptr);}return ptr}else {return 0}}if(!handle.$$){throwBindingError('Cannot pass "'+_embind_repr(handle)+'" as a '+this.name);}if(!handle.$$.ptr){throwBindingError("Cannot pass deleted object as a pointer of type "+this.name);}if(!this.isConst&&handle.$$.ptrType.isConst){throwBindingError("Cannot convert argument of type "+(handle.$$.smartPtrType?handle.$$.smartPtrType.name:handle.$$.ptrType.name)+" to parameter type "+this.name);}var handleClass=handle.$$.ptrType.registeredClass;ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);if(this.isSmartPointer){if(undefined===handle.$$.smartPtr){throwBindingError("Passing raw pointer to smart pointer is illegal");}switch(this.sharingPolicy){case 0:if(handle.$$.smartPtrType===this){ptr=handle.$$.smartPtr;}else {throwBindingError("Cannot convert argument of type "+(handle.$$.smartPtrType?handle.$$.smartPtrType.name:handle.$$.ptrType.name)+" to parameter type "+this.name);}break;case 1:ptr=handle.$$.smartPtr;break;case 2:if(handle.$$.smartPtrType===this){ptr=handle.$$.smartPtr;}else {var clonedHandle=handle["clone"]();ptr=this.rawShare(ptr,__emval_register(function(){clonedHandle["delete"]();}));if(destructors!==null){destructors.push(this.rawDestructor,ptr);}}break;default:throwBindingError("Unsupporting sharing policy");}}return ptr}function nonConstNoSmartPtrRawPointerToWireType(destructors,handle){if(handle===null){if(this.isReference){throwBindingError("null is not a valid "+this.name);}return 0}if(!handle.$$){throwBindingError('Cannot pass "'+_embind_repr(handle)+'" as a '+this.name);}if(!handle.$$.ptr){throwBindingError("Cannot pass deleted object as a pointer of type "+this.name);}if(handle.$$.ptrType.isConst){throwBindingError("Cannot convert argument of type "+handle.$$.ptrType.name+" to parameter type "+this.name);}var handleClass=handle.$$.ptrType.registeredClass;var ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);return ptr}function simpleReadValueFromPointer(pointer){return this["fromWireType"](HEAPU32[pointer>>2])}function RegisteredPointer_getPointee(ptr){if(this.rawGetPointee){ptr=this.rawGetPointee(ptr);}return ptr}function RegisteredPointer_destructor(ptr){if(this.rawDestructor){this.rawDestructor(ptr);}}function RegisteredPointer_deleteObject(handle){if(handle!==null){handle["delete"]();}}function downcastPointer(ptr,ptrClass,desiredClass){if(ptrClass===desiredClass){return ptr}if(undefined===desiredClass.baseClass){return null}var rv=downcastPointer(ptr,ptrClass,desiredClass.baseClass);if(rv===null){return null}return desiredClass.downcast(rv)}function getInheritedInstanceCount(){return Object.keys(registeredInstances).length}function getLiveInheritedInstances(){var rv=[];for(var k in registeredInstances){if(registeredInstances.hasOwnProperty(k)){rv.push(registeredInstances[k]);}}return rv}function setDelayFunction(fn){delayFunction=fn;if(deletionQueue.length&&delayFunction){delayFunction(flushPendingDeletes);}}function init_embind(){Module["getInheritedInstanceCount"]=getInheritedInstanceCount;Module["getLiveInheritedInstances"]=getLiveInheritedInstances;Module["flushPendingDeletes"]=flushPendingDeletes;Module["setDelayFunction"]=setDelayFunction;}var registeredInstances={};function getBasestPointer(class_,ptr){if(ptr===undefined){throwBindingError("ptr should not be undefined");}while(class_.baseClass){ptr=class_.upcast(ptr);class_=class_.baseClass;}return ptr}function getInheritedInstance(class_,ptr){ptr=getBasestPointer(class_,ptr);return registeredInstances[ptr]}function makeClassHandle(prototype,record){if(!record.ptrType||!record.ptr){throwInternalError("makeClassHandle requires ptr and ptrType");}var hasSmartPtrType=!!record.smartPtrType;var hasSmartPtr=!!record.smartPtr;if(hasSmartPtrType!==hasSmartPtr){throwInternalError("Both smartPtrType and smartPtr must be specified");}record.count={value:1};return attachFinalizer(Object.create(prototype,{$$:{value:record}}))}function RegisteredPointer_fromWireType(ptr){var rawPointer=this.getPointee(ptr);if(!rawPointer){this.destructor(ptr);return null}var registeredInstance=getInheritedInstance(this.registeredClass,rawPointer);if(undefined!==registeredInstance){if(0===registeredInstance.$$.count.value){registeredInstance.$$.ptr=rawPointer;registeredInstance.$$.smartPtr=ptr;return registeredInstance["clone"]()}else {var rv=registeredInstance["clone"]();this.destructor(ptr);return rv}}function makeDefaultHandle(){if(this.isSmartPointer){return makeClassHandle(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:rawPointer,smartPtrType:this,smartPtr:ptr})}else {return makeClassHandle(this.registeredClass.instancePrototype,{ptrType:this,ptr:ptr})}}var actualType=this.registeredClass.getActualType(rawPointer);var registeredPointerRecord=registeredPointers[actualType];if(!registeredPointerRecord){return makeDefaultHandle.call(this)}var toType;if(this.isConst){toType=registeredPointerRecord.constPointerType;}else {toType=registeredPointerRecord.pointerType;}var dp=downcastPointer(rawPointer,this.registeredClass,toType.registeredClass);if(dp===null){return makeDefaultHandle.call(this)}if(this.isSmartPointer){return makeClassHandle(toType.registeredClass.instancePrototype,{ptrType:toType,ptr:dp,smartPtrType:this,smartPtr:ptr})}else {return makeClassHandle(toType.registeredClass.instancePrototype,{ptrType:toType,ptr:dp})}}function init_RegisteredPointer(){RegisteredPointer.prototype.getPointee=RegisteredPointer_getPointee;RegisteredPointer.prototype.destructor=RegisteredPointer_destructor;RegisteredPointer.prototype["argPackAdvance"]=8;RegisteredPointer.prototype["readValueFromPointer"]=simpleReadValueFromPointer;RegisteredPointer.prototype["deleteObject"]=RegisteredPointer_deleteObject;RegisteredPointer.prototype["fromWireType"]=RegisteredPointer_fromWireType;}function RegisteredPointer(name,registeredClass,isReference,isConst,isSmartPointer,pointeeType,sharingPolicy,rawGetPointee,rawConstructor,rawShare,rawDestructor){this.name=name;this.registeredClass=registeredClass;this.isReference=isReference;this.isConst=isConst;this.isSmartPointer=isSmartPointer;this.pointeeType=pointeeType;this.sharingPolicy=sharingPolicy;this.rawGetPointee=rawGetPointee;this.rawConstructor=rawConstructor;this.rawShare=rawShare;this.rawDestructor=rawDestructor;if(!isSmartPointer&&registeredClass.baseClass===undefined){if(isConst){this["toWireType"]=constNoSmartPtrRawPointerToWireType;this.destructorFunction=null;}else {this["toWireType"]=nonConstNoSmartPtrRawPointerToWireType;this.destructorFunction=null;}}else {this["toWireType"]=genericPointerToWireType;}}function replacePublicSymbol(name,value,numArguments){if(!Module.hasOwnProperty(name)){throwInternalError("Replacing nonexistant public symbol");}if(undefined!==Module[name].overloadTable&&undefined!==numArguments){Module[name].overloadTable[numArguments]=value;}else {Module[name]=value;Module[name].argCount=numArguments;}}function embind__requireFunction(signature,rawFunction){signature=readLatin1String(signature);function makeDynCaller(dynCall){var args=[];for(var i=1;i<signature.length;++i){args.push("a"+i);}var name="dynCall_"+signature+"_"+rawFunction;var body="return function "+name+"("+args.join(", ")+") {\n";body+="    return dynCall(rawFunction"+(args.length?", ":"")+args.join(", ")+");\n";body+="};\n";return new Function("dynCall","rawFunction",body)(dynCall,rawFunction)}var fp;if(Module["FUNCTION_TABLE_"+signature]!==undefined){fp=Module["FUNCTION_TABLE_"+signature][rawFunction];}else if(typeof FUNCTION_TABLE!=="undefined"){fp=FUNCTION_TABLE[rawFunction];}else {var dc=Module["dynCall_"+signature];if(dc===undefined){dc=Module["dynCall_"+signature.replace(/f/g,"d")];if(dc===undefined){throwBindingError("No dynCall invoker for signature: "+signature);}}fp=makeDynCaller(dc);}if(typeof fp!=="function"){throwBindingError("unknown function pointer with signature "+signature+": "+rawFunction);}return fp}var UnboundTypeError=undefined;function getTypeName(type){var ptr=___getTypeName(type);var rv=readLatin1String(ptr);_free(ptr);return rv}function throwUnboundTypeError(message,types){var unboundTypes=[];var seen={};function visit(type){if(seen[type]){return}if(registeredTypes[type]){return}if(typeDependencies[type]){typeDependencies[type].forEach(visit);return}unboundTypes.push(type);seen[type]=true;}types.forEach(visit);throw new UnboundTypeError(message+": "+unboundTypes.map(getTypeName).join([", "]))}function __embind_register_class(rawType,rawPointerType,rawConstPointerType,baseClassRawType,getActualTypeSignature,getActualType,upcastSignature,upcast,downcastSignature,downcast,name,destructorSignature,rawDestructor){name=readLatin1String(name);getActualType=embind__requireFunction(getActualTypeSignature,getActualType);if(upcast){upcast=embind__requireFunction(upcastSignature,upcast);}if(downcast){downcast=embind__requireFunction(downcastSignature,downcast);}rawDestructor=embind__requireFunction(destructorSignature,rawDestructor);var legalFunctionName=makeLegalFunctionName(name);exposePublicSymbol(legalFunctionName,function(){throwUnboundTypeError("Cannot construct "+name+" due to unbound types",[baseClassRawType]);});whenDependentTypesAreResolved([rawType,rawPointerType,rawConstPointerType],baseClassRawType?[baseClassRawType]:[],function(base){base=base[0];var baseClass;var basePrototype;if(baseClassRawType){baseClass=base.registeredClass;basePrototype=baseClass.instancePrototype;}else {basePrototype=ClassHandle.prototype;}var constructor=createNamedFunction(legalFunctionName,function(){if(Object.getPrototypeOf(this)!==instancePrototype){throw new BindingError("Use 'new' to construct "+name)}if(undefined===registeredClass.constructor_body){throw new BindingError(name+" has no accessible constructor")}var body=registeredClass.constructor_body[arguments.length];if(undefined===body){throw new BindingError("Tried to invoke ctor of "+name+" with invalid number of parameters ("+arguments.length+") - expected ("+Object.keys(registeredClass.constructor_body).toString()+") parameters instead!")}return body.apply(this,arguments)});var instancePrototype=Object.create(basePrototype,{constructor:{value:constructor}});constructor.prototype=instancePrototype;var registeredClass=new RegisteredClass(name,constructor,instancePrototype,rawDestructor,baseClass,getActualType,upcast,downcast);var referenceConverter=new RegisteredPointer(name,registeredClass,true,false,false);var pointerConverter=new RegisteredPointer(name+"*",registeredClass,false,false,false);var constPointerConverter=new RegisteredPointer(name+" const*",registeredClass,false,true,false);registeredPointers[rawType]={pointerType:pointerConverter,constPointerType:constPointerConverter};replacePublicSymbol(legalFunctionName,constructor);return [referenceConverter,pointerConverter,constPointerConverter]});}function heap32VectorToArray(count,firstElement){var array=[];for(var i=0;i<count;i++){array.push(HEAP32[(firstElement>>2)+i]);}return array}function runDestructors(destructors){while(destructors.length){var ptr=destructors.pop();var del=destructors.pop();del(ptr);}}function __embind_register_class_constructor(rawClassType,argCount,rawArgTypesAddr,invokerSignature,invoker,rawConstructor){var rawArgTypes=heap32VectorToArray(argCount,rawArgTypesAddr);invoker=embind__requireFunction(invokerSignature,invoker);whenDependentTypesAreResolved([],[rawClassType],function(classType){classType=classType[0];var humanName="constructor "+classType.name;if(undefined===classType.registeredClass.constructor_body){classType.registeredClass.constructor_body=[];}if(undefined!==classType.registeredClass.constructor_body[argCount-1]){throw new BindingError("Cannot register multiple constructors with identical number of parameters ("+(argCount-1)+") for class '"+classType.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!")}classType.registeredClass.constructor_body[argCount-1]=function unboundTypeHandler(){throwUnboundTypeError("Cannot construct "+classType.name+" due to unbound types",rawArgTypes);};whenDependentTypesAreResolved([],rawArgTypes,function(argTypes){classType.registeredClass.constructor_body[argCount-1]=function constructor_body(){if(arguments.length!==argCount-1){throwBindingError(humanName+" called with "+arguments.length+" arguments, expected "+(argCount-1));}var destructors=[];var args=new Array(argCount);args[0]=rawConstructor;for(var i=1;i<argCount;++i){args[i]=argTypes[i]["toWireType"](destructors,arguments[i-1]);}var ptr=invoker.apply(null,args);runDestructors(destructors);return argTypes[0]["fromWireType"](ptr)};return []});return []});}function new_(constructor,argumentList){if(!(constructor instanceof Function)){throw new TypeError("new_ called with constructor type "+typeof constructor+" which is not a function")}var dummy=createNamedFunction(constructor.name||"unknownFunctionName",function(){});dummy.prototype=constructor.prototype;var obj=new dummy;var r=constructor.apply(obj,argumentList);return r instanceof Object?r:obj}function craftInvokerFunction(humanName,argTypes,classType,cppInvokerFunc,cppTargetFunc){var argCount=argTypes.length;if(argCount<2){throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");}var isClassMethodFunc=argTypes[1]!==null&&classType!==null;var needsDestructorStack=false;for(var i=1;i<argTypes.length;++i){if(argTypes[i]!==null&&argTypes[i].destructorFunction===undefined){needsDestructorStack=true;break}}var returns=argTypes[0].name!=="void";var argsList="";var argsListWired="";for(var i=0;i<argCount-2;++i){argsList+=(i!==0?", ":"")+"arg"+i;argsListWired+=(i!==0?", ":"")+"arg"+i+"Wired";}var invokerFnBody="return function "+makeLegalFunctionName(humanName)+"("+argsList+") {\n"+"if (arguments.length !== "+(argCount-2)+") {\n"+"throwBindingError('function "+humanName+" called with ' + arguments.length + ' arguments, expected "+(argCount-2)+" args!');\n"+"}\n";if(needsDestructorStack){invokerFnBody+="var destructors = [];\n";}var dtorStack=needsDestructorStack?"destructors":"null";var args1=["throwBindingError","invoker","fn","runDestructors","retType","classParam"];var args2=[throwBindingError,cppInvokerFunc,cppTargetFunc,runDestructors,argTypes[0],argTypes[1]];if(isClassMethodFunc){invokerFnBody+="var thisWired = classParam.toWireType("+dtorStack+", this);\n";}for(var i=0;i<argCount-2;++i){invokerFnBody+="var arg"+i+"Wired = argType"+i+".toWireType("+dtorStack+", arg"+i+"); // "+argTypes[i+2].name+"\n";args1.push("argType"+i);args2.push(argTypes[i+2]);}if(isClassMethodFunc){argsListWired="thisWired"+(argsListWired.length>0?", ":"")+argsListWired;}invokerFnBody+=(returns?"var rv = ":"")+"invoker(fn"+(argsListWired.length>0?", ":"")+argsListWired+");\n";if(needsDestructorStack){invokerFnBody+="runDestructors(destructors);\n";}else {for(var i=isClassMethodFunc?1:2;i<argTypes.length;++i){var paramName=i===1?"thisWired":"arg"+(i-2)+"Wired";if(argTypes[i].destructorFunction!==null){invokerFnBody+=paramName+"_dtor("+paramName+"); // "+argTypes[i].name+"\n";args1.push(paramName+"_dtor");args2.push(argTypes[i].destructorFunction);}}}if(returns){invokerFnBody+="var ret = retType.fromWireType(rv);\n"+"return ret;\n";}invokerFnBody+="}\n";args1.push(invokerFnBody);var invokerFunction=new_(Function,args1).apply(null,args2);return invokerFunction}function __embind_register_class_function(rawClassType,methodName,argCount,rawArgTypesAddr,invokerSignature,rawInvoker,context,isPureVirtual){var rawArgTypes=heap32VectorToArray(argCount,rawArgTypesAddr);methodName=readLatin1String(methodName);rawInvoker=embind__requireFunction(invokerSignature,rawInvoker);whenDependentTypesAreResolved([],[rawClassType],function(classType){classType=classType[0];var humanName=classType.name+"."+methodName;if(isPureVirtual){classType.registeredClass.pureVirtualFunctions.push(methodName);}function unboundTypesHandler(){throwUnboundTypeError("Cannot call "+humanName+" due to unbound types",rawArgTypes);}var proto=classType.registeredClass.instancePrototype;var method=proto[methodName];if(undefined===method||undefined===method.overloadTable&&method.className!==classType.name&&method.argCount===argCount-2){unboundTypesHandler.argCount=argCount-2;unboundTypesHandler.className=classType.name;proto[methodName]=unboundTypesHandler;}else {ensureOverloadTable(proto,methodName,humanName);proto[methodName].overloadTable[argCount-2]=unboundTypesHandler;}whenDependentTypesAreResolved([],rawArgTypes,function(argTypes){var memberFunction=craftInvokerFunction(humanName,argTypes,classType,rawInvoker,context);if(undefined===proto[methodName].overloadTable){memberFunction.argCount=argCount-2;proto[methodName]=memberFunction;}else {proto[methodName].overloadTable[argCount-2]=memberFunction;}return []});return []});}function validateThis(this_,classType,humanName){if(!(this_ instanceof Object)){throwBindingError(humanName+' with invalid "this": '+this_);}if(!(this_ instanceof classType.registeredClass.constructor)){throwBindingError(humanName+' incompatible with "this" of type '+this_.constructor.name);}if(!this_.$$.ptr){throwBindingError("cannot call emscripten binding method "+humanName+" on deleted object");}return upcastPointer(this_.$$.ptr,this_.$$.ptrType.registeredClass,classType.registeredClass)}function __embind_register_class_property(classType,fieldName,getterReturnType,getterSignature,getter,getterContext,setterArgumentType,setterSignature,setter,setterContext){fieldName=readLatin1String(fieldName);getter=embind__requireFunction(getterSignature,getter);whenDependentTypesAreResolved([],[classType],function(classType){classType=classType[0];var humanName=classType.name+"."+fieldName;var desc={get:function(){throwUnboundTypeError("Cannot access "+humanName+" due to unbound types",[getterReturnType,setterArgumentType]);},enumerable:true,configurable:true};if(setter){desc.set=function(){throwUnboundTypeError("Cannot access "+humanName+" due to unbound types",[getterReturnType,setterArgumentType]);};}else {desc.set=function(v){throwBindingError(humanName+" is a read-only property");};}Object.defineProperty(classType.registeredClass.instancePrototype,fieldName,desc);whenDependentTypesAreResolved([],setter?[getterReturnType,setterArgumentType]:[getterReturnType],function(types){var getterReturnType=types[0];var desc={get:function(){var ptr=validateThis(this,classType,humanName+" getter");return getterReturnType["fromWireType"](getter(getterContext,ptr))},enumerable:true};if(setter){setter=embind__requireFunction(setterSignature,setter);var setterArgumentType=types[1];desc.set=function(v){var ptr=validateThis(this,classType,humanName+" setter");var destructors=[];setter(setterContext,ptr,setterArgumentType["toWireType"](destructors,v));runDestructors(destructors);};}Object.defineProperty(classType.registeredClass.instancePrototype,fieldName,desc);return []});return []});}var emval_free_list=[];var emval_handle_array=[{},{value:undefined},{value:null},{value:true},{value:false}];function __emval_decref(handle){if(handle>4&&0===--emval_handle_array[handle].refcount){emval_handle_array[handle]=undefined;emval_free_list.push(handle);}}function count_emval_handles(){var count=0;for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){++count;}}return count}function get_first_emval(){for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){return emval_handle_array[i]}}return null}function init_emval(){Module["count_emval_handles"]=count_emval_handles;Module["get_first_emval"]=get_first_emval;}function __emval_register(value){switch(value){case undefined:{return 1}case null:{return 2}case true:{return 3}case false:{return 4}default:{var handle=emval_free_list.length?emval_free_list.pop():emval_handle_array.length;emval_handle_array[handle]={refcount:1,value:value};return handle}}}function __embind_register_emval(rawType,name){name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(handle){var rv=emval_handle_array[handle].value;__emval_decref(handle);return rv},"toWireType":function(destructors,value){return __emval_register(value)},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:null});}function enumReadValueFromPointer(name,shift,signed){switch(shift){case 0:return function(pointer){var heap=signed?HEAP8:HEAPU8;return this["fromWireType"](heap[pointer])};case 1:return function(pointer){var heap=signed?HEAP16:HEAPU16;return this["fromWireType"](heap[pointer>>1])};case 2:return function(pointer){var heap=signed?HEAP32:HEAPU32;return this["fromWireType"](heap[pointer>>2])};default:throw new TypeError("Unknown integer type: "+name)}}function __embind_register_enum(rawType,name,size,isSigned){var shift=getShiftFromSize(size);name=readLatin1String(name);function ctor(){}ctor.values={};registerType(rawType,{name:name,constructor:ctor,"fromWireType":function(c){return this.constructor.values[c]},"toWireType":function(destructors,c){return c.value},"argPackAdvance":8,"readValueFromPointer":enumReadValueFromPointer(name,shift,isSigned),destructorFunction:null});exposePublicSymbol(name,ctor);}function requireRegisteredType(rawType,humanName){var impl=registeredTypes[rawType];if(undefined===impl){throwBindingError(humanName+" has unknown type "+getTypeName(rawType));}return impl}function __embind_register_enum_value(rawEnumType,name,enumValue){var enumType=requireRegisteredType(rawEnumType,"enum");name=readLatin1String(name);var Enum=enumType.constructor;var Value=Object.create(enumType.constructor.prototype,{value:{value:enumValue},constructor:{value:createNamedFunction(enumType.name+"_"+name,function(){})}});Enum.values[enumValue]=Value;Enum[name]=Value;}function _embind_repr(v){if(v===null){return "null"}var t=typeof v;if(t==="object"||t==="array"||t==="function"){return v.toString()}else {return ""+v}}function floatReadValueFromPointer(name,shift){switch(shift){case 2:return function(pointer){return this["fromWireType"](HEAPF32[pointer>>2])};case 3:return function(pointer){return this["fromWireType"](HEAPF64[pointer>>3])};default:throw new TypeError("Unknown float type: "+name)}}function __embind_register_float(rawType,name,size){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(value){return value},"toWireType":function(destructors,value){if(typeof value!=="number"&&typeof value!=="boolean"){throw new TypeError('Cannot convert "'+_embind_repr(value)+'" to '+this.name)}return value},"argPackAdvance":8,"readValueFromPointer":floatReadValueFromPointer(name,shift),destructorFunction:null});}function __embind_register_function(name,argCount,rawArgTypesAddr,signature,rawInvoker,fn){var argTypes=heap32VectorToArray(argCount,rawArgTypesAddr);name=readLatin1String(name);rawInvoker=embind__requireFunction(signature,rawInvoker);exposePublicSymbol(name,function(){throwUnboundTypeError("Cannot call "+name+" due to unbound types",argTypes);},argCount-1);whenDependentTypesAreResolved([],argTypes,function(argTypes){var invokerArgsArray=[argTypes[0],null].concat(argTypes.slice(1));replacePublicSymbol(name,craftInvokerFunction(name,invokerArgsArray,null,rawInvoker,fn),argCount-1);return []});}function integerReadValueFromPointer(name,shift,signed){switch(shift){case 0:return signed?function readS8FromPointer(pointer){return HEAP8[pointer]}:function readU8FromPointer(pointer){return HEAPU8[pointer]};case 1:return signed?function readS16FromPointer(pointer){return HEAP16[pointer>>1]}:function readU16FromPointer(pointer){return HEAPU16[pointer>>1]};case 2:return signed?function readS32FromPointer(pointer){return HEAP32[pointer>>2]}:function readU32FromPointer(pointer){return HEAPU32[pointer>>2]};default:throw new TypeError("Unknown integer type: "+name)}}function __embind_register_integer(primitiveType,name,size,minRange,maxRange){name=readLatin1String(name);if(maxRange===-1){maxRange=4294967295;}var shift=getShiftFromSize(size);var fromWireType=function(value){return value};if(minRange===0){var bitshift=32-8*size;fromWireType=function(value){return value<<bitshift>>>bitshift};}var isUnsignedType=name.indexOf("unsigned")!=-1;registerType(primitiveType,{name:name,"fromWireType":fromWireType,"toWireType":function(destructors,value){if(typeof value!=="number"&&typeof value!=="boolean"){throw new TypeError('Cannot convert "'+_embind_repr(value)+'" to '+this.name)}if(value<minRange||value>maxRange){throw new TypeError('Passing a number "'+_embind_repr(value)+'" from JS side to C/C++ side to an argument of type "'+name+'", which is outside the valid range ['+minRange+", "+maxRange+"]!")}return isUnsignedType?value>>>0:value|0},"argPackAdvance":8,"readValueFromPointer":integerReadValueFromPointer(name,shift,minRange!==0),destructorFunction:null});}function __embind_register_memory_view(rawType,dataTypeIndex,name){var typeMapping=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];var TA=typeMapping[dataTypeIndex];function decodeMemoryView(handle){handle=handle>>2;var heap=HEAPU32;var size=heap[handle];var data=heap[handle+1];return new TA(heap["buffer"],data,size)}name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":decodeMemoryView,"argPackAdvance":8,"readValueFromPointer":decodeMemoryView},{ignoreDuplicateRegistrations:true});}function __embind_register_std_string(rawType,name){name=readLatin1String(name);var stdStringIsUTF8=name==="std::string";registerType(rawType,{name:name,"fromWireType":function(value){var length=HEAPU32[value>>2];var str;if(stdStringIsUTF8){var endChar=HEAPU8[value+4+length];var endCharSwap=0;if(endChar!=0){endCharSwap=endChar;HEAPU8[value+4+length]=0;}var decodeStartPtr=value+4;for(var i=0;i<=length;++i){var currentBytePtr=value+4+i;if(HEAPU8[currentBytePtr]==0){var stringSegment=UTF8ToString(decodeStartPtr);if(str===undefined)str=stringSegment;else {str+=String.fromCharCode(0);str+=stringSegment;}decodeStartPtr=currentBytePtr+1;}}if(endCharSwap!=0)HEAPU8[value+4+length]=endCharSwap;}else {var a=new Array(length);for(var i=0;i<length;++i){a[i]=String.fromCharCode(HEAPU8[value+4+i]);}str=a.join("");}_free(value);return str},"toWireType":function(destructors,value){if(value instanceof ArrayBuffer){value=new Uint8Array(value);}var getLength;var valueIsOfTypeString=typeof value==="string";if(!(valueIsOfTypeString||value instanceof Uint8Array||value instanceof Uint8ClampedArray||value instanceof Int8Array)){throwBindingError("Cannot pass non-string to std::string");}if(stdStringIsUTF8&&valueIsOfTypeString){getLength=function(){return lengthBytesUTF8(value)};}else {getLength=function(){return value.length};}var length=getLength();var ptr=_malloc(4+length+1);HEAPU32[ptr>>2]=length;if(stdStringIsUTF8&&valueIsOfTypeString){stringToUTF8(value,ptr+4,length+1);}else {if(valueIsOfTypeString){for(var i=0;i<length;++i){var charCode=value.charCodeAt(i);if(charCode>255){_free(ptr);throwBindingError("String has UTF-16 code units that do not fit in 8 bits");}HEAPU8[ptr+4+i]=charCode;}}else {for(var i=0;i<length;++i){HEAPU8[ptr+4+i]=value[i];}}}if(destructors!==null){destructors.push(_free,ptr);}return ptr},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr);}});}function __embind_register_std_wstring(rawType,charSize,name){name=readLatin1String(name);var getHeap,shift;if(charSize===2){getHeap=function(){return HEAPU16};shift=1;}else if(charSize===4){getHeap=function(){return HEAPU32};shift=2;}registerType(rawType,{name:name,"fromWireType":function(value){var HEAP=getHeap();var length=HEAPU32[value>>2];var a=new Array(length);var start=value+4>>shift;for(var i=0;i<length;++i){a[i]=String.fromCharCode(HEAP[start+i]);}_free(value);return a.join("")},"toWireType":function(destructors,value){var HEAP=getHeap();var length=value.length;var ptr=_malloc(4+length*charSize);HEAPU32[ptr>>2]=length;var start=ptr+4>>shift;for(var i=0;i<length;++i){HEAP[start+i]=value.charCodeAt(i);}if(destructors!==null){destructors.push(_free,ptr);}return ptr},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr);}});}function __embind_register_void(rawType,name){name=readLatin1String(name);registerType(rawType,{isVoid:true,name:name,"argPackAdvance":0,"fromWireType":function(){return undefined},"toWireType":function(destructors,o){return undefined}});}function __emval_incref(handle){if(handle>4){emval_handle_array[handle].refcount+=1;}}function __emval_take_value(type,argv){type=requireRegisteredType(type,"_emval_take_value");var v=type["readValueFromPointer"](argv);return __emval_register(v)}function _abort(){Module["abort"]();}function _emscripten_get_heap_size(){return HEAP8.length}function _llvm_trap(){abort("trap!");}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);}function ___setErrNo(value){if(Module["___errno_location"])HEAP32[Module["___errno_location"]()>>2]=value;return value}function abortOnCannotGrowMemory(requestedSize){abort("OOM");}function emscripten_realloc_buffer(size){try{var newBuffer=new ArrayBuffer(size);if(newBuffer.byteLength!=size)return;new Int8Array(newBuffer).set(HEAP8);_emscripten_replace_memory(newBuffer);updateGlobalBufferAndViews(newBuffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=_emscripten_get_heap_size();var PAGE_MULTIPLE=16777216;var LIMIT=2147483648-PAGE_MULTIPLE;if(requestedSize>LIMIT){return false}var MIN_TOTAL_MEMORY=16777216;var newSize=Math.max(oldSize,MIN_TOTAL_MEMORY);while(newSize<requestedSize){if(newSize<=536870912){newSize=alignUp(2*newSize,PAGE_MULTIPLE);}else {newSize=Math.min(alignUp((3*newSize+2147483648)/4,PAGE_MULTIPLE),LIMIT);}}var replacement=emscripten_realloc_buffer(newSize);if(!replacement){return false}return true}embind_init_charCodes();BindingError=Module["BindingError"]=extendError(Error,"BindingError");InternalError=Module["InternalError"]=extendError(Error,"InternalError");init_ClassHandle();init_RegisteredPointer();init_embind();UnboundTypeError=Module["UnboundTypeError"]=extendError(Error,"UnboundTypeError");init_emval();var decodeBase64=typeof atob==="function"?atob:function(input){var keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var output="";var chr1,chr2,chr3;var enc1,enc2,enc3,enc4;var i=0;input=input.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{enc1=keyStr.indexOf(input.charAt(i++));enc2=keyStr.indexOf(input.charAt(i++));enc3=keyStr.indexOf(input.charAt(i++));enc4=keyStr.indexOf(input.charAt(i++));chr1=enc1<<2|enc2>>4;chr2=(enc2&15)<<4|enc3>>2;chr3=(enc3&3)<<6|enc4;output=output+String.fromCharCode(chr1);if(enc3!==64){output=output+String.fromCharCode(chr2);}if(enc4!==64){output=output+String.fromCharCode(chr3);}}while(i<input.length);return output};function intArrayFromBase64(s){try{var decoded=decodeBase64(s);var bytes=new Uint8Array(decoded.length);for(var i=0;i<decoded.length;++i){bytes[i]=decoded.charCodeAt(i);}return bytes}catch(_){throw new Error("Converting base64 string to bytes failed.")}}function tryParseAsDataURI(filename){if(!isDataURI(filename)){return}return intArrayFromBase64(filename.slice(dataURIPrefix.length))}var asmGlobalArg={"Math":Math,"Int8Array":Int8Array,"Int16Array":Int16Array,"Int32Array":Int32Array,"Uint8Array":Uint8Array,"Uint16Array":Uint16Array,"Float32Array":Float32Array,"Float64Array":Float64Array};var asmLibraryArg={"a":abort,"b":setTempRet0,"c":getTempRet0,"d":ClassHandle,"e":ClassHandle_clone,"f":ClassHandle_delete,"g":ClassHandle_deleteLater,"h":ClassHandle_isAliasOf,"i":ClassHandle_isDeleted,"j":RegisteredClass,"k":RegisteredPointer,"l":RegisteredPointer_deleteObject,"m":RegisteredPointer_destructor,"n":RegisteredPointer_fromWireType,"o":RegisteredPointer_getPointee,"p":___cxa_allocate_exception,"q":___cxa_begin_catch,"r":___cxa_pure_virtual,"s":___cxa_throw,"t":___cxa_uncaught_exceptions,"u":___exception_addRef,"v":___exception_deAdjust,"w":___gxx_personality_v0,"x":___setErrNo,"y":___syscall140,"z":___syscall146,"A":___syscall6,"B":__embind_register_bool,"C":__embind_register_class,"D":__embind_register_class_constructor,"E":__embind_register_class_function,"F":__embind_register_class_property,"G":__embind_register_emval,"H":__embind_register_enum,"I":__embind_register_enum_value,"J":__embind_register_float,"K":__embind_register_function,"L":__embind_register_integer,"M":__embind_register_memory_view,"N":__embind_register_std_string,"O":__embind_register_std_wstring,"P":__embind_register_void,"Q":__emval_decref,"R":__emval_incref,"S":__emval_register,"T":__emval_take_value,"U":_abort,"V":_embind_repr,"W":_emscripten_get_heap_size,"X":_emscripten_memcpy_big,"Y":_emscripten_resize_heap,"Z":_llvm_trap,"_":abortOnCannotGrowMemory,"$":attachFinalizer,"aa":constNoSmartPtrRawPointerToWireType,"ab":count_emval_handles,"ac":craftInvokerFunction,"ad":createNamedFunction,"ae":demangle,"af":demangleAll,"ag":detachFinalizer,"ah":downcastPointer,"ai":embind__requireFunction,"aj":embind_init_charCodes,"ak":emscripten_realloc_buffer,"al":ensureOverloadTable,"am":enumReadValueFromPointer,"an":exposePublicSymbol,"ao":extendError,"ap":floatReadValueFromPointer,"aq":flushPendingDeletes,"ar":flush_NO_FILESYSTEM,"as":genericPointerToWireType,"at":getBasestPointer,"au":getInheritedInstance,"av":getInheritedInstanceCount,"aw":getLiveInheritedInstances,"ax":getShiftFromSize,"ay":getTypeName,"az":get_first_emval,"aA":heap32VectorToArray,"aB":init_ClassHandle,"aC":init_RegisteredPointer,"aD":init_embind,"aE":init_emval,"aF":integerReadValueFromPointer,"aG":jsStackTrace,"aH":makeClassHandle,"aI":makeLegalFunctionName,"aJ":new_,"aK":nonConstNoSmartPtrRawPointerToWireType,"aL":readLatin1String,"aM":registerType,"aN":releaseClassHandle,"aO":replacePublicSymbol,"aP":requireRegisteredType,"aQ":runDestructor,"aR":runDestructors,"aS":setDelayFunction,"aT":shallowCopyInternalPointer,"aU":simpleReadValueFromPointer,"aV":stackTrace,"aW":throwBindingError,"aX":throwInstanceAlreadyDeleted,"aY":throwInternalError,"aZ":throwUnboundTypeError,"a_":upcastPointer,"a$":validateThis,"ba":whenDependentTypesAreResolved,"bb":tempDoublePtr,"bc":DYNAMICTOP_PTR};// EMSCRIPTEN_START_ASM
            var asm=(/** @suppress {uselessCode} */ function(global,env,buffer) {
            "almost asm";var a=new global.Int8Array(buffer),b=new global.Int16Array(buffer),c=new global.Int32Array(buffer),d=new global.Uint8Array(buffer),e=new global.Uint16Array(buffer),f=new global.Float32Array(buffer),g=new global.Float64Array(buffer),h=env.bb|0,i=env.bc|0,r=global.Math.floor,s=global.Math.abs,t=global.Math.sqrt,u=global.Math.cos,v=global.Math.sin,w=global.Math.tan,x=global.Math.acos,y=global.Math.atan2,z=global.Math.ceil,A=global.Math.imul,B=global.Math.min,C=global.Math.clz32,D=env.a,E=env.b,F=env.c,G=env.d,H=env.e,I=env.f,J=env.g,K=env.h,L=env.i,M=env.j,N=env.k,O=env.l,P=env.m,Q=env.n,R=env.o,S=env.p,T=env.q,U=env.r,V=env.s,W=env.t,X=env.u,Y=env.v,Z=env.w,_=env.x,$=env.y,aa=env.z,ba=env.A,ca=env.B,da=env.C,ea=env.D,fa=env.E,ga=env.F,ha=env.G,ia=env.H,ja=env.I,ka=env.J,la=env.K,ma=env.L,na=env.M,oa=env.N,pa=env.O,qa=env.P,ra=env.Q,sa=env.R,ta=env.S,ua=env.T,va=env.U,wa=env.V,xa=env.W,ya=env.X,za=env.Y,Aa=env.Z,Ba=env._,Ca=env.$,Da=env.aa,Ea=env.ab,Fa=env.ac,Ga=env.ad,Ha=env.ae,Ia=env.af,Ja=env.ag,Ka=env.ah,La=env.ai,Ma=env.aj,Na=env.ak,Oa=env.al,Pa=env.am,Qa=env.an,Ra=env.ao,Sa=env.ap,Ta=env.aq,Ua=env.ar,Va=env.as,Wa=env.at,Xa=env.au,Ya=env.av,Za=env.aw,_a=env.ax,$a=env.ay,ab=env.az,bb=env.aA,cb=env.aB,db=env.aC,eb=env.aD,fb=env.aE,gb=env.aF,hb=env.aG,ib=env.aH,jb=env.aI,kb=env.aJ,lb=env.aK,mb=env.aL,nb=env.aM,ob=env.aN,pb=env.aO,qb=env.aP,rb=env.aQ,sb=env.aR,tb=env.aS,ub=env.aT,vb=env.aU,wb=env.aV,xb=env.aW,yb=env.aX,zb=env.aY,Ab=env.aZ,Bb=env.a_,Cb=env.a$,Db=env.ba,Eb=18992;function Hb(newBuffer){a=new Int8Array(newBuffer);d=new Uint8Array(newBuffer);b=new Int16Array(newBuffer);e=new Uint16Array(newBuffer);c=new Int32Array(newBuffer);f=new Float32Array(newBuffer);g=new Float64Array(newBuffer);buffer=newBuffer;return true}
            // EMSCRIPTEN_START_FUNCS
            function ld(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;d=c[b+80>>2]|0;m=d+32|0;f=b+32|0;e=c[f>>2]|0;f=c[f+4>>2]|0;if((((c[m>>2]|0)==(e|0)?(c[m+4>>2]|0)==(f|0):0)?(l=d+40|0,m=b+40|0,(c[l>>2]|0)==(c[m>>2]|0)?(c[l+4>>2]|0)==(c[m+4>>2]|0):0):0)?(c[d+88>>2]|0)==0:0){n=d;d=7;}else d=4;if((((d|0)==4?(h=c[b+84>>2]|0,m=h+32|0,(c[m>>2]|0)==(e|0)?(c[m+4>>2]|0)==(f|0):0):0)?(l=h+40|0,m=b+40|0,(c[l>>2]|0)==(c[m>>2]|0)?(c[l+4>>2]|0)==(c[m+4>>2]|0):0):0)?(c[h+88>>2]|0)==0:0){n=h;d=7;}do if((d|0)==7?(j=n+76|0,(c[j>>2]|0)!=-2):0){l=n+92|0;m=n+96|0;if((c[l>>2]|0)==(c[m>>2]|0)?!(+g[n+48>>3]==-1.e+40):0)break;k=b+92|0;d=c[k>>2]|0;if((d|0)!=(n|0)&(d|0)!=0){e=b+32|0;do{ed(a,b,d,e);Lc(a,b,d);d=c[k>>2]|0;}while((d|0)!=(n|0)&(d|0)!=0)}f=b+76|0;e=c[f>>2]|0;if((e|0)==-1)if((c[j>>2]|0)==-1){e=b+96|0;f=c[e>>2]|0;h=(f|0)!=0;i=(d|0)!=0;if(!(!(i|h)?(c[a+52>>2]|0)!=(b|0):0)){c[(h?f+92|0:a+52|0)>>2]=d;if(i)c[d+96>>2]=f;c[k>>2]=0;c[e>>2]=0;}d=c[m>>2]|0;e=c[l>>2]|0;f=(d|0)!=0;h=(e|0)!=0;if(!(f|h)?(c[a+52>>2]|0)!=(n|0):0)return;c[(f?d+92|0:a+52|0)>>2]=e;if(h)c[e+96>>2]=d;c[l>>2]=0;c[m>>2]=0;return}else e=0;else if((e|0)>-1)if((c[j>>2]|0)>-1){d=b+32|0;bd(a,b,d)|0;if(!(c[n+64>>2]|0))bd(a,n,d)|0;d=c[f>>2]|0;e=c[j>>2]|0;do if((d|0)!=(e|0))if((d|0)<(e|0)){cd(a,b,n);break}else {cd(a,n,b);break}else {c[f>>2]=-1;c[j>>2]=-1;}while(0);d=b+96|0;e=c[d>>2]|0;f=c[k>>2]|0;h=(e|0)!=0;i=(f|0)!=0;if(!(!(h|i)?(c[a+52>>2]|0)!=(b|0):0)){c[(h?e+92|0:a+52|0)>>2]=f;if(i)c[f+96>>2]=e;c[k>>2]=0;c[d>>2]=0;}d=c[m>>2]|0;e=c[l>>2]|0;f=(d|0)!=0;h=(e|0)!=0;if(!(f|h)?(c[a+52>>2]|0)!=(n|0):0)return;c[(f?d+92|0:a+52|0)>>2]=e;if(h)c[e+96>>2]=d;c[l>>2]=0;c[m>>2]=0;return}else e=1;else e=0;if(c[b+64>>2]|0){a=S(16)|0;Bc(a,7656);V(a|0,1024,9);}if(e){bd(a,b,b+32|0)|0;c[f>>2]=-1;d=c[k>>2]|0;}e=b+96|0;f=c[e>>2]|0;h=(f|0)!=0;i=(d|0)!=0;if(!(!(h|i)?(c[a+52>>2]|0)!=(b|0):0)){c[(h?f+92|0:a+52|0)>>2]=d;if(i)c[d+96>>2]=f;c[k>>2]=0;c[e>>2]=0;}if((c[j>>2]|0)>-1){bd(a,n,b+32|0)|0;c[j>>2]=-1;}d=c[m>>2]|0;e=c[l>>2]|0;f=(d|0)!=0;h=(e|0)!=0;if(!(f|h)?(c[a+52>>2]|0)!=(n|0):0)return;c[(f?d+92|0:a+52|0)>>2]=e;if(h)c[e+96>>2]=d;c[l>>2]=0;c[m>>2]=0;return}while(0);if((c[b+76>>2]|0)>-1)bd(a,b,b+32|0)|0;d=b+96|0;e=c[d>>2]|0;f=b+92|0;h=c[f>>2]|0;i=(e|0)!=0;j=(h|0)!=0;if(!(i|j)?(c[a+52>>2]|0)!=(b|0):0)return;c[(i?e+92|0:a+52|0)>>2]=h;if(j)c[h+96>>2]=e;c[f>>2]=0;c[d>>2]=0;return}function md(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;j=a+8|0;d=c[a>>2]|0;f=d;if((((c[j>>2]|0)-d|0)/12|0)>>>0>=b>>>0)return;k=a+4|0;if(b>>>0>357913941){k=S(8)|0;dk(k,8694);c[k>>2]=7328;V(k|0,3264,87);}g=c[k>>2]|0;h=Zj(b*12|0)|0;e=h+(((g-d|0)/12|0)*12|0)|0;i=e;h=h+(b*12|0)|0;b=g;if((b|0)!=(f|0)){d=b;do{l=e;e=e+-12|0;b=d;d=d+-12|0;c[e>>2]=0;m=l+-8|0;c[m>>2]=0;l=l+-4|0;c[l>>2]=0;c[e>>2]=c[d>>2];g=b+-8|0;c[m>>2]=c[g>>2];b=b+-4|0;c[l>>2]=c[b>>2];c[b>>2]=0;c[g>>2]=0;c[d>>2]=0;}while((d|0)!=(f|0));d=c[a>>2]|0;b=c[k>>2]|0;g=d;c[a>>2]=e;c[k>>2]=i;c[j>>2]=h;if((b|0)!=(g|0))do{e=b;b=b+-12|0;f=c[b>>2]|0;if(f|0){c[e+-8>>2]=f;$j(f);}}while((b|0)!=(g|0))}else {c[a>>2]=i;c[k>>2]=i;c[j>>2]=h;}if(!d)return;$j(d);return}function nd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;f=a+8|0;g=c[a>>2]|0;if((c[f>>2]|0)-g>>4>>>0>=b>>>0)return;h=a+4|0;if(b>>>0>268435455){h=S(8)|0;dk(h,8694);c[h>>2]=7328;V(h|0,3264,87);}d=(c[h>>2]|0)-g|0;e=Zj(b<<4)|0;if((d|0)>0)ax(e|0,g|0,d|0)|0;c[a>>2]=e;c[h>>2]=e+(d>>4<<4);c[f>>2]=e+(b<<4);if(!g)return;$j(g);return}function od(a,b){a=a|0;b=b|0;var d=0,e=0;d=a+4|0;e=c[d>>2]|0;if((e|0)==(c[a+8>>2]|0)){Ge(a,b);return}else {c[e>>2]=c[b>>2];c[e+4>>2]=c[b+4>>2];c[e+8>>2]=c[b+8>>2];c[e+12>>2]=c[b+12>>2];c[d>>2]=(c[d>>2]|0)+16;return}}function pd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;j=a+4|0;g=c[j>>2]|0;if((g|0)==(c[a+8>>2]|0)){He(a,b);return}c[g>>2]=0;i=g+4|0;c[i>>2]=0;e=g+8|0;c[e>>2]=0;h=b+4|0;a=(c[h>>2]|0)-(c[b>>2]|0)|0;d=a>>4;if(a|0){if(d>>>0>268435455)gk();f=Zj(a)|0;c[i>>2]=f;c[g>>2]=f;c[e>>2]=f+(d<<4);d=c[b>>2]|0;a=(c[h>>2]|0)-d|0;if((a|0)>0){ax(f|0,d|0,a|0)|0;c[i>>2]=f+(a>>>4<<4);}}c[j>>2]=(c[j>>2]|0)+12;return}function qd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;f=a+8|0;g=c[a>>2]|0;if((c[f>>2]|0)-g>>2>>>0>=b>>>0)return;h=a+4|0;if(b>>>0>1073741823){h=S(8)|0;dk(h,8694);c[h>>2]=7328;V(h|0,3264,87);}d=(c[h>>2]|0)-g|0;e=Zj(b<<2)|0;if((d|0)>0)ax(e|0,g|0,d|0)|0;c[a>>2]=e;c[h>>2]=e+(d>>2<<2);c[f>>2]=e+(b<<2);if(!g)return;$j(g);return}function rd(a,b){a=a|0;b=b|0;var d=0,e=0;d=a+4|0;e=c[d>>2]|0;if((e|0)==(c[a+8>>2]|0)){Ye(a,b);return}else {c[e>>2]=c[b>>2];c[d>>2]=(c[d>>2]|0)+4;return}}function sd(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0;m=a+8|0;n=c[m>>2]|0;m=c[m+4>>2]|0;B=b+8|0;u=c[B+4>>2]|0;B=(m|0)<(u|0)|((m|0)==(u|0)?n>>>0<=(c[B>>2]|0)>>>0:0);u=d+8|0;t=c[u>>2]|0;u=c[u+4>>2]|0;s=e+8|0;l=c[s+4>>2]|0;s=(u|0)<(l|0)|((u|0)==(l|0)?t>>>0<=(c[s>>2]|0)>>>0:0);if(!(B^s)){g=0;return g|0}e=c[a+24>>2]|0;l=e+8|0;k=c[l>>2]|0;l=c[l+4>>2]|0;i=f;b=c[i>>2]|0;i=c[i+4>>2]|0;do if(B){a:do if(!((l|0)>(i|0)|(l|0)==(i|0)&k>>>0>b>>>0)?(r=f+8|0,q=c[r>>2]|0,r=c[r+4>>2]|0,!((l|0)<(m|0)|(l|0)==(m|0)&k>>>0<n>>>0)):0)while(1){p=e+16|0;if(!((c[p>>2]|0)==(q|0)?(c[p+4>>2]|0)==(r|0):0))break a;l=c[e+24>>2]|0;k=l+8|0;a=c[k>>2]|0;k=c[k+4>>2]|0;if((k|0)>(i|0)|(k|0)==(i|0)&a>>>0>b>>>0){a=e;e=l;break a}p=e+8|0;o=c[p+4>>2]|0;if((k|0)<(o|0)|((k|0)==(o|0)?a>>>0<(c[p>>2]|0)>>>0:0)){a=e;e=l;break}else {a=e;e=l;}}while(0);if(g){r=a+8|0;a=((c[r>>2]|0)==(b|0)?(c[r+4>>2]|0)==(i|0):0)?a:e;}l=Zj(32)|0;e=l+8|0;k=a+8|0;c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];c[e+8>>2]=c[k+8>>2];c[e+12>>2]=c[k+12>>2];k=c[a>>2]|0;c[l>>2]=k;if(g){r=a+28|0;q=c[r>>2]|0;c[l+28>>2]=q;c[l+24>>2]=a;c[q+24>>2]=l;c[r>>2]=l;}else {r=a+24|0;q=c[r>>2]|0;c[l+24>>2]=q;c[l+28>>2]=a;c[q+28>>2]=l;c[r>>2]=l;}r=e;if(((c[r>>2]|0)==(b|0)?(c[r+4>>2]|0)==(i|0):0)?(q=l+16|0,r=f+8|0,(c[q>>2]|0)==(c[r>>2]|0)?(c[q+4>>2]|0)==(c[r+4>>2]|0):0):0){m=l;l=a;break}c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];c[e+8>>2]=c[f+8>>2];c[e+12>>2]=c[f+12>>2];e=Zj(32)|0;r=e+8|0;c[r>>2]=c[f>>2];c[r+4>>2]=c[f+4>>2];c[r+8>>2]=c[f+8>>2];c[r+12>>2]=c[f+12>>2];c[e>>2]=k;if(g){m=l+28|0;r=c[m>>2]|0;c[e+28>>2]=r;c[e+24>>2]=l;c[r+24>>2]=e;c[m>>2]=e;m=e;break}else {m=l+24|0;r=c[m>>2]|0;c[e+24>>2]=r;c[e+28>>2]=l;c[r+28>>2]=e;c[m>>2]=e;m=e;break}}else {b:do if(!((l|0)<(i|0)|(l|0)==(i|0)&k>>>0<b>>>0)?(p=f+8|0,o=c[p>>2]|0,p=c[p+4>>2]|0,!((l|0)>(m|0)|(l|0)==(m|0)&k>>>0>n>>>0)):0)while(1){r=e+16|0;if(!((c[r>>2]|0)==(o|0)?(c[r+4>>2]|0)==(p|0):0))break b;l=c[e+24>>2]|0;k=l+8|0;a=c[k>>2]|0;k=c[k+4>>2]|0;if((k|0)<(i|0)|(k|0)==(i|0)&a>>>0<b>>>0){a=e;e=l;break b}r=e+8|0;q=c[r+4>>2]|0;if((k|0)>(q|0)|((k|0)==(q|0)?a>>>0>(c[r>>2]|0)>>>0:0)){a=e;e=l;break}else {a=e;e=l;}}while(0);if(!g){r=a+8|0;a=((c[r>>2]|0)==(b|0)?(c[r+4>>2]|0)==(i|0):0)?a:e;}l=Zj(32)|0;e=l+8|0;k=a+8|0;c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];c[e+8>>2]=c[k+8>>2];c[e+12>>2]=c[k+12>>2];k=c[a>>2]|0;c[l>>2]=k;if(g){r=a+24|0;q=c[r>>2]|0;c[l+24>>2]=q;c[l+28>>2]=a;c[q+28>>2]=l;c[r>>2]=l;}else {r=a+28|0;q=c[r>>2]|0;c[l+28>>2]=q;c[l+24>>2]=a;c[q+24>>2]=l;c[r>>2]=l;}r=e;if(((c[r>>2]|0)==(b|0)?(c[r+4>>2]|0)==(i|0):0)?(q=l+16|0,r=f+8|0,(c[q>>2]|0)==(c[r>>2]|0)?(c[q+4>>2]|0)==(c[r+4>>2]|0):0):0){m=l;l=a;break}c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];c[e+8>>2]=c[f+8>>2];c[e+12>>2]=c[f+12>>2];e=Zj(32)|0;r=e+8|0;c[r>>2]=c[f>>2];c[r+4>>2]=c[f+4>>2];c[r+8>>2]=c[f+8>>2];c[r+12>>2]=c[f+12>>2];c[e>>2]=k;if(g){m=l+24|0;r=c[m>>2]|0;c[e+24>>2]=r;c[e+28>>2]=l;c[r+28>>2]=e;c[m>>2]=e;m=e;break}else {m=l+28|0;r=c[m>>2]|0;c[e+28>>2]=r;c[e+24>>2]=l;c[r+24>>2]=e;c[m>>2]=e;m=e;break}}while(0);e=c[d+24>>2]|0;k=e+8|0;a=c[k>>2]|0;k=c[k+4>>2]|0;do if(s){c:do if(!((k|0)>(i|0)|(k|0)==(i|0)&a>>>0>b>>>0)?(w=f+8|0,v=c[w>>2]|0,w=c[w+4>>2]|0,h=f,j=c[h>>2]|0,h=c[h+4>>2]|0,!((k|0)<(u|0)|(k|0)==(u|0)&a>>>0<t>>>0)):0){a=e;while(1){A=a+16|0;if(!((c[A>>2]|0)==(v|0)?(c[A+4>>2]|0)==(w|0):0)){e=a;j=b;h=i;break c}e=c[a+24>>2]|0;b=e+8|0;d=c[b>>2]|0;b=c[b+4>>2]|0;if((b|0)>(h|0)|(b|0)==(h|0)&d>>>0>j>>>0){d=a;break c}A=a+8|0;z=c[A+4>>2]|0;if((b|0)<(z|0)|((b|0)==(z|0)?d>>>0<(c[A>>2]|0)>>>0:0)){d=a;break}else {d=a;a=e;b=j;i=h;}}}else {j=b;h=i;}while(0);if(g){A=d+8|0;d=((c[A>>2]|0)==(j|0)?(c[A+4>>2]|0)==(h|0):0)?d:e;}i=Zj(32)|0;b=i+8|0;e=d+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=c[e+4>>2];c[b+8>>2]=c[e+8>>2];c[b+12>>2]=c[e+12>>2];e=c[d>>2]|0;c[i>>2]=e;if(g){A=d+28|0;z=c[A>>2]|0;c[i+28>>2]=z;c[i+24>>2]=d;c[z+24>>2]=i;c[A>>2]=i;}else {A=d+24|0;z=c[A>>2]|0;c[i+24>>2]=z;c[i+28>>2]=d;c[z+28>>2]=i;c[A>>2]=i;}A=b;if(((c[A>>2]|0)==(j|0)?(c[A+4>>2]|0)==(h|0):0)?(z=i+16|0,A=f+8|0,(c[z>>2]|0)==(c[A>>2]|0)?(c[z+4>>2]|0)==(c[A+4>>2]|0):0):0){b=i;e=68;break}c[b>>2]=c[f>>2];c[b+4>>2]=c[f+4>>2];c[b+8>>2]=c[f+8>>2];c[b+12>>2]=c[f+12>>2];b=Zj(32)|0;A=b+8|0;c[A>>2]=c[f>>2];c[A+4>>2]=c[f+4>>2];c[A+8>>2]=c[f+8>>2];c[A+12>>2]=c[f+12>>2];c[b>>2]=e;if(g){f=i+28|0;A=c[f>>2]|0;c[b+28>>2]=A;c[b+24>>2]=i;c[A+24>>2]=b;c[f>>2]=b;if(B^g){d=i;e=70;break}else {d=i;e=69;break}}else {f=i+24|0;A=c[f>>2]|0;c[b+24>>2]=A;c[b+28>>2]=i;c[A+28>>2]=b;c[f>>2]=b;if(B^g){d=i;e=70;break}else {d=i;e=69;break}}}else {d:do if(!((k|0)<(i|0)|(k|0)==(i|0)&a>>>0<b>>>0)?(y=f+8|0,x=c[y>>2]|0,y=c[y+4>>2]|0,A=f,z=c[A>>2]|0,A=c[A+4>>2]|0,!((k|0)>(u|0)|(k|0)==(u|0)&a>>>0>t>>>0)):0){j=b;h=i;while(1){w=e+16|0;if(!((c[w>>2]|0)==(x|0)?(c[w+4>>2]|0)==(y|0):0))break d;h=c[e+24>>2]|0;b=h+8|0;d=c[b>>2]|0;b=c[b+4>>2]|0;if((b|0)<(A|0)|(b|0)==(A|0)&d>>>0<z>>>0){d=e;e=h;j=z;h=A;break d}w=e+8|0;v=c[w+4>>2]|0;if((b|0)>(v|0)|((b|0)==(v|0)?d>>>0>(c[w>>2]|0)>>>0:0)){d=e;e=h;j=z;h=A;break}else {d=e;e=h;j=z;h=A;}}}else {j=b;h=i;}while(0);if(!g){A=d+8|0;d=((c[A>>2]|0)==(j|0)?(c[A+4>>2]|0)==(h|0):0)?d:e;}i=Zj(32)|0;b=i+8|0;e=d+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=c[e+4>>2];c[b+8>>2]=c[e+8>>2];c[b+12>>2]=c[e+12>>2];e=c[d>>2]|0;c[i>>2]=e;if(g){A=d+24|0;z=c[A>>2]|0;c[i+24>>2]=z;c[i+28>>2]=d;c[z+28>>2]=i;c[A>>2]=i;}else {A=d+28|0;z=c[A>>2]|0;c[i+28>>2]=z;c[i+24>>2]=d;c[z+24>>2]=i;c[A>>2]=i;}A=b;if(((c[A>>2]|0)==(j|0)?(c[A+4>>2]|0)==(h|0):0)?(z=i+16|0,A=f+8|0,(c[z>>2]|0)==(c[A>>2]|0)?(c[z+4>>2]|0)==(c[A+4>>2]|0):0):0){b=i;e=68;break}c[b>>2]=c[f>>2];c[b+4>>2]=c[f+4>>2];c[b+8>>2]=c[f+8>>2];c[b+12>>2]=c[f+12>>2];b=Zj(32)|0;A=b+8|0;c[A>>2]=c[f>>2];c[A+4>>2]=c[f+4>>2];c[A+8>>2]=c[f+8>>2];c[A+12>>2]=c[f+12>>2];c[b>>2]=e;if(g){g=i+24|0;f=c[g>>2]|0;c[b+24>>2]=f;c[b+28>>2]=i;c[f+28>>2]=b;c[g>>2]=b;if(B){d=i;e=69;break}else {d=i;e=70;break}}else {g=i+28|0;f=c[g>>2]|0;c[b+28>>2]=f;c[b+24>>2]=i;c[f+24>>2]=b;c[g>>2]=b;if(B){d=i;e=70;break}else {d=i;e=69;break}}}while(0);if((e|0)==68)if(B^g)e=70;else e=69;if((e|0)==69){c[l+28>>2]=d;c[d+24>>2]=l;c[m+24>>2]=b;c[b+28>>2]=m;g=1;return g|0}else if((e|0)==70){c[l+24>>2]=d;c[d+28>>2]=l;c[m+28>>2]=b;c[b+24>>2]=m;g=1;return g|0}return 0}function td(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0;O=Eb;Eb=Eb+32|0;H=O+16|0;I=O;G=c[d>>2]|0;N=d+4|0;A=c[N>>2]|0;M=G+8|0;i=G+16|0;L=i;K=c[L>>2]|0;L=c[L+4>>2]|0;E=d+16|0;D=c[E>>2]|0;E=c[E+4>>2]|0;if(!((K|0)==(D|0)&(L|0)==(E|0))){C=G+24|0;g=c[C>>2]|0;i=g+8|0;h=c[i>>2]|0;i=c[i+4>>2]|0;u=M;t=c[u>>2]|0;u=c[u+4>>2]|0;a:do if((h|0)==(t|0)&(i|0)==(u|0))do{I=g+16|0;if((g|0)==(G|0)|((c[I>>2]|0)!=(K|0)?1:(c[I+4>>2]|0)!=(L|0)))break a;g=c[g+24>>2]|0;I=g+8|0;}while((c[I>>2]|0)==(h|0)?(c[I+4>>2]|0)==(i|0):0);else {h=t;i=u;}while(0);k=g+16|0;j=c[k>>2]|0;k=c[k+4>>2]|0;do if(!((L|0)<(k|0)|(L|0)==(k|0)&K>>>0<j>>>0)){m=g+8|0;l=c[m>>2]|0;m=c[m+4>>2]|0;s=d+8|0;r=c[s>>2]|0;s=c[s+4>>2]|0;I=(a[b+20>>0]|0)==0;n=Ww(K|0,L|0,j|0,k|0)|0;o=F()|0;p=Ww(l|0,m|0,r|0,s|0)|0;q=F()|0;if(I){B=Uw(p|0,q|0,n|0,o|0)|0;I=F()|0;y=Ww(t|0,u|0,l|0,m|0)|0;z=F()|0;H=Ww(j|0,k|0,D|0,E|0)|0;H=Uw(y|0,z|0,H|0,F()|0)|0;if((B|0)==(H|0)&(I|0)==(F()|0)){z=g;B=0;y=0;p=r;q=s;break}else {J=56;break}}else {Q=(o|0)<0;S=_w(n|0,o|0,63)|0;F()|0;w=(q|0)<0;v=_w(p|0,q|0,63)|0;F()|0;v=(S|0)==(v|0);S=Ww(0,0,n|0,o|0)|0;P=F()|0;S=Q?S:n;P=Q?P:o;Q=Ww(0,0,p|0,q|0)|0;n=F()|0;Q=w?Q:p;n=w?n:q;w=Uw(n|0,0,P|0,0)|0;R=F()|0;o=Uw(Q|0,0,S|0,0)|0;y=F()|0;P=Uw(Q|0,0,P|0,0)|0;Q=F()|0;S=Uw(n|0,0,S|0,0)|0;S=Vw(P|0,Q|0,S|0,F()|0)|0;R=Vw(F()|0,0,w|0,R|0)|0;w=F()|0;S=Vw(0,S|0,o|0,y|0)|0;Q=F()|0;o=Vw(R|0,w|0,(Q>>>0<y>>>0|(Q|0)==(y|0)&S>>>0<o>>>0)&1|0,0)|0;y=F()|0;w=(S|0)==0&(Q|0)==0;R=Ww(0,0,S|0,Q|0)|0;P=F()|0;n=Ww(0,0,o|0,y|0)|0;x=F()|0;p=Ww(t|0,u|0,l|0,m|0)|0;l=F()|0;m=Ww(j|0,k|0,D|0,E|0)|0;j=F()|0;B=(l|0)<0;I=_w(p|0,l|0,63)|0;F()|0;k=(j|0)<0;z=_w(m|0,j|0,63)|0;F()|0;z=(I|0)==(z|0);I=Ww(0,0,p|0,l|0)|0;q=F()|0;p=B?I:p;l=B?q:l;q=Ww(0,0,m|0,j|0)|0;B=F()|0;m=k?q:m;j=k?B:j;B=Uw(l|0,0,j|0,0)|0;k=F()|0;q=Uw(p|0,0,m|0,0)|0;I=F()|0;m=Uw(l|0,0,m|0,0)|0;l=F()|0;j=Uw(p|0,0,j|0,0)|0;j=Vw(m|0,l|0,j|0,F()|0)|0;k=Vw(F()|0,0,B|0,k|0)|0;B=F()|0;j=Vw(0,j|0,q|0,I|0)|0;l=F()|0;q=Vw(k|0,B|0,(l>>>0<I>>>0|(l|0)==(I|0)&j>>>0<q>>>0)&1|0,0)|0;I=F()|0;B=(j|0)==0&(l|0)==0;k=Ww(0,0,j|0,l|0)|0;m=F()|0;p=Ww(0,0,q|0,I|0)|0;H=F()|0;if((((v?S:R)|0)==((z?j:k)|0)?((v?Q:P)|0)==((z?l:m)|0):0)&(((v?o:w?n:~o)|0)==((z?q:B?p:~q)|0)?((v?y:w?x:~y)|0)==((z?I:B?H:~I)|0):0)){z=g;B=0;y=1;p=r;q=s;break}else {J=56;break}}}else J=56;while(0);do if((J|0)==56){g=c[G+28>>2]|0;S=g+8|0;b:do if((c[S>>2]|0)==(h|0)?(c[S+4>>2]|0)==(i|0):0)do{S=g+16|0;if((g|0)==(G|0)|((c[S>>2]|0)!=(K|0)?1:(c[S+4>>2]|0)!=(L|0)))break b;g=c[g+28>>2]|0;S=g+8|0;}while((c[S>>2]|0)==(h|0)?(c[S+4>>2]|0)==(i|0):0);while(0);m=g+16|0;l=c[m>>2]|0;m=c[m+4>>2]|0;if((L|0)<(m|0)|(L|0)==(m|0)&K>>>0<l>>>0){S=0;Eb=O;return S|0}o=g+8|0;n=c[o>>2]|0;o=c[o+4>>2]|0;q=d+8|0;p=c[q>>2]|0;q=c[q+4>>2]|0;S=(a[b+20>>0]|0)==0;h=Ww(K|0,L|0,l|0,m|0)|0;i=F()|0;j=Ww(n|0,o|0,p|0,q|0)|0;k=F()|0;if(S){Q=Uw(j|0,k|0,h|0,i|0)|0;S=F()|0;L=Ww(t|0,u|0,n|0,o|0)|0;P=F()|0;R=Ww(l|0,m|0,D|0,E|0)|0;R=Uw(L|0,P|0,R|0,F()|0)|0;if((Q|0)==(R|0)&(S|0)==(F()|0)){z=g;B=1;y=0;break}else g=0;Eb=O;return g|0}else {b=(i|0)<0;r=_w(h|0,i|0,63)|0;F()|0;d=(k|0)<0;I=_w(j|0,k|0,63)|0;F()|0;I=(r|0)==(I|0);r=Ww(0,0,h|0,i|0)|0;v=F()|0;r=b?r:h;v=b?v:i;b=Ww(0,0,j|0,k|0)|0;y=F()|0;b=d?b:j;y=d?y:k;d=Uw(y|0,0,v|0,0)|0;s=F()|0;z=Uw(b|0,0,r|0,0)|0;L=F()|0;v=Uw(b|0,0,v|0,0)|0;b=F()|0;r=Uw(y|0,0,r|0,0)|0;r=Vw(v|0,b|0,r|0,F()|0)|0;s=Vw(F()|0,0,d|0,s|0)|0;d=F()|0;r=Vw(0,r|0,z|0,L|0)|0;b=F()|0;z=Vw(s|0,d|0,(b>>>0<L>>>0|(b|0)==(L|0)&r>>>0<z>>>0)&1|0,0)|0;L=F()|0;d=(r|0)==0&(b|0)==0;s=Ww(0,0,r|0,b|0)|0;v=F()|0;y=Ww(0,0,z|0,L|0)|0;K=F()|0;B=Ww(t|0,u|0,n|0,o|0)|0;w=F()|0;x=Ww(l|0,m|0,D|0,E|0)|0;t=F()|0;Q=(w|0)<0;S=_w(B|0,w|0,63)|0;F()|0;u=(t|0)<0;P=_w(x|0,t|0,63)|0;F()|0;P=(S|0)==(P|0);S=Ww(0,0,B|0,w|0)|0;H=F()|0;B=Q?S:B;w=Q?H:w;H=Ww(0,0,x|0,t|0)|0;Q=F()|0;x=u?H:x;t=u?Q:t;Q=Uw(w|0,0,t|0,0)|0;u=F()|0;H=Uw(B|0,0,x|0,0)|0;S=F()|0;x=Uw(w|0,0,x|0,0)|0;w=F()|0;t=Uw(B|0,0,t|0,0)|0;t=Vw(x|0,w|0,t|0,F()|0)|0;u=Vw(F()|0,0,Q|0,u|0)|0;Q=F()|0;t=Vw(0,t|0,H|0,S|0)|0;w=F()|0;H=Vw(u|0,Q|0,(w>>>0<S>>>0|(w|0)==(S|0)&t>>>0<H>>>0)&1|0,0)|0;S=F()|0;Q=(t|0)==0&(w|0)==0;u=Ww(0,0,t|0,w|0)|0;x=F()|0;B=Ww(0,0,H|0,S|0)|0;R=F()|0;if((((I?r:s)|0)==((P?t:u)|0)?((I?b:v)|0)==((P?w:x)|0):0)&(((I?z:d?y:~z)|0)==((P?H:Q?B:~H)|0)?((I?L:d?K:~L)|0)==((P?S:Q?R:~S)|0):0)){z=g;B=1;y=1;break}else g=0;Eb=O;return g|0}}while(0);w=A+24|0;g=c[w>>2]|0;x=A+8|0;i=g+8|0;h=c[i>>2]|0;i=c[i+4>>2]|0;v=x;b=c[v>>2]|0;v=c[v+4>>2]|0;u=A+16|0;t=c[u>>2]|0;u=c[u+4>>2]|0;c:do if((h|0)==(b|0)&(i|0)==(v|0))do{S=g+16|0;if((g|0)==(A|0)|((c[S>>2]|0)!=(t|0)?1:(c[S+4>>2]|0)!=(u|0)))break c;g=c[g+24>>2]|0;S=g+8|0;}while((c[S>>2]|0)==(h|0)?(c[S+4>>2]|0)==(i|0):0);else {h=b;i=v;}while(0);k=g+16|0;j=c[k>>2]|0;k=c[k+4>>2]|0;do if(!((u|0)<(k|0)|(u|0)==(k|0)&t>>>0<j>>>0)){m=g+8|0;l=c[m>>2]|0;m=c[m+4>>2]|0;n=Ww(t|0,u|0,j|0,k|0)|0;o=F()|0;r=Ww(l|0,m|0,p|0,q|0)|0;s=F()|0;if(!(y<<24>>24)){Q=Uw(r|0,s|0,n|0,o|0)|0;S=F()|0;L=Ww(b|0,v|0,l|0,m|0)|0;P=F()|0;R=Ww(j|0,k|0,D|0,E|0)|0;R=Uw(L|0,P|0,R|0,F()|0)|0;if((Q|0)==(R|0)&(S|0)==(F()|0)){h=0;break}else {J=72;break}}else {U=(o|0)<0;W=_w(n|0,o|0,63)|0;F()|0;d=(s|0)<0;I=_w(r|0,s|0,63)|0;F()|0;I=(W|0)==(I|0);W=Ww(0,0,n|0,o|0)|0;T=F()|0;W=U?W:n;T=U?T:o;U=Ww(0,0,r|0,s|0)|0;o=F()|0;U=d?U:r;o=d?o:s;d=Uw(o|0,0,T|0,0)|0;V=F()|0;r=Uw(U|0,0,W|0,0)|0;L=F()|0;T=Uw(U|0,0,T|0,0)|0;U=F()|0;W=Uw(o|0,0,W|0,0)|0;W=Vw(T|0,U|0,W|0,F()|0)|0;V=Vw(F()|0,0,d|0,V|0)|0;d=F()|0;W=Vw(0,W|0,r|0,L|0)|0;U=F()|0;r=Vw(V|0,d|0,(U>>>0<L>>>0|(U|0)==(L|0)&W>>>0<r>>>0)&1|0,0)|0;L=F()|0;d=(W|0)==0&(U|0)==0;V=Ww(0,0,W|0,U|0)|0;T=F()|0;o=Ww(0,0,r|0,L|0)|0;K=F()|0;s=Ww(b|0,v|0,l|0,m|0)|0;m=F()|0;n=Ww(j|0,k|0,D|0,E|0)|0;k=F()|0;Q=(m|0)<0;S=_w(s|0,m|0,63)|0;F()|0;l=(k|0)<0;P=_w(n|0,k|0,63)|0;F()|0;P=(S|0)==(P|0);S=Ww(0,0,s|0,m|0)|0;H=F()|0;s=Q?S:s;m=Q?H:m;H=Ww(0,0,n|0,k|0)|0;Q=F()|0;n=l?H:n;k=l?Q:k;Q=Uw(m|0,0,k|0,0)|0;l=F()|0;H=Uw(s|0,0,n|0,0)|0;S=F()|0;n=Uw(m|0,0,n|0,0)|0;m=F()|0;k=Uw(s|0,0,k|0,0)|0;k=Vw(n|0,m|0,k|0,F()|0)|0;l=Vw(F()|0,0,Q|0,l|0)|0;Q=F()|0;k=Vw(0,k|0,H|0,S|0)|0;m=F()|0;H=Vw(l|0,Q|0,(m>>>0<S>>>0|(m|0)==(S|0)&k>>>0<H>>>0)&1|0,0)|0;S=F()|0;Q=(k|0)==0&(m|0)==0;l=Ww(0,0,k|0,m|0)|0;n=F()|0;s=Ww(0,0,H|0,S|0)|0;R=F()|0;if((((I?W:V)|0)==((P?k:l)|0)?((I?U:T)|0)==((P?m:n)|0):0)&(((I?r:d?o:~r)|0)==((P?H:Q?s:~H)|0)?((I?L:d?K:~L)|0)==((P?S:Q?R:~S)|0):0)){h=0;break}else {J=72;break}}}else J=72;while(0);do if((J|0)==72){g=c[A+28>>2]|0;W=g+8|0;d:do if((c[W>>2]|0)==(h|0)?(c[W+4>>2]|0)==(i|0):0)do{W=g+16|0;if((g|0)==(A|0)|((c[W>>2]|0)!=(t|0)?1:(c[W+4>>2]|0)!=(u|0)))break d;g=c[g+28>>2]|0;W=g+8|0;}while((c[W>>2]|0)==(h|0)?(c[W+4>>2]|0)==(i|0):0);while(0);m=g+16|0;l=c[m>>2]|0;m=c[m+4>>2]|0;if((u|0)<(m|0)|(u|0)==(m|0)&t>>>0<l>>>0){W=0;Eb=O;return W|0}o=g+8|0;n=c[o>>2]|0;o=c[o+4>>2]|0;j=Ww(t|0,u|0,l|0,m|0)|0;k=F()|0;h=Ww(n|0,o|0,p|0,q|0)|0;i=F()|0;if(!(y<<24>>24)){U=Uw(h|0,i|0,j|0,k|0)|0;W=F()|0;S=Ww(b|0,v|0,n|0,o|0)|0;T=F()|0;V=Ww(l|0,m|0,D|0,E|0)|0;V=Uw(S|0,T|0,V|0,F()|0)|0;if((U|0)==(V|0)&(W|0)==(F()|0)){h=1;break}else g=0;Eb=O;return g|0}else {u=(k|0)<0;s=_w(j|0,k|0,63)|0;F()|0;Q=(i|0)<0;P=_w(h|0,i|0,63)|0;F()|0;P=(s|0)==(P|0);s=Ww(0,0,j|0,k|0)|0;y=F()|0;s=u?s:j;y=u?y:k;u=Ww(0,0,h|0,i|0)|0;d=F()|0;u=Q?u:h;d=Q?d:i;Q=Uw(d|0,0,y|0,0)|0;t=F()|0;J=Uw(u|0,0,s|0,0)|0;S=F()|0;y=Uw(u|0,0,y|0,0)|0;u=F()|0;s=Uw(d|0,0,s|0,0)|0;s=Vw(y|0,u|0,s|0,F()|0)|0;t=Vw(F()|0,0,Q|0,t|0)|0;Q=F()|0;s=Vw(0,s|0,J|0,S|0)|0;u=F()|0;J=Vw(t|0,Q|0,(u>>>0<S>>>0|(u|0)==(S|0)&s>>>0<J>>>0)&1|0,0)|0;S=F()|0;Q=(s|0)==0&(u|0)==0;t=Ww(0,0,s|0,u|0)|0;y=F()|0;d=Ww(0,0,J|0,S|0)|0;R=F()|0;K=Ww(b|0,v|0,n|0,o|0)|0;H=F()|0;I=Ww(l|0,m|0,D|0,E|0)|0;D=F()|0;U=(H|0)<0;W=_w(K|0,H|0,63)|0;F()|0;E=(D|0)<0;T=_w(I|0,D|0,63)|0;F()|0;T=(W|0)==(T|0);W=Ww(0,0,K|0,H|0)|0;L=F()|0;K=U?W:K;H=U?L:H;L=Ww(0,0,I|0,D|0)|0;U=F()|0;I=E?L:I;D=E?U:D;U=Uw(H|0,0,D|0,0)|0;E=F()|0;L=Uw(K|0,0,I|0,0)|0;W=F()|0;I=Uw(H|0,0,I|0,0)|0;H=F()|0;D=Uw(K|0,0,D|0,0)|0;D=Vw(I|0,H|0,D|0,F()|0)|0;E=Vw(F()|0,0,U|0,E|0)|0;U=F()|0;D=Vw(0,D|0,L|0,W|0)|0;H=F()|0;L=Vw(E|0,U|0,(H>>>0<W>>>0|(H|0)==(W|0)&D>>>0<L>>>0)&1|0,0)|0;W=F()|0;U=(D|0)==0&(H|0)==0;E=Ww(0,0,D|0,H|0)|0;I=F()|0;K=Ww(0,0,L|0,W|0)|0;V=F()|0;if((((P?s:t)|0)==((T?D:E)|0)?((P?u:y)|0)==((T?H:I)|0):0)&(((P?J:Q?d:~J)|0)==((T?L:U?K:~L)|0)?((P?S:Q?R:~S)|0)==((T?W:U?V:~W)|0):0)){h=1;break}else g=0;Eb=O;return g|0}}while(0);if((z|0)==(g|0)|((z|0)==(G|0)|(g|0)==(A|0))){W=0;Eb=O;return W|0}if(!((e|0)!=(f|0)|B^h)){W=0;Eb=O;return W|0}g=Zj(32)|0;W=g+8|0;c[W>>2]=c[M>>2];c[W+4>>2]=c[M+4>>2];c[W+8>>2]=c[M+8>>2];c[W+12>>2]=c[M+12>>2];c[g>>2]=c[G>>2];if(B){U=G+28|0;W=c[U>>2]|0;c[g+28>>2]=W;V=g+24|0;c[V>>2]=G;c[W+24>>2]=g;c[U>>2]=g;W=Zj(32)|0;T=W+8|0;c[T>>2]=c[x>>2];c[T+4>>2]=c[x+4>>2];c[T+8>>2]=c[x+8>>2];c[T+12>>2]=c[x+12>>2];c[W>>2]=c[A>>2];T=c[w>>2]|0;c[W+24>>2]=T;c[T+28>>2]=W;c[U>>2]=A;c[w>>2]=G;c[V>>2]=W;c[W+28>>2]=g;c[N>>2]=g;W=1;Eb=O;return W|0}else {W=c[C>>2]|0;c[g+24>>2]=W;V=g+28|0;c[V>>2]=G;c[W+28>>2]=g;c[C>>2]=g;W=Zj(32)|0;U=W+8|0;c[U>>2]=c[x>>2];c[U+4>>2]=c[x+4>>2];c[U+8>>2]=c[x+8>>2];c[U+12>>2]=c[x+12>>2];c[W>>2]=c[A>>2];U=A+28|0;T=c[U>>2]|0;c[W+28>>2]=T;c[T+24>>2]=W;c[C>>2]=A;c[U>>2]=G;c[V>>2]=W;c[W+24>>2]=g;c[N>>2]=g;W=1;Eb=O;return W|0}}m=d+8|0;l=c[m>>2]|0;m=c[m+4>>2]|0;W=M;if((((l|0)==(c[W>>2]|0)?(m|0)==(c[W+4>>2]|0):0)?(o=A+8|0,W=o,(l|0)==(c[W>>2]|0)?(m|0)==(c[W+4>>2]|0):0):0)?(n=A+16|0,W=n,(K|0)==(c[W>>2]|0)?(L|0)==(c[W+4>>2]|0):0):0){if((e|0)!=(f|0)){W=0;Eb=O;return W|0}k=G+24|0;g=c[k>>2]|0;if((g|0)==(G|0)){g=L;h=K;}else {h=g;while(1){W=h+8|0;g=h+16|0;if(!((c[W>>2]|0)==(l|0)?(c[W+4>>2]|0)==(m|0):0))break;W=g;if(!((c[W>>2]|0)==(K|0)?(c[W+4>>2]|0)==(L|0):0)){J=12;break}g=c[h+24>>2]|0;if((g|0)==(G|0)){g=i;break}else h=g;}if((J|0)==12)g=h+16|0;h=g;g=c[h+4>>2]|0;h=c[h>>2]|0;}j=(g|0)>(L|0)|(g|0)==(L|0)&h>>>0>K>>>0;i=A+24|0;g=c[i>>2]|0;if((g|0)==(A|0)){if(!j){W=0;Eb=O;return W|0}}else {h=g;while(1){W=h+8|0;g=h+16|0;if(!((c[W>>2]|0)==(l|0)?(c[W+4>>2]|0)==(m|0):0))break;W=g;if(!((c[W>>2]|0)==(K|0)?(c[W+4>>2]|0)==(L|0):0)){J=20;break}g=c[h+24>>2]|0;if((g|0)==(A|0)){g=n;break}else h=g;}if((J|0)==20)g=h+16|0;W=g;V=c[W+4>>2]|0;if(!(j^((V|0)>(L|0)|((V|0)==(L|0)?(c[W>>2]|0)>>>0>K>>>0:0)))){W=0;Eb=O;return W|0}}g=Zj(32)|0;W=g+8|0;c[W>>2]=c[M>>2];c[W+4>>2]=c[M+4>>2];c[W+8>>2]=c[M+8>>2];c[W+12>>2]=c[M+12>>2];c[g>>2]=c[G>>2];if(j){U=G+28|0;W=c[U>>2]|0;c[g+28>>2]=W;V=g+24|0;c[V>>2]=G;c[W+24>>2]=g;c[U>>2]=g;W=Zj(32)|0;T=W+8|0;c[T>>2]=c[o>>2];c[T+4>>2]=c[o+4>>2];c[T+8>>2]=c[o+8>>2];c[T+12>>2]=c[o+12>>2];c[W>>2]=c[A>>2];T=c[i>>2]|0;c[W+24>>2]=T;c[T+28>>2]=W;c[U>>2]=A;c[i>>2]=G;c[V>>2]=W;c[W+28>>2]=g;c[N>>2]=g;W=1;Eb=O;return W|0}else {W=c[k>>2]|0;c[g+24>>2]=W;V=g+28|0;c[V>>2]=G;c[W+28>>2]=g;c[k>>2]=g;W=Zj(32)|0;U=W+8|0;c[U>>2]=c[o>>2];c[U+4>>2]=c[o+4>>2];c[U+8>>2]=c[o+8>>2];c[U+12>>2]=c[o+12>>2];c[W>>2]=c[A>>2];U=A+28|0;T=c[U>>2]|0;c[W+28>>2]=T;c[T+24>>2]=W;c[k>>2]=A;c[U>>2]=G;c[V>>2]=W;c[W+24>>2]=g;c[N>>2]=g;W=1;Eb=O;return W|0}}e=G;while(1){g=c[e+28>>2]|0;W=g+16|0;if((g|0)==(A|0)|((g|0)==(G|0)|((c[W>>2]|0)!=(K|0)?1:(c[W+4>>2]|0)!=(L|0))))break;else e=g;}D=K;E=L;while(1){g=c[G+24>>2]|0;i=g+16|0;h=c[i>>2]|0;i=c[i+4>>2]|0;j=(g|0)==(e|0);if((g|0)!=(A|0)&((j|((h|0)!=(D|0)|(i|0)!=(E|0)))^1)){G=g;D=h;E=i;}else break}if(j|(g|0)==(A|0)){W=0;Eb=O;return W|0}g=A+16|0;B=c[g>>2]|0;g=c[g+4>>2]|0;C=A;while(1){h=c[C+28>>2]|0;W=h+16|0;if((h|0)==(G|0)|((h|0)==(A|0)|((c[W>>2]|0)!=(B|0)?1:(c[W+4>>2]|0)!=(g|0))))break;else C=h;}y=B;z=g;while(1){h=c[A+24>>2]|0;j=h+16|0;i=c[j>>2]|0;j=c[j+4>>2]|0;k=(h|0)==(C|0);if((h|0)!=(e|0)&((k|((i|0)!=(y|0)|(j|0)!=(z|0)))^1)){A=h;y=i;z=j;}else break}if(k|(h|0)==(e|0)){W=0;Eb=O;return W|0}i=e+8|0;j=i;h=c[j>>2]|0;j=c[j+4>>2]|0;v=G+8|0;l=v;k=c[l>>2]|0;l=c[l+4>>2]|0;w=C+8|0;n=w;m=c[n>>2]|0;n=c[n+4>>2]|0;x=A+8|0;p=x;o=c[p>>2]|0;p=c[p+4>>2]|0;q=(j|0)<(l|0)|(j|0)==(l|0)&h>>>0<k>>>0;r=(n|0)<(p|0)|(n|0)==(p|0)&m>>>0<o>>>0;do if(q)if(r){u=(j|0)<(n|0)|(j|0)==(n|0)&h>>>0<m>>>0;b=(p|0)<(l|0)|(p|0)==(l|0)&o>>>0<k>>>0;s=u?n:j;t=b?p:l;u=u?m:h;b=b?o:k;break}else {u=(j|0)<(p|0)|(j|0)==(p|0)&h>>>0<o>>>0;b=(n|0)<(l|0)|(n|0)==(l|0)&m>>>0<k>>>0;s=u?p:j;t=b?n:l;u=u?o:h;b=b?m:k;break}else if(r){u=(l|0)<(n|0)|(l|0)==(n|0)&k>>>0<m>>>0;b=(p|0)<(j|0)|(p|0)==(j|0)&o>>>0<h>>>0;s=u?n:l;t=b?p:j;u=u?m:k;b=b?o:h;break}else {u=(l|0)<(p|0)|(l|0)==(p|0)&k>>>0<o>>>0;b=(n|0)<(j|0)|(n|0)==(j|0)&m>>>0<h>>>0;s=u?p:l;t=b?n:j;u=u?o:k;b=b?m:h;break}while(0);if(!((s|0)<(t|0)|(s|0)==(t|0)&u>>>0<b>>>0)){W=0;Eb=O;return W|0}do if((j|0)>(t|0)|(j|0)==(t|0)&h>>>0>b>>>0|((j|0)<(s|0)|(j|0)==(s|0)&h>>>0<u>>>0))if((n|0)>(t|0)|(n|0)==(t|0)&m>>>0>b>>>0|((n|0)<(s|0)|(n|0)==(s|0)&m>>>0<u>>>0)){g=(l|0)>(t|0)|(l|0)==(t|0)&k>>>0>b>>>0|((l|0)<(s|0)|(l|0)==(s|0)&k>>>0<u>>>0);j=g?r:q;i=g?x:v;h=g?y:D;g=g?z:E;break}else {j=(n|0)>(p|0)|(n|0)==(p|0)&m>>>0>o>>>0;i=w;h=B;break}else {j=(j|0)>(l|0)|(j|0)==(l|0)&h>>>0>k>>>0;h=K;g=L;}while(0);V=i;U=c[V>>2]|0;V=c[V+4>>2]|0;c[d>>2]=e;c[N>>2]=C;W=I;c[W>>2]=U;c[W+4>>2]=V;W=I+8|0;c[W>>2]=h;c[W+4>>2]=g;c[H>>2]=c[I>>2];c[H+4>>2]=c[I+4>>2];c[H+8>>2]=c[I+8>>2];c[H+12>>2]=c[I+12>>2];W=sd(e,G,C,A,H,j)|0;Eb=O;return W|0}function ud(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;o=c[d+8>>2]|0;e=c[a+44>>2]|0;a=c[a+40>>2]|0;l=a;if((e|0)==(a|0))return;m=b+16|0;n=d+16|0;j=e-a>>2;i=0;do{a=c[l+(i<<2)>>2]|0;k=c[a+16>>2]|0;do if(!((a|0)==(b|0)|((a|0)==(d|0)|(k|0)==0))){g=a+8|0;h=c[g>>2]|0;a:do if(!h)a=0;else {a=h;while(1){if(c[a+16>>2]|0)break a;a=c[a+8>>2]|0;if(!a){a=0;break}}}while(0);if((a|0)==(d|0)|((a|0)==(o|0)|(a|0)==(b|0))){e=c[m>>2]|0;a=k;do{f=uc(a+8|0,e)|0;if((f|0)>-1){p=13;break}a=c[a+24>>2]|0;}while((a|0)!=(k|0));if((p|0)==13?(p=0,(f|0)==0):0){e=c[n>>2]|0;a=k;do{f=uc(a+8|0,e)|0;if((f|0)>-1){p=18;break}a=c[a+24>>2]|0;}while((a|0)!=(k|0));if((p|0)==18?(p=0,(f|0)==0):0){if(!((h|0)==(b|0)|(h|0)==(d|0)))break;c[g>>2]=o;break}c[g>>2]=d;break}c[g>>2]=b;}}while(0);i=i+1|0;}while(i>>>0<j>>>0);return}function vd(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0;h=a+144|0;i=a+148|0;e=c[i>>2]|0;d=c[h>>2]|0;b=d;if((e-d|0)>0){g=0;f=e;while(1){e=c[d+(g<<2)>>2]|0;if(!e)e=f;else {Ub[c[(c[e>>2]|0)+4>>2]&127](e);b=c[h>>2]|0;d=b;e=c[i>>2]|0;}g=g+1|0;if((g|0)>=(e-d>>2|0))break;else f=e;}}c[i>>2]=d;h=a+112|0;c[h>>2]=-1;c[h+4>>2]=-1;c[a+128>>2]=3512;if(b|0){c[i>>2]=b;$j(b);}b=c[a+132>>2]|0;if(b|0){c[a+136>>2]=b;$j(b);}b=c[a+52>>2]|0;if(b|0){c[a+56>>2]=b;$j(b);}b=c[a+40>>2]|0;if(b|0){c[a+44>>2]=b;$j(b);}b=c[a+28>>2]|0;if(b|0){c[a+32>>2]=b;$j(b);}f=a+16|0;h=c[f>>2]|0;if(!h)return;g=a+20|0;b=c[g>>2]|0;if((b|0)==(h|0))b=h;else {do{d=b;b=b+-12|0;e=c[b>>2]|0;if(e|0){c[d+-8>>2]=e;$j(e);}}while((b|0)!=(h|0));b=c[f>>2]|0;}c[g>>2]=h;$j(b);return}function wd(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0;g=a+144|0;h=a+148|0;d=c[h>>2]|0;b=c[g>>2]|0;if((d-b|0)>0){f=0;e=d;while(1){d=c[b+(f<<2)>>2]|0;if(!d)d=e;else {Ub[c[(c[d>>2]|0)+4>>2]&127](d);b=c[g>>2]|0;d=c[h>>2]|0;}f=f+1|0;if((f|0)>=(d-b>>2|0))break;else e=d;}}c[h>>2]=b;h=a+112|0;c[h>>2]=-1;c[h+4>>2]=-1;return}function xd(a){a=a|0;var b=0;c[a>>2]=3512;b=c[a+16>>2]|0;if(b|0){c[a+20>>2]=b;$j(b);}b=c[a+4>>2]|0;if(!b)return;c[a+8>>2]=b;$j(b);return}function yd(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;v=Eb;Eb=Eb+16|0;t=v;k=c[d>>2]|0;g=(c[d+4>>2]|0)-k|0;j=(g>>4)+-1|0;if((g|0)<16){Eb=v;return}s=Zj(48)|0;c[s>>2]=3512;u=s+4|0;c[u>>2]=0;c[u+4>>2]=0;c[u+8>>2]=0;c[u+12>>2]=0;c[u+16>>2]=0;c[u+20>>2]=0;c[u+24>>2]=0;c[u+28>>2]=0;a[u+32>>0]=0;c[s+40>>2]=e;c[s+44>>2]=f;r=(f|0)==0;a:do if(f>>>0<2&(g|0)!=16){h=k;g=c[h>>2]|0;h=c[h+4>>2]|0;i=k+8|0;e=j;while(1){p=k+(e<<4)|0;if(!((g|0)==(c[p>>2]|0)?(h|0)==(c[p+4>>2]|0):0))break a;o=i;p=k+(e<<4)+8|0;if(!((c[o>>2]|0)==(c[p>>2]|0)?(c[o+4>>2]|0)==(c[p+4>>2]|0):0))break a;f=e+-1|0;if((e|0)>1)e=f;else {e=f;break}}}else e=j;while(0);n=e+1|0;nd(u,n);f=c[d>>2]|0;o=s+8|0;g=c[o>>2]|0;p=s+12|0;if((g|0)==(c[p>>2]|0))Ge(u,f);else {c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];c[g+8>>2]=c[f+8>>2];c[g+12>>2]=c[f+12>>2];c[o>>2]=(c[o>>2]|0)+16;}if((e|0)<1){p=0;e=0;}else {m=1;l=0;e=0;h=c[d>>2]|0;f=c[u>>2]|0;while(1){g=h+(m<<4)|0;j=f+(e<<4)|0;k=g;if(((c[j>>2]|0)==(c[k>>2]|0)?(c[j+4>>2]|0)==(c[k+4>>2]|0):0)?(j=f+(e<<4)+8|0,k=h+(m<<4)+8|0,(c[j>>2]|0)==(c[k>>2]|0)?(c[j+4>>2]|0)==(c[k+4>>2]|0):0):0){i=l;g=h;}else q=15;do if((q|0)==15){q=0;e=e+1|0;f=c[o>>2]|0;if((f|0)==(c[p>>2]|0))Ge(u,g);else {c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];c[f+8>>2]=c[g+8>>2];c[f+12>>2]=c[g+12>>2];c[o>>2]=(c[o>>2]|0)+16;}k=c[d>>2]|0;h=k+(m<<4)+8|0;g=c[h>>2]|0;h=c[h+4>>2]|0;f=c[u>>2]|0;j=f+(l<<4)+8|0;i=c[j>>2]|0;j=c[j+4>>2]|0;if(!((h|0)>(j|0)|(h|0)==(j|0)&g>>>0>i>>>0)){if(!((g|0)==(i|0)&(h|0)==(j|0))){i=l;g=k;break}i=k+(m<<4)|0;g=c[i+4>>2]|0;j=f+(l<<4)|0;h=c[j+4>>2]|0;if(!((g|0)<(h|0)|((g|0)==(h|0)?(c[i>>2]|0)>>>0<(c[j>>2]|0)>>>0:0))){i=l;g=k;break}}i=e;g=k;}while(0);m=m+1|0;if((m|0)==(n|0)){p=i;break}else {l=i;h=g;}}}if(r&(e|0)<2){Ub[c[(c[s>>2]|0)+4>>2]&127](s);Eb=v;return}g=b+144|0;o=b+148|0;e=c[o>>2]|0;f=e-(c[g>>2]|0)>>2;c[t>>2]=s;if((c[b+152>>2]|0)>>>0>e>>>0){c[e>>2]=s;c[o>>2]=(c[o>>2]|0)+4;}else Ie(g,t);c[s+28>>2]=b+128;c[s+32>>2]=f;if(!r){Eb=v;return}n=b+112|0;t=n;e=c[t>>2]|0;if((c[t+4>>2]|0)<0){t=((c[o>>2]|0)-(c[g>>2]|0)>>2)+-1|0;u=n;c[u>>2]=t;c[u+4>>2]=((t|0)<0)<<31>>31;u=b+120|0;c[u>>2]=p;c[u+4>>2]=((p|0)<0)<<31>>31;Eb=v;return}h=c[b+144>>2]|0;m=b+120|0;l=c[m>>2]|0;k=c[(c[h+(e<<2)>>2]|0)+4>>2]|0;j=k+(l<<4)|0;i=c[j>>2]|0;j=c[j+4>>2]|0;l=k+(l<<4)+8|0;k=c[l>>2]|0;l=c[l+4>>2]|0;e=c[u>>2]|0;g=e+(p<<4)+8|0;f=c[g>>2]|0;g=c[g+4>>2]|0;if(!((g|0)>(l|0)|(g|0)==(l|0)&f>>>0>k>>>0)){if(!((f|0)==(k|0)&(g|0)==(l|0))){Eb=v;return}u=e+(p<<4)|0;b=c[u+4>>2]|0;if(!((b|0)<(j|0)|((b|0)==(j|0)?(c[u>>2]|0)>>>0<i>>>0:0))){Eb=v;return}}b=((c[o>>2]|0)-h>>2)+-1|0;u=n;c[u>>2]=b;c[u+4>>2]=((b|0)<0)<<31>>31;u=m;c[u>>2]=p;c[u+4>>2]=((p|0)<0)<<31>>31;Eb=v;return}function zd(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;h=b+4|0;f=c[b>>2]|0;if((c[h>>2]|0)==(f|0))return;g=0;do{yd(a,f+(g*12|0)|0,d,e);g=g+1|0;f=c[b>>2]|0;}while(g>>>0<(((c[h>>2]|0)-f|0)/12|0)>>>0);return}function Ad(a){a=a|0;var b=0,d=0,e=0,f=0.0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;u=Eb;Eb=Eb+16|0;t=u;m=a+112|0;d=c[m>>2]|0;m=c[m+4>>2]|0;if((m|0)>-1|(m|0)==-1&d>>>0>4294967295){b=c[a+144>>2]|0;m=c[b+(d<<2)>>2]|0;g=c[m+4>>2]|0;m=(c[m+8>>2]|0)-g|0;e=m>>4;l=b;if((m|0)>=48){k=e+-1|0;i=g+(k<<4)|0;k=g+(k<<4)+8|0;d=0;f=0.0;h=c[i+4>>2]|0;i=c[i>>2]|0;j=c[k+4>>2]|0;k=c[k>>2]|0;do{y=g+(d<<4)|0;x=i;i=c[y>>2]|0;w=h;h=c[y+4>>2]|0;y=g+(d<<4)+8|0;v=k;k=c[y>>2]|0;m=j;j=c[y+4>>2]|0;f=f+(+(x>>>0)+4294967296.0*+(w|0)+(+(i>>>0)+4294967296.0*+(h|0)))*(+(v>>>0)+4294967296.0*+(m|0)-(+(k>>>0)+4294967296.0*+(j|0)));d=d+1|0;}while((d|0)<(e|0));if(!(f*-.5>=0.0)){o=a+144|0;n=a+148|0;d=c[n>>2]|0;if((d-l|0)<=0){Eb=u;return}m=0;a=d;while(1){d=c[b+(m<<2)>>2]|0;switch(c[d+44>>2]|0){case 0:{b=c[d+4>>2]|0;d=c[d+8>>2]|0;s=15;break}case 1:{x=c[d+8>>2]|0;b=c[d+4>>2]|0;y=x-b|0;k=y>>4;d=x;if((y|0)>=48){j=k+-1|0;h=b+(j<<4)|0;j=b+(j<<4)+8|0;e=0;f=0.0;g=c[h+4>>2]|0;h=c[h>>2]|0;i=c[j+4>>2]|0;j=c[j>>2]|0;do{q=b+(e<<4)|0;v=h;h=c[q>>2]|0;w=g;g=c[q+4>>2]|0;q=b+(e<<4)+8|0;x=j;j=c[q>>2]|0;y=i;i=c[q+4>>2]|0;f=f+(+(v>>>0)+4294967296.0*+(w|0)+(+(h>>>0)+4294967296.0*+(g|0)))*(+(x>>>0)+4294967296.0*+(y|0)-(+(j>>>0)+4294967296.0*+(i|0)));e=e+1|0;}while((e|0)<(k|0));if(!(f*-.5>=0.0)){d=l;b=a;}else s=15;}else s=15;break}default:{d=l;b=a;}}if((s|0)==15){s=0;if((b|0)!=(d|0)?(r=d+-16|0,b>>>0<r>>>0):0){d=r;do{c[t>>2]=c[b>>2];c[t+4>>2]=c[b+4>>2];c[t+8>>2]=c[b+8>>2];c[t+12>>2]=c[b+12>>2];c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[d>>2]=c[t>>2];c[d+4>>2]=c[t+4>>2];c[d+8>>2]=c[t+8>>2];c[d+12>>2]=c[t+12>>2];b=b+16|0;d=d+-16|0;}while(b>>>0<d>>>0);d=c[o>>2]|0;b=c[n>>2]|0;}else {d=l;b=a;}}m=m+1|0;if((m|0)>=(b-d>>2|0))break;else {l=d;a=b;b=d;}}Eb=u;return}else d=l;}else d=l;}else {b=c[a+144>>2]|0;d=b;}m=a+144|0;l=a+148|0;e=c[l>>2]|0;if((e-d|0)<=0){Eb=u;return}k=0;while(1){b=c[b+(k<<2)>>2]|0;if((c[b+44>>2]|0)==1?(p=c[b+8>>2]|0,o=c[b+4>>2]|0,y=p-o|0,n=y>>4,(y|0)>=48):0){j=n+-1|0;h=o+(j<<4)|0;j=o+(j<<4)+8|0;b=0;f=0.0;g=c[h+4>>2]|0;h=c[h>>2]|0;i=c[j+4>>2]|0;j=c[j>>2]|0;do{s=o+(b<<4)|0;v=h;h=c[s>>2]|0;w=g;g=c[s+4>>2]|0;s=o+(b<<4)+8|0;x=j;j=c[s>>2]|0;y=i;i=c[s+4>>2]|0;f=f+(+(v>>>0)+4294967296.0*+(w|0)+(+(h>>>0)+4294967296.0*+(g|0)))*(+(x>>>0)+4294967296.0*+(y|0)-(+(j>>>0)+4294967296.0*+(i|0)));b=b+1|0;}while((b|0)<(n|0));if(!(f*-.5>=0.0|(o|0)==(p|0))?(q=p+-16|0,q>>>0>o>>>0):0){b=o;d=q;do{c[t>>2]=c[b>>2];c[t+4>>2]=c[b+4>>2];c[t+8>>2]=c[b+8>>2];c[t+12>>2]=c[b+12>>2];c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[d>>2]=c[t>>2];c[d+4>>2]=c[t+4>>2];c[d+8>>2]=c[t+8>>2];c[d+12>>2]=c[t+12>>2];b=b+16|0;d=d+-16|0;}while(b>>>0<d>>>0);d=c[m>>2]|0;e=c[l>>2]|0;}}k=k+1|0;if((k|0)>=(e-d>>2|0))break;else b=d;}Eb=u;return}function Bd(a){a=a|0;var b=0,d=0,e=0;e=Eb;Eb=Eb+16|0;d=e;b=c[a>>2]|0;a=c[a+4>>2]|0;if((b|0)==(a|0)){Eb=e;return}a=a+-16|0;if(b>>>0>=a>>>0){Eb=e;return}do{c[d>>2]=c[b>>2];c[d+4>>2]=c[b+4>>2];c[d+8>>2]=c[b+8>>2];c[d+12>>2]=c[b+12>>2];c[b>>2]=c[a>>2];c[b+4>>2]=c[a+4>>2];c[b+8>>2]=c[a+8>>2];c[b+12>>2]=c[a+12>>2];c[a>>2]=c[d>>2];c[a+4>>2]=c[d+4>>2];c[a+8>>2]=c[d+8>>2];c[a+12>>2]=c[d+12>>2];b=b+16|0;a=a+-16|0;}while(b>>>0<a>>>0);Eb=e;return}function Cd(b,d,e){b=b|0;d=d|0;e=+e;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0;U=Eb;Eb=Eb+176|0;M=U+24|0;B=U;D=U+8|0;i=c[d>>2]|0;J=d+4|0;f=c[J>>2]|0;if((f|0)!=(i|0))do{g=f;f=f+-12|0;h=c[f>>2]|0;if(h|0){c[g+-8>>2]=h;$j(h);}}while((f|0)!=(i|0));c[J>>2]=i;Ad(b);Dd(b,e);c[M+24>>2]=0;T=M+28|0;c[T>>2]=0;c[M+32>>2]=0;Q=M+40|0;c[Q>>2]=0;S=M+44|0;c[S>>2]=0;c[M+48>>2]=0;P=M+56|0;c[P>>2]=0;R=M+60|0;c[R>>2]=0;c[M+64>>2]=0;L=M+4|0;c[L>>2]=0;c[L+4>>2]=0;c[L+8>>2]=0;c[L+12>>2]=0;c[M>>2]=3556;I=M+72|0;h=M+112|0;f=I;g=f+36|0;do{c[f>>2]=0;f=f+4|0;}while((f|0)<(g|0));c[h>>2]=h;G=M+116|0;c[G>>2]=h;E=M+120|0;c[E>>2]=0;a[M+128>>0]=0;N=M+20|0;a[N>>0]=0;C=M+140|0;a[C>>0]=0;a[M+142>>0]=0;a[M+36>>0]=0;O=M+37|0;a[O>>0]=0;j=b+16|0;i=b+20|0;f=c[j>>2]|0;a:do if((c[i>>2]|0)!=(f|0)){g=0;h=3556;while(1){Qb[c[h+8>>2]&15](M,f+(g*12|0)|0,0,1)|0;g=g+1|0;f=c[j>>2]|0;if(g>>>0>=(((c[i>>2]|0)-f|0)/12|0)>>>0)break a;h=c[M>>2]|0;}}while(0);if(e>0.0)Oc(M,1,d,2,2)|0;else {f=c[M+8>>2]|0;A=c[M+12>>2]|0;b:do if((f|0)==(A|0)){l=B;c[l>>2]=0;c[l+4>>2]=0;l=0;k=0;b=0;j=0;i=0;h=0;g=0;f=0;}else {z=c[f+8>>2]|0;h=z;i=c[h>>2]|0;h=c[h+4>>2]|0;x=B;c[x>>2]=i;c[x+4>>2]=h;x=z+8|0;v=c[x>>2]|0;x=c[x+4>>2]|0;l=i;k=h;g=v;m=x;j=x;b=v;while(1){y=(j|0)<(x|0)|(j|0)==(x|0)&b>>>0<v>>>0;w=f+12|0;u=z;while(1){q=c[u+88>>2]|0;p=u;n=c[p>>2]|0;p=c[p+4>>2]|0;o=(p|0)<(k|0)|(p|0)==(k|0)&n>>>0<l>>>0;if(!q){n=u;l=o;k=u;}else {t=l;s=k;r=l;l=k;while(1){t=o?n:t;s=o?p:s;r=o?n:r;l=o?p:l;k=(p|0)>(h|0)|(p|0)==(h|0)&n>>>0>i>>>0;i=k?n:i;h=k?p:h;k=c[q+88>>2]|0;V=q;n=c[V>>2]|0;p=c[V+4>>2]|0;o=(p|0)<(l|0)|(p|0)==(l|0)&n>>>0<r>>>0;if(!k)break;else q=k;}n=B;c[n>>2]=t;c[n+4>>2]=s;n=q;l=o;k=q;}s=l?k:B;l=c[s>>2]|0;s=c[s+4>>2]|0;V=B;c[V>>2]=l;c[V+4>>2]=s;V=k;o=c[V>>2]|0;V=c[V+4>>2]|0;t=(h|0)<(V|0)|(h|0)==(V|0)&i>>>0<o>>>0;o=t?o:i;h=t?V:h;V=n+32|0;t=c[V>>2]|0;V=c[V+4>>2]|0;k=(V|0)<(s|0)|(V|0)==(s|0)&t>>>0<l>>>0;l=k?t:l;k=k?V:s;s=B;c[s>>2]=l;c[s+4>>2]=k;s=(h|0)<(V|0)|(h|0)==(V|0)&o>>>0<t>>>0;o=s?t:o;h=s?V:h;V=n+40|0;s=c[V>>2]|0;V=c[V+4>>2]|0;t=(V|0)<(m|0)|(V|0)==(m|0)&s>>>0<g>>>0;g=t?s:g;m=t?V:m;if((u|0)!=(z|0))break;u=c[w>>2]|0;i=o;}b=y?v:b;j=y?x:j;i=f+16|0;if((i|0)==(A|0)){i=o;f=m;break b}z=c[f+24>>2]|0;v=z+8|0;f=i;i=o;x=c[v+4>>2]|0;v=c[v>>2]|0;}}while(0);c[D>>2]=0;A=D+4|0;c[A>>2]=0;w=D+8|0;c[w>>2]=0;m=Zj(64)|0;c[D>>2]=m;B=m+64|0;c[w>>2]=B;c[A>>2]=B;A=Vw(l|0,k|0,-10,-1)|0;B=F()|0;w=Vw(b|0,j|0,10,0)|0;x=F()|0;y=m;c[y>>2]=A;c[y+4>>2]=B;y=m+8|0;c[y>>2]=w;c[y+4>>2]=x;y=Vw(i|0,h|0,10,0)|0;z=F()|0;V=m+16|0;c[V>>2]=y;c[V+4>>2]=z;V=m+24|0;c[V>>2]=w;c[V+4>>2]=x;g=Vw(g|0,f|0,-10,-1)|0;f=F()|0;V=m+32|0;c[V>>2]=y;c[V+4>>2]=z;V=m+40|0;c[V>>2]=g;c[V+4>>2]=f;V=m+48|0;c[V>>2]=A;c[V+4>>2]=B;V=m+56|0;c[V>>2]=g;c[V+4>>2]=f;Ec(M,D,0,1)|0;a[C>>0]=1;Oc(M,1,d,3,3)|0;D=c[J>>2]|0;V=c[d>>2]|0;f=V;g=D;if((D|0)!=(V|0)){h=f+12|0;if((h|0)!=(g|0)){do{i=c[f>>2]|0;if(!i){i=f+8|0;j=f+4|0;}else {j=f+4|0;c[j>>2]=i;$j(i);i=f+8|0;c[i>>2]=0;c[j>>2]=0;c[f>>2]=0;}c[f>>2]=c[h>>2];V=h+4|0;c[j>>2]=c[V>>2];D=h+8|0;c[i>>2]=c[D>>2];c[D>>2]=0;c[V>>2]=0;c[h>>2]=0;h=h+12|0;f=f+12|0;}while((h|0)!=(g|0));g=c[J>>2]|0;if((g|0)!=(f|0))H=32;}else H=32;if((H|0)==32)do{h=g;g=g+-12|0;i=c[g>>2]|0;if(i|0){c[h+-8>>2]=i;$j(i);}}while((g|0)!=(f|0));c[J>>2]=f;}$j(m);}c[M>>2]=3556;g=M+112|0;if(c[E>>2]|0?(K=c[G>>2]|0,V=(c[g>>2]|0)+4|0,J=c[K>>2]|0,c[J+4>>2]=c[V>>2],c[c[V>>2]>>2]=J,c[E>>2]=0,(K|0)!=(g|0)):0){f=K;do{V=f;f=c[f+4>>2]|0;$j(V);}while((f|0)!=(g|0))}f=c[M+96>>2]|0;if(f|0){c[M+100>>2]=f;$j(f);}f=c[M+84>>2]|0;if(f|0){c[M+88>>2]=f;$j(f);}f=c[I>>2]|0;if(f|0){c[M+76>>2]=f;$j(f);}c[M>>2]=3528;b=M+8|0;j=c[b>>2]|0;k=M+12|0;c[k>>2]=j;c[L>>2]=j;j=M+24|0;f=c[T>>2]|0;g=c[j>>2]|0;if((f|0)!=(g|0)){i=0;do{h=c[g+(i<<2)>>2]|0;if(h){ak(h);g=c[j>>2]|0;f=c[T>>2]|0;}i=i+1|0;}while(i>>>0<f-g>>2>>>0);f=g;}c[T>>2]=f;a[N>>0]=0;a[O>>0]=0;f=c[P>>2]|0;if(f|0){c[R>>2]=f;$j(f);}f=c[Q>>2]|0;if(f|0){c[S>>2]=f;$j(f);}f=c[j>>2]|0;if(f|0){c[T>>2]=f;$j(f);}f=c[b>>2]|0;if(!f){Eb=U;return}c[k>>2]=f;$j(f);Eb=U;return}function Dd(a,b){a=a|0;b=+b;var d=0.0,e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,w=0.0,y=0.0,A=0.0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0.0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0.0;ka=Eb;Eb=Eb+32|0;ga=ka+16|0;ha=ka;ia=a+16|0;i=c[ia>>2]|0;ja=a+20|0;e=c[ja>>2]|0;if((e|0)!=(i|0))do{f=e;e=e+-12|0;h=c[e>>2]|0;if(h|0){c[f+-8>>2]=h;$j(h);}}while((e|0)!=(i|0));c[ja>>2]=i;g[a+64>>3]=b;if(b>-1.0e-20&b<1.0e-20){n=a+144|0;o=a+148|0;md(ia,(c[o>>2]|0)-(c[n>>2]|0)>>2);e=c[n>>2]|0;if(((c[o>>2]|0)-e|0)<=0){Eb=ka;return}p=a+24|0;m=0;a:while(1){e=c[e+(m<<2)>>2]|0;do if(!(c[e+44>>2]|0)){h=e+4|0;q=c[ja>>2]|0;if((q|0)==(c[p>>2]|0)){He(ia,h);break}c[q>>2]=0;l=q+4|0;c[l>>2]=0;i=q+8|0;c[i>>2]=0;j=e+8|0;e=(c[j>>2]|0)-(c[h>>2]|0)|0;f=e>>4;if(e|0){if(f>>>0>268435455){e=13;break a}k=Zj(e)|0;c[l>>2]=k;c[q>>2]=k;c[i>>2]=k+(f<<4);f=c[h>>2]|0;e=(c[j>>2]|0)-f|0;if((e|0)>0){ax(k|0,f|0,e|0)|0;c[l>>2]=k+(e>>>4<<4);}}c[ja>>2]=(c[ja>>2]|0)+12;}while(0);m=m+1|0;e=c[n>>2]|0;if((m|0)>=((c[o>>2]|0)-e>>2|0)){e=153;break}}if((e|0)==13)gk();else if((e|0)==153){Eb=ka;return}}d=+g[a>>3];if(d>2.0)d=2.0/(d*d);else d=.5;g[a+96>>3]=d;_=+g[a+8>>3];A=+s(+b);d=A*.25;_=3.141592653589793/+x(+(1.0-(!(_<=0.0)?(_>d?d:_):.25)/A));A=A*3.141592653589793;_=_>A?A:_;A=6.283185307179586/_;d=+v(+A);$=a+80|0;g[$>>3]=d;A=+u(+A);aa=a+88|0;g[aa>>3]=A;g[a+104>>3]=_/6.283185307179586;if(b<0.0)g[$>>3]=-d;Y=a+144|0;Z=a+148|0;md(ia,(c[Z>>2]|0)-(c[Y>>2]|0)>>1);e=c[Y>>2]|0;if(((c[Z>>2]|0)-e|0)<=0){Eb=ka;return}G=a+28|0;H=a+32|0;I=!(b<=0.0);J=a+40|0;K=a+44|0;L=a+52|0;M=a+56|0;N=a+60|0;O=ga+8|0;P=!(_>=1.0);Q=a+24|0;R=ga+8|0;S=a+48|0;T=ga+8|0;U=ga+8|0;V=ha+8|0;W=a+72|0;X=a+40|0;E=0;b:while(1){D=c[e+(E<<2)>>2]|0;e=D+4|0;if((G|0)!=(e|0))Ze(G,c[e>>2]|0,c[D+8>>2]|0);f=c[G>>2]|0;p=(c[H>>2]|0)-f|0;q=p>>4;c:do if(p|0){if(I){e=c[J>>2]|0;c[K>>2]=e;h=e;if((p|0)==16){d:do if((c[D+40>>2]|0)==1){if(!P){y=0.0;A=1.0;i=f;e=h;h=1;f=0;while(1){C=i;d=A*b+(+((c[C>>2]|0)>>>0)+4294967296.0*+(c[C+4>>2]|0));d=d+(d<0.0?-.5:.5);C=+s(d)>=1.0?(d>0.0?~~+B(+r(d/4294967296.0),4294967295.0)>>>0:~~+z((d-+(~~d>>>0))/4294967296.0)>>>0):0;D=i+8|0;w=y*b+(+((c[D>>2]|0)>>>0)+4294967296.0*+(c[D+4>>2]|0));w=w+(w<0.0?-.5:.5);D=+s(w)>=1.0?(w>0.0?~~+B(+r(w/4294967296.0),4294967295.0)>>>0:~~+z((w-+(~~w>>>0))/4294967296.0)>>>0):0;ba=ga;c[ba>>2]=~~d>>>0;c[ba+4>>2]=C;ba=T;c[ba>>2]=~~w>>>0;c[ba+4>>2]=D;if(e>>>0<(c[S>>2]|0)>>>0){c[e>>2]=c[ga>>2];c[e+4>>2]=c[ga+4>>2];c[e+8>>2]=c[ga+8>>2];c[e+12>>2]=c[ga+12>>2];c[K>>2]=(c[K>>2]|0)+16;}else _e(J,ga);d=+g[aa>>3];w=+g[$>>3];h=Vw(h|0,f|0,1,0)|0;f=F()|0;if(!(_>=+(h>>>0)+4294967296.0*+(f|0)))break d;la=A*d-y*w;y=y*d+A*w;A=la;i=c[G>>2]|0;e=c[K>>2]|0;}}}else {C=f;A=+((c[C>>2]|0)>>>0)+4294967296.0*+(c[C+4>>2]|0)-b;A=A+(A<0.0?-.5:.5);C=+s(A)>=1.0?(A>0.0?~~+B(+r(A/4294967296.0),4294967295.0)>>>0:~~+z((A-+(~~A>>>0))/4294967296.0)>>>0):0;D=f+8|0;la=+((c[D>>2]|0)>>>0)+4294967296.0*+(c[D+4>>2]|0)-b;la=la+(la<0.0?-.5:.5);D=+s(la)>=1.0?(la>0.0?~~+B(+r(la/4294967296.0),4294967295.0)>>>0:~~+z((la-+(~~la>>>0))/4294967296.0)>>>0):0;ba=ga;c[ba>>2]=~~A>>>0;c[ba+4>>2]=C;ba=R;c[ba>>2]=~~la>>>0;c[ba+4>>2]=D;if((c[S>>2]|0)>>>0>h>>>0){c[e>>2]=c[ga>>2];c[e+4>>2]=c[ga+4>>2];c[e+8>>2]=c[ga+8>>2];c[e+12>>2]=c[ga+12>>2];e=(c[K>>2]|0)+16|0;c[K>>2]=e;}else {_e(J,ga);e=c[K>>2]|0;}D=c[G>>2]|0;C=D;A=+((c[C>>2]|0)>>>0)+4294967296.0*+(c[C+4>>2]|0)+b;A=A+(A<0.0?-.5:.5);C=+s(A)>=1.0?(A>0.0?~~+B(+r(A/4294967296.0),4294967295.0)>>>0:~~+z((A-+(~~A>>>0))/4294967296.0)>>>0):0;D=D+8|0;la=+((c[D>>2]|0)>>>0)+4294967296.0*+(c[D+4>>2]|0)-b;la=la+(la<0.0?-.5:.5);D=+s(la)>=1.0?(la>0.0?~~+B(+r(la/4294967296.0),4294967295.0)>>>0:~~+z((la-+(~~la>>>0))/4294967296.0)>>>0):0;ba=ga;c[ba>>2]=~~A>>>0;c[ba+4>>2]=C;ba=R;c[ba>>2]=~~la>>>0;c[ba+4>>2]=D;if(e>>>0<(c[S>>2]|0)>>>0){c[e>>2]=c[ga>>2];c[e+4>>2]=c[ga+4>>2];c[e+8>>2]=c[ga+8>>2];c[e+12>>2]=c[ga+12>>2];e=(c[K>>2]|0)+16|0;c[K>>2]=e;}else {_e(J,ga);e=c[K>>2]|0;}D=c[G>>2]|0;C=D;A=+((c[C>>2]|0)>>>0)+4294967296.0*+(c[C+4>>2]|0)+b;A=A+(A<0.0?-.5:.5);C=+s(A)>=1.0?(A>0.0?~~+B(+r(A/4294967296.0),4294967295.0)>>>0:~~+z((A-+(~~A>>>0))/4294967296.0)>>>0):0;D=D+8|0;la=+((c[D>>2]|0)>>>0)+4294967296.0*+(c[D+4>>2]|0)+b;la=la+(la<0.0?-.5:.5);D=+s(la)>=1.0?(la>0.0?~~+B(+r(la/4294967296.0),4294967295.0)>>>0:~~+z((la-+(~~la>>>0))/4294967296.0)>>>0):0;ba=ga;c[ba>>2]=~~A>>>0;c[ba+4>>2]=C;ba=R;c[ba>>2]=~~la>>>0;c[ba+4>>2]=D;if(e>>>0<(c[S>>2]|0)>>>0){c[e>>2]=c[ga>>2];c[e+4>>2]=c[ga+4>>2];c[e+8>>2]=c[ga+8>>2];c[e+12>>2]=c[ga+12>>2];e=(c[K>>2]|0)+16|0;c[K>>2]=e;}else {_e(J,ga);e=c[K>>2]|0;}D=c[G>>2]|0;C=D;A=+((c[C>>2]|0)>>>0)+4294967296.0*+(c[C+4>>2]|0)-b;A=A+(A<0.0?-.5:.5);C=+s(A)>=1.0?(A>0.0?~~+B(+r(A/4294967296.0),4294967295.0)>>>0:~~+z((A-+(~~A>>>0))/4294967296.0)>>>0):0;D=D+8|0;la=+((c[D>>2]|0)>>>0)+4294967296.0*+(c[D+4>>2]|0)+b;la=la+(la<0.0?-.5:.5);D=+s(la)>=1.0?(la>0.0?~~+B(+r(la/4294967296.0),4294967295.0)>>>0:~~+z((la-+(~~la>>>0))/4294967296.0)>>>0):0;ba=ga;c[ba>>2]=~~A>>>0;c[ba+4>>2]=C;ba=R;c[ba>>2]=~~la>>>0;c[ba+4>>2]=D;if(e>>>0<(c[S>>2]|0)>>>0){c[e>>2]=c[ga>>2];c[e+4>>2]=c[ga+4>>2];c[e+8>>2]=c[ga+8>>2];c[e+12>>2]=c[ga+12>>2];c[K>>2]=(c[K>>2]|0)+16;}else _e(J,ga);}while(0);ba=c[ja>>2]|0;if((ba|0)==(c[Q>>2]|0)){He(ia,J);break}c[ba>>2]=0;j=ba+4|0;c[j>>2]=0;f=ba+8|0;c[f>>2]=0;e=(c[K>>2]|0)-(c[J>>2]|0)|0;h=e>>4;if(e|0){if(h>>>0>268435455){e=48;break b}i=Zj(e)|0;c[j>>2]=i;c[ba>>2]=i;c[f>>2]=i+(h<<4);e=c[J>>2]|0;f=(c[K>>2]|0)-e|0;if((f|0)>0){ax(i|0,e|0,f|0)|0;c[j>>2]=i+(f>>>4<<4);}}c[ja>>2]=(c[ja>>2]|0)+12;break}}else {if((p|0)<48)break;if(c[D+44>>2]|0)break;c[K>>2]=c[J>>2];}c[M>>2]=c[L>>2];Gd(L,q);e=q+-1|0;C=(p|0)>16;if(C){o=0;do{m=c[G>>2]|0;n=o;o=o+1|0;h=m+(o<<4)|0;f=c[h>>2]|0;h=c[h+4>>2]|0;j=m+(n<<4)|0;i=c[j>>2]|0;j=c[j+4>>2]|0;l=m+(o<<4)+8|0;k=c[l>>2]|0;l=c[l+4>>2]|0;n=m+(n<<4)+8|0;m=c[n>>2]|0;n=c[n+4>>2]|0;if((f|0)==(i|0)&(h|0)==(j|0)&((k|0)==(m|0)&(l|0)==(n|0))){c[ga>>2]=0;c[ga+4>>2]=0;c[ga+8>>2]=0;c[ga+12>>2]=0;}else {j=Ww(f|0,h|0,i|0,j|0)|0;la=+(j>>>0)+4294967296.0*+(F()|0);n=Ww(k|0,l|0,m|0,n|0)|0;y=+(n>>>0)+4294967296.0*+(F()|0);A=1.0/+t(+(la*la+y*y));g[ga>>3]=A*y;g[O>>3]=-(A*la);}f=c[M>>2]|0;if(f>>>0<(c[N>>2]|0)>>>0){c[f>>2]=c[ga>>2];c[f+4>>2]=c[ga+4>>2];c[f+8>>2]=c[ga+8>>2];c[f+12>>2]=c[ga+12>>2];c[M>>2]=(c[M>>2]|0)+16;}else $e(L,ga);}while((o|0)<(e|0))}o=D+44|0;if((c[o>>2]|0)>>>0<2){n=c[G>>2]|0;h=n;f=c[h>>2]|0;h=c[h+4>>2]|0;j=n+(e<<4)|0;i=c[j>>2]|0;j=c[j+4>>2]|0;l=n+8|0;k=c[l>>2]|0;l=c[l+4>>2]|0;n=n+(e<<4)+8|0;m=c[n>>2]|0;n=c[n+4>>2]|0;if((f|0)==(i|0)&(h|0)==(j|0)&((k|0)==(m|0)&(l|0)==(n|0))){c[ga>>2]=0;c[ga+4>>2]=0;c[ga+8>>2]=0;c[ga+12>>2]=0;}else {j=Ww(f|0,h|0,i|0,j|0)|0;la=+(j>>>0)+4294967296.0*+(F()|0);n=Ww(k|0,l|0,m|0,n|0)|0;y=+(n>>>0)+4294967296.0*+(F()|0);A=1.0/+t(+(la*la+y*y));g[ga>>3]=A*y;g[U>>3]=-(A*la);}f=c[M>>2]|0;if(f>>>0<(c[N>>2]|0)>>>0){c[f>>2]=c[ga>>2];c[f+4>>2]=c[ga+4>>2];c[f+8>>2]=c[ga+8>>2];c[f+12>>2]=c[ga+12>>2];c[M>>2]=(c[M>>2]|0)+16;}else $e(L,ga);}else {f=(c[L>>2]|0)+(q+-2<<4)|0;c[ga>>2]=c[f>>2];c[ga+4>>2]=c[f+4>>2];c[ga+8>>2]=c[f+8>>2];c[ga+12>>2]=c[f+12>>2];f=c[M>>2]|0;if(f>>>0<(c[N>>2]|0)>>>0){c[f>>2]=c[ga>>2];c[f+4>>2]=c[ga+4>>2];c[f+8>>2]=c[ga+8>>2];c[f+12>>2]=c[ga+12>>2];c[M>>2]=(c[M>>2]|0)+16;}else $e(L,ga);}f=c[o>>2]|0;switch(f|0){case 0:{c[ga>>2]=e;if((p|0)>0){f=D+40|0;e=0;do{Hd(a,e,ga,c[f>>2]|0);e=e+1|0;}while((e|0)<(q|0))}ea=c[ja>>2]|0;if((ea|0)==(c[Q>>2]|0))He(ia,J);else {c[ea>>2]=0;j=ea+4|0;c[j>>2]=0;f=ea+8|0;c[f>>2]=0;e=(c[K>>2]|0)-(c[J>>2]|0)|0;h=e>>4;if(e|0){if(h>>>0>268435455){e=80;break b}i=Zj(e)|0;c[j>>2]=i;c[ea>>2]=i;c[f>>2]=i+(h<<4);e=c[X>>2]|0;f=(c[K>>2]|0)-e|0;if((f|0)>0){ax(i|0,e|0,f|0)|0;c[j>>2]=i+(f>>>4<<4);}}c[ja>>2]=(c[ja>>2]|0)+12;}break c}case 1:{c[ga>>2]=e;l=(p|0)>0;if(l){h=D+40|0;f=0;do{Hd(a,f,ga,c[h>>2]|0);f=f+1|0;}while((f|0)<(q|0))}fa=c[ja>>2]|0;if((fa|0)==(c[Q>>2]|0))He(ia,J);else {c[fa>>2]=0;k=fa+4|0;c[k>>2]=0;h=fa+8|0;c[h>>2]=0;f=(c[K>>2]|0)-(c[J>>2]|0)|0;i=f>>4;if(f|0){if(i>>>0>268435455){e=92;break b}j=Zj(f)|0;c[k>>2]=j;c[fa>>2]=j;c[h>>2]=j+(i<<4);f=c[X>>2]|0;h=(c[K>>2]|0)-f|0;if((h|0)>0){ax(j|0,f|0,h|0)|0;c[k>>2]=j+(h>>>4<<4);}}c[ja>>2]=(c[ja>>2]|0)+12;}c[K>>2]=c[J>>2];f=c[L>>2]|0;d=+g[f+(e<<4)>>3];w=+g[f+(e<<4)+8>>3];if(C){h=e;do{da=h;h=h+-1|0;la=-+g[f+(h<<4)+8>>3];g[f+(da<<4)>>3]=-+g[f+(h<<4)>>3];g[f+(da<<4)+8>>3]=la;f=c[L>>2]|0;}while((da|0)>1)}g[f>>3]=-d;g[f+8>>3]=-w;c[ga>>2]=0;if(l){f=D+40|0;while(1){Hd(a,e,ga,c[f>>2]|0);if((e|0)>0)e=e+-1|0;else break}}da=c[ja>>2]|0;if((da|0)==(c[Q>>2]|0))He(ia,J);else {c[da>>2]=0;j=da+4|0;c[j>>2]=0;f=da+8|0;c[f>>2]=0;e=(c[K>>2]|0)-(c[J>>2]|0)|0;h=e>>4;do if(e|0){if(h>>>0>268435455){e=106;break b}i=Zj(e)|0;c[j>>2]=i;c[da>>2]=i;c[f>>2]=i+(h<<4);e=c[X>>2]|0;f=(c[K>>2]|0)-e|0;if((f|0)<=0)break;ax(i|0,e|0,f|0)|0;c[j>>2]=i+(f>>>4<<4);}while(0);c[ja>>2]=(c[ja>>2]|0)+12;}break c}default:{c[ga>>2]=0;i=(p|0)>32;if(i){h=D+40|0;f=1;do{Hd(a,f,ga,c[h>>2]|0);f=f+1|0;}while((f|0)<(e|0));f=c[o>>2]|0;}c[ha>>2]=0;c[ha+4>>2]=0;c[ha+8>>2]=0;c[ha+12>>2]=0;do if((f|0)==2){ca=c[G>>2]|0;p=ca+(e<<4)|0;f=c[L>>2]|0;A=+g[f+(e<<4)>>3]*b+(+((c[p>>2]|0)>>>0)+4294967296.0*+(c[p+4>>2]|0));A=A+(A<0.0?-.5:.5);p=+s(A)>=1.0?(A>0.0?~~+B(+r(A/4294967296.0),4294967295.0)>>>0:~~+z((A-+(~~A>>>0))/4294967296.0)>>>0):0;ca=ca+(e<<4)+8|0;la=+g[f+(e<<4)+8>>3]*b+(+((c[ca>>2]|0)>>>0)+4294967296.0*+(c[ca+4>>2]|0));la=la+(la<0.0?-.5:.5);ca=+s(la)>=1.0?(la>0.0?~~+B(+r(la/4294967296.0),4294967295.0)>>>0:~~+z((la-+(~~la>>>0))/4294967296.0)>>>0):0;f=ha;c[f>>2]=~~A>>>0;c[f+4>>2]=p;f=V;c[f>>2]=~~la>>>0;c[f+4>>2]=ca;f=c[K>>2]|0;if((f|0)==(c[S>>2]|0)){Ge(J,ha);f=c[K>>2]|0;}else {c[f>>2]=c[ha>>2];c[f+4>>2]=c[ha+4>>2];c[f+8>>2]=c[ha+8>>2];c[f+12>>2]=c[ha+12>>2];f=(c[K>>2]|0)+16|0;c[K>>2]=f;}ca=c[G>>2]|0;n=ca+(e<<4)|0;p=c[L>>2]|0;A=+((c[n>>2]|0)>>>0)+4294967296.0*+(c[n+4>>2]|0)-+g[p+(e<<4)>>3]*b;A=A+(A<0.0?-.5:.5);n=+s(A)>=1.0?(A>0.0?~~+B(+r(A/4294967296.0),4294967295.0)>>>0:~~+z((A-+(~~A>>>0))/4294967296.0)>>>0):0;ca=ca+(e<<4)+8|0;la=+((c[ca>>2]|0)>>>0)+4294967296.0*+(c[ca+4>>2]|0)-+g[p+(e<<4)+8>>3]*b;la=la+(la<0.0?-.5:.5);p=+s(la)>=1.0?(la>0.0?~~+B(+r(la/4294967296.0),4294967295.0)>>>0:~~+z((la-+(~~la>>>0))/4294967296.0)>>>0):0;ca=ha;c[ca>>2]=~~A>>>0;c[ca+4>>2]=n;ca=V;c[ca>>2]=~~la>>>0;c[ca+4>>2]=p;if((f|0)==(c[S>>2]|0)){Ge(J,ha);break}else {c[f>>2]=c[ha>>2];c[f+4>>2]=c[ha+4>>2];c[f+8>>2]=c[ha+8>>2];c[f+12>>2]=c[ha+12>>2];c[K>>2]=(c[K>>2]|0)+16;break}}else {f=q+-2|0;c[ga>>2]=f;g[W>>3]=0.0;ca=c[L>>2]|0;p=ca+(e<<4)|0;ca=ca+(e<<4)+8|0;la=-+g[ca>>3];g[p>>3]=-+g[p>>3];g[ca>>3]=la;if((c[o>>2]|0)==3){Id(a,e,f);break}else {Jd(a,e,f);break}}while(0);if(C){f=e;do{ca=f;f=f+-1|0;C=c[L>>2]|0;la=-+g[C+(f<<4)+8>>3];g[C+(ca<<4)>>3]=-+g[C+(f<<4)>>3];g[C+(ca<<4)+8>>3]=la;}while((ca|0)>1)}ca=c[L>>2]|0;la=-+g[ca+24>>3];g[ca>>3]=-+g[ca+16>>3];g[ca+8>>3]=la;c[ga>>2]=e;if(i){f=D+40|0;e=q+-2|0;while(1){Hd(a,e,ga,c[f>>2]|0);if((e|0)>1)e=e+-1|0;else break}}e=c[o>>2]|0;do if((e|0)==2){e=c[G>>2]|0;D=e;ca=c[L>>2]|0;A=+((c[D>>2]|0)>>>0)+4294967296.0*+(c[D+4>>2]|0)-+g[ca>>3]*b;A=A+(A<0.0?-.5:.5);D=+s(A)>=1.0?(A>0.0?~~+B(+r(A/4294967296.0),4294967295.0)>>>0:~~+z((A-+(~~A>>>0))/4294967296.0)>>>0):0;e=e+8|0;la=+((c[e>>2]|0)>>>0)+4294967296.0*+(c[e+4>>2]|0)-+g[ca+8>>3]*b;la=la+(la<0.0?-.5:.5);ca=+s(la)>=1.0?(la>0.0?~~+B(+r(la/4294967296.0),4294967295.0)>>>0:~~+z((la-+(~~la>>>0))/4294967296.0)>>>0):0;e=ha;c[e>>2]=~~A>>>0;c[e+4>>2]=D;e=V;c[e>>2]=~~la>>>0;c[e+4>>2]=ca;e=c[K>>2]|0;if((e|0)==(c[S>>2]|0)){Ge(J,ha);e=c[K>>2]|0;}else {c[e>>2]=c[ha>>2];c[e+4>>2]=c[ha+4>>2];c[e+8>>2]=c[ha+8>>2];c[e+12>>2]=c[ha+12>>2];e=(c[K>>2]|0)+16|0;c[K>>2]=e;}D=c[G>>2]|0;C=D;ca=c[L>>2]|0;A=+g[ca>>3]*b+(+((c[C>>2]|0)>>>0)+4294967296.0*+(c[C+4>>2]|0));A=A+(A<0.0?-.5:.5);C=+s(A)>=1.0?(A>0.0?~~+B(+r(A/4294967296.0),4294967295.0)>>>0:~~+z((A-+(~~A>>>0))/4294967296.0)>>>0):0;D=D+8|0;la=+g[ca+8>>3]*b+(+((c[D>>2]|0)>>>0)+4294967296.0*+(c[D+4>>2]|0));la=la+(la<0.0?-.5:.5);D=+s(la)>=1.0?(la>0.0?~~+B(+r(la/4294967296.0),4294967295.0)>>>0:~~+z((la-+(~~la>>>0))/4294967296.0)>>>0):0;ca=ha;c[ca>>2]=~~A>>>0;c[ca+4>>2]=C;ca=V;c[ca>>2]=~~la>>>0;c[ca+4>>2]=D;if((e|0)==(c[S>>2]|0)){Ge(J,ha);break}else {c[e>>2]=c[ha>>2];c[e+4>>2]=c[ha+4>>2];c[e+8>>2]=c[ha+8>>2];c[e+12>>2]=c[ha+12>>2];c[K>>2]=(c[K>>2]|0)+16;break}}else {c[ga>>2]=1;g[W>>3]=0.0;if((e|0)==3){Id(a,0,1);break}else {Jd(a,0,1);break}}while(0);ca=c[ja>>2]|0;if((ca|0)==(c[Q>>2]|0))He(ia,J);else {c[ca>>2]=0;j=ca+4|0;c[j>>2]=0;f=ca+8|0;c[f>>2]=0;e=(c[K>>2]|0)-(c[J>>2]|0)|0;h=e>>4;do if(e|0){if(h>>>0>268435455){e=146;break b}i=Zj(e)|0;c[j>>2]=i;c[ca>>2]=i;c[f>>2]=i+(h<<4);e=c[X>>2]|0;f=(c[K>>2]|0)-e|0;if((f|0)<=0)break;ax(i|0,e|0,f|0)|0;c[j>>2]=i+(f>>>4<<4);}while(0);c[ja>>2]=(c[ja>>2]|0)+12;}break c}}}while(0);E=E+1|0;e=c[Y>>2]|0;if((E|0)>=((c[Z>>2]|0)-e>>2|0)){e=153;break}}if((e|0)==48)gk();else if((e|0)==80)gk();else if((e|0)==92)gk();else if((e|0)==106)gk();else if((e|0)==146)gk();else if((e|0)==153){Eb=ka;return}}function Ed(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;c[a>>2]=3556;e=a+112|0;d=a+120|0;if(c[d>>2]|0?(b=c[a+116>>2]|0,f=(c[e>>2]|0)+4|0,g=c[b>>2]|0,c[g+4>>2]=c[f>>2],c[c[f>>2]>>2]=g,c[d>>2]=0,(b|0)!=(e|0)):0)do{g=b;b=c[b+4>>2]|0;$j(g);}while((b|0)!=(e|0));b=c[a+96>>2]|0;if(b|0){c[a+100>>2]=b;$j(b);}b=c[a+84>>2]|0;if(b|0){c[a+88>>2]=b;$j(b);}b=c[a+72>>2]|0;if(!b){yc(a);return}c[a+76>>2]=b;$j(b);yc(a);return}function Fd(b,d,e){b=b|0;d=d|0;e=+e;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0;aa=Eb;Eb=Eb+176|0;L=aa+168|0;X=aa+24|0;D=aa;N=aa+8|0;H=d+48|0;I=d+52|0;h=c[I>>2]|0;g=c[H>>2]|0;if((h|0)!=(g|0)){j=0;i=h;do{h=c[g+(j<<2)>>2]|0;if(h){Ub[c[(c[h>>2]|0)+4>>2]&127](h);g=c[H>>2]|0;i=c[I>>2]|0;}j=j+1|0;h=i-g|0;}while(j>>>0<h>>2>>>0);if(h|0)c[I>>2]=g;}J=d+16|0;O=d+20|0;g=c[J>>2]|0;if((c[O>>2]|0)!=(g|0))c[O>>2]=g;Ad(b);Dd(b,e);c[X+24>>2]=0;$=X+28|0;c[$>>2]=0;c[X+32>>2]=0;Y=X+40|0;c[Y>>2]=0;_=X+44|0;c[_>>2]=0;c[X+48>>2]=0;W=X+56|0;c[W>>2]=0;Z=X+60|0;c[Z>>2]=0;c[X+64>>2]=0;T=X+4|0;c[T>>2]=0;c[T+4>>2]=0;c[T+8>>2]=0;c[T+12>>2]=0;c[X>>2]=3556;S=X+72|0;i=X+112|0;g=S;h=g+36|0;do{c[g>>2]=0;g=g+4|0;}while((g|0)<(h|0));c[i>>2]=i;Q=X+116|0;c[Q>>2]=i;P=X+120|0;c[P>>2]=0;a[X+128>>0]=0;U=X+20|0;a[U>>0]=0;C=X+140|0;a[C>>0]=0;a[X+142>>0]=0;a[X+36>>0]=0;V=X+37|0;a[V>>0]=0;k=b+16|0;j=b+20|0;g=c[k>>2]|0;a:do if((c[j>>2]|0)!=(g|0)){h=0;i=3556;while(1){Qb[c[i+8>>2]&15](X,g+(h*12|0)|0,0,1)|0;h=h+1|0;g=c[k>>2]|0;if(h>>>0>=(((c[j>>2]|0)-g|0)/12|0)>>>0)break a;i=c[X>>2]|0;}}while(0);if(!(e>0.0)){g=c[X+8>>2]|0;B=c[X+12>>2]|0;b:do if((g|0)==(B|0)){m=D;c[m>>2]=0;c[m+4>>2]=0;m=0;l=0;b=0;k=0;j=0;i=0;h=0;g=0;}else {A=c[g+8>>2]|0;i=A;j=c[i>>2]|0;i=c[i+4>>2]|0;y=D;c[y>>2]=j;c[y+4>>2]=i;y=A+8|0;b=c[y>>2]|0;y=c[y+4>>2]|0;z=b;m=j;l=i;h=b;n=y;k=y;while(1){x=(k|0)<(y|0)|(k|0)==(y|0)&b>>>0<z>>>0;w=g+12|0;v=A;u=n;while(1){q=c[v+88>>2]|0;p=v;n=c[p>>2]|0;p=c[p+4>>2]|0;o=(p|0)<(l|0)|(p|0)==(l|0)&n>>>0<m>>>0;if(!q){n=v;m=o;l=v;}else {t=m;s=l;r=m;m=l;while(1){t=o?n:t;s=o?p:s;r=o?n:r;m=o?p:m;l=(p|0)>(i|0)|(p|0)==(i|0)&n>>>0>j>>>0;j=l?n:j;i=l?p:i;l=c[q+88>>2]|0;ba=q;n=c[ba>>2]|0;p=c[ba+4>>2]|0;o=(p|0)<(m|0)|(p|0)==(m|0)&n>>>0<r>>>0;if(!l)break;else q=l;}n=D;c[n>>2]=t;c[n+4>>2]=s;n=q;m=o;l=q;}ba=m?l:D;m=c[ba>>2]|0;ba=c[ba+4>>2]|0;o=D;c[o>>2]=m;c[o+4>>2]=ba;o=l;s=c[o>>2]|0;o=c[o+4>>2]|0;t=(i|0)<(o|0)|(i|0)==(o|0)&j>>>0<s>>>0;j=t?s:j;o=t?o:i;t=n+32|0;s=c[t>>2]|0;t=c[t+4>>2]|0;l=(t|0)<(ba|0)|(t|0)==(ba|0)&s>>>0<m>>>0;m=l?s:m;l=l?t:ba;ba=D;c[ba>>2]=m;c[ba+4>>2]=l;ba=(o|0)<(t|0)|(o|0)==(t|0)&j>>>0<s>>>0;j=ba?s:j;o=ba?t:o;n=n+40|0;t=c[n>>2]|0;n=c[n+4>>2]|0;ba=(n|0)<(u|0)|(n|0)==(u|0)&t>>>0<h>>>0;h=ba?t:h;n=ba?n:u;if((v|0)!=(A|0))break;v=c[w>>2]|0;u=n;i=o;}b=x?z:b;k=x?y:k;i=g+16|0;if((i|0)==(B|0)){i=o;g=n;break b}A=c[g+24>>2]|0;y=A+8|0;g=i;z=c[y>>2]|0;i=o;y=c[y+4>>2]|0;}}while(0);c[N>>2]=0;o=N+4|0;c[o>>2]=0;B=N+8|0;c[B>>2]=0;n=Zj(64)|0;c[N>>2]=n;A=n+64|0;c[B>>2]=A;c[o>>2]=A;A=Vw(m|0,l|0,-10,-1)|0;B=F()|0;x=Vw(b|0,k|0,10,0)|0;ba=F()|0;y=n;c[y>>2]=A;c[y+4>>2]=B;y=n+8|0;c[y>>2]=x;c[y+4>>2]=ba;y=Vw(j|0,i|0,10,0)|0;z=F()|0;D=n+16|0;c[D>>2]=y;c[D+4>>2]=z;D=n+24|0;c[D>>2]=x;c[D+4>>2]=ba;D=Vw(h|0,g|0,-10,-1)|0;ba=F()|0;g=n+32|0;c[g>>2]=y;c[g+4>>2]=z;g=n+40|0;c[g>>2]=D;c[g+4>>2]=ba;g=n+48|0;c[g>>2]=A;c[g+4>>2]=B;g=n+56|0;c[g>>2]=D;c[g+4>>2]=ba;Ec(X,N,0,1)|0;a[C>>0]=1;Qc(X,1,d,3,3)|0;g=c[J>>2]|0;if(((c[O>>2]|0)-g|0)==4?(G=c[g>>2]|0,K=G+16|0,M=G+20|0,E=(c[M>>2]|0)-(c[K>>2]|0)|0,(E|0)>0):0){qd(J,E>>>2);c[c[J>>2]>>2]=c[c[K>>2]>>2];j=c[J>>2]|0;c[(c[j>>2]|0)+28>>2]=c[G+28>>2];h=c[K>>2]|0;if(((c[M>>2]|0)-h|0)>4){k=d+24|0;g=1;while(1){h=c[h+(g<<2)>>2]|0;i=c[O>>2]|0;c[L>>2]=h;if((c[k>>2]|0)>>>0>i>>>0){c[i>>2]=h;c[O>>2]=(c[O>>2]|0)+4;}else Ie(J,L);c[h+28>>2]=d;c[h+32>>2]=i-j>>2;g=g+1|0;h=c[K>>2]|0;if((g|0)>=((c[M>>2]|0)-h>>2|0))break;j=c[J>>2]|0;}g=c[N>>2]|0;if(g|0){h=g;R=47;}}else {h=n;g=n;R=47;}}else {h=c[I>>2]|0;g=c[H>>2]|0;if((h|0)!=(g|0)){j=0;do{i=c[g+(j<<2)>>2]|0;if(i){Ub[c[(c[i>>2]|0)+4>>2]&127](i);g=c[H>>2]|0;h=c[I>>2]|0;}j=j+1|0;i=h-g|0;}while(j>>>0<i>>2>>>0);if(i|0)c[I>>2]=g;}g=c[J>>2]|0;if((c[O>>2]|0)==(g|0)){h=n;g=n;R=47;}else {c[O>>2]=g;h=n;g=n;R=47;}}if((R|0)==47){c[o>>2]=h;$j(g);}}else Qc(X,1,d,2,2)|0;c[X>>2]=3556;g=X+112|0;if(c[P>>2]|0?(f=c[Q>>2]|0,ba=(c[g>>2]|0)+4|0,R=c[f>>2]|0,c[R+4>>2]=c[ba>>2],c[c[ba>>2]>>2]=R,c[P>>2]=0,(f|0)!=(g|0)):0)do{ba=f;f=c[f+4>>2]|0;$j(ba);}while((f|0)!=(g|0));f=c[X+96>>2]|0;if(f|0){c[X+100>>2]=f;$j(f);}f=c[X+84>>2]|0;if(f|0){c[X+88>>2]=f;$j(f);}f=c[S>>2]|0;if(f|0){c[X+76>>2]=f;$j(f);}c[X>>2]=3528;k=X+8|0;j=c[k>>2]|0;b=X+12|0;c[b>>2]=j;c[T>>2]=j;j=X+24|0;f=c[$>>2]|0;g=c[j>>2]|0;if((f|0)!=(g|0)){i=0;do{h=c[g+(i<<2)>>2]|0;if(h){ak(h);g=c[j>>2]|0;f=c[$>>2]|0;}i=i+1|0;}while(i>>>0<f-g>>2>>>0);f=g;}c[$>>2]=f;a[U>>0]=0;a[V>>0]=0;f=c[W>>2]|0;if(f|0){c[Z>>2]=f;$j(f);}f=c[Y>>2]|0;if(f|0){c[_>>2]=f;$j(f);}f=c[j>>2]|0;if(f|0){c[$>>2]=f;$j(f);}f=c[k>>2]|0;if(!f){Eb=aa;return}c[b>>2]=f;$j(f);Eb=aa;return}function Gd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;f=a+8|0;g=c[a>>2]|0;if((c[f>>2]|0)-g>>4>>>0>=b>>>0)return;h=a+4|0;if(b>>>0>268435455){h=S(8)|0;dk(h,8694);c[h>>2]=7328;V(h|0,3264,87);}d=(c[h>>2]|0)-g|0;e=Zj(b<<4)|0;if((d|0)>0)ax(e|0,g|0,d|0)|0;c[a>>2]=e;c[h>>2]=e+(d>>4<<4);c[f>>2]=e+(b<<4);if(!g)return;$j(g);return}function Hd(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0.0,i=0,j=0,k=0.0,l=0.0,m=0,n=0,o=0.0,p=0.0,q=0.0,t=0,u=0,v=0,w=0;w=Eb;Eb=Eb+16|0;v=w;i=c[d>>2]|0;u=a+52|0;f=c[u>>2]|0;q=+g[f+(i<<4)>>3];k=+g[f+(b<<4)+8>>3];l=+g[f+(b<<4)>>3];o=+g[f+(i<<4)+8>>3];h=q*k-l*o;f=a+72|0;g[f>>3]=h;t=a+64|0;p=+g[t>>3];do if(+s(+(h*p))<1.0){if(q*l+k*o>0.0){e=c[a+28>>2]|0;d=e+(b<<4)|0;l=q*p+(+((c[d>>2]|0)>>>0)+4294967296.0*+(c[d+4>>2]|0));l=l+(l<0.0?-.5:.5);d=+s(l)>=1.0?(l>0.0?~~+B(+r(l/4294967296.0),4294967295.0)>>>0:~~+z((l-+(~~l>>>0))/4294967296.0)>>>0):0;e=e+(b<<4)+8|0;q=o*p+(+((c[e>>2]|0)>>>0)+4294967296.0*+(c[e+4>>2]|0));q=q+(q<0.0?-.5:.5);e=+s(q)>=1.0?(q>0.0?~~+B(+r(q/4294967296.0),4294967295.0)>>>0:~~+z((q-+(~~q>>>0))/4294967296.0)>>>0):0;f=v;c[f>>2]=~~l>>>0;c[f+4>>2]=d;f=v+8|0;c[f>>2]=~~q>>>0;c[f+4>>2]=e;f=a+44|0;e=c[f>>2]|0;if(e>>>0<(c[a+48>>2]|0)>>>0){c[e>>2]=c[v>>2];c[e+4>>2]=c[v+4>>2];c[e+8>>2]=c[v+8>>2];c[e+12>>2]=c[v+12>>2];c[f>>2]=(c[f>>2]|0)+16;}else _e(a+40|0,v);Eb=w;return}}else {if(h>1.0){g[f>>3]=1.0;h=1.0;break}if(h<-1.0){g[f>>3]=-1.0;h=-1.0;}}while(0);a:do if(p*h<0.0){m=a+40|0;n=a+28|0;f=c[n>>2]|0;i=f+(b<<4)|0;l=q*p+(+((c[i>>2]|0)>>>0)+4294967296.0*+(c[i+4>>2]|0));l=l+(l<0.0?-.5:.5);i=+s(l)>=1.0?(l>0.0?~~+B(+r(l/4294967296.0),4294967295.0)>>>0:~~+z((l-+(~~l>>>0))/4294967296.0)>>>0):0;f=f+(b<<4)+8|0;q=o*p+(+((c[f>>2]|0)>>>0)+4294967296.0*+(c[f+4>>2]|0));q=q+(q<0.0?-.5:.5);f=+s(q)>=1.0?(q>0.0?~~+B(+r(q/4294967296.0),4294967295.0)>>>0:~~+z((q-+(~~q>>>0))/4294967296.0)>>>0):0;j=v;c[j>>2]=~~l>>>0;c[j+4>>2]=i;j=v+8|0;c[j>>2]=~~q>>>0;c[j+4>>2]=f;j=a+44|0;f=c[j>>2]|0;i=a+48|0;if(f>>>0<(c[i>>2]|0)>>>0){c[f>>2]=c[v>>2];c[f+4>>2]=c[v+4>>2];c[f+8>>2]=c[v+8>>2];c[f+12>>2]=c[v+12>>2];e=(c[j>>2]|0)+16|0;c[j>>2]=e;}else {_e(m,v);e=c[j>>2]|0;}f=(c[n>>2]|0)+(b<<4)|0;if((e|0)==(c[i>>2]|0)){Ge(m,f);f=c[j>>2]|0;}else {c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];c[e+8>>2]=c[f+8>>2];c[e+12>>2]=c[f+12>>2];f=(c[j>>2]|0)+16|0;c[j>>2]=f;}n=c[n>>2]|0;e=n+(b<<4)|0;a=c[u>>2]|0;q=+g[t>>3];p=+g[a+(b<<4)>>3]*q+(+((c[e>>2]|0)>>>0)+4294967296.0*+(c[e+4>>2]|0));p=p+(p<0.0?-.5:.5);t=+s(p)>=1.0?(p>0.0?~~+B(+r(p/4294967296.0),4294967295.0)>>>0:~~+z((p-+(~~p>>>0))/4294967296.0)>>>0):0;u=n+(b<<4)+8|0;q=q*+g[a+(b<<4)+8>>3]+(+((c[u>>2]|0)>>>0)+4294967296.0*+(c[u+4>>2]|0));q=q+(q<0.0?-.5:.5);u=+s(q)>=1.0?(q>0.0?~~+B(+r(q/4294967296.0),4294967295.0)>>>0:~~+z((q-+(~~q>>>0))/4294967296.0)>>>0):0;a=v;c[a>>2]=~~p>>>0;c[a+4>>2]=t;a=v+8|0;c[a>>2]=~~q>>>0;c[a+4>>2]=u;if(f>>>0<(c[i>>2]|0)>>>0){c[f>>2]=c[v>>2];c[f+4>>2]=c[v+4>>2];c[f+8>>2]=c[v+8>>2];c[f+12>>2]=c[v+12>>2];c[j>>2]=(c[j>>2]|0)+16;}else _e(m,v);}else switch(e|0){case 2:{h=q*l+k*o+1.0;if(!(h>=+g[a+96>>3])){Id(a,b,i);break a}h=p/h;e=c[a+28>>2]|0;u=e+(b<<4)|0;p=h*(q+l)+(+((c[u>>2]|0)>>>0)+4294967296.0*+(c[u+4>>2]|0));p=p+(p<0.0?-.5:.5);u=+s(p)>=1.0?(p>0.0?~~+B(+r(p/4294967296.0),4294967295.0)>>>0:~~+z((p-+(~~p>>>0))/4294967296.0)>>>0):0;e=e+(b<<4)+8|0;q=h*(o+k)+(+((c[e>>2]|0)>>>0)+4294967296.0*+(c[e+4>>2]|0));q=q+(q<0.0?-.5:.5);e=+s(q)>=1.0?(q>0.0?~~+B(+r(q/4294967296.0),4294967295.0)>>>0:~~+z((q-+(~~q>>>0))/4294967296.0)>>>0):0;f=v;c[f>>2]=~~p>>>0;c[f+4>>2]=u;f=v+8|0;c[f>>2]=~~q>>>0;c[f+4>>2]=e;f=a+44|0;e=c[f>>2]|0;if(e>>>0<(c[a+48>>2]|0)>>>0){c[e>>2]=c[v>>2];c[e+4>>2]=c[v+4>>2];c[e+8>>2]=c[v+8>>2];c[e+12>>2]=c[v+12>>2];c[f>>2]=(c[f>>2]|0)+16;}else _e(a+40|0,v);break a}case 0:{Id(a,b,i);break a}case 1:{Jd(a,b,i);break a}default:break a}while(0);c[d>>2]=b;Eb=w;return}function Id(a,b,d){a=a|0;b=b|0;d=d|0;var e=0.0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0.0,o=0,p=0.0,q=0.0,t=0.0;m=Eb;Eb=Eb+16|0;k=m;l=a+52|0;f=c[l>>2]|0;q=+g[f+(d<<4)>>3];t=+g[f+(d<<4)+8>>3];e=+w(+(+y(+(+g[a+72>>3]),+(q*+g[f+(b<<4)>>3]+t*+g[f+(b<<4)+8>>3]))*.25));f=a+40|0;h=a+28|0;d=c[h>>2]|0;o=d+(b<<4)|0;i=a+64|0;n=+g[i>>3];p=(q-t*e)*n+(+((c[o>>2]|0)>>>0)+4294967296.0*+(c[o+4>>2]|0));p=p+(p<0.0?-.5:.5);o=+s(p)>=1.0?(p>0.0?~~+B(+r(p/4294967296.0),4294967295.0)>>>0:~~+z((p-+(~~p>>>0))/4294967296.0)>>>0):0;d=d+(b<<4)+8|0;n=(t+q*e)*n+(+((c[d>>2]|0)>>>0)+4294967296.0*+(c[d+4>>2]|0));n=n+(n<0.0?-.5:.5);d=+s(n)>=1.0?(n>0.0?~~+B(+r(n/4294967296.0),4294967295.0)>>>0:~~+z((n-+(~~n>>>0))/4294967296.0)>>>0):0;j=k;c[j>>2]=~~p>>>0;c[j+4>>2]=o;j=k+8|0;c[j>>2]=~~n>>>0;c[j+4>>2]=d;j=a+44|0;d=c[j>>2]|0;a=a+48|0;if(d>>>0<(c[a>>2]|0)>>>0){c[d>>2]=c[k>>2];c[d+4>>2]=c[k+4>>2];c[d+8>>2]=c[k+8>>2];c[d+12>>2]=c[k+12>>2];d=(c[j>>2]|0)+16|0;c[j>>2]=d;}else {_e(f,k);d=c[j>>2]|0;}o=c[h>>2]|0;h=o+(b<<4)|0;n=+g[i>>3];i=c[l>>2]|0;t=+g[i+(b<<4)>>3];p=+g[i+(b<<4)+8>>3];q=n*(t+e*p)+(+((c[h>>2]|0)>>>0)+4294967296.0*+(c[h+4>>2]|0));q=q+(q<0.0?-.5:.5);i=+s(q)>=1.0?(q>0.0?~~+B(+r(q/4294967296.0),4294967295.0)>>>0:~~+z((q-+(~~q>>>0))/4294967296.0)>>>0):0;l=o+(b<<4)+8|0;t=n*(p-e*t)+(+((c[l>>2]|0)>>>0)+4294967296.0*+(c[l+4>>2]|0));t=t+(t<0.0?-.5:.5);l=+s(t)>=1.0?(t>0.0?~~+B(+r(t/4294967296.0),4294967295.0)>>>0:~~+z((t-+(~~t>>>0))/4294967296.0)>>>0):0;o=k;c[o>>2]=~~q>>>0;c[o+4>>2]=i;o=k+8|0;c[o>>2]=~~t>>>0;c[o+4>>2]=l;if(d>>>0<(c[a>>2]|0)>>>0){c[d>>2]=c[k>>2];c[d+4>>2]=c[k+4>>2];c[d+8>>2]=c[k+8>>2];c[d+12>>2]=c[k+12>>2];c[j>>2]=(c[j>>2]|0)+16;Eb=m;return}else {_e(f,k);Eb=m;return}}function Jd(a,b,d){a=a|0;b=b|0;d=d|0;var e=0.0,f=0.0,h=0,i=0,j=0,k=0.0,l=0.0,m=0.0,n=0,o=0,p=0,q=0,t=0,u=0,v=0,w=0,x=0,A=0,C=0;x=Eb;Eb=Eb+16|0;w=x;u=a+52|0;t=c[u>>2]|0;l=+g[t+(d<<4)>>3];f=+g[t+(b<<4)>>3];k=+g[t+(d<<4)+8>>3];e=+g[t+(b<<4)+8>>3];m=+y(+(+g[a+72>>3]),+(l*f+k*e));m=+g[a+104>>3]*+s(+m);t=~~(m+(m<0.0?-.5:.5))>>>0;t=(t|0)>1?t:1;v=a+40|0;if((t|0)>0){j=a+28|0;d=a+64|0;p=w+8|0;i=a+44|0;h=a+48|0;q=a+88|0;o=a+80|0;m=k;n=0;while(1){A=c[j>>2]|0;C=A+(b<<4)|0;k=+g[d>>3];f=l*k+(+((c[C>>2]|0)>>>0)+4294967296.0*+(c[C+4>>2]|0));f=f+(f<0.0?-.5:.5);C=+s(f)>=1.0?(f>0.0?~~+B(+r(f/4294967296.0),4294967295.0)>>>0:~~+z((f-+(~~f>>>0))/4294967296.0)>>>0):0;A=A+(b<<4)+8|0;k=m*k+(+((c[A>>2]|0)>>>0)+4294967296.0*+(c[A+4>>2]|0));k=k+(k<0.0?-.5:.5);A=+s(k)>=1.0?(k>0.0?~~+B(+r(k/4294967296.0),4294967295.0)>>>0:~~+z((k-+(~~k>>>0))/4294967296.0)>>>0):0;a=w;c[a>>2]=~~f>>>0;c[a+4>>2]=C;a=p;c[a>>2]=~~k>>>0;c[a+4>>2]=A;a=c[i>>2]|0;if(a>>>0<(c[h>>2]|0)>>>0){c[a>>2]=c[w>>2];c[a+4>>2]=c[w+4>>2];c[a+8>>2]=c[w+8>>2];c[a+12>>2]=c[w+12>>2];c[i>>2]=(c[i>>2]|0)+16;}else _e(v,w);e=+g[q>>3];f=+g[o>>3];k=m*e+l*f;n=n+1|0;if(n>>>0>=t>>>0)break;else {l=l*e-m*f;m=k;}}C=c[u>>2]|0;f=+g[C+(b<<4)>>3];e=+g[C+(b<<4)+8>>3];}else {j=a+28|0;d=a+64|0;i=a+44|0;h=a+48|0;}C=c[j>>2]|0;A=C+(b<<4)|0;m=+g[d>>3];l=f*m+(+((c[A>>2]|0)>>>0)+4294967296.0*+(c[A+4>>2]|0));l=l+(l<0.0?-.5:.5);A=+s(l)>=1.0?(l>0.0?~~+B(+r(l/4294967296.0),4294967295.0)>>>0:~~+z((l-+(~~l>>>0))/4294967296.0)>>>0):0;C=C+(b<<4)+8|0;m=m*e+(+((c[C>>2]|0)>>>0)+4294967296.0*+(c[C+4>>2]|0));m=m+(m<0.0?-.5:.5);C=+s(m)>=1.0?(m>0.0?~~+B(+r(m/4294967296.0),4294967295.0)>>>0:~~+z((m-+(~~m>>>0))/4294967296.0)>>>0):0;d=w;c[d>>2]=~~l>>>0;c[d+4>>2]=A;d=w+8|0;c[d>>2]=~~m>>>0;c[d+4>>2]=C;d=c[i>>2]|0;if(d>>>0<(c[h>>2]|0)>>>0){c[d>>2]=c[w>>2];c[d+4>>2]=c[w+4>>2];c[d+8>>2]=c[w+8>>2];c[d+12>>2]=c[w+12>>2];c[i>>2]=(c[i>>2]|0)+16;Eb=x;return}else {_e(v,w);Eb=x;return}}function Kd(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;k=Eb;Eb=Eb+16|0;h=k;j=a+4|0;b=c[j>>2]|0;d=c[a>>2]|0;if((b|0)==(d|0)){Eb=k;return}g=0;f=b;while(1){e=d;b=c[e+(g*12|0)>>2]|0;e=c[e+(g*12|0)+4>>2]|0;if((b|0)!=(e|0)?(i=e+-16|0,b>>>0<i>>>0):0){d=i;do{c[h>>2]=c[b>>2];c[h+4>>2]=c[b+4>>2];c[h+8>>2]=c[b+8>>2];c[h+12>>2]=c[b+12>>2];c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[d>>2]=c[h>>2];c[d+4>>2]=c[h+4>>2];c[d+8>>2]=c[h+8>>2];c[d+12>>2]=c[h+12>>2];b=b+16|0;d=d+-16|0;}while(b>>>0<d>>>0);d=c[a>>2]|0;b=c[j>>2]|0;}else b=f;g=g+1|0;if(g>>>0>=((b-d|0)/12|0)>>>0)break;else f=b;}Eb=k;return}function Ld(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;u=Eb;Eb=Eb+144|0;m=u;c[m+24>>2]=0;t=m+28|0;c[t>>2]=0;c[m+32>>2]=0;r=m+40|0;c[r>>2]=0;s=m+44|0;c[s>>2]=0;c[m+48>>2]=0;p=m+56|0;c[p>>2]=0;q=m+60|0;c[q>>2]=0;c[m+64>>2]=0;l=m+4|0;c[l>>2]=0;c[l+4>>2]=0;c[l+8>>2]=0;c[l+12>>2]=0;c[m>>2]=3556;k=m+72|0;i=m+112|0;g=k;h=g+36|0;do{c[g>>2]=0;g=g+4|0;}while((g|0)<(h|0));c[i>>2]=i;j=m+116|0;c[j>>2]=i;h=m+120|0;c[h>>2]=0;a[m+128>>0]=0;n=m+20|0;a[n>>0]=0;a[m+140>>0]=0;a[m+36>>0]=0;o=m+37|0;a[o>>0]=0;a[m+142>>0]=1;Ec(m,b,0,1)|0;Oc(m,1,d,e,e)|0;c[m>>2]=3556;g=m+112|0;if(c[h>>2]|0?(f=c[j>>2]|0,e=(c[g>>2]|0)+4|0,d=c[f>>2]|0,c[d+4>>2]=c[e>>2],c[c[e>>2]>>2]=d,c[h>>2]=0,(f|0)!=(g|0)):0)do{e=f;f=c[f+4>>2]|0;$j(e);}while((f|0)!=(g|0));f=c[m+96>>2]|0;if(f|0){c[m+100>>2]=f;$j(f);}f=c[m+84>>2]|0;if(f|0){c[m+88>>2]=f;$j(f);}f=c[k>>2]|0;if(f|0){c[m+76>>2]=f;$j(f);}c[m>>2]=3528;b=m+8|0;j=c[b>>2]|0;d=m+12|0;c[d>>2]=j;c[l>>2]=j;j=m+24|0;f=c[t>>2]|0;g=c[j>>2]|0;if((f|0)!=(g|0)){i=0;do{h=c[g+(i<<2)>>2]|0;if(h){ak(h);g=c[j>>2]|0;f=c[t>>2]|0;}i=i+1|0;}while(i>>>0<f-g>>2>>>0);f=g;}c[t>>2]=f;a[n>>0]=0;a[o>>0]=0;f=c[p>>2]|0;if(f|0){c[q>>2]=f;$j(f);}f=c[r>>2]|0;if(f|0){c[s>>2]=f;$j(f);}f=c[j>>2]|0;if(f|0){c[t>>2]=f;$j(f);}f=c[b>>2]|0;if(!f){Eb=u;return}c[d>>2]=f;$j(f);Eb=u;return}function Md(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;w=Eb;Eb=Eb+144|0;o=w;c[o+24>>2]=0;v=o+28|0;c[v>>2]=0;c[o+32>>2]=0;t=o+40|0;c[t>>2]=0;u=o+44|0;c[u>>2]=0;c[o+48>>2]=0;r=o+56|0;c[r>>2]=0;s=o+60|0;c[s>>2]=0;c[o+64>>2]=0;n=o+4|0;c[n>>2]=0;c[n+4>>2]=0;c[n+8>>2]=0;c[n+12>>2]=0;c[o>>2]=3556;m=o+72|0;i=o+112|0;g=m;h=g+36|0;do{c[g>>2]=0;g=g+4|0;}while((g|0)<(h|0));c[i>>2]=i;l=o+116|0;c[l>>2]=i;k=o+120|0;c[k>>2]=0;a[o+128>>0]=0;p=o+20|0;a[p>>0]=0;a[o+140>>0]=0;a[o+36>>0]=0;q=o+37|0;a[q>>0]=0;a[o+142>>0]=1;j=b+4|0;g=c[b>>2]|0;a:do if((c[j>>2]|0)!=(g|0)){h=0;i=3556;while(1){Qb[c[i+8>>2]&15](o,g+(h*12|0)|0,0,1)|0;h=h+1|0;g=c[b>>2]|0;if(h>>>0>=(((c[j>>2]|0)-g|0)/12|0)>>>0)break a;i=c[o>>2]|0;}}while(0);Oc(o,1,d,e,e)|0;c[o>>2]=3556;g=o+112|0;if(c[k>>2]|0?(f=c[l>>2]|0,e=(c[g>>2]|0)+4|0,d=c[f>>2]|0,c[d+4>>2]=c[e>>2],c[c[e>>2]>>2]=d,c[k>>2]=0,(f|0)!=(g|0)):0)do{e=f;f=c[f+4>>2]|0;$j(e);}while((f|0)!=(g|0));f=c[o+96>>2]|0;if(f|0){c[o+100>>2]=f;$j(f);}f=c[o+84>>2]|0;if(f|0){c[o+88>>2]=f;$j(f);}f=c[m>>2]|0;if(f|0){c[o+76>>2]=f;$j(f);}c[o>>2]=3528;k=o+8|0;j=c[k>>2]|0;l=o+12|0;c[l>>2]=j;c[n>>2]=j;j=o+24|0;f=c[v>>2]|0;g=c[j>>2]|0;if((f|0)!=(g|0)){i=0;do{h=c[g+(i<<2)>>2]|0;if(h){ak(h);g=c[j>>2]|0;f=c[v>>2]|0;}i=i+1|0;}while(i>>>0<f-g>>2>>>0);f=g;}c[v>>2]=f;a[p>>0]=0;a[q>>0]=0;f=c[r>>2]|0;if(f|0){c[s>>2]=f;$j(f);}f=c[t>>2]|0;if(f|0){c[u>>2]=f;$j(f);}f=c[j>>2]|0;if(f|0){c[v>>2]=f;$j(f);}f=c[k>>2]|0;if(!f){Eb=w;return}c[l>>2]=f;$j(f);Eb=w;return}function Nd(a,b){a=a|0;b=b|0;Md(a,a,b);return}function Od(a,b,d,e){a=a|0;b=b|0;d=d|0;e=+e;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0.0,v=0.0,w=0.0;o=a;n=c[o>>2]|0;o=c[o+4>>2]|0;m=b;l=c[m>>2]|0;m=c[m+4>>2]|0;p=Ww(n|0,o|0,l|0,m|0)|0;t=F()|0;r=(t|0)<0;q=Ww(0,0,p|0,t|0)|0;k=F()|0;t=r?k:t;k=a+8|0;j=c[k>>2]|0;k=c[k+4>>2]|0;g=b+8|0;f=c[g>>2]|0;g=c[g+4>>2]|0;h=Ww(j|0,k|0,f|0,g|0)|0;i=F()|0;a=(i|0)<0;b=Ww(0,0,h|0,i|0)|0;s=F()|0;s=a?s:i;if((t|0)>(s|0)|((t|0)==(s|0)?(r?q:p)>>>0>(a?b:h)>>>0:0)){b=d;a=c[b>>2]|0;b=c[b+4>>2]|0;if(!(((m|0)<(o|0)|(m|0)==(o|0)&l>>>0<n>>>0)^((b|0)>(o|0)|(b|0)==(o|0)&a>>>0>n>>>0))){t=d+8|0;t=Ww(f|0,g|0,c[t>>2]|0,c[t+4>>2]|0)|0;u=+(t>>>0)+4294967296.0*+(F()|0);t=Ww(a|0,b|0,l|0,m|0)|0;w=+(t>>>0)+4294967296.0*+(F()|0);v=(+(j>>>0)+4294967296.0*+(k|0))*w+(+(n>>>0)+4294967296.0*+(o|0))*u-((+(f>>>0)+4294967296.0*+(g|0))*w+(+(l>>>0)+4294967296.0*+(m|0))*u);v=v*v;w=w*w;u=u*u;u=w+u;u=v/u;t=u<e;return t|0}if(((m|0)>(o|0)|(m|0)==(o|0)&l>>>0>n>>>0)^((b|0)>(m|0)|(b|0)==(m|0)&a>>>0>l>>>0)){w=+(h>>>0)+4294967296.0*+(i|0);t=Ww(l|0,m|0,n|0,o|0)|0;u=+(t>>>0)+4294967296.0*+(F()|0);t=d+8|0;v=w*(+(a>>>0)+4294967296.0*+(b|0))+u*(+((c[t>>2]|0)>>>0)+4294967296.0*+(c[t+4>>2]|0))-((+(j>>>0)+4294967296.0*+(k|0))*u+(+(n>>>0)+4294967296.0*+(o|0))*w);v=v*v;u=u*u;w=w*w;w=u+w;w=v/w;t=w<e;return t|0}else {t=d+8|0;t=Ww(j|0,k|0,c[t>>2]|0,c[t+4>>2]|0)|0;w=+(t>>>0)+4294967296.0*+(F()|0);t=Ww(a|0,b|0,n|0,o|0)|0;u=+(t>>>0)+4294967296.0*+(F()|0);v=(+(f>>>0)+4294967296.0*+(g|0))*u+(+(l>>>0)+4294967296.0*+(m|0))*w-((+(j>>>0)+4294967296.0*+(k|0))*u+(+(n>>>0)+4294967296.0*+(o|0))*w);v=v*v;u=u*u;w=w*w;w=u+w;w=v/w;t=w<e;return t|0}}else {b=d+8|0;a=c[b>>2]|0;b=c[b+4>>2]|0;if(!(((k|0)>(g|0)|(k|0)==(g|0)&j>>>0>f>>>0)^((k|0)<(b|0)|(k|0)==(b|0)&j>>>0<a>>>0))){t=Ww(f|0,g|0,a|0,b|0)|0;u=+(t>>>0)+4294967296.0*+(F()|0);t=d;t=Ww(c[t>>2]|0,c[t+4>>2]|0,l|0,m|0)|0;w=+(t>>>0)+4294967296.0*+(F()|0);v=(+(n>>>0)+4294967296.0*+(o|0))*u+(+(j>>>0)+4294967296.0*+(k|0))*w-((+(l>>>0)+4294967296.0*+(m|0))*u+(+(f>>>0)+4294967296.0*+(g|0))*w);v=v*v;u=u*u;w=w*w;w=u+w;w=v/w;t=w<e;return t|0}if(((k|0)<(g|0)|(k|0)==(g|0)&j>>>0<f>>>0)^((g|0)<(b|0)|(g|0)==(b|0)&f>>>0<a>>>0)){w=+(h>>>0)+4294967296.0*+(i|0);t=Ww(l|0,m|0,n|0,o|0)|0;u=+(t>>>0)+4294967296.0*+(F()|0);t=d;v=u*(+(a>>>0)+4294967296.0*+(b|0))+w*(+((c[t>>2]|0)>>>0)+4294967296.0*+(c[t+4>>2]|0))-((+(j>>>0)+4294967296.0*+(k|0))*u+(+(n>>>0)+4294967296.0*+(o|0))*w);v=v*v;u=u*u;w=w*w;w=u+w;w=v/w;t=w<e;return t|0}else {t=Ww(j|0,k|0,a|0,b|0)|0;u=+(t>>>0)+4294967296.0*+(F()|0);t=d;t=Ww(c[t>>2]|0,c[t+4>>2]|0,n|0,o|0)|0;w=+(t>>>0)+4294967296.0*+(F()|0);v=(+(l>>>0)+4294967296.0*+(m|0))*u+(+(f>>>0)+4294967296.0*+(g|0))*w-((+(n>>>0)+4294967296.0*+(o|0))*u+(+(j>>>0)+4294967296.0*+(k|0))*w);v=v*v;u=u*u;w=w*w;w=u+w;w=v/w;t=w<e;return t|0}}}function Pd(a,b,d){a=a|0;b=b|0;d=+d;var e=0,f=0,g=0,h=0,i=0.0,j=0,k=0,l=0,m=0,n=0.0,o=0,p=0,q=0.0,r=0.0,s=0,t=0,u=0;p=(c[a+4>>2]|0)-(c[a>>2]|0)|0;e=p>>4;if(!p){c[b+4>>2]=c[b>>2];return}p=_j(e>>>0>134217727?-1:e<<5)|0;f=p+(e<<5)|0;g=p;do{m=g+8|0;c[m>>2]=0;c[m+4>>2]=0;c[m+8>>2]=0;c[m+12>>2]=0;g=g+32|0;}while((g|0)!=(f|0));f=c[a>>2]|0;a=0;do{l=f+(a<<4)|0;m=p+(a<<5)|0;k=p+(a<<5)+8|0;c[k>>2]=c[l>>2];c[k+4>>2]=c[l+4>>2];c[k+8>>2]=c[l+8>>2];c[k+12>>2]=c[l+12>>2];k=a;a=a+1|0;l=(a>>>0)%(e>>>0)|0;c[p+(k<<5)+24>>2]=p+(l<<5);c[p+(l<<5)+28>>2]=m;c[m>>2]=0;}while(a>>>0<e>>>0);n=d*d;a:do if(!(c[p>>2]|0)){f=p;g=p;while(1){a=f+24|0;m=c[a>>2]|0;h=f+28|0;l=c[h>>2]|0;j=m;if((m|0)==(l|0)){h=f;break a}k=f+8|0;t=f+8|0;f=f+16|0;u=l+8|0;s=l+16|0;d=+((c[u>>2]|0)>>>0)+4294967296.0*+(c[u+4>>2]|0);r=+((c[t>>2]|0)>>>0)+4294967296.0*+(c[t+4>>2]|0)-d;i=+((c[s>>2]|0)>>>0)+4294967296.0*+(c[s+4>>2]|0);q=+((c[f>>2]|0)>>>0)+4294967296.0*+(c[f+4>>2]|0)-i;do if(!(r*r+q*q<=n)){t=m+8|0;u=m+16|0;q=d-(+((c[t>>2]|0)>>>0)+4294967296.0*+(c[t+4>>2]|0));r=i-(+((c[u>>2]|0)>>>0)+4294967296.0*+(c[u+4>>2]|0));if(q*q+r*r<=n){g=c[m+28>>2]|0;f=m+24|0;c[g+24>>2]=c[f>>2];c[(c[f>>2]|0)+28>>2]=g;c[g>>2]=0;g=c[h>>2]|0;c[g+24>>2]=c[a>>2];c[(c[a>>2]|0)+28>>2]=g;c[g>>2]=0;f=g;e=e+-2|0;a=0;break}if(Od(l+8|0,k,m+8|0,n)|0){c[l+24>>2]=j;c[(c[a>>2]|0)+28>>2]=l;c[l>>2]=0;f=l;e=e+-1|0;g=l;a=0;break}else {c[g>>2]=1;f=m;g=m;a=c[m>>2]|0;break}}else {c[l+24>>2]=j;c[(c[a>>2]|0)+28>>2]=l;c[l>>2]=0;f=l;e=e+-1|0;g=l;a=0;}while(0);if(a){h=f;break}}}else h=p;while(0);g=e>>>0<3?0:e;e=b+4|0;a=c[b>>2]|0;f=(c[e>>2]|0)-a>>4;if(g>>>0<=f>>>0){if(g>>>0<f>>>0)c[e>>2]=a+(g<<4);if(g|0)o=23;}else {af(b,g-f|0);o=23;}if((o|0)==23){a=0;e=h;while(1){t=e+8|0;u=(c[b>>2]|0)+(a<<4)|0;c[u>>2]=c[t>>2];c[u+4>>2]=c[t+4>>2];c[u+8>>2]=c[t+8>>2];c[u+12>>2]=c[t+12>>2];a=a+1|0;if((a|0)==(g|0))break;else e=c[e+24>>2]|0;}}ak(p);return}function Qd(a,b){a=a|0;b=+b;Pd(a,a,b);return}function Rd(a,b,d){a=a|0;b=b|0;d=+d;var e=0,f=0,g=0,h=0,i=0,j=0;j=a+4|0;h=((c[j>>2]|0)-(c[a>>2]|0)|0)/12|0;i=b+4|0;e=c[i>>2]|0;g=c[b>>2]|0;f=(e-g|0)/12|0;if(h>>>0<=f>>>0){if(h>>>0<f>>>0){h=g+(h*12|0)|0;if((h|0)!=(e|0))do{f=e;e=e+-12|0;g=c[e>>2]|0;if(g|0){c[f+-8>>2]=g;$j(g);}}while((e|0)!=(h|0));c[i>>2]=h;}}else Qe(b,h-f|0);e=c[a>>2]|0;if((c[j>>2]|0)==(e|0))return;f=0;do{Pd(e+(f*12|0)|0,(c[b>>2]|0)+(f*12|0)|0,d);f=f+1|0;e=c[a>>2]|0;}while(f>>>0<(((c[j>>2]|0)-e|0)/12|0)>>>0);return}function Sd(a,b){a=a|0;b=+b;Rd(a,a,b);return}function Td(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0.0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0;D=Eb;Eb=Eb+48|0;y=D+16|0;C=D+32|0;z=D;s=f&1;r=a+4|0;u=(c[r>>2]|0)-(c[a>>2]|0)|0;v=u>>4;f=(c[b+4>>2]|0)-(c[b>>2]|0)|0;w=f>>4;c[C>>2]=0;B=C+4|0;c[B>>2]=0;q=C+8|0;c[q>>2]=0;md(C,w);f=(f|0)!=0;a:do if(e){if(f){n=y+4|0;o=y+8|0;p=z+8|0;m=0;while(1){c[y>>2]=0;c[n>>2]=0;c[o>>2]=0;nd(y,v);f=c[a>>2]|0;if((c[r>>2]|0)!=(f|0)){e=0;do{t=f;l=c[b>>2]|0;i=l+(m<<4)|0;j=t+(e<<4)|0;i=Vw(c[j>>2]|0,c[j+4>>2]|0,c[i>>2]|0,c[i+4>>2]|0)|0;j=F()|0;l=l+(m<<4)+8|0;t=t+(e<<4)+8|0;l=Vw(c[t>>2]|0,c[t+4>>2]|0,c[l>>2]|0,c[l+4>>2]|0)|0;t=F()|0;f=z;c[f>>2]=i;c[f+4>>2]=j;f=p;c[f>>2]=l;c[f+4>>2]=t;f=c[n>>2]|0;if(f>>>0<(c[o>>2]|0)>>>0){c[f>>2]=c[z>>2];c[f+4>>2]=c[z+4>>2];c[f+8>>2]=c[z+8>>2];c[f+12>>2]=c[z+12>>2];c[n>>2]=f+16;}else _e(y,z);e=e+1|0;f=c[a>>2]|0;}while(e>>>0<(c[r>>2]|0)-f>>4>>>0)}e=c[B>>2]|0;if((e|0)==(c[q>>2]|0)){He(C,y);f=c[y>>2]|0;}else {c[e>>2]=0;l=e+4|0;c[l>>2]=0;h=e+8|0;c[h>>2]=0;f=c[y>>2]|0;g=(c[n>>2]|0)-f|0;i=g>>4;if(g){if(i>>>0>268435455)break;j=Zj(g)|0;c[l>>2]=j;c[e>>2]=j;c[h>>2]=j+(i<<4);f=c[y>>2]|0;g=(c[n>>2]|0)-f|0;if((g|0)>0){ax(j|0,f|0,g|0)|0;c[l>>2]=j+(g>>>4<<4);e=c[B>>2]|0;}}c[B>>2]=e+12;}if(f|0){c[n>>2]=f;$j(f);}m=m+1|0;if(m>>>0>=w>>>0)break a}gk();}}else if(f){n=y+4|0;o=y+8|0;p=z+8|0;m=0;while(1){c[y>>2]=0;c[n>>2]=0;c[o>>2]=0;nd(y,v);f=c[a>>2]|0;if((c[r>>2]|0)!=(f|0)){e=0;do{l=f;t=c[b>>2]|0;j=t+(m<<4)|0;i=l+(e<<4)|0;i=Ww(c[j>>2]|0,c[j+4>>2]|0,c[i>>2]|0,c[i+4>>2]|0)|0;j=F()|0;t=t+(m<<4)+8|0;l=l+(e<<4)+8|0;l=Ww(c[t>>2]|0,c[t+4>>2]|0,c[l>>2]|0,c[l+4>>2]|0)|0;t=F()|0;f=z;c[f>>2]=i;c[f+4>>2]=j;f=p;c[f>>2]=l;c[f+4>>2]=t;f=c[n>>2]|0;if(f>>>0<(c[o>>2]|0)>>>0){c[f>>2]=c[z>>2];c[f+4>>2]=c[z+4>>2];c[f+8>>2]=c[z+8>>2];c[f+12>>2]=c[z+12>>2];c[n>>2]=f+16;}else _e(y,z);e=e+1|0;f=c[a>>2]|0;}while(e>>>0<(c[r>>2]|0)-f>>4>>>0)}e=c[B>>2]|0;if((e|0)==(c[q>>2]|0)){He(C,y);f=c[y>>2]|0;}else {c[e>>2]=0;l=e+4|0;c[l>>2]=0;h=e+8|0;c[h>>2]=0;f=c[y>>2]|0;g=(c[n>>2]|0)-f|0;i=g>>4;if(g){if(i>>>0>268435455)break;j=Zj(g)|0;c[l>>2]=j;c[e>>2]=j;c[h>>2]=j+(i<<4);f=c[y>>2]|0;g=(c[n>>2]|0)-f|0;if((g|0)>0){ax(j|0,f|0,g|0)|0;c[l>>2]=j+(g>>>4<<4);e=c[B>>2]|0;}}c[B>>2]=e+12;}if(f|0){c[n>>2]=f;$j(f);}m=m+1|0;if(m>>>0>=w>>>0)break a}gk();}while(0);h=c[d>>2]|0;t=d+4|0;f=c[t>>2]|0;if((f|0)!=(h|0))do{e=f;f=f+-12|0;g=c[f>>2]|0;if(g|0){c[e+-8>>2]=g;$j(g);}}while((f|0)!=(h|0));c[t>>2]=h;s=w+s|0;md(d,A(s,v+1|0)|0);s=s+-1|0;b:do if(s|0){q=(u|0)==0;r=z+4|0;a=z+8|0;b=d+8|0;o=0;c:while(1){p=o;o=o+1|0;if(!q){n=0;do{c[z>>2]=0;c[r>>2]=0;c[a>>2]=0;g=Zj(64)|0;c[z>>2]=g;c[r>>2]=g;c[a>>2]=g+64;h=(p>>>0)%(w>>>0)|0;m=c[C>>2]|0;u=(n>>>0)%(v>>>0)|0;f=(c[m+(h*12|0)>>2]|0)+(u<<4)|0;c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];c[g+8>>2]=c[f+8>>2];c[g+12>>2]=c[f+12>>2];f=g+16|0;c[r>>2]=f;l=m+(((o>>>0)%(w>>>0)|0)*12|0)|0;u=(c[l>>2]|0)+(u<<4)|0;c[f>>2]=c[u>>2];c[f+4>>2]=c[u+4>>2];c[f+8>>2]=c[u+8>>2];c[f+12>>2]=c[u+12>>2];f=g+32|0;c[r>>2]=f;n=n+1|0;u=(n>>>0)%(v>>>0)|0;l=(c[l>>2]|0)+(u<<4)|0;c[f>>2]=c[l>>2];c[f+4>>2]=c[l+4>>2];c[f+8>>2]=c[l+8>>2];c[f+12>>2]=c[l+12>>2];f=g+48|0;c[r>>2]=f;u=(c[m+(h*12|0)>>2]|0)+(u<<4)|0;c[f>>2]=c[u>>2];c[f+4>>2]=c[u+4>>2];c[f+8>>2]=c[u+8>>2];c[f+12>>2]=c[u+12>>2];g=g+64|0;c[r>>2]=g;f=c[z>>2]|0;u=g-f|0;h=u>>4;if((u|0)>=48){m=h+-1|0;j=f+(m<<4)|0;m=f+(m<<4)+8|0;e=0;k=0.0;i=c[j+4>>2]|0;j=c[j>>2]|0;l=c[m+4>>2]|0;m=c[m>>2]|0;do{I=f+(e<<4)|0;H=j;j=c[I>>2]|0;G=i;i=c[I+4>>2]|0;I=f+(e<<4)+8|0;E=m;m=c[I>>2]|0;u=l;l=c[I+4>>2]|0;k=k+(+(H>>>0)+4294967296.0*+(G|0)+(+(j>>>0)+4294967296.0*+(i|0)))*(+(E>>>0)+4294967296.0*+(u|0)-(+(m>>>0)+4294967296.0*+(l|0)));e=e+1|0;}while((e|0)<(h|0));if(!(k*-.5>=0.0|(g|0)==(f|0))?(x=g+-16|0,x>>>0>f>>>0):0){e=x;do{c[y>>2]=c[f>>2];c[y+4>>2]=c[f+4>>2];c[y+8>>2]=c[f+8>>2];c[y+12>>2]=c[f+12>>2];c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];c[f+8>>2]=c[e+8>>2];c[f+12>>2]=c[e+12>>2];c[e>>2]=c[y>>2];c[e+4>>2]=c[y+4>>2];c[e+8>>2]=c[y+8>>2];c[e+12>>2]=c[y+12>>2];f=f+16|0;e=e+-16|0;}while(f>>>0<e>>>0)}}g=c[t>>2]|0;if((g|0)==(c[b>>2]|0)){He(d,z);f=c[z>>2]|0;}else {c[g>>2]=0;l=g+4|0;c[l>>2]=0;h=g+8|0;c[h>>2]=0;f=c[z>>2]|0;e=(c[r>>2]|0)-f|0;i=e>>4;if(e){if(i>>>0>268435455)break c;j=Zj(e)|0;c[l>>2]=j;c[g>>2]=j;c[h>>2]=j+(i<<4);f=c[z>>2]|0;e=(c[r>>2]|0)-f|0;if((e|0)>0){ax(j|0,f|0,e|0)|0;c[l>>2]=j+(e>>>4<<4);}}c[t>>2]=(c[t>>2]|0)+12;}if(f|0){c[r>>2]=f;$j(f);}}while(n>>>0<v>>>0)}if(o>>>0>=s>>>0)break b}gk();}while(0);h=c[C>>2]|0;if(!h){Eb=D;return}f=c[B>>2]|0;if((f|0)==(h|0))f=h;else {do{e=f;f=f+-12|0;g=c[f>>2]|0;if(g|0){c[e+-8>>2]=g;$j(g);}}while((f|0)!=(h|0));f=c[C>>2]|0;}c[B>>2]=h;$j(f);Eb=D;return}function Ud(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;u=Eb;Eb=Eb+144|0;m=u;Td(b,d,e,1,f);c[m+24>>2]=0;t=m+28|0;c[t>>2]=0;c[m+32>>2]=0;r=m+40|0;c[r>>2]=0;s=m+44|0;c[s>>2]=0;c[m+48>>2]=0;p=m+56|0;c[p>>2]=0;q=m+60|0;c[q>>2]=0;c[m+64>>2]=0;l=m+4|0;c[l>>2]=0;c[l+4>>2]=0;c[l+8>>2]=0;c[l+12>>2]=0;c[m>>2]=3556;j=m+72|0;f=m+112|0;b=j;d=b+36|0;do{c[b>>2]=0;b=b+4|0;}while((b|0)<(d|0));c[f>>2]=f;i=m+116|0;c[i>>2]=f;h=m+120|0;c[h>>2]=0;a[m+128>>0]=0;n=m+20|0;a[n>>0]=0;a[m+140>>0]=0;a[m+142>>0]=0;a[m+36>>0]=0;o=m+37|0;a[o>>0]=0;g=e+4|0;b=c[e>>2]|0;a:do if((c[g>>2]|0)!=(b|0)){d=0;f=3556;while(1){Qb[c[f+8>>2]&15](m,b+(d*12|0)|0,0,1)|0;d=d+1|0;b=c[e>>2]|0;if(d>>>0>=(((c[g>>2]|0)-b|0)/12|0)>>>0)break a;f=c[m>>2]|0;}}while(0);Oc(m,1,e,1,1)|0;c[m>>2]=3556;d=m+112|0;if(c[h>>2]|0?(k=c[i>>2]|0,e=(c[d>>2]|0)+4|0,i=c[k>>2]|0,c[i+4>>2]=c[e>>2],c[c[e>>2]>>2]=i,c[h>>2]=0,(k|0)!=(d|0)):0){b=k;do{k=b;b=c[b+4>>2]|0;$j(k);}while((b|0)!=(d|0))}b=c[m+96>>2]|0;if(b|0){c[m+100>>2]=b;$j(b);}b=c[m+84>>2]|0;if(b|0){c[m+88>>2]=b;$j(b);}b=c[j>>2]|0;if(b|0){c[m+76>>2]=b;$j(b);}c[m>>2]=3528;i=m+8|0;h=c[i>>2]|0;e=m+12|0;c[e>>2]=h;c[l>>2]=h;h=m+24|0;b=c[t>>2]|0;d=c[h>>2]|0;if((b|0)!=(d|0)){g=0;do{f=c[d+(g<<2)>>2]|0;if(f){ak(f);d=c[h>>2]|0;b=c[t>>2]|0;}g=g+1|0;}while(g>>>0<b-d>>2>>>0);b=d;}c[t>>2]=b;a[n>>0]=0;a[o>>0]=0;b=c[p>>2]|0;if(b|0){c[q>>2]=b;$j(b);}b=c[r>>2]|0;if(b|0){c[s>>2]=b;$j(b);}b=c[h>>2]|0;if(b|0){c[t>>2]=b;$j(b);}b=c[i>>2]|0;if(!b){Eb=u;return}c[e>>2]=b;$j(b);Eb=u;return}function Vd(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0;L=Eb;Eb=Eb+176|0;C=L+24|0;y=L+12|0;z=L;c[C+24>>2]=0;K=C+28|0;c[K>>2]=0;c[C+32>>2]=0;H=C+40|0;c[H>>2]=0;J=C+44|0;c[J>>2]=0;c[C+48>>2]=0;G=C+56|0;c[G>>2]=0;I=C+60|0;c[I>>2]=0;c[C+64>>2]=0;B=C+4|0;c[B>>2]=0;c[B+4>>2]=0;c[B+8>>2]=0;c[B+12>>2]=0;c[C>>2]=3556;A=C+72|0;j=C+112|0;h=A;i=h+36|0;do{c[h>>2]=0;h=h+4|0;}while((h|0)<(i|0));c[j>>2]=j;x=C+116|0;c[x>>2]=j;w=C+120|0;c[w>>2]=0;a[C+128>>0]=0;D=C+20|0;a[D>>0]=0;a[C+140>>0]=0;a[C+142>>0]=0;a[C+36>>0]=0;E=C+37|0;a[E>>0]=0;r=d+4|0;h=c[d>>2]|0;if((c[r>>2]|0)!=(h|0)){s=y+4|0;t=y+8|0;u=z+4|0;v=z+8|0;q=0;do{c[y>>2]=0;c[s>>2]=0;c[t>>2]=0;Td(b,h+(q*12|0)|0,y,1,f);h=c[y>>2]|0;if((c[s>>2]|0)!=(h|0)){i=0;do{Qb[c[(c[C>>2]|0)+8>>2]&15](C,h+(i*12|0)|0,0,1)|0;i=i+1|0;h=c[y>>2]|0;}while(i>>>0<(((c[s>>2]|0)-h|0)/12|0)>>>0)}if(f){c[z>>2]=0;c[u>>2]=0;c[v>>2]=0;p=c[d>>2]|0;k=p+(q*12|0)|0;o=c[b>>2]|0;m=o;l=c[m>>2]|0;m=c[m+4>>2]|0;o=o+8|0;n=c[o>>2]|0;o=c[o+4>>2]|0;p=p+(q*12|0)+4|0;i=c[p>>2]|0;h=c[k>>2]|0;j=i-h|0;if(j){af(z,j>>4);h=c[k>>2]|0;i=c[p>>2]|0;}if((i|0)!=(h|0)){i=0;do{N=h;Q=N+(i<<4)|0;Q=Vw(c[Q>>2]|0,c[Q+4>>2]|0,l|0,m|0)|0;P=F()|0;N=N+(i<<4)+8|0;N=Vw(c[N>>2]|0,c[N+4>>2]|0,n|0,o|0)|0;M=F()|0;j=c[z>>2]|0;O=j+(i<<4)|0;c[O>>2]=Q;c[O+4>>2]=P;j=j+(i<<4)+8|0;c[j>>2]=N;c[j+4>>2]=M;i=i+1|0;h=c[k>>2]|0;}while(i>>>0<(c[p>>2]|0)-h>>4>>>0)}Ec(C,z,1,1)|0;h=c[z>>2]|0;if(h|0){c[u>>2]=h;$j(h);}h=c[y>>2]|0;}if(h|0){i=c[s>>2]|0;if((i|0)==(h|0))i=h;else {do{j=i;i=i+-12|0;k=c[i>>2]|0;if(k|0){c[j+-8>>2]=k;$j(k);}}while((i|0)!=(h|0));i=c[y>>2]|0;}c[s>>2]=h;$j(i);}q=q+1|0;h=c[d>>2]|0;}while(q>>>0<(((c[r>>2]|0)-h|0)/12|0)>>>0)}Oc(C,1,e,1,1)|0;c[C>>2]=3556;h=C+112|0;if(c[w>>2]|0?(g=c[x>>2]|0,Q=(c[h>>2]|0)+4|0,P=c[g>>2]|0,c[P+4>>2]=c[Q>>2],c[c[Q>>2]>>2]=P,c[w>>2]=0,(g|0)!=(h|0)):0)do{Q=g;g=c[g+4>>2]|0;$j(Q);}while((g|0)!=(h|0));g=c[C+96>>2]|0;if(g|0){c[C+100>>2]=g;$j(g);}g=c[C+84>>2]|0;if(g|0){c[C+88>>2]=g;$j(g);}g=c[A>>2]|0;if(g|0){c[C+76>>2]=g;$j(g);}c[C>>2]=3528;l=C+8|0;k=c[l>>2]|0;m=C+12|0;c[m>>2]=k;c[B>>2]=k;k=C+24|0;g=c[K>>2]|0;h=c[k>>2]|0;if((g|0)!=(h|0)){j=0;do{i=c[h+(j<<2)>>2]|0;if(i){ak(i);h=c[k>>2]|0;g=c[K>>2]|0;}j=j+1|0;}while(j>>>0<g-h>>2>>>0);g=h;}c[K>>2]=g;a[D>>0]=0;a[E>>0]=0;g=c[G>>2]|0;if(g|0){c[I>>2]=g;$j(g);}g=c[H>>2]|0;if(g|0){c[J>>2]=g;$j(g);}g=c[k>>2]|0;if(g|0){c[K>>2]=g;$j(g);}g=c[l>>2]|0;if(!g){Eb=L;return}c[m>>2]=g;$j(g);Eb=L;return}function Wd(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;u=Eb;Eb=Eb+144|0;m=u;Td(b,d,e,0,1);c[m+24>>2]=0;t=m+28|0;c[t>>2]=0;c[m+32>>2]=0;r=m+40|0;c[r>>2]=0;s=m+44|0;c[s>>2]=0;c[m+48>>2]=0;p=m+56|0;c[p>>2]=0;q=m+60|0;c[q>>2]=0;c[m+64>>2]=0;l=m+4|0;c[l>>2]=0;c[l+4>>2]=0;c[l+8>>2]=0;c[l+12>>2]=0;c[m>>2]=3556;k=m+72|0;f=m+112|0;b=k;d=b+36|0;do{c[b>>2]=0;b=b+4|0;}while((b|0)<(d|0));c[f>>2]=f;i=m+116|0;c[i>>2]=f;h=m+120|0;c[h>>2]=0;a[m+128>>0]=0;n=m+20|0;a[n>>0]=0;a[m+140>>0]=0;a[m+142>>0]=0;a[m+36>>0]=0;o=m+37|0;a[o>>0]=0;g=e+4|0;b=c[e>>2]|0;a:do if((c[g>>2]|0)!=(b|0)){d=0;f=3556;while(1){Qb[c[f+8>>2]&15](m,b+(d*12|0)|0,0,1)|0;d=d+1|0;b=c[e>>2]|0;if(d>>>0>=(((c[g>>2]|0)-b|0)/12|0)>>>0)break a;f=c[m>>2]|0;}}while(0);Oc(m,1,e,1,1)|0;c[m>>2]=3556;d=m+112|0;if(c[h>>2]|0?(j=c[i>>2]|0,e=(c[d>>2]|0)+4|0,i=c[j>>2]|0,c[i+4>>2]=c[e>>2],c[c[e>>2]>>2]=i,c[h>>2]=0,(j|0)!=(d|0)):0){b=j;do{j=b;b=c[b+4>>2]|0;$j(j);}while((b|0)!=(d|0))}b=c[m+96>>2]|0;if(b|0){c[m+100>>2]=b;$j(b);}b=c[m+84>>2]|0;if(b|0){c[m+88>>2]=b;$j(b);}b=c[k>>2]|0;if(b|0){c[m+76>>2]=b;$j(b);}c[m>>2]=3528;i=m+8|0;h=c[i>>2]|0;e=m+12|0;c[e>>2]=h;c[l>>2]=h;h=m+24|0;b=c[t>>2]|0;d=c[h>>2]|0;if((b|0)!=(d|0)){g=0;do{f=c[d+(g<<2)>>2]|0;if(f){ak(f);d=c[h>>2]|0;b=c[t>>2]|0;}g=g+1|0;}while(g>>>0<b-d>>2>>>0);b=d;}c[t>>2]=b;a[n>>0]=0;a[o>>0]=0;b=c[p>>2]|0;if(b|0){c[q>>2]=b;$j(b);}b=c[r>>2]|0;if(b|0){c[s>>2]=b;$j(b);}b=c[h>>2]|0;if(b|0){c[t>>2]=b;$j(b);}b=c[i>>2]|0;if(!b){Eb=u;return}c[e>>2]=b;$j(b);Eb=u;return}function Xd(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;switch(d|0){case 2:{f=(a[b+36>>0]|0)!=0;break}case 1:return;default:f=0;}k=b+4|0;n=b+8|0;do if(!(f|(c[k>>2]|0)==(c[n>>2]|0))){l=e+4|0;g=c[l>>2]|0;if((g|0)==(c[e+8>>2]|0)){He(e,k);break}c[g>>2]=0;m=g+4|0;c[m>>2]=0;h=g+8|0;c[h>>2]=0;f=(c[n>>2]|0)-(c[k>>2]|0)|0;i=f>>4;if(f|0){if(i>>>0>268435455)gk();j=Zj(f)|0;c[m>>2]=j;c[g>>2]=j;c[h>>2]=j+(i<<4);g=c[k>>2]|0;f=(c[n>>2]|0)-g|0;if((f|0)>0){ax(j|0,g|0,f|0)|0;c[m>>2]=j+(f>>>4<<4);}}c[l>>2]=(c[l>>2]|0)+12;}while(0);i=b+16|0;h=b+20|0;f=c[i>>2]|0;if(((c[h>>2]|0)-f|0)<=0)return;g=0;do{Xd(c[f+(g<<2)>>2]|0,d,e);g=g+1|0;f=c[i>>2]|0;}while((g|0)<((c[h>>2]|0)-f>>2|0));return}function Yd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;g=b+4|0;e=c[g>>2]|0;f=c[b>>2]|0;h=f;d=e;if((e|0)!=(f|0)){if((h|0)!=(d|0))do{e=d;d=d+-12|0;f=c[d>>2]|0;if(f|0){c[e+-8>>2]=f;$j(f);}}while((d|0)!=(h|0));c[g>>2]=h;}e=c[a+48>>2]|0;h=(c[a+52>>2]|0)-e|0;d=h>>2;if((h|0)>0)d=d+(((c[c[a+16>>2]>>2]|0)!=(c[e>>2]|0))<<31>>31)|0;md(b,d);Xd(a,0,b);return}function Zd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;g=b+4|0;e=c[g>>2]|0;f=c[b>>2]|0;h=f;d=e;if((e|0)!=(f|0)){if((h|0)!=(d|0))do{e=d;d=d+-12|0;f=c[d>>2]|0;if(f|0){c[e+-8>>2]=f;$j(f);}}while((d|0)!=(h|0));c[g>>2]=h;}e=c[a+48>>2]|0;h=(c[a+52>>2]|0)-e|0;d=h>>2;if((h|0)>0)d=d+(((c[c[a+16>>2]>>2]|0)!=(c[e>>2]|0))<<31>>31)|0;md(b,d);Xd(a,2,b);return}function _d(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;p=d+4|0;n=c[p>>2]|0;o=c[d>>2]|0;h=o;e=n;if((n|0)!=(o|0)){if((h|0)!=(e|0))do{f=e;e=e+-12|0;g=c[e>>2]|0;if(g|0){c[f+-8>>2]=g;$j(g);}}while((e|0)!=(h|0));c[p>>2]=h;}f=c[b+48>>2]|0;o=(c[b+52>>2]|0)-f|0;e=o>>2;if((o|0)>0)e=e+(((c[c[b+16>>2]>>2]|0)!=(c[f>>2]|0))<<31>>31)|0;md(d,e);o=b+16|0;m=b+20|0;e=c[o>>2]|0;if(((c[m>>2]|0)-e|0)<=0)return;n=d+8|0;l=0;a:while(1){e=c[e+(l<<2)>>2]|0;do if(a[e+36>>0]|0){g=e+4|0;j=c[p>>2]|0;if((j|0)==(c[n>>2]|0)){He(d,g);break}c[j>>2]=0;k=j+4|0;c[k>>2]=0;h=j+8|0;c[h>>2]=0;b=e+8|0;e=(c[b>>2]|0)-(c[g>>2]|0)|0;f=e>>4;if(e|0){if(f>>>0>268435455){e=17;break a}i=Zj(e)|0;c[k>>2]=i;c[j>>2]=i;c[h>>2]=i+(f<<4);f=c[g>>2]|0;e=(c[b>>2]|0)-f|0;if((e|0)>0){ax(i|0,f|0,e|0)|0;c[k>>2]=i+(e>>>4<<4);}}c[p>>2]=(c[p>>2]|0)+12;}while(0);l=l+1|0;e=c[o>>2]|0;if((l|0)>=((c[m>>2]|0)-e>>2|0)){e=12;break}}if((e|0)==12)return;else if((e|0)==17)gk();}function $d(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0.0,k=0,l=0,m=0.0;h=~~+g[b>>3]>>>0;c[a+4>>2]=c[a>>2];if(!h)return;af(a,h);e=b+8|0;f=0;while(1){m=+g[e>>3];l=+s(m)>=1.0?(m>0.0?~~+B(+r(m/4294967296.0),4294967295.0)>>>0:~~+z((m-+(~~m>>>0))/4294967296.0)>>>0):0;d=b+16|0;j=+g[d>>3];i=+s(j)>=1.0?(j>0.0?~~+B(+r(j/4294967296.0),4294967295.0)>>>0:~~+z((j-+(~~j>>>0))/4294967296.0)>>>0):0;e=c[a>>2]|0;k=e+(f<<4)|0;c[k>>2]=~~m>>>0;c[k+4>>2]=l;e=e+(f<<4)+8|0;c[e>>2]=~~j>>>0;c[e+4>>2]=i;f=f+1|0;if((f|0)==(h|0))break;else {e=b+24|0;b=d;}}return}function ae(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,t=0,u=0,v=0.0,w=0,x=0,y=0.0;u=Eb;Eb=Eb+16|0;q=u;t=~~+g[b>>3]>>>0;h=b+8|0;f=c[a>>2]|0;p=a+4|0;b=c[p>>2]|0;if((b|0)!=(f|0))do{d=b;b=b+-12|0;e=c[b>>2]|0;if(e|0){c[d+-8>>2]=e;$j(e);}}while((b|0)!=(f|0));c[p>>2]=f;md(a,t);if(!t){Eb=u;return}m=q+4|0;n=q+8|0;o=a+8|0;l=0;while(1){c[q>>2]=0;c[n>>2]=0;f=~~+g[h>>3]>>>0;c[m>>2]=0;if(!f)b=1;else {af(q,f);i=f<<1;b=h+8|0;d=0;e=h;while(1){y=+g[b>>3];x=+s(y)>=1.0?(y>0.0?~~+B(+r(y/4294967296.0),4294967295.0)>>>0:~~+z((y-+(~~y>>>0))/4294967296.0)>>>0):0;j=e+16|0;v=+g[j>>3];b=+s(v)>=1.0?(v>0.0?~~+B(+r(v/4294967296.0),4294967295.0)>>>0:~~+z((v-+(~~v>>>0))/4294967296.0)>>>0):0;k=c[q>>2]|0;w=k+(d<<4)|0;c[w>>2]=~~y>>>0;c[w+4>>2]=x;k=k+(d<<4)+8|0;c[k>>2]=~~v>>>0;c[k+4>>2]=b;d=d+1|0;if((d|0)==(f|0))break;else {b=e+24|0;e=j;}}b=i|1;}h=h+(b<<3)|0;j=c[p>>2]|0;if((j|0)==(c[o>>2]|0)){He(a,q);b=c[q>>2]|0;}else {c[j>>2]=0;k=j+4|0;c[k>>2]=0;e=j+8|0;c[e>>2]=0;b=c[q>>2]|0;d=(c[m>>2]|0)-b|0;f=d>>4;if(d){if(f>>>0>268435455){b=16;break}i=Zj(d)|0;c[k>>2]=i;c[j>>2]=i;c[e>>2]=i+(f<<4);b=c[q>>2]|0;d=(c[m>>2]|0)-b|0;if((d|0)>0){ax(i|0,b|0,d|0)|0;c[k>>2]=i+(d>>>4<<4);}}c[p>>2]=(c[p>>2]|0)+12;}if(b|0){c[m>>2]=b;$j(b);}l=l+1|0;if(l>>>0>=t>>>0){b=8;break}}if((b|0)==8){Eb=u;return}else if((b|0)==16)gk();}function be(a,b){a=a|0;b=b|0;ae(a,b);return}function ce(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0,k=0,l=0;l=Eb;Eb=Eb+16|0;k=l;h=c[b>>2]|0;i=(c[b+4>>2]|0)-h|0;j=i>>4;f=hk((A(2<<3,j)|0)+8|0)|0;g[f>>3]=+(j>>>0);if(!i){j=j<<1;j=j+1|0;i=f;c[k>>2]=j;j=k+4|0;c[j>>2]=i;k=ua(1072,k|0)|0;c[a>>2]=k;Eb=l;return}b=0;d=f+8|0;e=f;while(1){i=h+(b<<4)|0;g[d>>3]=+((c[i>>2]|0)>>>0)+4294967296.0*+(c[i+4>>2]|0);i=e+16|0;d=h+(b<<4)+8|0;g[i>>3]=+((c[d>>2]|0)>>>0)+4294967296.0*+(c[d+4>>2]|0);b=b+1|0;if(b>>>0>=j>>>0)break;else {d=e+24|0;e=i;}}j=j<<1;j=j+1|0;i=f;c[k>>2]=j;j=k+4|0;c[j>>2]=i;k=ua(1072,k|0)|0;c[a>>2]=k;Eb=l;return}function de(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,i=0,j=0,k=0,l=0;k=c[a>>2]|0;d=(c[a+4>>2]|0)-k|0;j=(d|0)/12|0;d=(d|0)==0;if(d){k=hk(8)|0;g[k>>3]=+(j>>>0);return k|0}a=1;b=0;do{a=a+1+((c[k+(b*12|0)+4>>2]|0)-(c[k+(b*12|0)>>2]|0)>>4<<1)|0;b=b+1|0;}while(b>>>0<j>>>0);a=hk(a<<3)|0;g[a>>3]=+(j>>>0);if(d){k=a;return k|0}d=a+8|0;i=0;while(1){h=c[k+(i*12|0)>>2]|0;e=(c[k+(i*12|0)+4>>2]|0)-h|0;f=e>>4;g[d>>3]=+(f>>>0);b=d+8|0;if(e){e=0;do{l=h+(e<<4)|0;g[b>>3]=+((c[l>>2]|0)>>>0)+4294967296.0*+(c[l+4>>2]|0);b=d;d=d+16|0;l=h+(e<<4)+8|0;g[d>>3]=+((c[l>>2]|0)>>>0)+4294967296.0*+(c[l+4>>2]|0);e=e+1|0;b=b+24|0;}while(e>>>0<f>>>0)}i=i+1|0;if(i>>>0>=j>>>0)break;else d=b;}return a|0}function ee(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;i=Eb;Eb=Eb+16|0;h=i;g=c[b>>2]|0;e=(c[b+4>>2]|0)-g|0;f=(e|0)/12|0;if(!e)d=1;else {d=1;e=0;do{d=d+1+((c[g+(e*12|0)+4>>2]|0)-(c[g+(e*12|0)>>2]|0)>>4<<1)|0;e=e+1|0;}while(e>>>0<f>>>0)}b=de(b)|0;c[h>>2]=d;c[h+4>>2]=b;h=ua(1072,h|0)|0;c[a>>2]=h;Eb=i;return}function fe(a){a=a|0;var b=0;la(7671,3,3600,8958,1,87);la(7678,3,3612,8958,2,88);la(7686,2,3624,9150,26,89);la(7695,2,3632,9150,27,90);ia(1192,7705,4,0);ja(1192,7714,0);ja(1192,7727,1);ja(1192,7733,2);ja(1192,7744,3);ia(1200,7748,4,0);ja(1200,7757,0);ja(1200,7765,1);ia(1208,7770,4,0);ja(1208,7783,0);ja(1208,7791,1);ja(1208,7799,2);ja(1208,7808,3);da(1216,1224,1240,0,9306,5,9309,0,9309,0,7817,9311,94);b=Zj(8)|0;c[b>>2]=1;c[b+4>>2]=0;a=Zj(8)|0;c[a>>2]=1;c[a+4>>2]=0;ga(1216,7826,3464,9314,1,b|0,3464,9318,1,a|0);a=Zj(8)|0;c[a>>2]=2;c[a+4>>2]=0;b=Zj(8)|0;c[b>>2]=2;c[b+4>>2]=0;ga(1216,7828,3464,9314,1,a|0,3464,9318,1,b|0);la(7830,3,3640,9323,1,1);ke(7842);le(7847);ia(1320,7853,4,0);ja(1320,7865,1);ja(1320,7881,2);ja(1320,7896,4);ia(1328,7914,4,0);ja(1328,7923,0);ja(1328,7930,1);ja(1328,7936,2);ia(1336,7942,4,0);ja(1336,7950,0);ja(1336,7964,1);ja(1336,7975,2);ja(1336,7984,3);ja(1336,7995,4);da(1064,1344,1360,0,9306,6,9309,0,9309,0,8005,9311,95);ea(1064,1,3724,9306,7,1);b=Zj(4)|0;c[b>>2]=4;a=Zj(4)|0;c[a>>2]=4;ga(1064,8014,1112,9150,28,b|0,1112,8958,3,a|0);a=Zj(4)|0;c[a>>2]=16;b=Zj(4)|0;c[b>>2]=16;ga(1064,8022,1400,9150,29,a|0,1400,8958,4,b|0);b=Zj(8)|0;c[b>>2]=8;c[b+4>>2]=0;fa(1064,8029,2,3728,9150,30,b|0,0);b=Zj(8)|0;c[b>>2]=9;c[b+4>>2]=0;fa(1064,8039,2,3728,9150,30,b|0,0);b=Zj(8)|0;c[b>>2]=10;c[b+4>>2]=0;fa(1064,8047,2,3736,9150,31,b|0,0);b=Zj(8)|0;c[b>>2]=11;c[b+4>>2]=0;fa(1064,8054,2,3736,9150,31,b|0,0);b=Zj(8)|0;c[b>>2]=12;c[b+4>>2]=0;fa(1064,8061,2,3744,9150,32,b|0,0);ne(8072);da(1456,1472,1488,1064,9306,13,9306,14,9306,15,8082,9311,96);ea(1456,1,3788,9306,16,2);b=Zj(8)|0;c[b>>2]=17;c[b+4>>2]=0;fa(1456,8091,2,3808,9150,33,b|0,0);b=Zj(8)|0;c[b>>2]=97;c[b+4>>2]=0;fa(1456,8100,2,3816,10111,91,b|0,0);b=Zj(8)|0;c[b>>2]=18;c[b+4>>2]=0;fa(1456,8106,2,3824,9150,34,b|0,0);la(8112,2,3832,9150,35,19);la(8124,2,3840,9314,2,3);la(8129,3,3848,9487,7,36);la(8144,4,112,9481,4,5);la(8160,4,128,9481,5,6);la(8182,3,3860,8958,7,92);la(8208,4,144,10115,1,2);la(8208,3,3872,9318,3,3);la(8221,4,160,10115,2,4);la(8221,3,3884,9318,5,4);la(8235,5,176,10121,4,6);la(8252,5,208,10121,5,7);la(8270,4,240,9481,8,8);la(8284,3,3896,8958,9,93);la(8300,3,3896,8958,9,94);la(8324,3,3908,8958,10,95);la(8346,2,3920,10111,96,98);la(8358,2,3928,10111,97,99);da(1504,1512,1528,0,9306,20,9309,0,9309,0,8371,9311,100);b=Zj(8)|0;c[b>>2]=4;c[b+4>>2]=0;a=Zj(8)|0;c[a>>2]=5;c[a+4>>2]=0;ga(1504,8379,3464,9314,3,b|0,3464,9318,6,a|0);a=Zj(8)|0;c[a>>2]=5;c[a+4>>2]=0;b=Zj(8)|0;c[b>>2]=6;c[b+4>>2]=0;ga(1504,8384,3464,9314,3,a|0,3464,9318,6,b|0);b=Zj(8)|0;c[b>>2]=6;c[b+4>>2]=0;a=Zj(8)|0;c[a>>2]=7;c[a+4>>2]=0;ga(1504,8388,3464,9314,3,b|0,3464,9318,6,a|0);a=Zj(8)|0;c[a>>2]=7;c[a+4>>2]=0;b=Zj(8)|0;c[b>>2]=8;c[b+4>>2]=0;ga(1504,8394,3464,9314,3,a|0,3464,9318,6,b|0);da(1040,1544,1560,0,9306,21,9309,0,9309,0,8401,9311,101);b=Zj(8)|0;c[b>>2]=8;c[b+4>>2]=1;fa(1040,8413,5,256,10259,1,b|0,0);b=Zj(8)|0;c[b>>2]=3;c[b+4>>2]=0;fa(1040,8421,5,288,10259,2,b|0,0);b=Zj(8)|0;c[b>>2]=12;c[b+4>>2]=1;fa(1040,8100,2,3936,10111,98,b|0,0);b=Zj(8)|0;c[b>>2]=99;c[b+4>>2]=0;fa(1040,8430,2,3944,9150,37,b|0,0);b=Zj(8)|0;c[b>>2]=22;c[b+4>>2]=0;a=Zj(8)|0;c[a>>2]=100;c[a+4>>2]=0;ga(1040,8440,3376,9150,38,b|0,3376,8958,11,a|0);da(1048,1576,1592,1040,9306,23,9306,24,9306,25,8458,9311,102);ea(1048,2,3952,9150,39,26);a=Zj(8)|0;c[a>>2]=4;c[a+4>>2]=0;fa(1048,8466,5,320,10259,3,a|0,0);a=Zj(8)|0;c[a>>2]=4;c[a+4>>2]=0;fa(1048,8479,6,352,10315,1,a|0,0);a=Zj(8)|0;c[a>>2]=5;c[a+4>>2]=0;fa(1048,8505,5,384,10259,5,a|0,0);a=Zj(8)|0;c[a>>2]=6;c[a+4>>2]=0;fa(1048,8521,6,416,10315,2,a|0,0);a=Zj(8)|0;c[a>>2]=27;c[a+4>>2]=0;b=Zj(8)|0;c[b>>2]=101;c[b+4>>2]=0;ga(1048,8550,3376,9150,40,a|0,3376,8958,12,b|0);b=Zj(8)|0;c[b>>2]=28;c[b+4>>2]=0;a=Zj(8)|0;c[a>>2]=102;c[a+4>>2]=0;ga(1048,8566,3376,9150,40,b|0,3376,8958,12,a|0);da(1608,1616,1632,0,9306,29,9309,0,9309,0,8581,9311,103);ea(1608,3,3960,9323,2,41);a=Zj(8)|0;c[a>>2]=9;c[a+4>>2]=0;fa(1608,8413,5,448,10121,6,a|0,0);a=Zj(8)|0;c[a>>2]=10;c[a+4>>2]=0;fa(1608,8421,5,480,10121,7,a|0,0);a=Zj(8)|0;c[a>>2]=7;c[a+4>>2]=0;fa(1608,8466,4,512,10115,3,a|0,0);a=Zj(8)|0;c[a>>2]=8;c[a+4>>2]=0;fa(1608,8505,4,528,10115,4,a|0,0);a=Zj(8)|0;c[a>>2]=104;c[a+4>>2]=0;fa(1608,8100,2,3972,10111,103,a|0,0);a=Zj(4)|0;c[a>>2]=0;b=Zj(4)|0;c[b>>2]=0;ga(1608,8595,3464,9314,4,a|0,3464,9318,9,b|0);b=Zj(4)|0;c[b>>2]=8;a=Zj(4)|0;c[a>>2]=8;ga(1608,8606,3464,9314,4,b|0,3464,9318,9,a|0);return}function ge(a){a=a|0;return +(+((c[a>>2]|0)>>>0)+4294967296.0*+(c[a+4>>2]|0))}function he(a,b){a=a|0;b=+b;var d=0;d=+s(b)>=1.0?(b>0.0?~~+B(+r(b/4294967296.0),4294967295.0)>>>0:~~+z((b-+(~~b>>>0))/4294967296.0)>>>0):0;c[a>>2]=~~b>>>0;c[a+4>>2]=d;return}function ie(a){a=a|0;a=a+8|0;return +(+((c[a>>2]|0)>>>0)+4294967296.0*+(c[a+4>>2]|0))}function je(a,b){a=a|0;b=+b;var d=0;d=+s(b)>=1.0?(b>0.0?~~+B(+r(b/4294967296.0),4294967295.0)>>>0:~~+z((b-+(~~b>>>0))/4294967296.0)>>>0):0;a=a+8|0;c[a>>2]=~~b>>>0;c[a+4>>2]=d;return}function ke(a){a=a|0;da(1112,1256,1272,0,9306,30,9309,0,9309,0,a|0,9311,105);ea(1112,1,3652,9306,31,3);a=Zj(8)|0;c[a>>2]=104;c[a+4>>2]=0;fa(1112,9328,3,3656,8958,13,a|0,0);a=Zj(8)|0;c[a>>2]=14;c[a+4>>2]=0;fa(1112,9338,4,16,9481,11,a|0,0);a=Zj(8)|0;c[a>>2]=32;c[a+4>>2]=0;fa(1112,9345,2,3668,9150,42,a|0,0);a=Zj(4)|0;c[a>>2]=15;fa(1112,9350,3,3676,9487,8,a|0,0);a=Zj(4)|0;c[a>>2]=9;fa(1112,9354,4,32,9492,6,a|0,0);return}function le(a){a=a|0;da(1160,1288,1304,0,9306,33,9309,0,9309,0,a|0,9311,106);ea(1160,1,3688,9306,34,4);a=Zj(8)|0;c[a>>2]=105;c[a+4>>2]=0;fa(1160,9328,3,3692,8958,16,a|0,0);a=Zj(8)|0;c[a>>2]=17;c[a+4>>2]=0;fa(1160,9338,4,48,9481,12,a|0,0);a=Zj(8)|0;c[a>>2]=35;c[a+4>>2]=0;fa(1160,9345,2,3704,9150,43,a|0,0);a=Zj(4)|0;c[a>>2]=18;fa(1160,9350,3,3712,9487,10,a|0,0);a=Zj(4)|0;c[a>>2]=11;fa(1160,9354,4,64,9492,7,a|0,0);return}function me(a){a=a|0;return c[a+28>>2]|0}function ne(a){a=a|0;da(1400,1424,1440,0,9306,36,9309,0,9309,0,a|0,9311,107);ea(1400,1,3752,9306,37,5);a=Zj(8)|0;c[a>>2]=106;c[a+4>>2]=0;fa(1400,9328,3,3756,8958,19,a|0,0);a=Zj(8)|0;c[a>>2]=20;c[a+4>>2]=0;fa(1400,9338,4,80,9481,13,a|0,0);a=Zj(8)|0;c[a>>2]=38;c[a+4>>2]=0;fa(1400,9345,2,3768,9150,44,a|0,0);a=Zj(4)|0;c[a>>2]=21;fa(1400,9350,3,3776,9487,12,a|0,0);a=Zj(4)|0;c[a>>2]=13;fa(1400,9354,4,96,9492,8,a|0,0);return}function oe(a){a=a|0;return +(+((c[a>>2]|0)>>>0)+4294967296.0*+(c[a+4>>2]|0))}function pe(a,b){a=a|0;b=+b;var d=0;d=+s(b)>=1.0?(b>0.0?~~+B(+r(b/4294967296.0),4294967295.0)>>>0:~~+z((b-+(~~b>>>0))/4294967296.0)>>>0):0;c[a>>2]=~~b>>>0;c[a+4>>2]=d;return}function qe(a){a=a|0;a=a+8|0;return +(+((c[a>>2]|0)>>>0)+4294967296.0*+(c[a+4>>2]|0))}function re(a,b){a=a|0;b=+b;var d=0;d=+s(b)>=1.0?(b>0.0?~~+B(+r(b/4294967296.0),4294967295.0)>>>0:~~+z((b-+(~~b>>>0))/4294967296.0)>>>0):0;a=a+8|0;c[a>>2]=~~b>>>0;c[a+4>>2]=d;return}function se(a){a=a|0;a=a+16|0;return +(+((c[a>>2]|0)>>>0)+4294967296.0*+(c[a+4>>2]|0))}function te(a,b){a=a|0;b=+b;var d=0;d=+s(b)>=1.0?(b>0.0?~~+B(+r(b/4294967296.0),4294967295.0)>>>0:~~+z((b-+(~~b>>>0))/4294967296.0)>>>0):0;a=a+16|0;c[a>>2]=~~b>>>0;c[a+4>>2]=d;return}function ue(a){a=a|0;a=a+24|0;return +(+((c[a>>2]|0)>>>0)+4294967296.0*+(c[a+4>>2]|0))}function ve(a,b){return}function we(b){b=b|0;return (a[b+36>>0]|0)!=0|0}function xe(b,c){b=b|0;c=c|0;a[b+36>>0]=c&1;return}function ye(b){b=b|0;return (a[b+140>>0]|0)!=0|0}function ze(b,c){b=b|0;c=c|0;a[b+140>>0]=c&1;return}function Ae(b){b=b|0;return (a[b+142>>0]|0)!=0|0}function Be(b,c){b=b|0;c=c|0;a[b+142>>0]=c&1;return}function Ce(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;c[a>>2]=3556;e=a+112|0;d=a+120|0;if(c[d>>2]|0?(b=c[a+116>>2]|0,f=(c[e>>2]|0)+4|0,g=c[b>>2]|0,c[g+4>>2]=c[f>>2],c[c[f>>2]>>2]=g,c[d>>2]=0,(b|0)!=(e|0)):0)do{g=b;b=c[b+4>>2]|0;$j(g);}while((b|0)!=(e|0));b=c[a+96>>2]|0;if(b|0){c[a+100>>2]=b;$j(b);}b=c[a+84>>2]|0;if(b|0){c[a+88>>2]=b;$j(b);}b=c[a+72>>2]|0;if(!b){yc(a);$j(a);return}c[a+76>>2]=b;$j(b);yc(a);$j(a);return}function De(a){a=a|0;var b=0;c[a>>2]=3512;b=c[a+16>>2]|0;if(b|0){c[a+20>>2]=b;$j(b);}b=c[a+4>>2]|0;if(!b){$j(a);return}c[a+8>>2]=b;$j(b);$j(a);return}function Ee(b){b=b|0;var d=0;c[b>>2]=3588;d=b+4|0;if((a[d+11>>0]|0)>=0){$j(b);return}$j(c[d>>2]|0);$j(b);return}function Fe(b){b=b|0;b=b+4|0;if((a[b+11>>0]|0)<0){b=c[b>>2]|0;return b|0}else return b|0;}function Ge(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>4;d=g+1|0;if(d>>>0>268435455)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>3;h=f>>4>>>0<134217727?(h>>>0<d>>>0?d:h):268435455;do if(h)if(h>>>0>268435455){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else {f=Zj(h<<4)|0;e=f;break}else {e=0;f=0;}while(0);d=e+(g<<4)|0;c[d>>2]=c[b>>2];c[d+4>>2]=c[b+4>>2];c[d+8>>2]=c[b+8>>2];c[d+12>>2]=c[b+12>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+16;c[l>>2]=e+(h<<4);if(!j)return;$j(j);return}function He(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;p=a+4|0;l=c[p>>2]|0;d=c[a>>2]|0;h=(l-d|0)/12|0;e=h+1|0;m=d;if(e>>>0>357913941)gk();o=a+8|0;k=((c[o>>2]|0)-d|0)/12|0;n=k<<1;e=k>>>0<178956970?(n>>>0<e>>>0?e:n):357913941;do if(e)if(e>>>0>357913941){p=S(8)|0;dk(p,8694);c[p>>2]=7328;V(p|0,3264,87);}else {g=Zj(e*12|0)|0;break}else g=0;while(0);f=g+(h*12|0)|0;n=g+(e*12|0)|0;c[f>>2]=0;k=g+(h*12|0)+4|0;c[k>>2]=0;i=g+(h*12|0)+8|0;c[i>>2]=0;j=c[b>>2]|0;e=(c[b+4>>2]|0)-j|0;g=e>>4;if(e|0){if(g>>>0>268435455)gk();h=Zj(e)|0;c[k>>2]=h;c[f>>2]=h;c[i>>2]=h+(g<<4);if((e|0)>0){ax(h|0,j|0,e|0)|0;c[k>>2]=h+(e>>>4<<4);}}g=f+12|0;if((l|0)!=(m|0)){d=l;do{b=f;f=f+-12|0;k=d;d=d+-12|0;c[f>>2]=0;j=b+-8|0;c[j>>2]=0;b=b+-4|0;c[b>>2]=0;c[f>>2]=c[d>>2];l=k+-8|0;c[j>>2]=c[l>>2];k=k+-4|0;c[b>>2]=c[k>>2];c[k>>2]=0;c[l>>2]=0;c[d>>2]=0;}while((d|0)!=(m|0));d=c[a>>2]|0;e=c[p>>2]|0;h=d;c[a>>2]=f;c[p>>2]=g;c[o>>2]=n;if((e|0)!=(h|0))do{f=e;e=e+-12|0;g=c[e>>2]|0;if(g|0){c[f+-8>>2]=g;$j(g);}}while((e|0)!=(h|0))}else {c[a>>2]=f;c[p>>2]=g;c[o>>2]=n;}if(!d)return;$j(d);return}function Ie(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>2;d=g+1|0;if(d>>>0>1073741823)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>1;h=f>>2>>>0<536870911?(h>>>0<d>>>0?d:h):1073741823;do if(h)if(h>>>0>1073741823){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else {f=Zj(h<<2)|0;e=f;break}else {e=0;f=0;}while(0);d=e+(g<<2)|0;c[d>>2]=c[b>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+4;c[l>>2]=e+(h<<2);if(!j)return;$j(j);return}function Je(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>4;d=g+1|0;if(d>>>0>268435455)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>3;h=f>>4>>>0<134217727?(h>>>0<d>>>0?d:h):268435455;do if(h)if(h>>>0>268435455){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else {f=Zj(h<<4)|0;e=f;break}else {e=0;f=0;}while(0);d=e+(g<<4)|0;c[d>>2]=c[b>>2];c[d+4>>2]=c[b+4>>2];c[d+8>>2]=c[b+8>>2];c[d+12>>2]=c[b+12>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+16;c[l>>2]=e+(h<<4);if(!j)return;$j(j);return}function Ke(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>2;d=g+1|0;if(d>>>0>1073741823)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>1;h=f>>2>>>0<536870911?(h>>>0<d>>>0?d:h):1073741823;do if(h)if(h>>>0>1073741823){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else {f=Zj(h<<2)|0;e=f;break}else {e=0;f=0;}while(0);d=e+(g<<2)|0;c[d>>2]=c[b>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+4;c[l>>2]=e+(h<<2);if(!j)return;$j(j);return}function Le(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;r=Eb;Eb=Eb+16|0;q=r;a:while(1){m=b;e=b+-16|0;n=b+-32|0;o=b;p=a;b:while(1){f=m-p|0;a=f>>4;switch(a|0){case 2:{k=4;break a}case 3:{k=6;break a}case 4:{k=14;break a}case 5:{k=15;break a}case 1:case 0:{k=95;break a}}if((f|0)<496){k=21;break a}k=p+(((a|0)/2|0)<<4)|0;do if((f|0)>15984){f=(a|0)/4|0;h=p+(f<<4)|0;f=k+(f<<4)|0;a=Me(p,h,k,f,d)|0;j=f;g=c[j+4>>2]|0;l=e;i=c[l+4>>2]|0;if(!((g|0)<(i|0)|((g|0)==(i|0)?(c[j>>2]|0)>>>0<(c[l>>2]|0)>>>0:0))){f=k;break}c[q>>2]=c[f>>2];c[q+4>>2]=c[f+4>>2];c[q+8>>2]=c[f+8>>2];c[q+12>>2]=c[f+12>>2];c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];c[f+8>>2]=c[e+8>>2];c[f+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];g=a+1|0;j=k;s=c[j+4>>2]|0;l=f;i=c[l+4>>2]|0;if((s|0)<(i|0)|((s|0)==(i|0)?(c[j>>2]|0)>>>0<(c[l>>2]|0)>>>0:0)){c[q>>2]=c[k>>2];c[q+4>>2]=c[k+4>>2];c[q+8>>2]=c[k+8>>2];c[q+12>>2]=c[k+12>>2];c[k>>2]=c[f>>2];c[k+4>>2]=c[f+4>>2];c[k+8>>2]=c[f+8>>2];c[k+12>>2]=c[f+12>>2];c[f>>2]=c[q>>2];c[f+4>>2]=c[q+4>>2];c[f+8>>2]=c[q+8>>2];c[f+12>>2]=c[q+12>>2];f=a+2|0;l=h;i=c[l+4>>2]|0;s=k;j=c[s+4>>2]|0;if((i|0)<(j|0)|((i|0)==(j|0)?(c[l>>2]|0)>>>0<(c[s>>2]|0)>>>0:0)){c[q>>2]=c[h>>2];c[q+4>>2]=c[h+4>>2];c[q+8>>2]=c[h+8>>2];c[q+12>>2]=c[h+12>>2];c[h>>2]=c[k>>2];c[h+4>>2]=c[k+4>>2];c[h+8>>2]=c[k+8>>2];c[h+12>>2]=c[k+12>>2];c[k>>2]=c[q>>2];c[k+4>>2]=c[q+4>>2];c[k+8>>2]=c[q+8>>2];c[k+12>>2]=c[q+12>>2];l=p;i=c[l+4>>2]|0;s=h;j=c[s+4>>2]|0;if((i|0)<(j|0)|((i|0)==(j|0)?(c[l>>2]|0)>>>0<(c[s>>2]|0)>>>0:0)){c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[h>>2];c[p+4>>2]=c[h+4>>2];c[p+8>>2]=c[h+8>>2];c[p+12>>2]=c[h+12>>2];c[h>>2]=c[q>>2];c[h+4>>2]=c[q+4>>2];c[h+8>>2]=c[q+8>>2];c[h+12>>2]=c[q+12>>2];a=a+4|0;f=k;}else {a=a+3|0;f=k;}}else {a=f;f=k;}}else {a=g;f=k;}}else {l=p;i=c[l+4>>2]|0;j=k;s=c[j>>2]|0;j=c[j+4>>2]|0;a=e;h=c[a+4>>2]|0;a=(j|0)<(h|0)|((j|0)==(h|0)?s>>>0<(c[a>>2]|0)>>>0:0);if(!((i|0)<(j|0)|((i|0)==(j|0)?(c[l>>2]|0)>>>0<s>>>0:0))){if(!a){a=0;f=k;break}c[q>>2]=c[k>>2];c[q+4>>2]=c[k+4>>2];c[q+8>>2]=c[k+8>>2];c[q+12>>2]=c[k+12>>2];c[k>>2]=c[e>>2];c[k+4>>2]=c[e+4>>2];c[k+8>>2]=c[e+8>>2];c[k+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];l=p;i=c[l+4>>2]|0;s=k;j=c[s+4>>2]|0;if(!((i|0)<(j|0)|((i|0)==(j|0)?(c[l>>2]|0)>>>0<(c[s>>2]|0)>>>0:0))){a=1;f=k;break}c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[k>>2];c[p+4>>2]=c[k+4>>2];c[p+8>>2]=c[k+8>>2];c[p+12>>2]=c[k+12>>2];c[k>>2]=c[q>>2];c[k+4>>2]=c[q+4>>2];c[k+8>>2]=c[q+8>>2];c[k+12>>2]=c[q+12>>2];a=2;f=k;break}if(a){c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[e>>2];c[p+4>>2]=c[e+4>>2];c[p+8>>2]=c[e+8>>2];c[p+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];a=1;f=k;break}c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[k>>2];c[p+4>>2]=c[k+4>>2];c[p+8>>2]=c[k+8>>2];c[p+12>>2]=c[k+12>>2];c[k>>2]=c[q>>2];c[k+4>>2]=c[q+4>>2];c[k+8>>2]=c[q+8>>2];c[k+12>>2]=c[q+12>>2];l=k;i=c[l+4>>2]|0;s=e;j=c[s+4>>2]|0;if((i|0)<(j|0)|((i|0)==(j|0)?(c[l>>2]|0)>>>0<(c[s>>2]|0)>>>0:0)){c[q>>2]=c[k>>2];c[q+4>>2]=c[k+4>>2];c[q+8>>2]=c[k+8>>2];c[q+12>>2]=c[k+12>>2];c[k>>2]=c[e>>2];c[k+4>>2]=c[e+4>>2];c[k+8>>2]=c[e+8>>2];c[k+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];a=2;f=k;}else {a=1;f=k;}}while(0);h=f;g=c[h>>2]|0;h=c[h+4>>2]|0;l=p;j=c[l>>2]|0;l=c[l+4>>2]|0;if((h|0)<(l|0)|(h|0)==(l|0)&g>>>0<j>>>0)f=e;else {if((p|0)==(n|0)){k=58;break}f=n;while(1){s=f;i=c[s+4>>2]|0;if((h|0)<(i|0)|((h|0)==(i|0)?g>>>0<(c[s>>2]|0)>>>0:0))break;f=f+-16|0;if((p|0)==(f|0)){k=57;break b}}c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[f>>2];c[p+4>>2]=c[f+4>>2];c[p+8>>2]=c[f+8>>2];c[p+12>>2]=c[f+12>>2];c[f>>2]=c[q>>2];c[f+4>>2]=c[q+4>>2];c[f+8>>2]=c[q+8>>2];c[f+12>>2]=c[q+12>>2];a=a+1|0;}g=p+16|0;c:do if(g>>>0<f>>>0)while(1){j=k;i=c[j>>2]|0;j=c[j+4>>2]|0;while(1){s=g;l=c[s+4>>2]|0;h=g+16|0;if((j|0)<(l|0)|((j|0)==(l|0)?i>>>0<(c[s>>2]|0)>>>0:0))g=h;else break}do{f=f+-16|0;s=f;l=c[s+4>>2]|0;}while(!((j|0)<(l|0)|((j|0)==(l|0)?i>>>0<(c[s>>2]|0)>>>0:0)));if(g>>>0>f>>>0){f=k;break c}c[q>>2]=c[g>>2];c[q+4>>2]=c[g+4>>2];c[q+8>>2]=c[g+8>>2];c[q+12>>2]=c[g+12>>2];c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];c[g+8>>2]=c[f+8>>2];c[g+12>>2]=c[f+12>>2];c[f>>2]=c[q>>2];c[f+4>>2]=c[q+4>>2];c[f+8>>2]=c[q+8>>2];c[f+12>>2]=c[q+12>>2];k=(k|0)==(g|0)?f:k;g=h;a=a+1|0;}else f=k;while(0);if((g|0)!=(f|0)?(l=g,j=c[l+4>>2]|0,s=f,k=c[s+4>>2]|0,(j|0)<(k|0)|((j|0)==(k|0)?(c[l>>2]|0)>>>0<(c[s>>2]|0)>>>0:0)):0){c[q>>2]=c[g>>2];c[q+4>>2]=c[g+4>>2];c[q+8>>2]=c[g+8>>2];c[q+12>>2]=c[g+12>>2];c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];c[g+8>>2]=c[f+8>>2];c[g+12>>2]=c[f+12>>2];c[f>>2]=c[q>>2];c[f+4>>2]=c[q+4>>2];c[f+8>>2]=c[q+8>>2];c[f+12>>2]=c[q+12>>2];a=a+1|0;}if(!a){f=Ne(p,g,d)|0;a=g+16|0;if(Ne(a,b,d)|0){k=88;break}if(f){e=2;k=93;break}}s=g;if((s-p|0)>=(o-s|0)){k=92;break}Le(p,g,d);p=g+16|0;}if((k|0)==57){i=p;k=59;}else if((k|0)==58){i=p;k=59;}else if((k|0)==88){e=f?1:2;a=p;b=f?b:g;k=93;}else if((k|0)==92){k=0;Le(g+16|0,b,d);a=p;b=g;}d:do if((k|0)==59){a=p+16|0;s=e;p=c[s+4>>2]|0;if(!((p|0)<(l|0)|((p|0)==(l|0)?(c[s>>2]|0)>>>0<j>>>0:0))){if((a|0)==(e|0)){k=95;break a}while(1){s=a;p=c[s+4>>2]|0;if((p|0)<(l|0)|((p|0)==(l|0)?(c[s>>2]|0)>>>0<j>>>0:0))break;a=a+16|0;if((a|0)==(e|0)){k=95;break a}}c[q>>2]=c[a>>2];c[q+4>>2]=c[a+4>>2];c[q+8>>2]=c[a+8>>2];c[q+12>>2]=c[a+12>>2];c[a>>2]=c[e>>2];c[a+4>>2]=c[e+4>>2];c[a+8>>2]=c[e+8>>2];c[a+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];a=a+16|0;}if((a|0)==(e|0)){k=95;break a}while(1){h=i;g=c[h>>2]|0;h=c[h+4>>2]|0;while(1){s=a;p=c[s+4>>2]|0;f=a+16|0;if((p|0)<(h|0)|((p|0)==(h|0)?(c[s>>2]|0)>>>0<g>>>0:0))break;else a=f;}do{e=e+-16|0;s=e;p=c[s+4>>2]|0;}while((p|0)<(h|0)|((p|0)==(h|0)?(c[s>>2]|0)>>>0<g>>>0:0));if(a>>>0>=e>>>0){e=4;k=93;break d}c[q>>2]=c[a>>2];c[q+4>>2]=c[a+4>>2];c[q+8>>2]=c[a+8>>2];c[q+12>>2]=c[a+12>>2];c[a>>2]=c[e>>2];c[a+4>>2]=c[e+4>>2];c[a+8>>2]=c[e+8>>2];c[a+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];a=f;}}while(0);if((k|0)==93)switch(e&7){case 2:case 4:case 0:break;default:{k=95;break a}}}if((k|0)==4){a=b+-16|0;d=p;n=c[d+4>>2]|0;s=a;o=c[s+4>>2]|0;if(!((n|0)<(o|0)|((n|0)==(o|0)?(c[d>>2]|0)>>>0<(c[s>>2]|0)>>>0:0))){Eb=r;return}c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[a>>2];c[p+4>>2]=c[a+4>>2];c[p+8>>2]=c[a+8>>2];c[p+12>>2]=c[a+12>>2];c[a>>2]=c[q>>2];c[a+4>>2]=c[q+4>>2];c[a+8>>2]=c[q+8>>2];c[a+12>>2]=c[q+12>>2];Eb=r;return}else if((k|0)==6){e=p+16|0;a=b+-16|0;d=p;n=c[d+4>>2]|0;o=e;s=c[o>>2]|0;o=c[o+4>>2]|0;b=a;m=c[b+4>>2]|0;b=(o|0)<(m|0)|((o|0)==(m|0)?s>>>0<(c[b>>2]|0)>>>0:0);if(!((n|0)<(o|0)|((n|0)==(o|0)?(c[d>>2]|0)>>>0<s>>>0:0))){if(!b){Eb=r;return}c[q>>2]=c[e>>2];c[q+4>>2]=c[e+4>>2];c[q+8>>2]=c[e+8>>2];c[q+12>>2]=c[e+12>>2];c[e>>2]=c[a>>2];c[e+4>>2]=c[a+4>>2];c[e+8>>2]=c[a+8>>2];c[e+12>>2]=c[a+12>>2];c[a>>2]=c[q>>2];c[a+4>>2]=c[q+4>>2];c[a+8>>2]=c[q+8>>2];c[a+12>>2]=c[q+12>>2];d=p;n=c[d+4>>2]|0;s=e;o=c[s+4>>2]|0;if(!((n|0)<(o|0)|((n|0)==(o|0)?(c[d>>2]|0)>>>0<(c[s>>2]|0)>>>0:0))){Eb=r;return}c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[e>>2];c[p+4>>2]=c[e+4>>2];c[p+8>>2]=c[e+8>>2];c[p+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];Eb=r;return}if(b){c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[a>>2];c[p+4>>2]=c[a+4>>2];c[p+8>>2]=c[a+8>>2];c[p+12>>2]=c[a+12>>2];c[a>>2]=c[q>>2];c[a+4>>2]=c[q+4>>2];c[a+8>>2]=c[q+8>>2];c[a+12>>2]=c[q+12>>2];Eb=r;return}c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[e>>2];c[p+4>>2]=c[e+4>>2];c[p+8>>2]=c[e+8>>2];c[p+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];p=e;o=c[p+4>>2]|0;s=a;d=c[s+4>>2]|0;if(!((o|0)<(d|0)|((o|0)==(d|0)?(c[p>>2]|0)>>>0<(c[s>>2]|0)>>>0:0))){Eb=r;return}c[q>>2]=c[e>>2];c[q+4>>2]=c[e+4>>2];c[q+8>>2]=c[e+8>>2];c[q+12>>2]=c[e+12>>2];c[e>>2]=c[a>>2];c[e+4>>2]=c[a+4>>2];c[e+8>>2]=c[a+8>>2];c[e+12>>2]=c[a+12>>2];c[a>>2]=c[q>>2];c[a+4>>2]=c[q+4>>2];c[a+8>>2]=c[q+8>>2];c[a+12>>2]=c[q+12>>2];Eb=r;return}else if((k|0)==14){Me(p,p+16|0,p+32|0,b+-16|0,d)|0;Eb=r;return}else if((k|0)==15){e=p+16|0;f=p+32|0;g=p+48|0;a=b+-16|0;Me(p,e,f,g,d)|0;d=g;n=c[d+4>>2]|0;s=a;o=c[s+4>>2]|0;if(!((n|0)<(o|0)|((n|0)==(o|0)?(c[d>>2]|0)>>>0<(c[s>>2]|0)>>>0:0))){Eb=r;return}c[q>>2]=c[g>>2];c[q+4>>2]=c[g+4>>2];c[q+8>>2]=c[g+8>>2];c[q+12>>2]=c[g+12>>2];c[g>>2]=c[a>>2];c[g+4>>2]=c[a+4>>2];c[g+8>>2]=c[a+8>>2];c[g+12>>2]=c[a+12>>2];c[a>>2]=c[q>>2];c[a+4>>2]=c[q+4>>2];c[a+8>>2]=c[q+8>>2];c[a+12>>2]=c[q+12>>2];d=f;n=c[d+4>>2]|0;s=g;o=c[s+4>>2]|0;if(!((n|0)<(o|0)|((n|0)==(o|0)?(c[d>>2]|0)>>>0<(c[s>>2]|0)>>>0:0))){Eb=r;return}c[q>>2]=c[f>>2];c[q+4>>2]=c[f+4>>2];c[q+8>>2]=c[f+8>>2];c[q+12>>2]=c[f+12>>2];c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];c[f+8>>2]=c[g+8>>2];c[f+12>>2]=c[g+12>>2];c[g>>2]=c[q>>2];c[g+4>>2]=c[q+4>>2];c[g+8>>2]=c[q+8>>2];c[g+12>>2]=c[q+12>>2];d=e;n=c[d+4>>2]|0;s=f;o=c[s+4>>2]|0;if(!((n|0)<(o|0)|((n|0)==(o|0)?(c[d>>2]|0)>>>0<(c[s>>2]|0)>>>0:0))){Eb=r;return}c[q>>2]=c[e>>2];c[q+4>>2]=c[e+4>>2];c[q+8>>2]=c[e+8>>2];c[q+12>>2]=c[e+12>>2];c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];c[e+8>>2]=c[f+8>>2];c[e+12>>2]=c[f+12>>2];c[f>>2]=c[q>>2];c[f+4>>2]=c[q+4>>2];c[f+8>>2]=c[q+8>>2];c[f+12>>2]=c[q+12>>2];d=p;n=c[d+4>>2]|0;s=e;o=c[s+4>>2]|0;if(!((n|0)<(o|0)|((n|0)==(o|0)?(c[d>>2]|0)>>>0<(c[s>>2]|0)>>>0:0))){Eb=r;return}c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[e>>2];c[p+4>>2]=c[e+4>>2];c[p+8>>2]=c[e+8>>2];c[p+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];Eb=r;return}else if((k|0)==21){e=p+32|0;a=p+16|0;g=p;f=c[g>>2]|0;g=c[g+4>>2]|0;d=a;s=c[d>>2]|0;d=c[d+4>>2]|0;i=e;h=c[i>>2]|0;i=c[i+4>>2]|0;j=(d|0)<(i|0)|(d|0)==(i|0)&s>>>0<h>>>0;do if((g|0)<(d|0)|(g|0)==(d|0)&f>>>0<s>>>0){if(j){c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[e>>2];c[p+4>>2]=c[e+4>>2];c[p+8>>2]=c[e+8>>2];c[p+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];break}c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[a>>2];c[p+4>>2]=c[a+4>>2];c[p+8>>2]=c[a+8>>2];c[p+12>>2]=c[a+12>>2];c[a>>2]=c[q>>2];c[a+4>>2]=c[q+4>>2];c[a+8>>2]=c[q+8>>2];c[a+12>>2]=c[q+12>>2];s=a;d=c[s+4>>2]|0;if((d|0)<(i|0)|((d|0)==(i|0)?(c[s>>2]|0)>>>0<h>>>0:0)){c[q>>2]=c[a>>2];c[q+4>>2]=c[a+4>>2];c[q+8>>2]=c[a+8>>2];c[q+12>>2]=c[a+12>>2];c[a>>2]=c[e>>2];c[a+4>>2]=c[e+4>>2];c[a+8>>2]=c[e+8>>2];c[a+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];}}else if(j?(c[q>>2]=c[a>>2],c[q+4>>2]=c[a+4>>2],c[q+8>>2]=c[a+8>>2],c[q+12>>2]=c[a+12>>2],c[a>>2]=c[e>>2],c[a+4>>2]=c[e+4>>2],c[a+8>>2]=c[e+8>>2],c[a+12>>2]=c[e+12>>2],c[e>>2]=c[q>>2],c[e+4>>2]=c[q+4>>2],c[e+8>>2]=c[q+8>>2],c[e+12>>2]=c[q+12>>2],s=a,d=c[s+4>>2]|0,(g|0)<(d|0)|((g|0)==(d|0)?f>>>0<(c[s>>2]|0)>>>0:0)):0){c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[a>>2];c[p+4>>2]=c[a+4>>2];c[p+8>>2]=c[a+8>>2];c[p+12>>2]=c[a+12>>2];c[a>>2]=c[q>>2];c[a+4>>2]=c[q+4>>2];c[a+8>>2]=c[q+8>>2];c[a+12>>2]=c[q+12>>2];}while(0);a=p+48|0;if((a|0)==(b|0)){Eb=r;return}while(1){s=e;q=c[s+4>>2]|0;h=a;g=c[h>>2]|0;h=c[h+4>>2]|0;if((q|0)<(h|0)|((q|0)==(h|0)?(c[s>>2]|0)>>>0<g>>>0:0)){j=a+8|0;i=c[j>>2]|0;j=c[j+4>>2]|0;f=a;while(1){c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];c[f+8>>2]=c[e+8>>2];c[f+12>>2]=c[e+12>>2];if((e|0)==(p|0)){f=p;e=p;break}f=e+-16|0;s=f;q=c[s+4>>2]|0;if((q|0)<(h|0)|((q|0)==(h|0)?(c[s>>2]|0)>>>0<g>>>0:0)){s=e;e=f;f=s;}else {k=35;break}}if((k|0)==35){k=0;f=e;}s=e;c[s>>2]=g;c[s+4>>2]=h;s=f+8|0;c[s>>2]=i;c[s+4>>2]=j;}e=a+16|0;if((e|0)==(b|0))break;else {s=a;a=e;e=s;}}Eb=r;return}else if((k|0)==95){Eb=r;return}}function Me(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0;h=Eb;Eb=Eb+16|0;g=h;j=a;l=c[j+4>>2]|0;k=b;i=c[k>>2]|0;k=c[k+4>>2]|0;f=d;m=c[f+4>>2]|0;f=(k|0)<(m|0)|((k|0)==(m|0)?i>>>0<(c[f>>2]|0)>>>0:0);do if((l|0)<(k|0)|((l|0)==(k|0)?(c[j>>2]|0)>>>0<i>>>0:0)){if(f){c[g>>2]=c[a>>2];c[g+4>>2]=c[a+4>>2];c[g+8>>2]=c[a+8>>2];c[g+12>>2]=c[a+12>>2];c[a>>2]=c[d>>2];c[a+4>>2]=c[d+4>>2];c[a+8>>2]=c[d+8>>2];c[a+12>>2]=c[d+12>>2];c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];c[d+8>>2]=c[g+8>>2];c[d+12>>2]=c[g+12>>2];f=1;break}c[g>>2]=c[a>>2];c[g+4>>2]=c[a+4>>2];c[g+8>>2]=c[a+8>>2];c[g+12>>2]=c[a+12>>2];c[a>>2]=c[b>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];c[a+12>>2]=c[b+12>>2];c[b>>2]=c[g>>2];c[b+4>>2]=c[g+4>>2];c[b+8>>2]=c[g+8>>2];c[b+12>>2]=c[g+12>>2];l=b;j=c[l+4>>2]|0;m=d;k=c[m+4>>2]|0;if((j|0)<(k|0)|((j|0)==(k|0)?(c[l>>2]|0)>>>0<(c[m>>2]|0)>>>0:0)){c[g>>2]=c[b>>2];c[g+4>>2]=c[b+4>>2];c[g+8>>2]=c[b+8>>2];c[g+12>>2]=c[b+12>>2];c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];c[d+8>>2]=c[g+8>>2];c[d+12>>2]=c[g+12>>2];f=2;}else f=1;}else if(f){c[g>>2]=c[b>>2];c[g+4>>2]=c[b+4>>2];c[g+8>>2]=c[b+8>>2];c[g+12>>2]=c[b+12>>2];c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];c[d+8>>2]=c[g+8>>2];c[d+12>>2]=c[g+12>>2];l=a;j=c[l+4>>2]|0;m=b;k=c[m+4>>2]|0;if((j|0)<(k|0)|((j|0)==(k|0)?(c[l>>2]|0)>>>0<(c[m>>2]|0)>>>0:0)){c[g>>2]=c[a>>2];c[g+4>>2]=c[a+4>>2];c[g+8>>2]=c[a+8>>2];c[g+12>>2]=c[a+12>>2];c[a>>2]=c[b>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];c[a+12>>2]=c[b+12>>2];c[b>>2]=c[g>>2];c[b+4>>2]=c[g+4>>2];c[b+8>>2]=c[g+8>>2];c[b+12>>2]=c[g+12>>2];f=2;}else f=1;}else f=0;while(0);l=d;j=c[l+4>>2]|0;m=e;k=c[m+4>>2]|0;if(!((j|0)<(k|0)|((j|0)==(k|0)?(c[l>>2]|0)>>>0<(c[m>>2]|0)>>>0:0))){m=f;Eb=h;return m|0}c[g>>2]=c[d>>2];c[g+4>>2]=c[d+4>>2];c[g+8>>2]=c[d+8>>2];c[g+12>>2]=c[d+12>>2];c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];c[d+8>>2]=c[e+8>>2];c[d+12>>2]=c[e+12>>2];c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];c[e+8>>2]=c[g+8>>2];c[e+12>>2]=c[g+12>>2];l=b;j=c[l+4>>2]|0;m=d;k=c[m+4>>2]|0;if(!((j|0)<(k|0)|((j|0)==(k|0)?(c[l>>2]|0)>>>0<(c[m>>2]|0)>>>0:0))){m=f+1|0;Eb=h;return m|0}c[g>>2]=c[b>>2];c[g+4>>2]=c[b+4>>2];c[g+8>>2]=c[b+8>>2];c[g+12>>2]=c[b+12>>2];c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];c[d+8>>2]=c[g+8>>2];c[d+12>>2]=c[g+12>>2];l=a;j=c[l+4>>2]|0;m=b;k=c[m+4>>2]|0;if(!((j|0)<(k|0)|((j|0)==(k|0)?(c[l>>2]|0)>>>0<(c[m>>2]|0)>>>0:0))){m=f+2|0;Eb=h;return m|0}c[g>>2]=c[a>>2];c[g+4>>2]=c[a+4>>2];c[g+8>>2]=c[a+8>>2];c[g+12>>2]=c[a+12>>2];c[a>>2]=c[b>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];c[a+12>>2]=c[b+12>>2];c[b>>2]=c[g>>2];c[b+4>>2]=c[g+4>>2];c[b+8>>2]=c[g+8>>2];c[b+12>>2]=c[g+12>>2];m=f+3|0;Eb=h;return m|0}function Ne(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;m=Eb;Eb=Eb+16|0;l=m;switch(b-a>>4|0){case 2:{e=b+-16|0;k=a;i=c[k+4>>2]|0;b=e;j=c[b+4>>2]|0;if(!((i|0)<(j|0)|((i|0)==(j|0)?(c[k>>2]|0)>>>0<(c[b>>2]|0)>>>0:0))){l=1;Eb=m;return l|0}c[l>>2]=c[a>>2];c[l+4>>2]=c[a+4>>2];c[l+8>>2]=c[a+8>>2];c[l+12>>2]=c[a+12>>2];c[a>>2]=c[e>>2];c[a+4>>2]=c[e+4>>2];c[a+8>>2]=c[e+8>>2];c[a+12>>2]=c[e+12>>2];c[e>>2]=c[l>>2];c[e+4>>2]=c[l+4>>2];c[e+8>>2]=c[l+8>>2];c[e+12>>2]=c[l+12>>2];l=1;Eb=m;return l|0}case 3:{g=a+16|0;e=b+-16|0;k=a;i=c[k+4>>2]|0;j=g;b=c[j>>2]|0;j=c[j+4>>2]|0;f=e;d=c[f+4>>2]|0;f=(j|0)<(d|0)|((j|0)==(d|0)?b>>>0<(c[f>>2]|0)>>>0:0);if(!((i|0)<(j|0)|((i|0)==(j|0)?(c[k>>2]|0)>>>0<b>>>0:0))){if(!f){l=1;Eb=m;return l|0}c[l>>2]=c[g>>2];c[l+4>>2]=c[g+4>>2];c[l+8>>2]=c[g+8>>2];c[l+12>>2]=c[g+12>>2];c[g>>2]=c[e>>2];c[g+4>>2]=c[e+4>>2];c[g+8>>2]=c[e+8>>2];c[g+12>>2]=c[e+12>>2];c[e>>2]=c[l>>2];c[e+4>>2]=c[l+4>>2];c[e+8>>2]=c[l+8>>2];c[e+12>>2]=c[l+12>>2];k=a;i=c[k+4>>2]|0;b=g;j=c[b+4>>2]|0;if(!((i|0)<(j|0)|((i|0)==(j|0)?(c[k>>2]|0)>>>0<(c[b>>2]|0)>>>0:0))){l=1;Eb=m;return l|0}c[l>>2]=c[a>>2];c[l+4>>2]=c[a+4>>2];c[l+8>>2]=c[a+8>>2];c[l+12>>2]=c[a+12>>2];c[a>>2]=c[g>>2];c[a+4>>2]=c[g+4>>2];c[a+8>>2]=c[g+8>>2];c[a+12>>2]=c[g+12>>2];c[g>>2]=c[l>>2];c[g+4>>2]=c[l+4>>2];c[g+8>>2]=c[l+8>>2];c[g+12>>2]=c[l+12>>2];l=1;Eb=m;return l|0}if(f){c[l>>2]=c[a>>2];c[l+4>>2]=c[a+4>>2];c[l+8>>2]=c[a+8>>2];c[l+12>>2]=c[a+12>>2];c[a>>2]=c[e>>2];c[a+4>>2]=c[e+4>>2];c[a+8>>2]=c[e+8>>2];c[a+12>>2]=c[e+12>>2];c[e>>2]=c[l>>2];c[e+4>>2]=c[l+4>>2];c[e+8>>2]=c[l+8>>2];c[e+12>>2]=c[l+12>>2];l=1;Eb=m;return l|0}c[l>>2]=c[a>>2];c[l+4>>2]=c[a+4>>2];c[l+8>>2]=c[a+8>>2];c[l+12>>2]=c[a+12>>2];c[a>>2]=c[g>>2];c[a+4>>2]=c[g+4>>2];c[a+8>>2]=c[g+8>>2];c[a+12>>2]=c[g+12>>2];c[g>>2]=c[l>>2];c[g+4>>2]=c[l+4>>2];c[g+8>>2]=c[l+8>>2];c[g+12>>2]=c[l+12>>2];b=g;j=c[b+4>>2]|0;a=e;k=c[a+4>>2]|0;if(!((j|0)<(k|0)|((j|0)==(k|0)?(c[b>>2]|0)>>>0<(c[a>>2]|0)>>>0:0))){l=1;Eb=m;return l|0}c[l>>2]=c[g>>2];c[l+4>>2]=c[g+4>>2];c[l+8>>2]=c[g+8>>2];c[l+12>>2]=c[g+12>>2];c[g>>2]=c[e>>2];c[g+4>>2]=c[e+4>>2];c[g+8>>2]=c[e+8>>2];c[g+12>>2]=c[e+12>>2];c[e>>2]=c[l>>2];c[e+4>>2]=c[l+4>>2];c[e+8>>2]=c[l+8>>2];c[e+12>>2]=c[l+12>>2];l=1;Eb=m;return l|0}case 4:{Me(a,a+16|0,a+32|0,b+-16|0,d)|0;l=1;Eb=m;return l|0}case 5:{f=a+16|0;g=a+32|0;h=a+48|0;e=b+-16|0;Me(a,f,g,h,d)|0;k=h;i=c[k+4>>2]|0;b=e;j=c[b+4>>2]|0;if(!((i|0)<(j|0)|((i|0)==(j|0)?(c[k>>2]|0)>>>0<(c[b>>2]|0)>>>0:0))){l=1;Eb=m;return l|0}c[l>>2]=c[h>>2];c[l+4>>2]=c[h+4>>2];c[l+8>>2]=c[h+8>>2];c[l+12>>2]=c[h+12>>2];c[h>>2]=c[e>>2];c[h+4>>2]=c[e+4>>2];c[h+8>>2]=c[e+8>>2];c[h+12>>2]=c[e+12>>2];c[e>>2]=c[l>>2];c[e+4>>2]=c[l+4>>2];c[e+8>>2]=c[l+8>>2];c[e+12>>2]=c[l+12>>2];k=g;i=c[k+4>>2]|0;b=h;j=c[b+4>>2]|0;if(!((i|0)<(j|0)|((i|0)==(j|0)?(c[k>>2]|0)>>>0<(c[b>>2]|0)>>>0:0))){l=1;Eb=m;return l|0}c[l>>2]=c[g>>2];c[l+4>>2]=c[g+4>>2];c[l+8>>2]=c[g+8>>2];c[l+12>>2]=c[g+12>>2];c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];c[g+8>>2]=c[h+8>>2];c[g+12>>2]=c[h+12>>2];c[h>>2]=c[l>>2];c[h+4>>2]=c[l+4>>2];c[h+8>>2]=c[l+8>>2];c[h+12>>2]=c[l+12>>2];k=f;i=c[k+4>>2]|0;b=g;j=c[b+4>>2]|0;if(!((i|0)<(j|0)|((i|0)==(j|0)?(c[k>>2]|0)>>>0<(c[b>>2]|0)>>>0:0))){l=1;Eb=m;return l|0}c[l>>2]=c[f>>2];c[l+4>>2]=c[f+4>>2];c[l+8>>2]=c[f+8>>2];c[l+12>>2]=c[f+12>>2];c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];c[f+8>>2]=c[g+8>>2];c[f+12>>2]=c[g+12>>2];c[g>>2]=c[l>>2];c[g+4>>2]=c[l+4>>2];c[g+8>>2]=c[l+8>>2];c[g+12>>2]=c[l+12>>2];k=a;i=c[k+4>>2]|0;b=f;j=c[b+4>>2]|0;if(!((i|0)<(j|0)|((i|0)==(j|0)?(c[k>>2]|0)>>>0<(c[b>>2]|0)>>>0:0))){l=1;Eb=m;return l|0}c[l>>2]=c[a>>2];c[l+4>>2]=c[a+4>>2];c[l+8>>2]=c[a+8>>2];c[l+12>>2]=c[a+12>>2];c[a>>2]=c[f>>2];c[a+4>>2]=c[f+4>>2];c[a+8>>2]=c[f+8>>2];c[a+12>>2]=c[f+12>>2];c[f>>2]=c[l>>2];c[f+4>>2]=c[l+4>>2];c[f+8>>2]=c[l+8>>2];c[f+12>>2]=c[l+12>>2];l=1;Eb=m;return l|0}case 1:case 0:{l=1;Eb=m;return l|0}default:{g=a+32|0;e=a+16|0;h=a;f=c[h>>2]|0;h=c[h+4>>2]|0;o=e;n=c[o>>2]|0;o=c[o+4>>2]|0;i=g;d=c[i>>2]|0;i=c[i+4>>2]|0;j=(o|0)<(i|0)|(o|0)==(i|0)&n>>>0<d>>>0;do if((h|0)<(o|0)|(h|0)==(o|0)&f>>>0<n>>>0){if(j){c[l>>2]=c[a>>2];c[l+4>>2]=c[a+4>>2];c[l+8>>2]=c[a+8>>2];c[l+12>>2]=c[a+12>>2];c[a>>2]=c[g>>2];c[a+4>>2]=c[g+4>>2];c[a+8>>2]=c[g+8>>2];c[a+12>>2]=c[g+12>>2];c[g>>2]=c[l>>2];c[g+4>>2]=c[l+4>>2];c[g+8>>2]=c[l+8>>2];c[g+12>>2]=c[l+12>>2];break}c[l>>2]=c[a>>2];c[l+4>>2]=c[a+4>>2];c[l+8>>2]=c[a+8>>2];c[l+12>>2]=c[a+12>>2];c[a>>2]=c[e>>2];c[a+4>>2]=c[e+4>>2];c[a+8>>2]=c[e+8>>2];c[a+12>>2]=c[e+12>>2];c[e>>2]=c[l>>2];c[e+4>>2]=c[l+4>>2];c[e+8>>2]=c[l+8>>2];c[e+12>>2]=c[l+12>>2];o=e;n=c[o+4>>2]|0;if((n|0)<(i|0)|((n|0)==(i|0)?(c[o>>2]|0)>>>0<d>>>0:0)){c[l>>2]=c[e>>2];c[l+4>>2]=c[e+4>>2];c[l+8>>2]=c[e+8>>2];c[l+12>>2]=c[e+12>>2];c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];c[e+8>>2]=c[g+8>>2];c[e+12>>2]=c[g+12>>2];c[g>>2]=c[l>>2];c[g+4>>2]=c[l+4>>2];c[g+8>>2]=c[l+8>>2];c[g+12>>2]=c[l+12>>2];}}else if(j?(c[l>>2]=c[e>>2],c[l+4>>2]=c[e+4>>2],c[l+8>>2]=c[e+8>>2],c[l+12>>2]=c[e+12>>2],c[e>>2]=c[g>>2],c[e+4>>2]=c[g+4>>2],c[e+8>>2]=c[g+8>>2],c[e+12>>2]=c[g+12>>2],c[g>>2]=c[l>>2],c[g+4>>2]=c[l+4>>2],c[g+8>>2]=c[l+8>>2],c[g+12>>2]=c[l+12>>2],o=e,n=c[o+4>>2]|0,(h|0)<(n|0)|((h|0)==(n|0)?f>>>0<(c[o>>2]|0)>>>0:0)):0){c[l>>2]=c[a>>2];c[l+4>>2]=c[a+4>>2];c[l+8>>2]=c[a+8>>2];c[l+12>>2]=c[a+12>>2];c[a>>2]=c[e>>2];c[a+4>>2]=c[e+4>>2];c[a+8>>2]=c[e+8>>2];c[a+12>>2]=c[e+12>>2];c[e>>2]=c[l>>2];c[e+4>>2]=c[l+4>>2];c[e+8>>2]=c[l+8>>2];c[e+12>>2]=c[l+12>>2];}while(0);e=a+48|0;if((e|0)==(b|0)){o=1;Eb=m;return o|0}f=0;while(1){o=g;n=c[o+4>>2]|0;i=e;d=c[i>>2]|0;i=c[i+4>>2]|0;if((n|0)<(i|0)|((n|0)==(i|0)?(c[o>>2]|0)>>>0<d>>>0:0)){n=e+8|0;o=c[n+4>>2]|0;h=l;c[h>>2]=c[n>>2];c[h+4>>2]=o;h=e;while(1){c[h>>2]=c[g>>2];c[h+4>>2]=c[g+4>>2];c[h+8>>2]=c[g+8>>2];c[h+12>>2]=c[g+12>>2];if((g|0)==(a|0)){h=a;g=a;break}h=g+-16|0;o=h;n=c[o+4>>2]|0;if((n|0)<(i|0)|((n|0)==(i|0)?(c[o>>2]|0)>>>0<d>>>0:0)){o=g;g=h;h=o;}else {k=32;break}}if((k|0)==32){k=0;h=g;}j=g;c[j>>2]=d;c[j+4>>2]=i;j=l;n=c[j+4>>2]|0;o=h+8|0;c[o>>2]=c[j>>2];c[o+4>>2]=n;f=f+1|0;if((f|0)==8)break}g=e+16|0;if((g|0)==(b|0)){e=1;k=36;break}else {o=e;e=g;g=o;}}if((k|0)==36){Eb=m;return e|0}o=(e+16|0)==(b|0);Eb=m;return o|0}}return 0}function Oe(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>3;d=g+1|0;if(d>>>0>536870911)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>2;h=f>>3>>>0<268435455?(h>>>0<d>>>0?d:h):536870911;do if(h)if(h>>>0>536870911){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else {f=Zj(h<<3)|0;e=f;break}else {e=0;f=0;}while(0);d=e+(g<<3)|0;m=b;g=c[m+4>>2]|0;b=d;c[b>>2]=c[m>>2];c[b+4>>2]=g;if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+8;c[l>>2]=e+(h<<3);if(!j)return;$j(j);return}function Pe(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>2;d=g+1|0;if(d>>>0>1073741823)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>1;h=f>>2>>>0<536870911?(h>>>0<d>>>0?d:h):1073741823;do if(h)if(h>>>0>1073741823){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else {f=Zj(h<<2)|0;e=f;break}else {e=0;f=0;}while(0);d=e+(g<<2)|0;c[d>>2]=c[b>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+4;c[l>>2]=e+(h<<2);if(!j)return;$j(j);return}function Qe(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;l=a+8|0;f=c[l>>2]|0;m=a+4|0;e=c[m>>2]|0;d=e;if(((f-e|0)/12|0)>>>0>=b>>>0){cx(e|0,0,b*12|0)|0;c[m>>2]=d+(b*12|0);return}k=c[a>>2]|0;h=(e-k|0)/12|0;e=h+b|0;j=k;if(e>>>0>357913941)gk();i=(f-k|0)/12|0;g=i<<1;g=i>>>0<178956970?(g>>>0<e>>>0?e:g):357913941;do if(g)if(g>>>0>357913941){m=S(8)|0;dk(m,8694);c[m>>2]=7328;V(m|0,3264,87);}else {f=Zj(g*12|0)|0;break}else f=0;while(0);e=f+(h*12|0)|0;i=f+(g*12|0)|0;cx(e|0,0,b*12|0)|0;f=e+(b*12|0)|0;if((d|0)==(j|0)){h=j;g=k;}else {do{h=e;e=e+-12|0;b=d;d=d+-12|0;c[e>>2]=0;g=h+-8|0;c[g>>2]=0;h=h+-4|0;c[h>>2]=0;c[e>>2]=c[d>>2];k=b+-8|0;c[g>>2]=c[k>>2];b=b+-4|0;c[h>>2]=c[b>>2];c[b>>2]=0;c[k>>2]=0;c[d>>2]=0;}while((d|0)!=(j|0));g=c[a>>2]|0;h=g;d=c[m>>2]|0;}c[a>>2]=e;c[m>>2]=f;c[l>>2]=i;if((d|0)!=(h|0))do{e=d;d=d+-12|0;f=c[d>>2]|0;if(f|0){c[e+-8>>2]=f;$j(f);}}while((d|0)!=(h|0));if(!g)return;$j(g);return}function Re(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>2;d=g+1|0;if(d>>>0>1073741823)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>1;h=f>>2>>>0<536870911?(h>>>0<d>>>0?d:h):1073741823;do if(h)if(h>>>0>1073741823){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else {f=Zj(h<<2)|0;e=f;break}else {e=0;f=0;}while(0);d=e+(g<<2)|0;c[d>>2]=c[b>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+4;c[l>>2]=e+(h<<2);if(!j)return;$j(j);return}function Se(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>2;d=g+1|0;if(d>>>0>1073741823)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>1;h=f>>2>>>0<536870911?(h>>>0<d>>>0?d:h):1073741823;do if(h)if(h>>>0>1073741823){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else {f=Zj(h<<2)|0;e=f;break}else {e=0;f=0;}while(0);d=e+(g<<2)|0;c[d>>2]=c[b>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+4;c[l>>2]=e+(h<<2);if(!j)return;$j(j);return}function Te(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;a:while(1){k=b;f=b+-4|0;l=b+-8|0;m=b;b:while(1){e=k-a|0;g=e>>2;switch(g|0){case 2:{e=4;break a}case 3:{e=6;break a}case 4:{e=14;break a}case 5:{e=15;break a}case 1:case 0:{e=76;break a}}if((e|0)<124){e=21;break a}j=a+(((g|0)/2|0)<<2)|0;do if((e|0)>3996){g=(g|0)/4|0;i=a+(g<<2)|0;g=j+(g<<2)|0;e=Ue(a,i,j,g,d)|0;if(Ob[c[d>>2]&63](c[f>>2]|0,c[g>>2]|0)|0){h=c[g>>2]|0;c[g>>2]=c[f>>2];c[f>>2]=h;h=e+1|0;if(Ob[c[d>>2]&63](c[g>>2]|0,c[j>>2]|0)|0){h=c[j>>2]|0;c[j>>2]=c[g>>2];c[g>>2]=h;g=e+2|0;if(Ob[c[d>>2]&63](c[j>>2]|0,c[i>>2]|0)|0){h=c[i>>2]|0;c[i>>2]=c[j>>2];c[j>>2]=h;if(Ob[c[d>>2]&63](c[i>>2]|0,c[a>>2]|0)|0){h=c[a>>2]|0;c[a>>2]=c[i>>2];c[i>>2]=h;e=e+4|0;}else e=e+3|0;}else e=g;}else e=h;}}else {i=Ob[c[d>>2]&63](c[j>>2]|0,c[a>>2]|0)|0;e=Ob[c[d>>2]&63](c[f>>2]|0,c[j>>2]|0)|0;if(!i){if(!e){e=0;break}i=c[j>>2]|0;c[j>>2]=c[f>>2];c[f>>2]=i;if(!(Ob[c[d>>2]&63](c[j>>2]|0,c[a>>2]|0)|0)){e=1;break}e=c[a>>2]|0;c[a>>2]=c[j>>2];c[j>>2]=e;e=2;break}g=c[a>>2]|0;if(e){c[a>>2]=c[f>>2];c[f>>2]=g;e=1;break}c[a>>2]=c[j>>2];c[j>>2]=g;if(Ob[c[d>>2]&63](c[f>>2]|0,g)|0){e=c[j>>2]|0;c[j>>2]=c[f>>2];c[f>>2]=e;e=2;}else e=1;}while(0);if(Ob[c[d>>2]&63](c[a>>2]|0,c[j>>2]|0)|0)g=f;else {if((a|0)==(l|0)){e=40;break}g=l;while(1){if(Ob[c[d>>2]&63](c[g>>2]|0,c[j>>2]|0)|0)break;g=g+-4|0;if((a|0)==(g|0)){e=40;break b}}i=c[a>>2]|0;c[a>>2]=c[g>>2];c[g>>2]=i;e=e+1|0;}h=a+4|0;c:do if(h>>>0<g>>>0)while(1){while(1){i=h+4|0;if(Ob[c[d>>2]&63](c[h>>2]|0,c[j>>2]|0)|0)h=i;else break}do g=g+-4|0;while(!(Ob[c[d>>2]&63](c[g>>2]|0,c[j>>2]|0)|0));if(h>>>0>g>>>0){g=j;break c}n=c[h>>2]|0;c[h>>2]=c[g>>2];c[g>>2]=n;j=(j|0)==(h|0)?g:j;h=i;e=e+1|0;}else g=j;while(0);if((h|0)!=(g|0)?Ob[c[d>>2]&63](c[g>>2]|0,c[h>>2]|0)|0:0){n=c[h>>2]|0;c[h>>2]=c[g>>2];c[g>>2]=n;e=e+1|0;}if(!e){g=We(a,h,d)|0;e=h+4|0;if(We(e,b,d)|0){e=69;break}if(g){f=2;a=e;e=74;break}}n=h;if((n-a|0)>=(m-n|0)){e=73;break}Te(a,h,d);a=h+4|0;}d:do if((e|0)==40){e=a+4|0;if(!(Ob[c[d>>2]&63](c[a>>2]|0,c[f>>2]|0)|0)){if((e|0)==(f|0)){e=76;break a}while(1){if(Ob[c[d>>2]&63](c[a>>2]|0,c[e>>2]|0)|0)break;e=e+4|0;if((e|0)==(f|0)){e=76;break a}}n=c[e>>2]|0;c[e>>2]=c[f>>2];c[f>>2]=n;e=e+4|0;}if((e|0)==(f|0)){e=76;break a}while(1){while(1){g=e+4|0;if(Ob[c[d>>2]&63](c[a>>2]|0,c[e>>2]|0)|0)break;else e=g;}do f=f+-4|0;while(Ob[c[d>>2]&63](c[a>>2]|0,c[f>>2]|0)|0);if(e>>>0>=f>>>0){f=4;a=e;e=74;break d}n=c[e>>2]|0;c[e>>2]=c[f>>2];c[f>>2]=n;e=g;}}else if((e|0)==69){f=g?1:2;b=g?b:h;e=74;}else if((e|0)==73){e=0;Te(h+4|0,b,d);b=h;}while(0);if((e|0)==74)switch(f&7){case 2:case 4:case 0:break;default:{e=76;break a}}}if((e|0)==4){b=b+-4|0;if(!(Ob[c[d>>2]&63](c[b>>2]|0,c[a>>2]|0)|0))return;n=c[a>>2]|0;c[a>>2]=c[b>>2];c[b>>2]=n;return}else if((e|0)==6){g=a+4|0;b=b+-4|0;n=Ob[c[d>>2]&63](c[g>>2]|0,c[a>>2]|0)|0;e=Ob[c[d>>2]&63](c[b>>2]|0,c[g>>2]|0)|0;if(!n){if(!e)return;n=c[g>>2]|0;c[g>>2]=c[b>>2];c[b>>2]=n;if(!(Ob[c[d>>2]&63](c[g>>2]|0,c[a>>2]|0)|0))return;n=c[a>>2]|0;c[a>>2]=c[g>>2];c[g>>2]=n;return}f=c[a>>2]|0;if(e){c[a>>2]=c[b>>2];c[b>>2]=f;return}c[a>>2]=c[g>>2];c[g>>2]=f;if(!(Ob[c[d>>2]&63](c[b>>2]|0,f)|0))return;n=c[g>>2]|0;c[g>>2]=c[b>>2];c[b>>2]=n;return}else if((e|0)==14){Ue(a,a+4|0,a+8|0,b+-4|0,d)|0;return}else if((e|0)==15){e=a+4|0;f=a+8|0;g=a+12|0;b=b+-4|0;Ue(a,e,f,g,d)|0;if(!(Ob[c[d>>2]&63](c[b>>2]|0,c[g>>2]|0)|0))return;n=c[g>>2]|0;c[g>>2]=c[b>>2];c[b>>2]=n;if(!(Ob[c[d>>2]&63](c[g>>2]|0,c[f>>2]|0)|0))return;m=c[f>>2]|0;n=c[g>>2]|0;c[f>>2]=n;c[g>>2]=m;if(!(Ob[c[d>>2]&63](n,c[e>>2]|0)|0))return;m=c[e>>2]|0;n=c[f>>2]|0;c[e>>2]=n;c[f>>2]=m;if(!(Ob[c[d>>2]&63](n,c[a>>2]|0)|0))return;n=c[a>>2]|0;c[a>>2]=c[e>>2];c[e>>2]=n;return}else if((e|0)==21){Ve(a,b,d);return}else if((e|0)==76)return}function Ue(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;h=Ob[c[f>>2]&63](c[b>>2]|0,c[a>>2]|0)|0;g=Ob[c[f>>2]&63](c[d>>2]|0,c[b>>2]|0)|0;do if(h){h=c[a>>2]|0;if(g){c[a>>2]=c[d>>2];c[d>>2]=h;g=1;break}c[a>>2]=c[b>>2];c[b>>2]=h;if(Ob[c[f>>2]&63](c[d>>2]|0,h)|0){g=c[b>>2]|0;c[b>>2]=c[d>>2];c[d>>2]=g;g=2;}else g=1;}else if(g){h=c[b>>2]|0;c[b>>2]=c[d>>2];c[d>>2]=h;if(Ob[c[f>>2]&63](c[b>>2]|0,c[a>>2]|0)|0){g=c[a>>2]|0;c[a>>2]=c[b>>2];c[b>>2]=g;g=2;}else g=1;}else g=0;while(0);if(!(Ob[c[f>>2]&63](c[e>>2]|0,c[d>>2]|0)|0)){f=g;return f|0}h=c[d>>2]|0;c[d>>2]=c[e>>2];c[e>>2]=h;if(!(Ob[c[f>>2]&63](c[d>>2]|0,c[b>>2]|0)|0)){f=g+1|0;return f|0}e=c[b>>2]|0;c[b>>2]=c[d>>2];c[d>>2]=e;if(!(Ob[c[f>>2]&63](c[b>>2]|0,c[a>>2]|0)|0)){f=g+2|0;return f|0}f=c[a>>2]|0;c[a>>2]=c[b>>2];c[b>>2]=f;f=g+3|0;return f|0}
            function Ve(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;f=a+8|0;h=a+4|0;i=Ob[c[d>>2]&63](c[h>>2]|0,c[a>>2]|0)|0;e=Ob[c[d>>2]&63](c[f>>2]|0,c[h>>2]|0)|0;do if(i){g=c[a>>2]|0;if(e){c[a>>2]=c[f>>2];c[f>>2]=g;break}c[a>>2]=c[h>>2];c[h>>2]=g;if(Ob[c[d>>2]&63](c[f>>2]|0,g)|0){i=c[h>>2]|0;c[h>>2]=c[f>>2];c[f>>2]=i;}}else if(e?(g=c[h>>2]|0,i=c[f>>2]|0,c[h>>2]=i,c[f>>2]=g,Ob[c[d>>2]&63](i,c[a>>2]|0)|0):0){i=c[a>>2]|0;c[a>>2]=c[h>>2];c[h>>2]=i;}while(0);e=a+12|0;if((e|0)==(b|0))return;while(1){if(Ob[c[d>>2]&63](c[e>>2]|0,c[f>>2]|0)|0){i=c[e>>2]|0;h=i;g=e;while(1){c[g>>2]=c[f>>2];if((f|0)==(a|0)){f=a;break}g=f+-4|0;if(Ob[c[d>>2]&63](h,c[g>>2]|0)|0){j=f;f=g;g=j;}else break}c[f>>2]=i;}f=e+4|0;if((f|0)==(b|0))break;else {j=e;e=f;f=j;}}return}function We(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;switch(b-a>>2|0){case 2:{e=b+-4|0;if(!(Ob[c[d>>2]&63](c[e>>2]|0,c[a>>2]|0)|0)){d=1;return d|0}d=c[a>>2]|0;c[a>>2]=c[e>>2];c[e>>2]=d;d=1;return d|0}case 3:{h=a+4|0;e=b+-4|0;b=Ob[c[d>>2]&63](c[h>>2]|0,c[a>>2]|0)|0;f=Ob[c[d>>2]&63](c[e>>2]|0,c[h>>2]|0)|0;if(!b){if(!f){d=1;return d|0}b=c[h>>2]|0;c[h>>2]=c[e>>2];c[e>>2]=b;if(!(Ob[c[d>>2]&63](c[h>>2]|0,c[a>>2]|0)|0)){d=1;return d|0}d=c[a>>2]|0;c[a>>2]=c[h>>2];c[h>>2]=d;d=1;return d|0}g=c[a>>2]|0;if(f){c[a>>2]=c[e>>2];c[e>>2]=g;d=1;return d|0}c[a>>2]=c[h>>2];c[h>>2]=g;if(!(Ob[c[d>>2]&63](c[e>>2]|0,g)|0)){d=1;return d|0}d=c[h>>2]|0;c[h>>2]=c[e>>2];c[e>>2]=d;d=1;return d|0}case 4:{Ue(a,a+4|0,a+8|0,b+-4|0,d)|0;d=1;return d|0}case 5:{f=a+4|0;g=a+8|0;h=a+12|0;e=b+-4|0;Ue(a,f,g,h,d)|0;if(!(Ob[c[d>>2]&63](c[e>>2]|0,c[h>>2]|0)|0)){d=1;return d|0}b=c[h>>2]|0;c[h>>2]=c[e>>2];c[e>>2]=b;if(!(Ob[c[d>>2]&63](c[h>>2]|0,c[g>>2]|0)|0)){d=1;return d|0}k=c[g>>2]|0;b=c[h>>2]|0;c[g>>2]=b;c[h>>2]=k;if(!(Ob[c[d>>2]&63](b,c[f>>2]|0)|0)){d=1;return d|0}k=c[f>>2]|0;b=c[g>>2]|0;c[f>>2]=b;c[g>>2]=k;if(!(Ob[c[d>>2]&63](b,c[a>>2]|0)|0)){d=1;return d|0}d=c[a>>2]|0;c[a>>2]=c[f>>2];c[f>>2]=d;d=1;return d|0}case 1:case 0:{d=1;return d|0}default:{f=a+8|0;e=a+4|0;j=Ob[c[d>>2]&63](c[e>>2]|0,c[a>>2]|0)|0;g=Ob[c[d>>2]&63](c[f>>2]|0,c[e>>2]|0)|0;do if(j){h=c[a>>2]|0;if(g){c[a>>2]=c[f>>2];c[f>>2]=h;break}c[a>>2]=c[e>>2];c[e>>2]=h;if(Ob[c[d>>2]&63](c[f>>2]|0,h)|0){j=c[e>>2]|0;c[e>>2]=c[f>>2];c[f>>2]=j;}}else if(g?(i=c[e>>2]|0,j=c[f>>2]|0,c[e>>2]=j,c[f>>2]=i,Ob[c[d>>2]&63](j,c[a>>2]|0)|0):0){j=c[a>>2]|0;c[a>>2]=c[e>>2];c[e>>2]=j;}while(0);e=a+12|0;if((e|0)==(b|0)){d=1;return d|0}j=e;e=0;while(1){if(Ob[c[d>>2]&63](c[j>>2]|0,c[f>>2]|0)|0){i=c[j>>2]|0;h=i;g=j;while(1){c[g>>2]=c[f>>2];if((f|0)==(a|0)){f=a;break}g=f+-4|0;if(Ob[c[d>>2]&63](h,c[g>>2]|0)|0){l=f;f=g;g=l;}else break}c[f>>2]=i;e=e+1|0;if((e|0)==8)break}f=j+4|0;if((f|0)==(b|0)){e=1;k=35;break}else {l=j;j=f;f=l;}}if((k|0)==35)return e|0;l=(j+4|0)==(b|0);return l|0}}return 0}function Xe(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;q=Eb;Eb=Eb+32|0;l=q+20|0;k=q+16|0;h=q+12|0;j=q+8|0;n=q+4|0;o=q;switch(d|0){case 1:case 0:{a=c[a>>2]|0;Eb=q;return a|0}case 2:{h=c[c[b>>2]>>2]|0;c[b>>2]=h;f=c[a>>2]|0;p=h+8|0;o=c[p+4>>2]|0;a=f+8|0;b=c[a+4>>2]|0;g=h;if(!((o|0)<(b|0)|((o|0)==(b|0)?(c[p>>2]|0)>>>0<(c[a>>2]|0)>>>0:0))){a=f;Eb=q;return a|0}a=g+4|0;p=c[g>>2]|0;c[p+4>>2]=c[a>>2];c[c[a>>2]>>2]=p;p=c[f>>2]|0;c[p+4>>2]=g;c[h>>2]=p;c[f>>2]=g;c[a>>2]=f;a=g;Eb=q;return a|0}default:{m=d>>>1;i=c[a>>2]|0;f=i;if(m){g=m;while(1){f=c[f+4>>2]|0;if((g|0)>1)g=g+-1|0;else break}}g=f;c[h>>2]=i;c[j>>2]=g;c[k>>2]=c[h>>2];c[l>>2]=c[j>>2];p=Xe(k,l,m,e)|0;c[a>>2]=p;c[n>>2]=g;g=c[b>>2]|0;c[o>>2]=g;c[k>>2]=c[n>>2];c[l>>2]=c[o>>2];j=Xe(k,l,d-m|0,e)|0;b=j+8|0;o=c[b+4>>2]|0;i=p+8|0;h=c[i>>2]|0;i=c[i+4>>2]|0;n=g;if((o|0)<(i|0)|((o|0)==(i|0)?(c[b>>2]|0)>>>0<h>>>0:0)){g=c[j+4>>2]|0;f=g;a:do if((n|0)==(f|0))f=n;else while(1){b=g+8|0;o=c[b+4>>2]|0;if(!((o|0)<(i|0)|((o|0)==(i|0)?(c[b>>2]|0)>>>0<h>>>0:0)))break a;g=c[f+4>>2]|0;f=g;if((n|0)==(f|0)){f=n;break}}while(0);b=c[f>>2]|0;f=b+4|0;h=c[j>>2]|0;c[h+4>>2]=c[f>>2];c[c[f>>2]>>2]=h;h=c[p+4>>2]|0;o=c[p>>2]|0;c[o+4>>2]=j;c[j>>2]=o;c[p>>2]=b;c[f>>2]=p;f=j;}else {f=p;g=j;h=c[p+4>>2]|0;}c[a>>2]=h;j=h;i=g;if((j|0)==(i|0)){a=f;Eb=q;return a|0}k=g;while(1){m=k;if((n|0)==(m|0)){g=26;break}p=k+8|0;b=c[p+4>>2]|0;e=h+8|0;d=c[e>>2]|0;e=c[e+4>>2]|0;if((b|0)<(e|0)|((b|0)==(e|0)?(c[p>>2]|0)>>>0<d>>>0:0)){h=c[m+4>>2]|0;l=h;b:do if((n|0)==(l|0))l=n;else while(1){p=h+8|0;b=c[p+4>>2]|0;if(!((b|0)<(e|0)|((b|0)==(e|0)?(c[p>>2]|0)>>>0<d>>>0:0)))break b;h=c[l+4>>2]|0;l=h;if((n|0)==(l|0)){l=n;break}}while(0);o=c[l>>2]|0;b=o+4|0;p=c[m>>2]|0;c[p+4>>2]=c[b>>2];c[c[b>>2]>>2]=p;p=c[j+4>>2]|0;e=c[j>>2]|0;c[e+4>>2]=m;c[k>>2]=e;c[j>>2]=o;c[b>>2]=j;k=h;g=(i|0)==(m|0)?h:g;h=p;}else h=c[j+4>>2]|0;c[a>>2]=h;j=h;i=g;if((j|0)==(i|0)){g=26;break}}if((g|0)==26){Eb=q;return f|0}}}return 0}function Ye(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>2;d=g+1|0;if(d>>>0>1073741823)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>1;h=f>>2>>>0<536870911?(h>>>0<d>>>0?d:h):1073741823;do if(h)if(h>>>0>1073741823){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else {f=Zj(h<<2)|0;e=f;break}else {e=0;f=0;}while(0);d=e+(g<<2)|0;c[d>>2]=c[b>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+4;c[l>>2]=e+(h<<2);if(!j)return;$j(j);return}function Ze(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;k=d;h=b;g=k-h|0;f=g>>4;i=a+8|0;e=c[i>>2]|0;l=c[a>>2]|0;j=l;if(f>>>0<=e-l>>4>>>0){g=a+4|0;a=(c[g>>2]|0)-l>>4;f=f>>>0>a>>>0;a=f?b+(a<<4)|0:d;d=a;e=d-h|0;if(e|0)bx(l|0,b|0,e|0)|0;if(!f){c[g>>2]=j+(e>>4<<4);return}e=k-d|0;if((e|0)<=0)return;ax(c[g>>2]|0,a|0,e|0)|0;c[g>>2]=(c[g>>2]|0)+(e>>>4<<4);return}if(l){e=a+4|0;c[e>>2]=l;$j(l);c[i>>2]=0;c[e>>2]=0;c[a>>2]=0;e=0;}if(f>>>0>268435455)gk();l=e>>3;f=e>>4>>>0<134217727?(l>>>0<f>>>0?f:l):268435455;if(f>>>0>268435455)gk();e=Zj(f<<4)|0;d=a+4|0;c[d>>2]=e;c[a>>2]=e;c[i>>2]=e+(f<<4);if((g|0)<=0)return;ax(e|0,b|0,g|0)|0;c[d>>2]=e+(g>>>4<<4);return}function _e(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>4;d=g+1|0;if(d>>>0>268435455)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>3;h=f>>4>>>0<134217727?(h>>>0<d>>>0?d:h):268435455;do if(h)if(h>>>0>268435455){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else {f=Zj(h<<4)|0;e=f;break}else {e=0;f=0;}while(0);d=e+(g<<4)|0;c[d>>2]=c[b>>2];c[d+4>>2]=c[b+4>>2];c[d+8>>2]=c[b+8>>2];c[d+12>>2]=c[b+12>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+16;c[l>>2]=e+(h<<4);if(!j)return;$j(j);return}function $e(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>4;d=g+1|0;if(d>>>0>268435455)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>3;h=f>>4>>>0<134217727?(h>>>0<d>>>0?d:h):268435455;do if(h)if(h>>>0>268435455){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else {f=Zj(h<<4)|0;e=f;break}else {e=0;f=0;}while(0);d=e+(g<<4)|0;c[d>>2]=c[b>>2];c[d+4>>2]=c[b+4>>2];c[d+8>>2]=c[b+8>>2];c[d+12>>2]=c[b+12>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+16;c[l>>2]=e+(h<<4);if(!j)return;$j(j);return}function af(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;k=a+8|0;e=c[k>>2]|0;l=a+4|0;d=c[l>>2]|0;if(e-d>>4>>>0>=b>>>0){do{c[d>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;d=(c[l>>2]|0)+16|0;c[l>>2]=d;b=b+-1|0;}while((b|0)!=0);return}j=c[a>>2]|0;g=d-j|0;h=g>>4;i=h+b|0;if(i>>>0>268435455)gk();e=e-j|0;f=e>>3;f=e>>4>>>0<134217727?(f>>>0<i>>>0?i:f):268435455;do if(f)if(f>>>0>268435455){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else {e=Zj(f<<4)|0;d=e;break}else {d=0;e=0;}while(0);cx(d+(h<<4)|0,0,b<<4|0)|0;if((g|0)>0)ax(e|0,j|0,g|0)|0;c[a>>2]=d;c[l>>2]=d+(i<<4);c[k>>2]=d+(f<<4);if(!j)return;$j(j);return}function bf(a,b,c){a=a|0;b=b|0;c=c|0;Xb[a&127](b,c);return}function cf(a,b,c){a=a|0;b=b|0;c=c|0;Xb[a&127](b,c);return}function df(a,b){a=a|0;b=b|0;var d=0,e=0;d=Eb;Eb=Eb+16|0;e=d;Xb[a&127](e,b);sa(c[e>>2]|0);b=c[e>>2]|0;ra(b|0);Eb=d;return b|0}function ef(a,b){a=a|0;b=b|0;var d=0,e=0;d=Eb;Eb=Eb+16|0;e=d;Xb[a&127](e,b);sa(c[e>>2]|0);b=c[e>>2]|0;ra(b|0);Eb=d;return b|0}function ff(a){return 1216}function gf(a){a=a|0;if(!a)return;$j(a);return}function hf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0.0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(!(e&1)){e=d;f=+Ib[e&7](a);return +f}else {e=c[(c[a>>2]|0)+d>>2]|0;f=+Ib[e&7](a);return +f}}function jf(a,b,d){a=a|0;b=b|0;d=+d;var e=0,f=0;e=c[a>>2]|0;f=c[a+4>>2]|0;a=b+(f>>1)|0;if(!(f&1)){f=e;Vb[f&15](a,d);return}else {f=c[(c[a>>2]|0)+e>>2]|0;Vb[f&15](a,d);return}}function kf(a,b,d){a=a|0;b=+b;d=+d;var e=0,f=0;e=Eb;Eb=Eb+16|0;f=e;Wb[a&1](f,b,d);a=Zj(16)|0;c[a>>2]=c[f>>2];c[a+4>>2]=c[f+4>>2];c[a+8>>2]=c[f+8>>2];c[a+12>>2]=c[f+12>>2];Eb=e;return a|0}function lf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=a+4|0;f=c[a>>2]|0;g=(c[e>>2]|0)-f>>4;if(g>>>0<b>>>0){of(a,b-g|0,d);return}if(g>>>0<=b>>>0)return;c[e>>2]=f+(b<<4);return}function mf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g;f=c[b>>2]|0;if((c[b+4>>2]|0)-f>>4>>>0<=d>>>0){f=1;c[a>>2]=f;Eb=g;return}d=f+(d<<4)|0;f=Zj(16)|0;c[f>>2]=c[d>>2];c[f+4>>2]=c[d+4>>2];c[f+8>>2]=c[d+8>>2];c[f+12>>2]=c[d+12>>2];c[e>>2]=f;f=ua(1216,e|0)|0;c[a>>2]=f;Eb=g;return}function nf(a,b,d){a=a|0;b=b|0;d=d|0;b=(c[a>>2]|0)+(b<<4)|0;c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];return 1}function of(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;k=a+8|0;g=c[k>>2]|0;l=a+4|0;e=c[l>>2]|0;if(g-e>>4>>>0>=b>>>0){do{c[e>>2]=c[d>>2];c[e+4>>2]=c[d+4>>2];c[e+8>>2]=c[d+8>>2];c[e+12>>2]=c[d+12>>2];e=(c[l>>2]|0)+16|0;c[l>>2]=e;b=b+-1|0;}while((b|0)!=0);return}f=c[a>>2]|0;h=e-f>>4;j=h+b|0;if(j>>>0>268435455)gk();i=g-f|0;e=i>>3;e=i>>4>>>0<134217727?(e>>>0<j>>>0?j:e):268435455;do if(e)if(e>>>0>268435455){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else {i=Zj(e<<4)|0;break}else i=0;while(0);g=i+(h<<4)|0;h=i+(e<<4)|0;e=g;while(1){c[e>>2]=c[d>>2];c[e+4>>2]=c[d+4>>2];c[e+8>>2]=c[d+8>>2];c[e+12>>2]=c[d+12>>2];b=b+-1|0;if(!b)break;else e=e+16|0;}b=c[a>>2]|0;f=(c[l>>2]|0)-b|0;e=g+(0-(f>>4)<<4)|0;if((f|0)>0)ax(e|0,b|0,f|0)|0;c[a>>2]=e;c[l>>2]=i+(j<<4);c[k>>2]=h;if(!b)return;$j(b);return}function pf(a){return 1112}function qf(a){a=a|0;var b=0;if(!a)return;b=c[a>>2]|0;if(b|0){c[a+4>>2]=b;$j(b);}$j(a);return}function rf(){var a=0;a=Zj(12)|0;c[a>>2]=0;c[a+4>>2]=0;c[a+8>>2]=0;return a|0}function sf(a){a=a|0;return Kb[a&7]()|0}function tf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=c[a>>2]|0;f=c[a+4>>2]|0;a=b+(f>>1)|0;if(!(f&1)){f=e;Xb[f&127](a,d);return}else {f=c[(c[a>>2]|0)+e>>2]|0;Xb[f&127](a,d);return}}function uf(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;f=c[a>>2]|0;g=c[a+4>>2]|0;a=b+(g>>1)|0;if(!(g&1)){g=f;Zb[g&31](a,d,e);return}else {g=c[(c[a>>2]|0)+f>>2]|0;Zb[g&31](a,d,e);return}}function vf(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function wf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=Eb;Eb=Eb+16|0;f=e;Zb[c[a>>2]&31](f,b,d);sa(c[f>>2]|0);d=c[f>>2]|0;ra(d|0);Eb=e;return d|0}function xf(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;return Pb[c[a>>2]&15](b,d,e)|0}function yf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0;h=a+4|0;e=c[h>>2]|0;f=c[a>>2]|0;g=(e-f|0)/12|0;if(g>>>0<b>>>0){Bf(a,b-g|0,d);return}if(g>>>0<=b>>>0)return;d=f+(b*12|0)|0;if((d|0)!=(e|0))do{a=e;e=e+-12|0;b=c[e>>2]|0;if(b|0){c[a+-8>>2]=b;$j(b);}}while((e|0)!=(d|0));c[h>>2]=d;return}function zf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g;f=c[b>>2]|0;if((((c[b+4>>2]|0)-f|0)/12|0)>>>0<=d>>>0){f=1;c[a>>2]=f;Eb=g;return}Kf(e,f+(d*12|0)|0);f=ua(1112,e|0)|0;c[a>>2]=f;Eb=g;return}function Af(a,b,d){a=a|0;b=b|0;d=d|0;a=(c[a>>2]|0)+(b*12|0)|0;if((a|0)==(d|0))return 1;Ze(a,c[d>>2]|0,c[d+4>>2]|0);return 1}function Bf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;s=a+8|0;n=c[s>>2]|0;t=a+4|0;m=c[t>>2]|0;if(((n-m|0)/12|0)>>>0>=b>>>0){l=d+4|0;k=b;e=m;while(1){c[e>>2]=0;j=e+4|0;c[j>>2]=0;g=e+8|0;c[g>>2]=0;f=(c[l>>2]|0)-(c[d>>2]|0)|0;h=f>>4;if(f|0){if(h>>>0>268435455){q=5;break}i=Zj(f)|0;c[j>>2]=i;c[e>>2]=i;c[g>>2]=i+(h<<4);e=c[d>>2]|0;f=(c[l>>2]|0)-e|0;if((f|0)>0){ax(i|0,e|0,f|0)|0;c[j>>2]=i+(f>>>4<<4);}}e=(c[t>>2]|0)+12|0;c[t>>2]=e;k=k+-1|0;if(!k){q=34;break}}if((q|0)==5)gk();else if((q|0)==34)return}f=c[a>>2]|0;h=(m-f|0)/12|0;e=h+b|0;if(e>>>0>357913941)gk();p=(n-f|0)/12|0;g=p<<1;g=p>>>0<178956970?(g>>>0<e>>>0?e:g):357913941;do if(g)if(g>>>0>357913941){t=S(8)|0;dk(t,8694);c[t>>2]=7328;V(t|0,3264,87);}else {f=Zj(g*12|0)|0;break}else f=0;while(0);e=f+(h*12|0)|0;o=e;p=f+(g*12|0)|0;n=d+4|0;k=b;l=o;g=e;while(1){c[g>>2]=0;m=g+4|0;c[m>>2]=0;h=g+8|0;c[h>>2]=0;f=(c[n>>2]|0)-(c[d>>2]|0)|0;i=f>>4;if(f|0){if(i>>>0>268435455){q=18;break}j=Zj(f)|0;c[m>>2]=j;c[g>>2]=j;c[h>>2]=j+(i<<4);f=c[d>>2]|0;g=(c[n>>2]|0)-f|0;if((g|0)>0){ax(j|0,f|0,g|0)|0;c[m>>2]=j+(g>>>4<<4);}}r=l+12|0;k=k+-1|0;if(!k)break;else {l=r;g=r;}}if((q|0)==18)gk();h=r;g=c[a>>2]|0;f=c[t>>2]|0;if((f|0)==(g|0)){f=o;i=g;e=g;}else {do{q=e;e=e+-12|0;r=f;f=f+-12|0;c[e>>2]=0;b=q+-8|0;c[b>>2]=0;q=q+-4|0;c[q>>2]=0;c[e>>2]=c[f>>2];d=r+-8|0;c[b>>2]=c[d>>2];r=r+-4|0;c[q>>2]=c[r>>2];c[r>>2]=0;c[d>>2]=0;c[f>>2]=0;}while((f|0)!=(g|0));f=e;i=c[a>>2]|0;e=c[t>>2]|0;}c[a>>2]=f;c[t>>2]=h;c[s>>2]=p;h=i;if((e|0)!=(h|0))do{f=e;e=e+-12|0;g=c[e>>2]|0;if(g|0){c[f+-8>>2]=g;$j(g);}}while((e|0)!=(h|0));if(!i)return;$j(i);return}function Cf(a){return 1160}function Df(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;if(!a)return;f=c[a>>2]|0;if(f|0){g=a+4|0;b=c[g>>2]|0;if((b|0)==(f|0))b=f;else {do{d=b;b=b+-12|0;e=c[b>>2]|0;if(e|0){c[d+-8>>2]=e;$j(e);}}while((b|0)!=(f|0));b=c[a>>2]|0;}c[g>>2]=f;$j(b);}$j(a);return}function Ef(){var a=0;a=Zj(12)|0;c[a>>2]=0;c[a+4>>2]=0;c[a+8>>2]=0;return a|0}function Ff(a){a=a|0;return Kb[a&7]()|0}function Gf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=c[a>>2]|0;f=c[a+4>>2]|0;a=b+(f>>1)|0;if(!(f&1)){f=e;Xb[f&127](a,d);return}else {f=c[(c[a>>2]|0)+e>>2]|0;Xb[f&127](a,d);return}}function Hf(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;f=c[a>>2]|0;g=c[a+4>>2]|0;a=b+(g>>1)|0;if(!(g&1)){g=f;Zb[g&31](a,d,e);return}else {g=c[(c[a>>2]|0)+f>>2]|0;Zb[g&31](a,d,e);return}}function If(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function Jf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=Eb;Eb=Eb+16|0;f=e;Zb[c[a>>2]&31](f,b,d);sa(c[f>>2]|0);d=c[f>>2]|0;ra(d|0);Eb=e;return d|0}function Kf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;f=Zj(12)|0;c[f>>2]=0;g=f+4|0;c[g>>2]=0;h=f+8|0;c[h>>2]=0;i=c[b>>2]|0;d=(c[b+4>>2]|0)-i|0;e=d>>4;if(!d){c[a>>2]=f;return}if(e>>>0>268435455)gk();b=Zj(d)|0;c[g>>2]=b;c[f>>2]=b;c[h>>2]=b+(e<<4);if((d|0)<=0){c[a>>2]=f;return}ax(b|0,i|0,d|0)|0;c[g>>2]=b+(d>>>4<<4);c[a>>2]=f;return}function Lf(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;return Pb[c[a>>2]&15](b,d,e)|0}function Mf(a){a=a|0;return c[(c[a>>2]|0)+-4>>2]|0}function Nf(a){a=a|0;if(!a)return;Ub[c[(c[a>>2]|0)+4>>2]&127](a);return}function Of(){var b=0,d=0;b=Zj(48)|0;c[b>>2]=3512;d=b+4|0;c[d>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;c[d+16>>2]=0;c[d+20>>2]=0;c[d+24>>2]=0;c[d+28>>2]=0;a[d+32>>0]=0;return b|0}function Pf(a){a=a|0;return Kb[a&7]()|0}function Qf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;a=b+(c[a>>2]|0)|0;e=Zj(12)|0;c[e>>2]=0;f=e+4|0;c[f>>2]=0;g=e+8|0;c[g>>2]=0;h=c[a>>2]|0;a=(c[a+4>>2]|0)-h|0;b=a>>4;if(!a)return e|0;if(b>>>0>268435455)gk();d=Zj(a)|0;c[f>>2]=d;c[e>>2]=d;c[g>>2]=d+(b<<4);if((a|0)<=0)return e|0;ax(d|0,h|0,a|0)|0;c[f>>2]=d+(a>>>4<<4);return e|0}function Rf(a,b,d){a=a|0;b=b|0;d=d|0;a=b+(c[a>>2]|0)|0;if((a|0)==(d|0))return;Ze(a,c[d>>2]|0,c[d+4>>2]|0);return}function Sf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;a=b+(c[a>>2]|0)|0;e=Zj(12)|0;c[e>>2]=0;f=e+4|0;c[f>>2]=0;g=e+8|0;c[g>>2]=0;h=c[a>>2]|0;a=(c[a+4>>2]|0)-h|0;b=a>>2;if(!a)return e|0;if(b>>>0>1073741823)gk();d=Zj(a)|0;c[f>>2]=d;c[e>>2]=d;c[g>>2]=d+(b<<2);if((a|0)<=0)return e|0;ax(d|0,h|0,a|0)|0;c[f>>2]=d+(a>>>2<<2);return e|0}function Tf(a,b,d){a=a|0;b=b|0;d=d|0;a=b+(c[a>>2]|0)|0;if((a|0)==(d|0))return;Uf(a,c[d>>2]|0,c[d+4>>2]|0);return}function Uf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;k=d;h=b;g=k-h|0;f=g>>2;i=a+8|0;e=c[i>>2]|0;l=c[a>>2]|0;j=l;if(f>>>0<=e-l>>2>>>0){g=a+4|0;a=(c[g>>2]|0)-l>>2;f=f>>>0>a>>>0;a=f?b+(a<<2)|0:d;d=a;e=d-h|0;if(e|0)bx(l|0,b|0,e|0)|0;if(!f){c[g>>2]=j+(e>>2<<2);return}e=k-d|0;if((e|0)<=0)return;ax(c[g>>2]|0,a|0,e|0)|0;c[g>>2]=(c[g>>2]|0)+(e>>>2<<2);return}if(l){e=a+4|0;c[e>>2]=l;$j(l);c[i>>2]=0;c[e>>2]=0;c[a>>2]=0;e=0;}if(f>>>0>1073741823)gk();l=e>>1;f=e>>2>>>0<536870911?(l>>>0<f>>>0?f:l):1073741823;if(f>>>0>1073741823)gk();e=Zj(f<<2)|0;d=a+4|0;c[d>>2]=e;c[a>>2]=e;c[i>>2]=e+(f<<2);if((g|0)<=0)return;ax(e|0,b|0,g|0)|0;c[d>>2]=e+(g>>>2<<2);return}function Vf(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function Wf(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function Xf(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function Yf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=a+4|0;f=c[a>>2]|0;g=(c[e>>2]|0)-f>>2;if(g>>>0<b>>>0){$f(a,b-g|0,d);return}if(g>>>0<=b>>>0)return;c[e>>2]=f+(b<<2);return}function Zf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g;f=c[b>>2]|0;if((c[b+4>>2]|0)-f>>2>>>0<=d>>>0){f=1;c[a>>2]=f;Eb=g;return}c[e>>2]=c[f+(d<<2)>>2];f=ua(1344,e|0)|0;c[a>>2]=f;Eb=g;return}function _f(a,b,d){a=a|0;b=b|0;d=d|0;c[(c[a>>2]|0)+(b<<2)>>2]=c[d>>2];return 1}function $f(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;k=a+8|0;g=c[k>>2]|0;l=a+4|0;e=c[l>>2]|0;if(g-e>>2>>>0>=b>>>0){do{c[e>>2]=c[d>>2];e=(c[l>>2]|0)+4|0;c[l>>2]=e;b=b+-1|0;}while((b|0)!=0);return}f=c[a>>2]|0;h=e-f>>2;j=h+b|0;if(j>>>0>1073741823)gk();i=g-f|0;e=i>>1;e=i>>2>>>0<536870911?(e>>>0<j>>>0?j:e):1073741823;do if(e)if(e>>>0>1073741823){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else {i=Zj(e<<2)|0;break}else i=0;while(0);g=i+(h<<2)|0;h=i+(e<<2)|0;e=g;while(1){c[e>>2]=c[d>>2];b=b+-1|0;if(!b)break;else e=e+4|0;}b=c[a>>2]|0;f=(c[l>>2]|0)-b|0;e=g+(0-(f>>2)<<2)|0;if((f|0)>0)ax(e|0,b|0,f|0)|0;c[a>>2]=e;c[l>>2]=i+(j<<2);c[k>>2]=h;if(!b)return;$j(b);return}function ag(a){return 1400}function bg(a){a=a|0;var b=0;if(!a)return;b=c[a>>2]|0;if(b|0){c[a+4>>2]=b;$j(b);}$j(a);return}function cg(){var a=0;a=Zj(12)|0;c[a>>2]=0;c[a+4>>2]=0;c[a+8>>2]=0;return a|0}function dg(a){a=a|0;return Kb[a&7]()|0}function eg(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0;g=Eb;Eb=Eb+16|0;f=g;e=c[a>>2]|0;h=c[a+4>>2]|0;a=b+(h>>1)|0;if(h&1)e=c[(c[a>>2]|0)+e>>2]|0;c[f>>2]=d;Xb[e&127](a,f);Eb=g;return}function fg(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;h=Eb;Eb=Eb+16|0;g=h;f=c[a>>2]|0;i=c[a+4>>2]|0;a=b+(i>>1)|0;if(i&1)f=c[(c[a>>2]|0)+f>>2]|0;c[g>>2]=e;Zb[f&31](a,d,g);Eb=h;return}function gg(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function hg(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=Eb;Eb=Eb+16|0;f=e;Zb[c[a>>2]&31](f,b,d);sa(c[f>>2]|0);d=c[f>>2]|0;ra(d|0);Eb=e;return d|0}function ig(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;f=Eb;Eb=Eb+16|0;g=f;a=c[a>>2]|0;c[g>>2]=e;e=Pb[a&15](b,d,g)|0;Eb=f;return e|0}function jg(a){a=a|0;return c[(c[a>>2]|0)+-4>>2]|0}function kg(a){a=a|0;if(!a)return;Ub[c[(c[a>>2]|0)+4>>2]&127](a);return}function lg(a){a=a|0;return a|0}function mg(a){a=a|0;return a|0}function ng(){var a=0,b=0,d=0;a=Zj(60)|0;b=a;d=b+48|0;do{c[b>>2]=0;b=b+4|0;}while((b|0)<(d|0));c[a>>2]=3800;c[a+48>>2]=0;c[a+52>>2]=0;c[a+56>>2]=0;return a|0}function og(a){a=a|0;return Kb[a&7]()|0}function pg(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0;c[a>>2]=3800;h=a+48|0;i=a+52|0;f=c[i>>2]|0;b=c[h>>2]|0;d=b;if((f|0)!=(b|0)){g=0;do{e=c[b+(g<<2)>>2]|0;if(e){Ub[c[(c[e>>2]|0)+4>>2]&127](e);b=c[h>>2]|0;f=c[i>>2]|0;d=b;}g=g+1|0;e=f-b|0;}while(g>>>0<e>>2>>>0);if(e)c[i>>2]=b;}e=a+20|0;h=c[a+16>>2]|0;b=h;if((c[e>>2]|0)!=(h|0))c[e>>2]=b;if(d){c[i>>2]=d;$j(d);b=c[a+16>>2]|0;}c[a>>2]=3512;if(b|0){c[e>>2]=b;$j(b);}b=c[a+4>>2]|0;if(!b)return;c[a+8>>2]=b;$j(b);return}function qg(a){a=a|0;pg(a);$j(a);return}function rg(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function sg(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(!(e&1)){e=d;Ub[e&127](a);return}else {e=c[(c[a>>2]|0)+d>>2]|0;Ub[e&127](a);return}}function tg(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function ug(a,b){a=a|0;b=b|0;return Lb[a&63](b)|0}function vg(a,b){a=a|0;b=b|0;return +(+Ib[a&7](b))}function wg(a,b,c){a=a|0;b=b|0;c=c|0;return Ob[a&63](b,c)|0}function xg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;Zb[a&31](b,c,d);return}function yg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;Zb[a&31](b,c,d);return}function zg(a,b,c){a=a|0;b=b|0;c=c|0;Xb[a&127](b,c);return}function Ag(a,b,c,d){a=a|0;b=b|0;c=c|0;d=+d;Yb[a&15](b,c,d);return}function Bg(a,b,c){a=a|0;b=b|0;c=+c;Vb[a&15](b,c);return}function Cg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=+d;Yb[a&15](b,c,d);return}function Dg(a,b,c){a=a|0;b=b|0;c=+c;Vb[a&15](b,c);return}function Eg(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;$b[a&15](b,c,d,e);return}function Fg(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;$b[a&15](b,c,d,e);return}function Gg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;Zb[a&31](b,c,d);return}function Hg(a,b,c){a=a|0;b=b|0;c=c|0;Xb[a&127](b,c);return}function Ig(a,b,c){a=a|0;b=b|0;c=c|0;Xb[a&127](b,c);return}function Jg(a,b){a=a|0;b=b|0;Ub[a&127](b);return}function Kg(a,b){a=a|0;b=b|0;Ub[a&127](b);return}function Lg(a){return 1504}function Mg(a){a=a|0;if(!a)return;$j(a);return}function Ng(a,b){a=a|0;b=b|0;var d=0,e=0,f=0.0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(!(e&1)){e=d;f=+Ib[e&7](a);return +f}else {e=c[(c[a>>2]|0)+d>>2]|0;f=+Ib[e&7](a);return +f}}function Og(a,b,d){a=a|0;b=b|0;d=+d;var e=0,f=0;e=c[a>>2]|0;f=c[a+4>>2]|0;a=b+(f>>1)|0;if(!(f&1)){f=e;Vb[f&15](a,d);return}else {f=c[(c[a>>2]|0)+e>>2]|0;Vb[f&15](a,d);return}}function Pg(a){a=a|0;return c[(c[a>>2]|0)+-4>>2]|0}function Qg(a){a=a|0;if(!a)return;Ub[c[(c[a>>2]|0)+4>>2]&127](a);return}function Rg(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=c[a>>2]|0;h=c[a+4>>2]|0;a=b+(h>>1)|0;if(h&1)g=c[(c[a>>2]|0)+g>>2]|0;return Qb[g&15](a,d,e,f)|0}function Sg(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=c[a>>2]|0;h=c[a+4>>2]|0;a=b+(h>>1)|0;if(h&1)g=c[(c[a>>2]|0)+g>>2]|0;return Qb[g&15](a,d,e,f)|0}function Tg(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(!(e&1)){e=d;Ub[e&127](a);return}else {e=c[(c[a>>2]|0)+d>>2]|0;Ub[e&127](a);return}}function Ug(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;f=Eb;Eb=Eb+32|0;e=f;d=c[a>>2]|0;g=c[a+4>>2]|0;a=b+(g>>1)|0;if(g&1)d=c[(c[a>>2]|0)+d>>2]|0;Xb[d&127](e,a);g=Zj(32)|0;c[g>>2]=c[e>>2];c[g+4>>2]=c[e+4>>2];c[g+8>>2]=c[e+8>>2];c[g+12>>2]=c[e+12>>2];c[g+16>>2]=c[e+16>>2];c[g+20>>2]=c[e+20>>2];c[g+24>>2]=c[e+24>>2];c[g+28>>2]=c[e+28>>2];Eb=f;return g|0}function Vg(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function Wg(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=c[a>>2]|0;f=c[a+4>>2]|0;a=b+(f>>1)|0;if(!(f&1)){f=e;Xb[f&127](a,d);return}else {f=c[(c[a>>2]|0)+e>>2]|0;Xb[f&127](a,d);return}}function Xg(a){a=a|0;return c[(c[a>>2]|0)+-4>>2]|0}function Yg(a){a=a|0;if(!a)return;Ub[c[(c[a>>2]|0)+4>>2]&127](a);return}function Zg(a){a=a|0;return a|0}function _g(a){a=a|0;return a|0}function $g(b){b=b|0;var d=0,e=0,f=0,g=0;g=Zj(144)|0;d=c[b>>2]|0;c[g+24>>2]=0;c[g+28>>2]=0;c[g+32>>2]=0;c[g+40>>2]=0;c[g+44>>2]=0;c[g+48>>2]=0;c[g+56>>2]=0;c[g+60>>2]=0;c[g+64>>2]=0;b=g+4|0;c[b>>2]=0;c[b+4>>2]=0;c[b+8>>2]=0;c[b+12>>2]=0;c[g>>2]=3556;b=g+112|0;e=g+72|0;f=e+36|0;do{c[e>>2]=0;e=e+4|0;}while((e|0)<(f|0));c[b>>2]=b;c[g+116>>2]=b;c[g+120>>2]=0;a[g+128>>0]=0;a[g+20>>0]=0;a[g+140>>0]=d&1;a[g+142>>0]=d>>>1&1;a[g+36>>0]=d>>>2&1;a[g+37>>0]=0;return g|0}function ah(a,b){a=a|0;b=b|0;var d=0,e=0;d=Eb;Eb=Eb+16|0;e=d;c[e>>2]=b;b=Lb[a&63](e)|0;Eb=d;return b|0}function bh(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=c[a>>2]|0;h=c[a+4>>2]|0;a=b+(h>>1)|0;if(h&1)g=c[(c[a>>2]|0)+g>>2]|0;return Qb[g&15](a,d,e,f)|0}function ch(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0;h=c[a>>2]|0;i=c[a+4>>2]|0;a=b+(i>>1)|0;if(i&1)h=c[(c[a>>2]|0)+h>>2]|0;return Rb[h&7](a,d,e,f,g)|0}function dh(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=c[a>>2]|0;h=c[a+4>>2]|0;a=b+(h>>1)|0;if(h&1)g=c[(c[a>>2]|0)+g>>2]|0;return Qb[g&15](a,d,e,f)|0}function eh(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0;h=c[a>>2]|0;i=c[a+4>>2]|0;a=b+(i>>1)|0;if(i&1)h=c[(c[a>>2]|0)+h>>2]|0;return Rb[h&7](a,d,e,f,g)|0}function fh(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function gh(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=c[a>>2]|0;f=c[a+4>>2]|0;a=b+(f>>1)|0;if(!(f&1)){f=e;Xb[f&127](a,d);return}else {f=c[(c[a>>2]|0)+e>>2]|0;Xb[f&127](a,d);return}}function hh(a){return 1608}function ih(a){a=a|0;if(!a)return;vd(a);$j(a);return}function jh(b,d){b=b|0;d=d|0;var e=0.0,f=0,h=0,i=0.0,j=0;j=Zj(176)|0;i=+g[b>>3];e=+g[d>>3];b=j+112|0;d=j+128|0;f=j+16|0;h=f+48|0;do{c[f>>2]=0;f=f+4|0;}while((f|0)<(h|0));h=j+120|0;c[h>>2]=0;c[h+4>>2]=0;c[d>>2]=3512;h=j+132|0;c[h>>2]=0;c[h+4>>2]=0;c[h+8>>2]=0;c[h+12>>2]=0;c[h+16>>2]=0;c[h+20>>2]=0;c[h+24>>2]=0;c[h+28>>2]=0;a[h+32>>0]=0;g[j>>3]=i;g[j+8>>3]=e;h=b;c[h>>2]=-1;c[h+4>>2]=-1;return j|0}function kh(a,b,c){a=a|0;b=+b;c=+c;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;f=d+8|0;e=d;g[f>>3]=b;g[e>>3]=c;a=Ob[a&63](f,e)|0;Eb=d;return a|0}function lh(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=c[a>>2]|0;h=c[a+4>>2]|0;a=b+(h>>1)|0;if(!(h&1)){h=g;$b[h&15](a,d,e,f);return}else {h=c[(c[a>>2]|0)+g>>2]|0;$b[h&15](a,d,e,f);return}}function mh(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=c[a>>2]|0;h=c[a+4>>2]|0;a=b+(h>>1)|0;if(!(h&1)){h=g;$b[h&15](a,d,e,f);return}else {h=c[(c[a>>2]|0)+g>>2]|0;$b[h&15](a,d,e,f);return}}function nh(a,b,d,e){a=a|0;b=b|0;d=d|0;e=+e;var f=0,g=0;f=c[a>>2]|0;g=c[a+4>>2]|0;a=b+(g>>1)|0;if(!(g&1)){g=f;Yb[g&15](a,d,e);return}else {g=c[(c[a>>2]|0)+f>>2]|0;Yb[g&15](a,d,e);return}}function oh(a,b,d,e){a=a|0;b=b|0;d=d|0;e=+e;var f=0,g=0;f=c[a>>2]|0;g=c[a+4>>2]|0;a=b+(g>>1)|0;if(!(g&1)){g=f;Yb[g&15](a,d,e);return}else {g=c[(c[a>>2]|0)+f>>2]|0;Yb[g&15](a,d,e);return}}function ph(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(!(e&1)){e=d;Ub[e&127](a);return}else {e=c[(c[a>>2]|0)+d>>2]|0;Ub[e&127](a);return}}function qh(a,b){a=a|0;b=b|0;return +(+g[b+(c[a>>2]|0)>>3])}function rh(a,b,d){a=a|0;b=b|0;d=+d;g[b+(c[a>>2]|0)>>3]=d;return}function sh(){fe(0);return}function th(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;a=yh(c[a+60>>2]|0)|0;c[d>>2]=a;a=wh(ba(6,d|0)|0)|0;Eb=b;return a|0}function uh(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;m=Eb;Eb=Eb+48|0;k=m+32|0;g=m+16|0;f=m;i=a+28|0;e=c[i>>2]|0;c[f>>2]=e;j=a+20|0;e=(c[j>>2]|0)-e|0;c[f+4>>2]=e;c[f+8>>2]=b;c[f+12>>2]=d;e=e+d|0;h=a+60|0;c[g>>2]=c[h>>2];c[g+4>>2]=f;c[g+8>>2]=2;g=wh(aa(146,g|0)|0)|0;a:do if((e|0)!=(g|0)){b=2;while(1){if((g|0)<0)break;e=e-g|0;o=c[f+4>>2]|0;n=g>>>0>o>>>0;f=n?f+8|0:f;b=b+(n<<31>>31)|0;o=g-(n?o:0)|0;c[f>>2]=(c[f>>2]|0)+o;n=f+4|0;c[n>>2]=(c[n>>2]|0)-o;c[k>>2]=c[h>>2];c[k+4>>2]=f;c[k+8>>2]=b;g=wh(aa(146,k|0)|0)|0;if((e|0)==(g|0)){l=3;break a}}c[a+16>>2]=0;c[i>>2]=0;c[j>>2]=0;c[a>>2]=c[a>>2]|32;if((b|0)==2)d=0;else d=d-(c[f+4>>2]|0)|0;}else l=3;while(0);if((l|0)==3){o=c[a+44>>2]|0;c[a+16>>2]=o+(c[a+48>>2]|0);c[i>>2]=o;c[j>>2]=o;}Eb=m;return d|0}function vh(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;g=Eb;Eb=Eb+32|0;h=g+8|0;f=g;c[h>>2]=c[a+60>>2];c[h+4>>2]=d;c[h+8>>2]=b;c[h+12>>2]=f;c[h+16>>2]=e;if((wh($(140,h|0)|0)|0)<0){a=f;c[a>>2]=-1;c[a+4>>2]=-1;a=-1;b=-1;}else {b=f;a=c[b+4>>2]|0;b=c[b>>2]|0;}E(a|0);Eb=g;return b|0}function wh(a){a=a|0;var b=0;if(a>>>0>4294963200){b=xh()|0;c[b>>2]=0-a;a=-1;}return a|0}function xh(){return 18240}function yh(a){a=a|0;return a|0}function zh(a){a=a|0;return (a+-97|0)>>>0<26|0}function Ah(b,c){b=b|0;c=c|0;var d=0,e=0;d=a[b>>0]|0;e=a[c>>0]|0;if(d<<24>>24==0?1:d<<24>>24!=e<<24>>24)b=e;else {do{b=b+1|0;c=c+1|0;d=a[b>>0]|0;e=a[c>>0]|0;}while(!(d<<24>>24==0?1:d<<24>>24!=e<<24>>24));b=e;}return (d&255)-(b&255)|0}function Bh(a){a=a|0;return (a+-48|0)>>>0<10|0}function Ch(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0;j=Eb;Eb=Eb+160|0;g=j+144|0;i=j;ax(i|0,1792,144)|0;if((d+-1|0)>>>0>2147483646)if(!d){b=g;d=1;h=4;}else {d=xh()|0;c[d>>2]=75;d=-1;}else h=4;if((h|0)==4){h=-2-b|0;h=d>>>0>h>>>0?h:d;c[i+48>>2]=h;g=i+20|0;c[g>>2]=b;c[i+44>>2]=b;d=b+h|0;b=i+16|0;c[b>>2]=d;c[i+28>>2]=d;d=Dh(i,e,f)|0;if(h){i=c[g>>2]|0;a[i+(((i|0)==(c[b>>2]|0))<<31>>31)>>0]=0;}}Eb=j;return d|0}function Dh(a,b,c){a=a|0;b=b|0;c=c|0;return Gh(a,b,c,1,107)|0}function Eh(b,e,f,g,h,i){b=b|0;e=+e;f=f|0;g=g|0;h=h|0;i=i|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0.0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,B=0,C=0,D=0,E=0,G=0,H=0;H=Eb;Eb=Eb+560|0;l=H+32|0;u=H+536|0;G=H;E=G;m=H+540|0;c[u>>2]=0;D=m+12|0;Yh(e)|0;j=F()|0;if((j|0)<0){e=-e;Yh(e)|0;C=1;B=10433;j=F()|0;}else {C=(h&2049|0)!=0&1;B=(h&2048|0)==0?((h&1|0)==0?10434:10439):10436;}do if(0==0&(j&2146435072|0)==2146435072){G=(i&32|0)!=0;j=C+3|0;Rh(b,32,f,j,h&-65537);Kh(b,B,C);Kh(b,e!=e|0.0!=0.0?(G?10460:10464):G?10452:10456,3);Rh(b,32,f,j,h^8192);}else {q=+Zh(e,u)*2.0;j=q!=0.0;if(j)c[u>>2]=(c[u>>2]|0)+-1;t=i|32;if((t|0)==97){o=i&32;r=(o|0)==0?B:B+9|0;p=C|2;j=12-g|0;do if(!(g>>>0>11|(j|0)==0)){e=8.0;do{j=j+-1|0;e=e*16.0;}while((j|0)!=0);if((a[r>>0]|0)==45){e=-(e+(-q-e));break}else {e=q+e-e;break}}else e=q;while(0);k=c[u>>2]|0;j=(k|0)<0?0-k|0:k;j=Ph(j,((j|0)<0)<<31>>31,D)|0;if((j|0)==(D|0)){j=m+11|0;a[j>>0]=48;}a[j+-1>>0]=(k>>31&2)+43;n=j+-2|0;a[n>>0]=i+15;k=(g|0)<1;l=(h&8|0)==0;m=G;do{C=~~e;j=m+1|0;a[m>>0]=o|d[1008+C>>0];e=(e-+(C|0))*16.0;if((j-E|0)==1?!(l&(k&e==0.0)):0){a[j>>0]=46;m=m+2|0;}else m=j;}while(e!=0.0);if((g|0)!=0?(-2-E+m|0)<(g|0):0){k=D;l=n;j=g+2+k-l|0;}else {k=D;l=n;j=k-E-l+m|0;}D=j+p|0;Rh(b,32,f,D,h);Kh(b,r,p);Rh(b,48,f,D,h^65536);E=m-E|0;Kh(b,G,E);G=k-l|0;Rh(b,48,j-(E+G)|0,0,0);Kh(b,n,G);Rh(b,32,f,D,h^8192);j=D;break}k=(g|0)<0?6:g;if(j){j=(c[u>>2]|0)+-28|0;c[u>>2]=j;e=q*268435456.0;}else {e=q;j=c[u>>2]|0;}z=(j|0)<0?l:l+288|0;l=z;do{x=~~e>>>0;c[l>>2]=x;l=l+4|0;e=(e-+(x>>>0))*1.0e9;}while(e!=0.0);x=z;if((j|0)>0){o=z;while(1){n=(j|0)<29?j:29;j=l+-4|0;if(j>>>0>=o>>>0){m=0;do{s=$w(c[j>>2]|0,0,n|0)|0;s=Vw(s|0,F()|0,m|0,0)|0;v=F()|0;m=Zw(s|0,v|0,1e9,0)|0;w=Uw(m|0,F()|0,1e9,0)|0;w=Ww(s|0,v|0,w|0,F()|0)|0;F()|0;c[j>>2]=w;j=j+-4|0;}while(j>>>0>=o>>>0);if(m){w=o+-4|0;c[w>>2]=m;m=w;}else m=o;}else m=o;a:do if(l>>>0>m>>>0){j=l;while(1){l=j+-4|0;if(c[l>>2]|0){l=j;break a}if(l>>>0>m>>>0)j=l;else break}}while(0);j=(c[u>>2]|0)-n|0;c[u>>2]=j;if((j|0)>0)o=m;else break}}else m=z;if((j|0)<0){g=((k+25|0)/9|0)+1|0;s=(t|0)==102;do{r=0-j|0;r=(r|0)<9?r:9;if(m>>>0<l>>>0){n=(1<<r)+-1|0;o=1e9>>>r;p=0;j=m;do{w=c[j>>2]|0;c[j>>2]=(w>>>r)+p;p=A(w&n,o)|0;j=j+4|0;}while(j>>>0<l>>>0);m=(c[m>>2]|0)==0?m+4|0:m;if(p){c[l>>2]=p;l=l+4|0;}}else m=(c[m>>2]|0)==0?m+4|0:m;j=s?z:m;l=(l-j>>2|0)>(g|0)?j+(g<<2)|0:l;j=(c[u>>2]|0)+r|0;c[u>>2]=j;}while((j|0)<0);s=m;}else s=m;if(s>>>0<l>>>0){j=(x-s>>2)*9|0;n=c[s>>2]|0;if(n>>>0>=10){m=10;do{m=m*10|0;j=j+1|0;}while(n>>>0>=m>>>0)}}else j=0;v=(t|0)==103;w=(k|0)!=0;m=k-((t|0)==102?0:j)+((w&v)<<31>>31)|0;if((m|0)<(((l-x>>2)*9|0)+-9|0)){u=m+9216|0;m=(u|0)/9|0;g=z+4+(m+-1024<<2)|0;m=u-(m*9|0)|0;if((m|0)<8){n=10;while(1){n=n*10|0;if((m|0)<7)m=m+1|0;else break}}else n=10;p=c[g>>2]|0;m=(p>>>0)/(n>>>0)|0;r=p-(A(m,n)|0)|0;o=(g+4|0)==(l|0);if(!(o&(r|0)==0)){q=(m&1|0)==0?9007199254740992.0:9007199254740994.0;u=n>>>1;e=r>>>0<u>>>0?.5:o&(r|0)==(u|0)?1.0:1.5;if(C){u=(a[B>>0]|0)==45;e=u?-e:e;q=u?-q:q;}m=p-r|0;c[g>>2]=m;if(q+e!=q){u=m+n|0;c[g>>2]=u;if(u>>>0>999999999){n=g;j=s;while(1){m=n+-4|0;c[n>>2]=0;if(m>>>0<j>>>0){j=j+-4|0;c[j>>2]=0;}u=(c[m>>2]|0)+1|0;c[m>>2]=u;if(u>>>0>999999999)n=m;else {n=j;break}}}else {m=g;n=s;}j=(x-n>>2)*9|0;p=c[n>>2]|0;if(p>>>0>=10){o=10;do{o=o*10|0;j=j+1|0;}while(p>>>0>=o>>>0)}}else {m=g;n=s;}}else {m=g;n=s;}u=m+4|0;l=l>>>0>u>>>0?u:l;}else n=s;g=0-j|0;b:do if(l>>>0>n>>>0)while(1){m=l+-4|0;if(c[m>>2]|0){u=l;t=1;break b}if(m>>>0>n>>>0)l=m;else {u=m;t=0;break}}else {u=l;t=0;}while(0);do if(v){k=k+((w^1)&1)|0;if((k|0)>(j|0)&(j|0)>-5){o=i+-1|0;k=k+-1-j|0;}else {o=i+-2|0;k=k+-1|0;}if(!(h&8)){if(t?(y=c[u+-4>>2]|0,(y|0)!=0):0)if(!((y>>>0)%10|0)){m=0;l=10;do{l=l*10|0;m=m+1|0;}while(!((y>>>0)%(l>>>0)|0|0))}else m=0;else m=9;l=((u-x>>2)*9|0)+-9|0;if((o|32|0)==102){i=l-m|0;i=(i|0)>0?i:0;k=(k|0)<(i|0)?k:i;break}else {i=l+j-m|0;i=(i|0)>0?i:0;k=(k|0)<(i|0)?k:i;break}}}else o=i;while(0);s=(k|0)!=0;p=s?1:h>>>3&1;r=(o|32|0)==102;if(r){v=0;j=(j|0)>0?j:0;}else {l=(j|0)<0?g:j;l=Ph(l,((l|0)<0)<<31>>31,D)|0;m=D;if((m-l|0)<2)do{l=l+-1|0;a[l>>0]=48;}while((m-l|0)<2);a[l+-1>>0]=(j>>31&2)+43;j=l+-2|0;a[j>>0]=o;v=j;j=m-j|0;}j=C+1+k+p+j|0;Rh(b,32,f,j,h);Kh(b,B,C);Rh(b,48,f,j,h^65536);if(r){p=n>>>0>z>>>0?z:n;r=G+9|0;n=r;o=G+8|0;m=p;do{l=Ph(c[m>>2]|0,0,r)|0;if((m|0)==(p|0)){if((l|0)==(r|0)){a[o>>0]=48;l=o;}}else if(l>>>0>G>>>0){cx(G|0,48,l-E|0)|0;do l=l+-1|0;while(l>>>0>G>>>0)}Kh(b,l,n-l|0);m=m+4|0;}while(m>>>0<=z>>>0);if(!((h&8|0)==0&(s^1)))Kh(b,14405,1);if(m>>>0<u>>>0&(k|0)>0)while(1){l=Ph(c[m>>2]|0,0,r)|0;if(l>>>0>G>>>0){cx(G|0,48,l-E|0)|0;do l=l+-1|0;while(l>>>0>G>>>0)}Kh(b,l,(k|0)<9?k:9);m=m+4|0;l=k+-9|0;if(!(m>>>0<u>>>0&(k|0)>9)){k=l;break}else k=l;}Rh(b,48,k+9|0,9,0);}else {u=t?u:n+4|0;if(n>>>0<u>>>0&(k|0)>-1){g=G+9|0;s=(h&8|0)==0;t=g;p=0-E|0;r=G+8|0;o=n;do{l=Ph(c[o>>2]|0,0,g)|0;if((l|0)==(g|0)){a[r>>0]=48;l=r;}do if((o|0)==(n|0)){m=l+1|0;Kh(b,l,1);if(s&(k|0)<1){l=m;break}Kh(b,14405,1);l=m;}else {if(l>>>0<=G>>>0)break;cx(G|0,48,l+p|0)|0;do l=l+-1|0;while(l>>>0>G>>>0)}while(0);E=t-l|0;Kh(b,l,(k|0)>(E|0)?E:k);k=k-E|0;o=o+4|0;}while(o>>>0<u>>>0&(k|0)>-1)}Rh(b,48,k+18|0,18,0);Kh(b,v,D-v|0);}Rh(b,32,f,j,h^8192);}while(0);Eb=H;return ((j|0)<(f|0)?f:j)|0}function Fh(a,b){a=a|0;b=b|0;var d=0.0,e=0;e=(c[b>>2]|0)+(8-1)&~(8-1);d=+g[e>>3];c[b>>2]=e+8;g[a>>3]=d;return}function Gh(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,p=0,q=0,r=0,s=0,t=0;t=Eb;Eb=Eb+224|0;p=t+208|0;q=t+160|0;r=t+80|0;s=t;h=q;i=h+40|0;do{c[h>>2]=0;h=h+4|0;}while((h|0)<(i|0));c[p>>2]=c[e>>2];if((Hh(0,d,p,r,q,f,g)|0)<0)e=-1;else {if((c[b+76>>2]|0)>-1);e=c[b>>2]|0;n=e&32;if((a[b+74>>0]|0)<1)c[b>>2]=e&-33;h=b+48|0;if(!(c[h>>2]|0)){i=b+44|0;j=c[i>>2]|0;c[i>>2]=s;k=b+28|0;c[k>>2]=s;l=b+20|0;c[l>>2]=s;c[h>>2]=80;m=b+16|0;c[m>>2]=s+80;e=Hh(b,d,p,r,q,f,g)|0;if(j){Pb[c[b+36>>2]&15](b,0,0)|0;e=(c[l>>2]|0)==0?-1:e;c[i>>2]=j;c[h>>2]=0;c[m>>2]=0;c[k>>2]=0;c[l>>2]=0;}}else e=Hh(b,d,p,r,q,f,g)|0;h=c[b>>2]|0;c[b>>2]=h|n;e=(h&32|0)==0?e:-1;}Eb=t;return e|0}function Hh(d,e,f,h,i,j,k){d=d|0;e=e|0;f=f|0;h=h|0;i=i|0;j=j|0;k=k|0;var l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0;J=Eb;Eb=Eb+64|0;G=J+56|0;I=J+40|0;A=J;C=J+48|0;D=J+60|0;c[G>>2]=e;x=(d|0)!=0;y=A+40|0;z=y;A=A+39|0;B=C+4|0;l=0;e=0;n=0;a:while(1){do{do if((e|0)>-1)if((l|0)>(2147483647-e|0)){e=xh()|0;c[e>>2]=75;e=-1;break}else {e=l+e|0;break}while(0);r=c[G>>2]|0;l=a[r>>0]|0;if(!(l<<24>>24)){w=92;break a}m=r;b:while(1){switch(l<<24>>24){case 37:{w=10;break b}case 0:{l=m;break b}}v=m+1|0;c[G>>2]=v;l=a[v>>0]|0;m=v;}c:do if((w|0)==10){w=0;l=m;do{if((a[m+1>>0]|0)!=37)break c;l=l+1|0;m=m+2|0;c[G>>2]=m;}while((a[m>>0]|0)==37)}while(0);l=l-r|0;if(x)Kh(d,r,l);}while((l|0)!=0);v=(Bh(a[(c[G>>2]|0)+1>>0]|0)|0)==0;m=c[G>>2]|0;if(!v?(a[m+2>>0]|0)==36:0){t=(a[m+1>>0]|0)+-48|0;p=1;l=3;}else {t=-1;p=n;l=1;}l=m+l|0;c[G>>2]=l;m=a[l>>0]|0;n=(m<<24>>24)+-32|0;if(n>>>0>31|(1<<n&75913|0)==0)o=0;else {o=0;do{o=1<<n|o;l=l+1|0;c[G>>2]=l;m=a[l>>0]|0;n=(m<<24>>24)+-32|0;}while(!(n>>>0>31|(1<<n&75913|0)==0))}if(m<<24>>24==42){if((Bh(a[l+1>>0]|0)|0)!=0?(H=c[G>>2]|0,(a[H+2>>0]|0)==36):0){l=H+1|0;c[i+((a[l>>0]|0)+-48<<2)>>2]=10;l=c[h+((a[l>>0]|0)+-48<<3)>>2]|0;n=1;m=H+3|0;}else {if(p|0){e=-1;break}if(x){v=(c[f>>2]|0)+(4-1)&~(4-1);l=c[v>>2]|0;c[f>>2]=v+4;}else l=0;n=0;m=(c[G>>2]|0)+1|0;}c[G>>2]=m;v=(l|0)<0;u=v?0-l|0:l;o=v?o|8192:o;v=n;}else {l=Lh(G)|0;if((l|0)<0){e=-1;break}u=l;v=p;m=c[G>>2]|0;}do if((a[m>>0]|0)==46){l=m+1|0;if((a[l>>0]|0)!=42){c[G>>2]=l;l=Lh(G)|0;m=c[G>>2]|0;break}if(Bh(a[m+2>>0]|0)|0?(E=c[G>>2]|0,(a[E+3>>0]|0)==36):0){l=E+2|0;c[i+((a[l>>0]|0)+-48<<2)>>2]=10;l=c[h+((a[l>>0]|0)+-48<<3)>>2]|0;m=E+4|0;c[G>>2]=m;break}if(v|0){e=-1;break a}if(x){s=(c[f>>2]|0)+(4-1)&~(4-1);l=c[s>>2]|0;c[f>>2]=s+4;}else l=0;m=(c[G>>2]|0)+2|0;c[G>>2]=m;}else l=-1;while(0);s=0;while(1){if(((a[m>>0]|0)+-65|0)>>>0>57){e=-1;break a}n=m;m=m+1|0;c[G>>2]=m;n=a[(a[n>>0]|0)+-65+(544+(s*58|0))>>0]|0;p=n&255;if((p+-1|0)>>>0>=8)break;else s=p;}if(!(n<<24>>24)){e=-1;break}q=(t|0)>-1;do if(n<<24>>24==19)if(q){e=-1;break a}else w=54;else {if(q){c[i+(t<<2)>>2]=p;q=h+(t<<3)|0;t=c[q+4>>2]|0;w=I;c[w>>2]=c[q>>2];c[w+4>>2]=t;w=54;break}if(!x){e=0;break a}Mh(I,p,f,k);m=c[G>>2]|0;w=55;}while(0);if((w|0)==54){w=0;if(x)w=55;else l=0;}d:do if((w|0)==55){w=0;m=a[m+-1>>0]|0;m=(s|0)!=0&(m&15|0)==3?m&-33:m;n=o&-65537;t=(o&8192|0)==0?o:n;e:do switch(m|0){case 110:switch((s&255)<<24>>24){case 0:{c[c[I>>2]>>2]=e;l=0;break d}case 1:{c[c[I>>2]>>2]=e;l=0;break d}case 2:{l=c[I>>2]|0;c[l>>2]=e;c[l+4>>2]=((e|0)<0)<<31>>31;l=0;break d}case 3:{b[c[I>>2]>>1]=e;l=0;break d}case 4:{a[c[I>>2]>>0]=e;l=0;break d}case 6:{c[c[I>>2]>>2]=e;l=0;break d}case 7:{l=c[I>>2]|0;c[l>>2]=e;c[l+4>>2]=((e|0)<0)<<31>>31;l=0;break d}default:{l=0;break d}}case 112:{m=120;l=l>>>0>8?l:8;n=t|8;w=67;break}case 88:case 120:{n=t;w=67;break}case 111:{q=I;q=Oh(c[q>>2]|0,c[q+4>>2]|0,y)|0;n=z-q|0;o=0;p=10416;l=(t&8|0)==0|(l|0)>(n|0)?l:n+1|0;n=t;w=73;break}case 105:case 100:{n=I;m=c[n>>2]|0;n=c[n+4>>2]|0;if((n|0)<0){m=Ww(0,0,m|0,n|0)|0;n=F()|0;o=I;c[o>>2]=m;c[o+4>>2]=n;o=1;p=10416;w=72;break e}else {o=(t&2049|0)!=0&1;p=(t&2048|0)==0?((t&1|0)==0?10416:10418):10417;w=72;break e}}case 117:{n=I;o=0;p=10416;m=c[n>>2]|0;n=c[n+4>>2]|0;w=72;break}case 99:{a[A>>0]=c[I>>2];r=A;o=0;p=10416;q=1;m=n;l=z;break}case 115:{s=c[I>>2]|0;s=(s|0)==0?10426:s;t=Qh(s,0,l)|0;K=(t|0)==0;r=s;o=0;p=10416;q=K?l:t-s|0;m=n;l=K?s+l|0:t;break}case 67:{c[C>>2]=c[I>>2];c[B>>2]=0;c[I>>2]=C;p=-1;w=79;break}case 83:{if(!l){Rh(d,32,u,0,t);l=0;w=89;}else {p=l;w=79;}break}case 65:case 71:case 70:case 69:case 97:case 103:case 102:case 101:{l=Nb[j&1](d,+g[I>>3],u,l,t,m)|0;break d}default:{o=0;p=10416;q=l;m=t;l=z;}}while(0);f:do if((w|0)==67){q=I;q=Nh(c[q>>2]|0,c[q+4>>2]|0,y,m&32)|0;p=I;p=(n&8|0)==0|(c[p>>2]|0)==0&(c[p+4>>2]|0)==0;o=p?0:2;p=p?10416:10416+(m>>>4)|0;w=73;}else if((w|0)==72){q=Ph(m,n,y)|0;n=t;w=73;}else if((w|0)==79){w=0;o=c[I>>2]|0;l=0;while(1){m=c[o>>2]|0;if(!m)break;m=Sh(D,m)|0;n=(m|0)<0;if(n|m>>>0>(p-l|0)>>>0){w=83;break}l=m+l|0;if(p>>>0>l>>>0)o=o+4|0;else break}if((w|0)==83){w=0;if(n){e=-1;break a}}Rh(d,32,u,l,t);if(!l){l=0;w=89;}else {n=c[I>>2]|0;o=0;while(1){m=c[n>>2]|0;if(!m){w=89;break f}m=Sh(D,m)|0;o=m+o|0;if((o|0)>(l|0)){w=89;break f}Kh(d,D,m);if(o>>>0>=l>>>0){w=89;break}else n=n+4|0;}}}while(0);if((w|0)==73){w=0;m=I;m=(c[m>>2]|0)!=0|(c[m+4>>2]|0)!=0;K=(l|0)!=0|m;m=z-q+((m^1)&1)|0;r=K?q:y;q=K?((l|0)>(m|0)?l:m):0;m=(l|0)>-1?n&-65537:n;l=z;}else if((w|0)==89){w=0;Rh(d,32,u,l,t^8192);l=(u|0)>(l|0)?u:l;break}t=l-r|0;s=(q|0)<(t|0)?t:q;K=s+o|0;l=(u|0)<(K|0)?K:u;Rh(d,32,l,K,m);Kh(d,p,o);Rh(d,48,l,K,m^65536);Rh(d,48,s,t,0);Kh(d,r,t);Rh(d,32,l,K,m^8192);}while(0);n=v;}g:do if((w|0)==92)if(!d)if(!n)e=0;else {e=1;while(1){l=c[i+(e<<2)>>2]|0;if(!l)break;Mh(h+(e<<3)|0,l,f,k);e=e+1|0;if(e>>>0>=10){e=1;break g}}while(1){if(c[i+(e<<2)>>2]|0){e=-1;break g}e=e+1|0;if(e>>>0>=10){e=1;break}}}while(0);Eb=J;return e|0}function Ih(a){return 1}function Kh(a,b,d){a=a|0;b=b|0;d=d|0;if(!(c[a>>2]&32))Wh(b,d,a)|0;return}function Lh(b){b=b|0;var d=0,e=0;if(!(Bh(a[c[b>>2]>>0]|0)|0))d=0;else {d=0;do{e=c[b>>2]|0;d=(d*10|0)+-48+(a[e>>0]|0)|0;e=e+1|0;c[b>>2]=e;}while((Bh(a[e>>0]|0)|0)!=0)}return d|0}function Mh(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0.0;a:do if(b>>>0<=20)do switch(b|0){case 9:{b=(c[d>>2]|0)+(4-1)&~(4-1);e=c[b>>2]|0;c[d>>2]=b+4;c[a>>2]=e;break a}case 10:{e=(c[d>>2]|0)+(4-1)&~(4-1);b=c[e>>2]|0;c[d>>2]=e+4;e=a;c[e>>2]=b;c[e+4>>2]=((b|0)<0)<<31>>31;break a}case 11:{e=(c[d>>2]|0)+(4-1)&~(4-1);b=c[e>>2]|0;c[d>>2]=e+4;e=a;c[e>>2]=b;c[e+4>>2]=0;break a}case 12:{e=(c[d>>2]|0)+(8-1)&~(8-1);b=e;f=c[b>>2]|0;b=c[b+4>>2]|0;c[d>>2]=e+8;e=a;c[e>>2]=f;c[e+4>>2]=b;break a}case 13:{f=(c[d>>2]|0)+(4-1)&~(4-1);e=c[f>>2]|0;c[d>>2]=f+4;e=(e&65535)<<16>>16;f=a;c[f>>2]=e;c[f+4>>2]=((e|0)<0)<<31>>31;break a}case 14:{f=(c[d>>2]|0)+(4-1)&~(4-1);e=c[f>>2]|0;c[d>>2]=f+4;f=a;c[f>>2]=e&65535;c[f+4>>2]=0;break a}case 15:{f=(c[d>>2]|0)+(4-1)&~(4-1);e=c[f>>2]|0;c[d>>2]=f+4;e=(e&255)<<24>>24;f=a;c[f>>2]=e;c[f+4>>2]=((e|0)<0)<<31>>31;break a}case 16:{f=(c[d>>2]|0)+(4-1)&~(4-1);e=c[f>>2]|0;c[d>>2]=f+4;f=a;c[f>>2]=e&255;c[f+4>>2]=0;break a}case 17:{f=(c[d>>2]|0)+(8-1)&~(8-1);h=+g[f>>3];c[d>>2]=f+8;g[a>>3]=h;break a}case 18:{Xb[e&127](a,d);break a}default:break a}while(0);while(0);return}function Nh(b,c,e,f){b=b|0;c=c|0;e=e|0;f=f|0;if(!((b|0)==0&(c|0)==0))do{e=e+-1|0;a[e>>0]=d[1008+(b&15)>>0]|0|f;b=_w(b|0,c|0,4)|0;c=F()|0;}while(!((b|0)==0&(c|0)==0));return e|0}function Oh(b,c,d){b=b|0;c=c|0;d=d|0;if(!((b|0)==0&(c|0)==0))do{d=d+-1|0;a[d>>0]=b&7|48;b=_w(b|0,c|0,3)|0;c=F()|0;}while(!((b|0)==0&(c|0)==0));return d|0}function Ph(b,c,d){b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0;if(c>>>0>0|(c|0)==0&b>>>0>4294967295){do{e=b;b=Zw(b|0,c|0,10,0)|0;f=c;c=F()|0;g=Uw(b|0,c|0,10,0)|0;g=Ww(e|0,f|0,g|0,F()|0)|0;F()|0;d=d+-1|0;a[d>>0]=g&255|48;}while(f>>>0>9|(f|0)==9&e>>>0>4294967295);c=b;}else c=b;if(c)do{g=c;c=(c>>>0)/10|0;d=d+-1|0;a[d>>0]=g-(c*10|0)|48;}while(g>>>0>=10);return d|0}function Qh(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;h=d&255;f=(e|0)!=0;a:do if(f&(b&3|0)!=0){g=d&255;while(1){if((a[b>>0]|0)==g<<24>>24){i=6;break a}b=b+1|0;e=e+-1|0;f=(e|0)!=0;if(!(f&(b&3|0)!=0)){i=5;break}}}else i=5;while(0);if((i|0)==5)if(f)i=6;else i=16;b:do if((i|0)==6){g=d&255;if((a[b>>0]|0)==g<<24>>24)if(!e){i=16;break}else break;f=A(h,16843009)|0;c:do if(e>>>0>3)while(1){h=c[b>>2]^f;if((h&-2139062144^-2139062144)&h+-16843009|0)break c;b=b+4|0;e=e+-4|0;if(e>>>0<=3){i=11;break}}else i=11;while(0);if((i|0)==11)if(!e){i=16;break}while(1){if((a[b>>0]|0)==g<<24>>24)break b;e=e+-1|0;if(!e){i=16;break}else b=b+1|0;}}while(0);if((i|0)==16)b=0;return b|0}function Rh(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0;g=Eb;Eb=Eb+256|0;f=g;if((c|0)>(d|0)&(e&73728|0)==0){e=c-d|0;cx(f|0,b<<24>>24|0,(e>>>0<256?e:256)|0)|0;if(e>>>0>255){b=c-d|0;do{Kh(a,f,256);e=e+-256|0;}while(e>>>0>255);e=b&255;}Kh(a,f,e);}Eb=g;return}function Sh(a,b){a=a|0;b=b|0;if(!a)a=0;else a=Th(a,b,0)|0;return a|0}function Th(b,d,e){b=b|0;d=d|0;e=e|0;do if(b){if(d>>>0<128){a[b>>0]=d;b=1;break}e=(Uh()|0)+188|0;if(!(c[c[e>>2]>>2]|0))if((d&-128|0)==57216){a[b>>0]=d;b=1;break}else {b=xh()|0;c[b>>2]=84;b=-1;break}if(d>>>0<2048){a[b>>0]=d>>>6|192;a[b+1>>0]=d&63|128;b=2;break}if(d>>>0<55296|(d&-8192|0)==57344){a[b>>0]=d>>>12|224;a[b+1>>0]=d>>>6&63|128;a[b+2>>0]=d&63|128;b=3;break}if((d+-65536|0)>>>0<1048576){a[b>>0]=d>>>18|240;a[b+1>>0]=d>>>12&63|128;a[b+2>>0]=d>>>6&63|128;a[b+3>>0]=d&63|128;b=4;break}else {b=xh()|0;c[b>>2]=84;b=-1;break}}else b=1;while(0);return b|0}function Uh(){return Vh()|0}function Vh(){return 3984}function Wh(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0;f=e+16|0;g=c[f>>2]|0;if(!g)if(!(Xh(e)|0)){g=c[f>>2]|0;h=5;}else f=0;else h=5;a:do if((h|0)==5){j=e+20|0;i=c[j>>2]|0;f=i;if((g-i|0)>>>0<d>>>0){f=Pb[c[e+36>>2]&15](e,b,d)|0;break}b:do if((a[e+75>>0]|0)<0|(d|0)==0){h=0;g=b;}else {i=d;while(1){g=i+-1|0;if((a[b+g>>0]|0)==10)break;if(!g){h=0;g=b;break b}else i=g;}f=Pb[c[e+36>>2]&15](e,b,i)|0;if(f>>>0<i>>>0)break a;h=i;g=b+i|0;d=d-i|0;f=c[j>>2]|0;}while(0);ax(f|0,g|0,d|0)|0;c[j>>2]=(c[j>>2]|0)+d;f=h+d|0;}while(0);return f|0}function Xh(b){b=b|0;var d=0,e=0;d=b+74|0;e=a[d>>0]|0;a[d>>0]=e+255|e;d=c[b>>2]|0;if(!(d&8)){c[b+8>>2]=0;c[b+4>>2]=0;e=c[b+44>>2]|0;c[b+28>>2]=e;c[b+20>>2]=e;c[b+16>>2]=e+(c[b+48>>2]|0);b=0;}else {c[b>>2]=d|32;b=-1;}return b|0}function Yh(a){a=+a;var b=0;g[h>>3]=a;b=c[h>>2]|0;E(c[h+4>>2]|0);return b|0}function Zh(a,b){a=+a;b=b|0;var d=0,e=0,f=0;g[h>>3]=a;d=c[h>>2]|0;e=c[h+4>>2]|0;f=_w(d|0,e|0,52)|0;F()|0;switch(f&2047){case 0:{if(a!=0.0){a=+Zh(a*18446744073709551616.0,b);d=(c[b>>2]|0)+-64|0;}else d=0;c[b>>2]=d;break}case 2047:break;default:{c[b>>2]=(f&2047)+-1022;c[h>>2]=d;c[h+4>>2]=e&-2146435073|1071644672;a=+g[h>>3];}}return +a}function _h(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=a+20|0;f=c[e>>2]|0;a=(c[a+16>>2]|0)-f|0;a=a>>>0>d>>>0?d:a;ax(f|0,b|0,a|0)|0;c[e>>2]=(c[e>>2]|0)+a;return d|0}function $h(a){a=a|0;return (((a|32)+-97|0)>>>0<6|(Bh(a)|0)!=0)&1|0}function ai(b){b=b|0;var d=0,e=0,f=0;f=b;a:do if(!(f&3))e=5;else {d=f;while(1){if(!(a[b>>0]|0)){b=d;break a}b=b+1|0;d=b;if(!(d&3)){e=5;break}}}while(0);if((e|0)==5){while(1){d=c[b>>2]|0;if(!((d&-2139062144^-2139062144)&d+-16843009))b=b+4|0;else break}if((d&255)<<24>>24)do b=b+1|0;while((a[b>>0]|0)!=0)}return b-f|0}function bi(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;f=Eb;Eb=Eb+16|0;g=f;c[g>>2]=e;e=Ch(a,b,d,g)|0;Eb=f;return e|0}function ci(a){a=a|0;var b=0,c=0;b=(ai(a)|0)+1|0;c=hk(b)|0;if(!c)a=0;else a=ax(c|0,a|0,b|0)|0;return a|0}function di(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0;l=Eb;Eb=Eb+16|0;j=l;k=e&255;a[j>>0]=k;g=b+16|0;h=c[g>>2]|0;if(!h)if(!(Xh(b)|0)){h=c[g>>2]|0;i=4;}else f=-1;else i=4;do if((i|0)==4){i=b+20|0;g=c[i>>2]|0;if(g>>>0<h>>>0?(f=e&255,(f|0)!=(a[b+75>>0]|0)):0){c[i>>2]=g+1;a[g>>0]=k;break}if((Pb[c[b+36>>2]&15](b,j,1)|0)==1)f=d[j>>0]|0;else f=-1;}while(0);Eb=l;return f|0}function ei(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0;if((c[d+76>>2]|0)>=0?(Ih()|0)!=0:0){f=b&255;e=b&255;if((e|0)!=(a[d+75>>0]|0)?(i=d+20|0,j=c[i>>2]|0,j>>>0<(c[d+16>>2]|0)>>>0):0){c[i>>2]=j+1;a[j>>0]=f;}else e=di(d,b)|0;}else k=3;do if((k|0)==3){f=b&255;e=b&255;if((e|0)!=(a[d+75>>0]|0)?(g=d+20|0,h=c[g>>2]|0,h>>>0<(c[d+16>>2]|0)>>>0):0){c[g>>2]=h+1;a[h>>0]=f;break}e=di(d,b)|0;}while(0);return e|0}function fi(){gi();return}function gi(){hi(18756);return}function hi(a){a=a|0;var b=0;b=Eb;Eb=Eb+16|0;c[b>>2]=a;ii();Eb=b;return}function ii(){qa(ji()|0,12081);ca(ki()|0,12086,1,1,0);li(12091);mi(12096);ni(12108);oi(12122);pi(12128);qi(12143);ri(12147);si(12160);ti(12165);ui(12216);vi(16870);oa(wi()|0,12526);oa(xi()|0,10468);pa(yi()|0,4,10501);ha(zi()|0,10514);Ai(10530);Bi(10560);Ci(10597);Di(10636);Ei(10667);Fi(10707);Gi(10736);Hi(10774);Ii(10804);Bi(10843);Ci(10875);Di(10908);Ei(10941);Fi(10975);Gi(11008);Ji(11042);Ki(11073);Li(11105);return}function ji(){return Vj()|0}function ki(){return Uj()|0}function li(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Sj()|0;ma(a|0,c[d>>2]|0,1,-128<<24>>24|0,127<<24>>24|0);Eb=b;return}function mi(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Qj()|0;ma(a|0,c[d>>2]|0,1,-128<<24>>24|0,127<<24>>24|0);Eb=b;return}function ni(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Oj()|0;ma(a|0,c[d>>2]|0,1,0,255);Eb=b;return}function oi(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Mj()|0;ma(a|0,c[d>>2]|0,2,-32768<<16>>16|0,32767<<16>>16|0);Eb=b;return}function pi(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Kj()|0;ma(a|0,c[d>>2]|0,2,0,65535);Eb=b;return}function qi(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Ij()|0;ma(a|0,c[d>>2]|0,4,-2147483648,2147483647);Eb=b;return}function ri(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Gj()|0;ma(a|0,c[d>>2]|0,4,0,-1);Eb=b;return}function si(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Ej()|0;ma(a|0,c[d>>2]|0,4,-2147483648,2147483647);Eb=b;return}function ti(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Cj()|0;ma(a|0,c[d>>2]|0,4,0,-1);Eb=b;return}function ui(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Aj()|0;ka(a|0,c[d>>2]|0,4);Eb=b;return}function vi(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=yj()|0;ka(a|0,c[d>>2]|0,8);Eb=b;return}function wi(){return xj()|0}function xi(){return wj()|0}function yi(){return vj()|0}function zi(){return uj()|0}function Ai(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=rj()|0;a=sj()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Bi(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=oj()|0;a=pj()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Ci(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=lj()|0;a=mj()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Di(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=ij()|0;a=jj()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Ei(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=fj()|0;a=gj()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Fi(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=cj()|0;a=dj()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Gi(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=$i()|0;a=aj()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Hi(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=Yi()|0;a=Zi()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Ii(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=Vi()|0;a=Wi()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Ji(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=Si()|0;a=Ti()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Ki(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=Pi()|0;a=Qi()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Li(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=Mi()|0;a=Ni()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Mi(){return Oi()|0}function Ni(){return 7}function Oi(){return 1936}function Pi(){return Ri()|0}function Qi(){return 7}function Ri(){return 1072}function Si(){return Ui()|0}function Ti(){return 6}function Ui(){return 1944}function Vi(){return Xi()|0}function Wi(){return 5}function Xi(){return 1952}function Yi(){return _i()|0}function Zi(){return 4}function _i(){return 1960}function $i(){return bj()|0}function aj(){return 5}function bj(){return 1968}function cj(){return ej()|0}function dj(){return 4}function ej(){return 1976}function fj(){return hj()|0}function gj(){return 3}function hj(){return 1984}function ij(){return kj()|0}function jj(){return 2}function kj(){return 1992}function lj(){return nj()|0}function mj(){return 1}function nj(){return 2e3}function oj(){return qj()|0}function pj(){return 0}function qj(){return 2008}function rj(){return tj()|0}function sj(){return 0}function tj(){return 2016}function uj(){return 1184}function vj(){return 2024}function wj(){return 2056}function xj(){return 2080}function yj(){return zj()|0}function zj(){return 3464}function Aj(){return Bj()|0}function Bj(){return 3456}function Cj(){return Dj()|0}function Dj(){return 3448}function Ej(){return Fj()|0}function Fj(){return 3440}function Gj(){return Hj()|0}function Hj(){return 3432}function Ij(){return Jj()|0}function Jj(){return 3424}function Kj(){return Lj()|0}function Lj(){return 3416}function Mj(){return Nj()|0}function Nj(){return 3408}function Oj(){return Pj()|0}function Pj(){return 3392}function Qj(){return Rj()|0}function Rj(){return 3400}function Sj(){return Tj()|0}function Tj(){return 3384}function Uj(){return 3376}function Vj(){return 3360}function Wj(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b+4|0;e=b;c[e>>2]=a;c[d>>2]=c[e>>2];a=ci(c[(c[d>>2]|0)+4>>2]|0)|0;Eb=b;return a|0}function Xj(){return (Yj()|0)>0|0}function Yj(){return W()|0}function Zj(a){a=a|0;var b=0;b=(a|0)==0?1:a;while(1){a=hk(b)|0;if(a|0)break;a=Qw()|0;if(!a){a=0;break}Tb[a&3]();}return a|0}function _j(a){a=a|0;return Zj(a)|0}function $j(a){a=a|0;ik(a);return}function ak(a){a=a|0;$j(a);return}function bk(a,b){a=a|0;b=b|0;var d=0,e=0;e=ai(b)|0;d=Zj(e+13|0)|0;c[d>>2]=e;c[d+4>>2]=e;c[d+8>>2]=0;d=ck(d)|0;ax(d|0,b|0,e+1|0)|0;c[a>>2]=d;return}function ck(a){a=a|0;return a+12|0}function dk(a,b){a=a|0;b=b|0;c[a>>2]=7308;bk(a+4|0,b);return}function fk(a){va();}function gk(a){va();}function hk(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;w=Eb;Eb=Eb+16|0;n=w;do if(a>>>0<245){k=a>>>0<11?16:a+11&-8;a=k>>>3;m=c[4561]|0;d=m>>>a;if(d&3|0){b=(d&1^1)+a|0;a=18284+(b<<1<<2)|0;d=a+8|0;e=c[d>>2]|0;f=e+8|0;g=c[f>>2]|0;if((g|0)==(a|0))c[4561]=m&~(1<<b);else {c[g+12>>2]=a;c[d>>2]=g;}v=b<<3;c[e+4>>2]=v|3;v=e+v+4|0;c[v>>2]=c[v>>2]|1;v=f;Eb=w;return v|0}l=c[4563]|0;if(k>>>0>l>>>0){if(d|0){b=2<<a;b=d<<a&(b|0-b);b=(b&0-b)+-1|0;i=b>>>12&16;b=b>>>i;d=b>>>5&8;b=b>>>d;g=b>>>2&4;b=b>>>g;a=b>>>1&2;b=b>>>a;e=b>>>1&1;e=(d|i|g|a|e)+(b>>>e)|0;b=18284+(e<<1<<2)|0;a=b+8|0;g=c[a>>2]|0;i=g+8|0;d=c[i>>2]|0;if((d|0)==(b|0)){a=m&~(1<<e);c[4561]=a;}else {c[d+12>>2]=b;c[a>>2]=d;a=m;}v=e<<3;h=v-k|0;c[g+4>>2]=k|3;f=g+k|0;c[f+4>>2]=h|1;c[g+v>>2]=h;if(l|0){e=c[4566]|0;b=l>>>3;d=18284+(b<<1<<2)|0;b=1<<b;if(!(a&b)){c[4561]=a|b;b=d;a=d+8|0;}else {a=d+8|0;b=c[a>>2]|0;}c[a>>2]=e;c[b+12>>2]=e;c[e+8>>2]=b;c[e+12>>2]=d;}c[4563]=h;c[4566]=f;v=i;Eb=w;return v|0}g=c[4562]|0;if(g){d=(g&0-g)+-1|0;f=d>>>12&16;d=d>>>f;e=d>>>5&8;d=d>>>e;h=d>>>2&4;d=d>>>h;i=d>>>1&2;d=d>>>i;j=d>>>1&1;j=c[18548+((e|f|h|i|j)+(d>>>j)<<2)>>2]|0;d=j;i=j;j=(c[j+4>>2]&-8)-k|0;while(1){a=c[d+16>>2]|0;if(!a){a=c[d+20>>2]|0;if(!a)break}h=(c[a+4>>2]&-8)-k|0;f=h>>>0<j>>>0;d=a;i=f?a:i;j=f?h:j;}h=i+k|0;if(h>>>0>i>>>0){f=c[i+24>>2]|0;b=c[i+12>>2]|0;do if((b|0)==(i|0)){a=i+20|0;b=c[a>>2]|0;if(!b){a=i+16|0;b=c[a>>2]|0;if(!b){d=0;break}}while(1){e=b+20|0;d=c[e>>2]|0;if(!d){e=b+16|0;d=c[e>>2]|0;if(!d)break;else {b=d;a=e;}}else {b=d;a=e;}}c[a>>2]=0;d=b;}else {d=c[i+8>>2]|0;c[d+12>>2]=b;c[b+8>>2]=d;d=b;}while(0);do if(f|0){b=c[i+28>>2]|0;a=18548+(b<<2)|0;if((i|0)==(c[a>>2]|0)){c[a>>2]=d;if(!d){c[4562]=g&~(1<<b);break}}else {v=f+16|0;c[((c[v>>2]|0)==(i|0)?v:f+20|0)>>2]=d;if(!d)break}c[d+24>>2]=f;b=c[i+16>>2]|0;if(b|0){c[d+16>>2]=b;c[b+24>>2]=d;}b=c[i+20>>2]|0;if(b|0){c[d+20>>2]=b;c[b+24>>2]=d;}}while(0);if(j>>>0<16){v=j+k|0;c[i+4>>2]=v|3;v=i+v+4|0;c[v>>2]=c[v>>2]|1;}else {c[i+4>>2]=k|3;c[h+4>>2]=j|1;c[h+j>>2]=j;if(l|0){e=c[4566]|0;b=l>>>3;d=18284+(b<<1<<2)|0;b=1<<b;if(!(b&m)){c[4561]=b|m;b=d;a=d+8|0;}else {a=d+8|0;b=c[a>>2]|0;}c[a>>2]=e;c[b+12>>2]=e;c[e+8>>2]=b;c[e+12>>2]=d;}c[4563]=j;c[4566]=h;}v=i+8|0;Eb=w;return v|0}else m=k;}else m=k;}else m=k;}else if(a>>>0<=4294967231){a=a+11|0;k=a&-8;e=c[4562]|0;if(e){f=0-k|0;a=a>>>8;if(a)if(k>>>0>16777215)j=31;else {m=(a+1048320|0)>>>16&8;q=a<<m;i=(q+520192|0)>>>16&4;q=q<<i;j=(q+245760|0)>>>16&2;j=14-(i|m|j)+(q<<j>>>15)|0;j=k>>>(j+7|0)&1|j<<1;}else j=0;d=c[18548+(j<<2)>>2]|0;a:do if(!d){d=0;a=0;q=61;}else {a=0;i=k<<((j|0)==31?0:25-(j>>>1)|0);g=0;while(1){h=(c[d+4>>2]&-8)-k|0;if(h>>>0<f>>>0)if(!h){a=d;f=0;q=65;break a}else {a=d;f=h;}q=c[d+20>>2]|0;d=c[d+16+(i>>>31<<2)>>2]|0;g=(q|0)==0|(q|0)==(d|0)?g:q;if(!d){d=g;q=61;break}else i=i<<1;}}while(0);if((q|0)==61){if((d|0)==0&(a|0)==0){a=2<<j;a=(a|0-a)&e;if(!a){m=k;break}m=(a&0-a)+-1|0;h=m>>>12&16;m=m>>>h;g=m>>>5&8;m=m>>>g;i=m>>>2&4;m=m>>>i;j=m>>>1&2;m=m>>>j;d=m>>>1&1;a=0;d=c[18548+((g|h|i|j|d)+(m>>>d)<<2)>>2]|0;}if(!d){i=a;h=f;}else q=65;}if((q|0)==65){g=d;while(1){m=(c[g+4>>2]&-8)-k|0;d=m>>>0<f>>>0;f=d?m:f;a=d?g:a;d=c[g+16>>2]|0;if(!d)d=c[g+20>>2]|0;if(!d){i=a;h=f;break}else g=d;}}if(((i|0)!=0?h>>>0<((c[4563]|0)-k|0)>>>0:0)?(l=i+k|0,l>>>0>i>>>0):0){g=c[i+24>>2]|0;b=c[i+12>>2]|0;do if((b|0)==(i|0)){a=i+20|0;b=c[a>>2]|0;if(!b){a=i+16|0;b=c[a>>2]|0;if(!b){b=0;break}}while(1){f=b+20|0;d=c[f>>2]|0;if(!d){f=b+16|0;d=c[f>>2]|0;if(!d)break;else {b=d;a=f;}}else {b=d;a=f;}}c[a>>2]=0;}else {v=c[i+8>>2]|0;c[v+12>>2]=b;c[b+8>>2]=v;}while(0);do if(g){a=c[i+28>>2]|0;d=18548+(a<<2)|0;if((i|0)==(c[d>>2]|0)){c[d>>2]=b;if(!b){e=e&~(1<<a);c[4562]=e;break}}else {v=g+16|0;c[((c[v>>2]|0)==(i|0)?v:g+20|0)>>2]=b;if(!b)break}c[b+24>>2]=g;a=c[i+16>>2]|0;if(a|0){c[b+16>>2]=a;c[a+24>>2]=b;}a=c[i+20>>2]|0;if(a){c[b+20>>2]=a;c[a+24>>2]=b;}}while(0);b:do if(h>>>0<16){v=h+k|0;c[i+4>>2]=v|3;v=i+v+4|0;c[v>>2]=c[v>>2]|1;}else {c[i+4>>2]=k|3;c[l+4>>2]=h|1;c[l+h>>2]=h;b=h>>>3;if(h>>>0<256){d=18284+(b<<1<<2)|0;a=c[4561]|0;b=1<<b;if(!(a&b)){c[4561]=a|b;b=d;a=d+8|0;}else {a=d+8|0;b=c[a>>2]|0;}c[a>>2]=l;c[b+12>>2]=l;c[l+8>>2]=b;c[l+12>>2]=d;break}b=h>>>8;if(b)if(h>>>0>16777215)d=31;else {u=(b+1048320|0)>>>16&8;v=b<<u;t=(v+520192|0)>>>16&4;v=v<<t;d=(v+245760|0)>>>16&2;d=14-(t|u|d)+(v<<d>>>15)|0;d=h>>>(d+7|0)&1|d<<1;}else d=0;b=18548+(d<<2)|0;c[l+28>>2]=d;a=l+16|0;c[a+4>>2]=0;c[a>>2]=0;a=1<<d;if(!(e&a)){c[4562]=e|a;c[b>>2]=l;c[l+24>>2]=b;c[l+12>>2]=l;c[l+8>>2]=l;break}b=c[b>>2]|0;c:do if((c[b+4>>2]&-8|0)!=(h|0)){e=h<<((d|0)==31?0:25-(d>>>1)|0);while(1){d=b+16+(e>>>31<<2)|0;a=c[d>>2]|0;if(!a)break;if((c[a+4>>2]&-8|0)==(h|0)){b=a;break c}else {e=e<<1;b=a;}}c[d>>2]=l;c[l+24>>2]=b;c[l+12>>2]=l;c[l+8>>2]=l;break b}while(0);u=b+8|0;v=c[u>>2]|0;c[v+12>>2]=l;c[u>>2]=l;c[l+8>>2]=v;c[l+12>>2]=b;c[l+24>>2]=0;}while(0);v=i+8|0;Eb=w;return v|0}else m=k;}else m=k;}else m=-1;while(0);d=c[4563]|0;if(d>>>0>=m>>>0){b=d-m|0;a=c[4566]|0;if(b>>>0>15){v=a+m|0;c[4566]=v;c[4563]=b;c[v+4>>2]=b|1;c[a+d>>2]=b;c[a+4>>2]=m|3;}else {c[4563]=0;c[4566]=0;c[a+4>>2]=d|3;v=a+d+4|0;c[v>>2]=c[v>>2]|1;}v=a+8|0;Eb=w;return v|0}h=c[4564]|0;if(h>>>0>m>>>0){t=h-m|0;c[4564]=t;v=c[4567]|0;u=v+m|0;c[4567]=u;c[u+4>>2]=t|1;c[v+4>>2]=m|3;v=v+8|0;Eb=w;return v|0}if(!(c[4679]|0)){c[4681]=4096;c[4680]=4096;c[4682]=-1;c[4683]=-1;c[4684]=0;c[4672]=0;c[4679]=n&-16^1431655768;a=4096;}else a=c[4681]|0;i=m+48|0;j=m+47|0;g=a+j|0;f=0-a|0;k=g&f;if(k>>>0<=m>>>0){v=0;Eb=w;return v|0}a=c[4671]|0;if(a|0?(l=c[4669]|0,n=l+k|0,n>>>0<=l>>>0|n>>>0>a>>>0):0){v=0;Eb=w;return v|0}d:do if(!(c[4672]&4)){d=c[4567]|0;e:do if(d){e=18692;while(1){n=c[e>>2]|0;if(n>>>0<=d>>>0?(n+(c[e+4>>2]|0)|0)>>>0>d>>>0:0)break;a=c[e+8>>2]|0;if(!a){q=128;break e}else e=a;}b=g-h&f;if(b>>>0<2147483647){a=dx(b|0)|0;if((a|0)==((c[e>>2]|0)+(c[e+4>>2]|0)|0)){if((a|0)!=(-1|0)){h=b;g=a;q=145;break d}}else {e=a;q=136;}}else b=0;}else q=128;while(0);do if((q|0)==128){d=dx(0)|0;if((d|0)!=(-1|0)?(b=d,o=c[4680]|0,p=o+-1|0,b=((p&b|0)==0?0:(p+b&0-o)-b|0)+k|0,o=c[4669]|0,p=b+o|0,b>>>0>m>>>0&b>>>0<2147483647):0){n=c[4671]|0;if(n|0?p>>>0<=o>>>0|p>>>0>n>>>0:0){b=0;break}a=dx(b|0)|0;if((a|0)==(d|0)){h=b;g=d;q=145;break d}else {e=a;q=136;}}else b=0;}while(0);do if((q|0)==136){d=0-b|0;if(!(i>>>0>b>>>0&(b>>>0<2147483647&(e|0)!=(-1|0))))if((e|0)==(-1|0)){b=0;break}else {h=b;g=e;q=145;break d}a=c[4681]|0;a=j-b+a&0-a;if(a>>>0>=2147483647){h=b;g=e;q=145;break d}if((dx(a|0)|0)==(-1|0)){dx(d|0)|0;b=0;break}else {h=a+b|0;g=e;q=145;break d}}while(0);c[4672]=c[4672]|4;q=143;}else {b=0;q=143;}while(0);if(((q|0)==143?k>>>0<2147483647:0)?(t=dx(k|0)|0,p=dx(0)|0,r=p-t|0,s=r>>>0>(m+40|0)>>>0,!((t|0)==(-1|0)|s^1|t>>>0<p>>>0&((t|0)!=(-1|0)&(p|0)!=(-1|0))^1)):0){h=s?r:b;g=t;q=145;}if((q|0)==145){b=(c[4669]|0)+h|0;c[4669]=b;if(b>>>0>(c[4670]|0)>>>0)c[4670]=b;j=c[4567]|0;f:do if(j){b=18692;while(1){a=c[b>>2]|0;d=c[b+4>>2]|0;if((g|0)==(a+d|0)){q=154;break}e=c[b+8>>2]|0;if(!e)break;else b=e;}if(((q|0)==154?(u=b+4|0,(c[b+12>>2]&8|0)==0):0)?g>>>0>j>>>0&a>>>0<=j>>>0:0){c[u>>2]=d+h;v=(c[4564]|0)+h|0;t=j+8|0;t=(t&7|0)==0?0:0-t&7;u=j+t|0;t=v-t|0;c[4567]=u;c[4564]=t;c[u+4>>2]=t|1;c[j+v+4>>2]=40;c[4568]=c[4683];break}if(g>>>0<(c[4565]|0)>>>0)c[4565]=g;d=g+h|0;b=18692;while(1){if((c[b>>2]|0)==(d|0)){q=162;break}a=c[b+8>>2]|0;if(!a)break;else b=a;}if((q|0)==162?(c[b+12>>2]&8|0)==0:0){c[b>>2]=g;l=b+4|0;c[l>>2]=(c[l>>2]|0)+h;l=g+8|0;l=g+((l&7|0)==0?0:0-l&7)|0;b=d+8|0;b=d+((b&7|0)==0?0:0-b&7)|0;k=l+m|0;i=b-l-m|0;c[l+4>>2]=m|3;g:do if((j|0)==(b|0)){v=(c[4564]|0)+i|0;c[4564]=v;c[4567]=k;c[k+4>>2]=v|1;}else {if((c[4566]|0)==(b|0)){v=(c[4563]|0)+i|0;c[4563]=v;c[4566]=k;c[k+4>>2]=v|1;c[k+v>>2]=v;break}a=c[b+4>>2]|0;if((a&3|0)==1){h=a&-8;e=a>>>3;h:do if(a>>>0<256){a=c[b+8>>2]|0;d=c[b+12>>2]|0;if((d|0)==(a|0)){c[4561]=c[4561]&~(1<<e);break}else {c[a+12>>2]=d;c[d+8>>2]=a;break}}else {g=c[b+24>>2]|0;a=c[b+12>>2]|0;do if((a|0)==(b|0)){d=b+16|0;e=d+4|0;a=c[e>>2]|0;if(!a){a=c[d>>2]|0;if(!a){a=0;break}}else d=e;while(1){f=a+20|0;e=c[f>>2]|0;if(!e){f=a+16|0;e=c[f>>2]|0;if(!e)break;else {a=e;d=f;}}else {a=e;d=f;}}c[d>>2]=0;}else {v=c[b+8>>2]|0;c[v+12>>2]=a;c[a+8>>2]=v;}while(0);if(!g)break;d=c[b+28>>2]|0;e=18548+(d<<2)|0;do if((c[e>>2]|0)!=(b|0)){v=g+16|0;c[((c[v>>2]|0)==(b|0)?v:g+20|0)>>2]=a;if(!a)break h}else {c[e>>2]=a;if(a|0)break;c[4562]=c[4562]&~(1<<d);break h}while(0);c[a+24>>2]=g;d=b+16|0;e=c[d>>2]|0;if(e|0){c[a+16>>2]=e;c[e+24>>2]=a;}d=c[d+4>>2]|0;if(!d)break;c[a+20>>2]=d;c[d+24>>2]=a;}while(0);b=b+h|0;f=h+i|0;}else f=i;b=b+4|0;c[b>>2]=c[b>>2]&-2;c[k+4>>2]=f|1;c[k+f>>2]=f;b=f>>>3;if(f>>>0<256){d=18284+(b<<1<<2)|0;a=c[4561]|0;b=1<<b;if(!(a&b)){c[4561]=a|b;b=d;a=d+8|0;}else {a=d+8|0;b=c[a>>2]|0;}c[a>>2]=k;c[b+12>>2]=k;c[k+8>>2]=b;c[k+12>>2]=d;break}b=f>>>8;do if(!b)e=0;else {if(f>>>0>16777215){e=31;break}u=(b+1048320|0)>>>16&8;v=b<<u;t=(v+520192|0)>>>16&4;v=v<<t;e=(v+245760|0)>>>16&2;e=14-(t|u|e)+(v<<e>>>15)|0;e=f>>>(e+7|0)&1|e<<1;}while(0);b=18548+(e<<2)|0;c[k+28>>2]=e;a=k+16|0;c[a+4>>2]=0;c[a>>2]=0;a=c[4562]|0;d=1<<e;if(!(a&d)){c[4562]=a|d;c[b>>2]=k;c[k+24>>2]=b;c[k+12>>2]=k;c[k+8>>2]=k;break}b=c[b>>2]|0;i:do if((c[b+4>>2]&-8|0)!=(f|0)){e=f<<((e|0)==31?0:25-(e>>>1)|0);while(1){d=b+16+(e>>>31<<2)|0;a=c[d>>2]|0;if(!a)break;if((c[a+4>>2]&-8|0)==(f|0)){b=a;break i}else {e=e<<1;b=a;}}c[d>>2]=k;c[k+24>>2]=b;c[k+12>>2]=k;c[k+8>>2]=k;break g}while(0);u=b+8|0;v=c[u>>2]|0;c[v+12>>2]=k;c[u>>2]=k;c[k+8>>2]=v;c[k+12>>2]=b;c[k+24>>2]=0;}while(0);v=l+8|0;Eb=w;return v|0}b=18692;while(1){a=c[b>>2]|0;if(a>>>0<=j>>>0?(v=a+(c[b+4>>2]|0)|0,v>>>0>j>>>0):0)break;b=c[b+8>>2]|0;}f=v+-47|0;a=f+8|0;a=f+((a&7|0)==0?0:0-a&7)|0;f=j+16|0;a=a>>>0<f>>>0?j:a;b=a+8|0;d=h+-40|0;t=g+8|0;t=(t&7|0)==0?0:0-t&7;u=g+t|0;t=d-t|0;c[4567]=u;c[4564]=t;c[u+4>>2]=t|1;c[g+d+4>>2]=40;c[4568]=c[4683];d=a+4|0;c[d>>2]=27;c[b>>2]=c[4673];c[b+4>>2]=c[4674];c[b+8>>2]=c[4675];c[b+12>>2]=c[4676];c[4673]=g;c[4674]=h;c[4676]=0;c[4675]=b;b=a+24|0;do{u=b;b=b+4|0;c[b>>2]=7;}while((u+8|0)>>>0<v>>>0);if((a|0)!=(j|0)){g=a-j|0;c[d>>2]=c[d>>2]&-2;c[j+4>>2]=g|1;c[a>>2]=g;b=g>>>3;if(g>>>0<256){d=18284+(b<<1<<2)|0;a=c[4561]|0;b=1<<b;if(!(a&b)){c[4561]=a|b;b=d;a=d+8|0;}else {a=d+8|0;b=c[a>>2]|0;}c[a>>2]=j;c[b+12>>2]=j;c[j+8>>2]=b;c[j+12>>2]=d;break}b=g>>>8;if(b)if(g>>>0>16777215)e=31;else {u=(b+1048320|0)>>>16&8;v=b<<u;t=(v+520192|0)>>>16&4;v=v<<t;e=(v+245760|0)>>>16&2;e=14-(t|u|e)+(v<<e>>>15)|0;e=g>>>(e+7|0)&1|e<<1;}else e=0;d=18548+(e<<2)|0;c[j+28>>2]=e;c[j+20>>2]=0;c[f>>2]=0;b=c[4562]|0;a=1<<e;if(!(b&a)){c[4562]=b|a;c[d>>2]=j;c[j+24>>2]=d;c[j+12>>2]=j;c[j+8>>2]=j;break}b=c[d>>2]|0;j:do if((c[b+4>>2]&-8|0)!=(g|0)){e=g<<((e|0)==31?0:25-(e>>>1)|0);while(1){d=b+16+(e>>>31<<2)|0;a=c[d>>2]|0;if(!a)break;if((c[a+4>>2]&-8|0)==(g|0)){b=a;break j}else {e=e<<1;b=a;}}c[d>>2]=j;c[j+24>>2]=b;c[j+12>>2]=j;c[j+8>>2]=j;break f}while(0);u=b+8|0;v=c[u>>2]|0;c[v+12>>2]=j;c[u>>2]=j;c[j+8>>2]=v;c[j+12>>2]=b;c[j+24>>2]=0;}}else {v=c[4565]|0;if((v|0)==0|g>>>0<v>>>0)c[4565]=g;c[4673]=g;c[4674]=h;c[4676]=0;c[4570]=c[4679];c[4569]=-1;c[4574]=18284;c[4573]=18284;c[4576]=18292;c[4575]=18292;c[4578]=18300;c[4577]=18300;c[4580]=18308;c[4579]=18308;c[4582]=18316;c[4581]=18316;c[4584]=18324;c[4583]=18324;c[4586]=18332;c[4585]=18332;c[4588]=18340;c[4587]=18340;c[4590]=18348;c[4589]=18348;c[4592]=18356;c[4591]=18356;c[4594]=18364;c[4593]=18364;c[4596]=18372;c[4595]=18372;c[4598]=18380;c[4597]=18380;c[4600]=18388;c[4599]=18388;c[4602]=18396;c[4601]=18396;c[4604]=18404;c[4603]=18404;c[4606]=18412;c[4605]=18412;c[4608]=18420;c[4607]=18420;c[4610]=18428;c[4609]=18428;c[4612]=18436;c[4611]=18436;c[4614]=18444;c[4613]=18444;c[4616]=18452;c[4615]=18452;c[4618]=18460;c[4617]=18460;c[4620]=18468;c[4619]=18468;c[4622]=18476;c[4621]=18476;c[4624]=18484;c[4623]=18484;c[4626]=18492;c[4625]=18492;c[4628]=18500;c[4627]=18500;c[4630]=18508;c[4629]=18508;c[4632]=18516;c[4631]=18516;c[4634]=18524;c[4633]=18524;c[4636]=18532;c[4635]=18532;v=h+-40|0;t=g+8|0;t=(t&7|0)==0?0:0-t&7;u=g+t|0;t=v-t|0;c[4567]=u;c[4564]=t;c[u+4>>2]=t|1;c[g+v+4>>2]=40;c[4568]=c[4683];}while(0);b=c[4564]|0;if(b>>>0>m>>>0){t=b-m|0;c[4564]=t;v=c[4567]|0;u=v+m|0;c[4567]=u;c[u+4>>2]=t|1;c[v+4>>2]=m|3;v=v+8|0;Eb=w;return v|0}}v=xh()|0;c[v>>2]=12;v=0;Eb=w;return v|0}function ik(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;if(!a)return;d=a+-8|0;f=c[4565]|0;a=c[a+-4>>2]|0;b=a&-8;j=d+b|0;do if(!(a&1)){e=c[d>>2]|0;if(!(a&3))return;h=d+(0-e)|0;g=e+b|0;if(h>>>0<f>>>0)return;if((c[4566]|0)==(h|0)){a=j+4|0;b=c[a>>2]|0;if((b&3|0)!=3){i=h;b=g;break}c[4563]=g;c[a>>2]=b&-2;c[h+4>>2]=g|1;c[h+g>>2]=g;return}d=e>>>3;if(e>>>0<256){a=c[h+8>>2]|0;b=c[h+12>>2]|0;if((b|0)==(a|0)){c[4561]=c[4561]&~(1<<d);i=h;b=g;break}else {c[a+12>>2]=b;c[b+8>>2]=a;i=h;b=g;break}}f=c[h+24>>2]|0;a=c[h+12>>2]|0;do if((a|0)==(h|0)){b=h+16|0;d=b+4|0;a=c[d>>2]|0;if(!a){a=c[b>>2]|0;if(!a){a=0;break}}else b=d;while(1){e=a+20|0;d=c[e>>2]|0;if(!d){e=a+16|0;d=c[e>>2]|0;if(!d)break;else {a=d;b=e;}}else {a=d;b=e;}}c[b>>2]=0;}else {i=c[h+8>>2]|0;c[i+12>>2]=a;c[a+8>>2]=i;}while(0);if(f){b=c[h+28>>2]|0;d=18548+(b<<2)|0;if((c[d>>2]|0)==(h|0)){c[d>>2]=a;if(!a){c[4562]=c[4562]&~(1<<b);i=h;b=g;break}}else {i=f+16|0;c[((c[i>>2]|0)==(h|0)?i:f+20|0)>>2]=a;if(!a){i=h;b=g;break}}c[a+24>>2]=f;b=h+16|0;d=c[b>>2]|0;if(d|0){c[a+16>>2]=d;c[d+24>>2]=a;}b=c[b+4>>2]|0;if(b){c[a+20>>2]=b;c[b+24>>2]=a;i=h;b=g;}else {i=h;b=g;}}else {i=h;b=g;}}else {i=d;h=d;}while(0);if(h>>>0>=j>>>0)return;a=j+4|0;e=c[a>>2]|0;if(!(e&1))return;if(!(e&2)){if((c[4567]|0)==(j|0)){j=(c[4564]|0)+b|0;c[4564]=j;c[4567]=i;c[i+4>>2]=j|1;if((i|0)!=(c[4566]|0))return;c[4566]=0;c[4563]=0;return}if((c[4566]|0)==(j|0)){j=(c[4563]|0)+b|0;c[4563]=j;c[4566]=h;c[i+4>>2]=j|1;c[h+j>>2]=j;return}f=(e&-8)+b|0;d=e>>>3;do if(e>>>0<256){b=c[j+8>>2]|0;a=c[j+12>>2]|0;if((a|0)==(b|0)){c[4561]=c[4561]&~(1<<d);break}else {c[b+12>>2]=a;c[a+8>>2]=b;break}}else {g=c[j+24>>2]|0;a=c[j+12>>2]|0;do if((a|0)==(j|0)){b=j+16|0;d=b+4|0;a=c[d>>2]|0;if(!a){a=c[b>>2]|0;if(!a){d=0;break}}else b=d;while(1){e=a+20|0;d=c[e>>2]|0;if(!d){e=a+16|0;d=c[e>>2]|0;if(!d)break;else {a=d;b=e;}}else {a=d;b=e;}}c[b>>2]=0;d=a;}else {d=c[j+8>>2]|0;c[d+12>>2]=a;c[a+8>>2]=d;d=a;}while(0);if(g|0){a=c[j+28>>2]|0;b=18548+(a<<2)|0;if((c[b>>2]|0)==(j|0)){c[b>>2]=d;if(!d){c[4562]=c[4562]&~(1<<a);break}}else {e=g+16|0;c[((c[e>>2]|0)==(j|0)?e:g+20|0)>>2]=d;if(!d)break}c[d+24>>2]=g;a=j+16|0;b=c[a>>2]|0;if(b|0){c[d+16>>2]=b;c[b+24>>2]=d;}a=c[a+4>>2]|0;if(a|0){c[d+20>>2]=a;c[a+24>>2]=d;}}}while(0);c[i+4>>2]=f|1;c[h+f>>2]=f;if((i|0)==(c[4566]|0)){c[4563]=f;return}}else {c[a>>2]=e&-2;c[i+4>>2]=b|1;c[h+b>>2]=b;f=b;}a=f>>>3;if(f>>>0<256){d=18284+(a<<1<<2)|0;b=c[4561]|0;a=1<<a;if(!(b&a)){c[4561]=b|a;a=d;b=d+8|0;}else {b=d+8|0;a=c[b>>2]|0;}c[b>>2]=i;c[a+12>>2]=i;c[i+8>>2]=a;c[i+12>>2]=d;return}a=f>>>8;if(a)if(f>>>0>16777215)e=31;else {h=(a+1048320|0)>>>16&8;j=a<<h;g=(j+520192|0)>>>16&4;j=j<<g;e=(j+245760|0)>>>16&2;e=14-(g|h|e)+(j<<e>>>15)|0;e=f>>>(e+7|0)&1|e<<1;}else e=0;a=18548+(e<<2)|0;c[i+28>>2]=e;c[i+20>>2]=0;c[i+16>>2]=0;b=c[4562]|0;d=1<<e;a:do if(!(b&d)){c[4562]=b|d;c[a>>2]=i;c[i+24>>2]=a;c[i+12>>2]=i;c[i+8>>2]=i;}else {a=c[a>>2]|0;b:do if((c[a+4>>2]&-8|0)!=(f|0)){e=f<<((e|0)==31?0:25-(e>>>1)|0);while(1){d=a+16+(e>>>31<<2)|0;b=c[d>>2]|0;if(!b)break;if((c[b+4>>2]&-8|0)==(f|0)){a=b;break b}else {e=e<<1;a=b;}}c[d>>2]=i;c[i+24>>2]=a;c[i+12>>2]=i;c[i+8>>2]=i;break a}while(0);h=a+8|0;j=c[h>>2]|0;c[j+12>>2]=i;c[h>>2]=i;c[i+8>>2]=j;c[i+12>>2]=a;c[i+24>>2]=0;}while(0);j=(c[4569]|0)+-1|0;c[4569]=j;if(j|0)return;a=18700;while(1){a=c[a>>2]|0;if(!a)break;else a=a+8|0;}c[4569]=-1;return}function jk(a,b){a=a|0;b=b|0;var d=0,e=0;if(!a){b=hk(b)|0;return b|0}if(b>>>0>4294967231){b=xh()|0;c[b>>2]=12;b=0;return b|0}d=kk(a+-8|0,b>>>0<11?16:b+11&-8)|0;if(d|0){b=d+8|0;return b|0}d=hk(b)|0;if(!d){b=0;return b|0}e=c[a+-4>>2]|0;e=(e&-8)-((e&3|0)==0?8:4)|0;ax(d|0,a|0,(e>>>0<b>>>0?e:b)|0)|0;ik(a);b=d;return b|0}function kk(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;l=a+4|0;m=c[l>>2]|0;d=m&-8;i=a+d|0;if(!(m&3)){if(b>>>0<256){a=0;return a|0}if(d>>>0>=(b+4|0)>>>0?(d-b|0)>>>0<=c[4681]<<1>>>0:0)return a|0;a=0;return a|0}if(d>>>0>=b>>>0){d=d-b|0;if(d>>>0<=15)return a|0;k=a+b|0;c[l>>2]=m&1|b|2;c[k+4>>2]=d|3;m=i+4|0;c[m>>2]=c[m>>2]|1;lk(k,d);return a|0}if((c[4567]|0)==(i|0)){k=(c[4564]|0)+d|0;d=k-b|0;e=a+b|0;if(k>>>0<=b>>>0){a=0;return a|0}c[l>>2]=m&1|b|2;c[e+4>>2]=d|1;c[4567]=e;c[4564]=d;return a|0}if((c[4566]|0)==(i|0)){e=(c[4563]|0)+d|0;if(e>>>0<b>>>0){a=0;return a|0}d=e-b|0;if(d>>>0>15){k=a+b|0;e=a+e|0;c[l>>2]=m&1|b|2;c[k+4>>2]=d|1;c[e>>2]=d;e=e+4|0;c[e>>2]=c[e>>2]&-2;e=k;}else {c[l>>2]=m&1|e|2;e=a+e+4|0;c[e>>2]=c[e>>2]|1;e=0;d=0;}c[4563]=d;c[4566]=e;return a|0}e=c[i+4>>2]|0;if(e&2|0){a=0;return a|0}j=(e&-8)+d|0;if(j>>>0<b>>>0){a=0;return a|0}k=j-b|0;f=e>>>3;do if(e>>>0<256){e=c[i+8>>2]|0;d=c[i+12>>2]|0;if((d|0)==(e|0)){c[4561]=c[4561]&~(1<<f);break}else {c[e+12>>2]=d;c[d+8>>2]=e;break}}else {h=c[i+24>>2]|0;d=c[i+12>>2]|0;do if((d|0)==(i|0)){e=i+16|0;f=e+4|0;d=c[f>>2]|0;if(!d){d=c[e>>2]|0;if(!d){f=0;break}}else e=f;while(1){g=d+20|0;f=c[g>>2]|0;if(!f){g=d+16|0;f=c[g>>2]|0;if(!f)break;else {d=f;e=g;}}else {d=f;e=g;}}c[e>>2]=0;f=d;}else {f=c[i+8>>2]|0;c[f+12>>2]=d;c[d+8>>2]=f;f=d;}while(0);if(h|0){d=c[i+28>>2]|0;e=18548+(d<<2)|0;if((c[e>>2]|0)==(i|0)){c[e>>2]=f;if(!f){c[4562]=c[4562]&~(1<<d);break}}else {g=h+16|0;c[((c[g>>2]|0)==(i|0)?g:h+20|0)>>2]=f;if(!f)break}c[f+24>>2]=h;d=i+16|0;e=c[d>>2]|0;if(e|0){c[f+16>>2]=e;c[e+24>>2]=f;}d=c[d+4>>2]|0;if(d|0){c[f+20>>2]=d;c[d+24>>2]=f;}}}while(0);if(k>>>0<16){c[l>>2]=m&1|j|2;m=a+j+4|0;c[m>>2]=c[m>>2]|1;return a|0}else {i=a+b|0;c[l>>2]=m&1|b|2;c[i+4>>2]=k|3;m=a+j+4|0;c[m>>2]=c[m>>2]|1;lk(i,k);return a|0}}function lk(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;i=a+b|0;d=c[a+4>>2]|0;do if(!(d&1)){f=c[a>>2]|0;if(!(d&3))return;h=a+(0-f)|0;b=f+b|0;if((c[4566]|0)==(h|0)){a=i+4|0;d=c[a>>2]|0;if((d&3|0)!=3)break;c[4563]=b;c[a>>2]=d&-2;c[h+4>>2]=b|1;c[i>>2]=b;return}e=f>>>3;if(f>>>0<256){a=c[h+8>>2]|0;d=c[h+12>>2]|0;if((d|0)==(a|0)){c[4561]=c[4561]&~(1<<e);break}else {c[a+12>>2]=d;c[d+8>>2]=a;break}}g=c[h+24>>2]|0;a=c[h+12>>2]|0;do if((a|0)==(h|0)){d=h+16|0;e=d+4|0;a=c[e>>2]|0;if(!a){a=c[d>>2]|0;if(!a){a=0;break}}else d=e;while(1){f=a+20|0;e=c[f>>2]|0;if(!e){f=a+16|0;e=c[f>>2]|0;if(!e)break;else {a=e;d=f;}}else {a=e;d=f;}}c[d>>2]=0;}else {f=c[h+8>>2]|0;c[f+12>>2]=a;c[a+8>>2]=f;}while(0);if(g){d=c[h+28>>2]|0;e=18548+(d<<2)|0;if((c[e>>2]|0)==(h|0)){c[e>>2]=a;if(!a){c[4562]=c[4562]&~(1<<d);break}}else {f=g+16|0;c[((c[f>>2]|0)==(h|0)?f:g+20|0)>>2]=a;if(!a)break}c[a+24>>2]=g;d=h+16|0;e=c[d>>2]|0;if(e|0){c[a+16>>2]=e;c[e+24>>2]=a;}d=c[d+4>>2]|0;if(d){c[a+20>>2]=d;c[d+24>>2]=a;}}}else h=a;while(0);a=i+4|0;e=c[a>>2]|0;if(!(e&2)){if((c[4567]|0)==(i|0)){i=(c[4564]|0)+b|0;c[4564]=i;c[4567]=h;c[h+4>>2]=i|1;if((h|0)!=(c[4566]|0))return;c[4566]=0;c[4563]=0;return}if((c[4566]|0)==(i|0)){i=(c[4563]|0)+b|0;c[4563]=i;c[4566]=h;c[h+4>>2]=i|1;c[h+i>>2]=i;return}f=(e&-8)+b|0;d=e>>>3;do if(e>>>0<256){a=c[i+8>>2]|0;b=c[i+12>>2]|0;if((b|0)==(a|0)){c[4561]=c[4561]&~(1<<d);break}else {c[a+12>>2]=b;c[b+8>>2]=a;break}}else {g=c[i+24>>2]|0;b=c[i+12>>2]|0;do if((b|0)==(i|0)){a=i+16|0;d=a+4|0;b=c[d>>2]|0;if(!b){b=c[a>>2]|0;if(!b){d=0;break}}else a=d;while(1){e=b+20|0;d=c[e>>2]|0;if(!d){e=b+16|0;d=c[e>>2]|0;if(!d)break;else {b=d;a=e;}}else {b=d;a=e;}}c[a>>2]=0;d=b;}else {d=c[i+8>>2]|0;c[d+12>>2]=b;c[b+8>>2]=d;d=b;}while(0);if(g|0){b=c[i+28>>2]|0;a=18548+(b<<2)|0;if((c[a>>2]|0)==(i|0)){c[a>>2]=d;if(!d){c[4562]=c[4562]&~(1<<b);break}}else {e=g+16|0;c[((c[e>>2]|0)==(i|0)?e:g+20|0)>>2]=d;if(!d)break}c[d+24>>2]=g;b=i+16|0;a=c[b>>2]|0;if(a|0){c[d+16>>2]=a;c[a+24>>2]=d;}b=c[b+4>>2]|0;if(b|0){c[d+20>>2]=b;c[b+24>>2]=d;}}}while(0);c[h+4>>2]=f|1;c[h+f>>2]=f;if((h|0)==(c[4566]|0)){c[4563]=f;return}}else {c[a>>2]=e&-2;c[h+4>>2]=b|1;c[h+b>>2]=b;f=b;}b=f>>>3;if(f>>>0<256){d=18284+(b<<1<<2)|0;a=c[4561]|0;b=1<<b;if(!(a&b)){c[4561]=a|b;b=d;a=d+8|0;}else {a=d+8|0;b=c[a>>2]|0;}c[a>>2]=h;c[b+12>>2]=h;c[h+8>>2]=b;c[h+12>>2]=d;return}b=f>>>8;if(b)if(f>>>0>16777215)e=31;else {g=(b+1048320|0)>>>16&8;i=b<<g;d=(i+520192|0)>>>16&4;i=i<<d;e=(i+245760|0)>>>16&2;e=14-(d|g|e)+(i<<e>>>15)|0;e=f>>>(e+7|0)&1|e<<1;}else e=0;b=18548+(e<<2)|0;c[h+28>>2]=e;c[h+20>>2]=0;c[h+16>>2]=0;a=c[4562]|0;d=1<<e;if(!(a&d)){c[4562]=a|d;c[b>>2]=h;c[h+24>>2]=b;c[h+12>>2]=h;c[h+8>>2]=h;return}b=c[b>>2]|0;a:do if((c[b+4>>2]&-8|0)!=(f|0)){e=f<<((e|0)==31?0:25-(e>>>1)|0);while(1){d=b+16+(e>>>31<<2)|0;a=c[d>>2]|0;if(!a)break;if((c[a+4>>2]&-8|0)==(f|0)){b=a;break a}else {e=e<<1;b=a;}}c[d>>2]=h;c[h+24>>2]=b;c[h+12>>2]=h;c[h+8>>2]=h;return}while(0);g=b+8|0;i=c[g>>2]|0;c[i+12>>2]=h;c[g>>2]=h;c[h+8>>2]=i;c[h+12>>2]=b;c[h+24>>2]=0;return}function mk(){var a=0,b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;f=Eb;Eb=Eb+1072|0;j=f+1056|0;b=f+1048|0;k=f+1040|0;i=f+1024|0;h=f+1068|0;g=f+1064|0;e=f;f=f+1060|0;a=nk()|0;if(a|0?(d=c[a>>2]|0,d|0):0){a=d+48|0;if(!(ok(a)|0)){c[b>>2]=11846;rk(11796,b);}b=pk(a)|0;if((b|0)==1126902529&(F()|0)==1129074247)a=c[d+44>>2]|0;else a=d+80|0;c[h>>2]=a;d=c[d>>2]|0;c[f>>2]=1024;b=d+4|0;a=qk(c[b>>2]|0,e,f,g)|0;if(c[g>>2]|0)a=c[b>>2]|0;if(Pb[c[(c[526]|0)+16>>2]&15](2104,d,h)|0){k=c[h>>2]|0;k=Lb[c[(c[k>>2]|0)+8>>2]&63](k)|0;c[i>>2]=11846;c[i+4>>2]=a;c[i+8>>2]=k;rk(11710,i);}else {c[k>>2]=11846;c[k+4>>2]=a;rk(11755,k);}}rk(11834,j);}function nk(){return 18740}function ok(a){a=a|0;a=pk(a)|0;return (a&-256|0)==1126902528&(F()|0)==1129074247|0}function pk(a){a=a|0;var b=0;b=a;a=c[b>>2]|0;E(c[b+4>>2]|0);return a|0}function qk(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;i=Eb;Eb=Eb+4496|0;h=i;f=i+4472|0;if((a|0)!=0?(g=(d|0)==0,!((b|0)!=0&g)):0){Kk(h,a,a+(ai(a)|0)|0);Lk(f);a=Mk(h)|0;if(a)if(Ok(b,d,f)|0){Pk(a,f);Qk(f,0);if(!g){g=Rk(f)|0;c[d>>2]=g;}b=Sk(f)|0;a=0;}else a=-1;else a=-2;if(e|0)c[e>>2]=a;Nk(h);b=(a|0)==0?b:0;}else if(!e)b=0;else {c[e>>2]=-3;b=0;}Eb=i;return b|0}function rk(a,b){a=a|0;b=b|0;var d=0;d=Eb;Eb=Eb+16|0;c[d>>2]=b;b=c[995]|0;Dh(b,a,d)|0;ei(10,b)|0;va();}function sk(a){return}function tk(a){a=a|0;$j(a);return}function uk(a){return}function vk(a){return}function wk(d,e,f){d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0;l=Eb;Eb=Eb+64|0;j=l;if(!(Ak(d,e,0)|0))if((e|0)!=0?(k=Ek(e,2128,2112,0)|0,(k|0)!=0):0){c[j>>2]=k;c[j+4>>2]=0;c[j+8>>2]=d;c[j+12>>2]=-1;d=j+16|0;e=j+24|0;g=j+48|0;h=d;i=h+36|0;do{c[h>>2]=0;h=h+4|0;}while((h|0)<(i|0));b[d+36>>1]=0;a[d+38>>0]=0;c[g>>2]=1;$b[c[(c[k>>2]|0)+28>>2]&15](k,j,c[f>>2]|0,1);if((c[e>>2]|0)==1){c[f>>2]=c[d>>2];d=1;}else d=0;}else d=0;else d=1;Eb=l;return d|0}function xk(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;if(Ak(a,c[b+8>>2]|0,g)|0)Dk(0,b,d,e,f);return}function yk(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0;do if(!(Ak(b,c[d+8>>2]|0,g)|0)){if(Ak(b,c[d>>2]|0,g)|0){if((c[d+16>>2]|0)!=(e|0)?(h=d+20|0,(c[h>>2]|0)!=(e|0)):0){c[d+32>>2]=f;c[h>>2]=e;g=d+40|0;c[g>>2]=(c[g>>2]|0)+1;if((c[d+36>>2]|0)==1?(c[d+24>>2]|0)==2:0)a[d+54>>0]=1;c[d+44>>2]=4;break}if((f|0)==1)c[d+32>>2]=1;}}else Ck(0,d,e,f);while(0);return}function zk(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;if(Ak(a,c[b+8>>2]|0,0)|0)Bk(0,b,d,e);return}function Ak(a,b,d){a=a|0;b=b|0;d=d|0;if(d)a=(Ah(c[a+4>>2]|0,c[b+4>>2]|0)|0)==0;else a=(a|0)==(b|0);return a|0}function Bk(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0;b=d+16|0;g=c[b>>2]|0;do if(g){if((g|0)!=(e|0)){f=d+36|0;c[f>>2]=(c[f>>2]|0)+1;c[d+24>>2]=2;a[d+54>>0]=1;break}b=d+24|0;if((c[b>>2]|0)==2)c[b>>2]=f;}else {c[b>>2]=e;c[d+24>>2]=f;c[d+36>>2]=1;}while(0);return}function Ck(a,b,d,e){b=b|0;d=d|0;e=e|0;var f=0;if((c[b+4>>2]|0)==(d|0)?(f=b+28|0,(c[f>>2]|0)!=1):0)c[f>>2]=e;return}function Dk(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;a[d+53>>0]=1;do if((c[d+4>>2]|0)==(f|0)){a[d+52>>0]=1;b=d+16|0;f=c[b>>2]|0;if(!f){c[b>>2]=e;c[d+24>>2]=g;c[d+36>>2]=1;if(!((g|0)==1?(c[d+48>>2]|0)==1:0))break;a[d+54>>0]=1;break}if((f|0)!=(e|0)){g=d+36|0;c[g>>2]=(c[g>>2]|0)+1;a[d+54>>0]=1;break}f=d+24|0;b=c[f>>2]|0;if((b|0)==2){c[f>>2]=g;b=g;}if((b|0)==1?(c[d+48>>2]|0)==1:0)a[d+54>>0]=1;}while(0);return}function Ek(d,e,f,g){d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;p=Eb;Eb=Eb+64|0;n=p;m=c[d>>2]|0;o=d+(c[m+-8>>2]|0)|0;m=c[m+-4>>2]|0;c[n>>2]=f;c[n+4>>2]=d;c[n+8>>2]=e;c[n+12>>2]=g;d=n+16|0;e=n+20|0;g=n+24|0;h=n+28|0;i=n+32|0;j=n+40|0;k=d;l=k+36|0;do{c[k>>2]=0;k=k+4|0;}while((k|0)<(l|0));b[d+36>>1]=0;a[d+38>>0]=0;a:do if(Ak(m,f,0)|0){c[n+48>>2]=1;bc[c[(c[m>>2]|0)+20>>2]&3](m,n,o,o,1,0);d=(c[g>>2]|0)==1?o:0;}else {ac[c[(c[m>>2]|0)+24>>2]&7](m,n,o,1,0);switch(c[n+36>>2]|0){case 0:{d=(c[j>>2]|0)==1&(c[h>>2]|0)==1&(c[i>>2]|0)==1?c[e>>2]|0:0;break a}case 1:break;default:{d=0;break a}}if((c[g>>2]|0)!=1?!((c[j>>2]|0)==0&(c[h>>2]|0)==1&(c[i>>2]|0)==1):0){d=0;break}d=c[d>>2]|0;}while(0);Eb=p;return d|0}function Fk(a){a=a|0;$j(a);return}function Gk(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;if(Ak(a,c[b+8>>2]|0,g)|0)Dk(0,b,d,e,f);else {a=c[a+8>>2]|0;bc[c[(c[a>>2]|0)+20>>2]&3](a,b,d,e,f,g);}return}function Hk(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0;a:do if(!(Ak(b,c[d+8>>2]|0,g)|0)){if(!(Ak(b,c[d>>2]|0,g)|0)){i=c[b+8>>2]|0;ac[c[(c[i>>2]|0)+24>>2]&7](i,d,e,f,g);break}if((c[d+16>>2]|0)!=(e|0)?(i=d+20|0,(c[i>>2]|0)!=(e|0)):0){c[d+32>>2]=f;f=d+44|0;do if((c[f>>2]|0)!=4){h=d+52|0;a[h>>0]=0;j=d+53|0;a[j>>0]=0;b=c[b+8>>2]|0;bc[c[(c[b>>2]|0)+20>>2]&3](b,d,e,e,1,g);if(a[j>>0]|0){j=(a[h>>0]|0)==0;c[f>>2]=3;if(j)break;else break a}else {c[f>>2]=4;break}}while(0);c[i>>2]=e;j=d+40|0;c[j>>2]=(c[j>>2]|0)+1;if((c[d+36>>2]|0)!=1)break;if((c[d+24>>2]|0)!=2)break;a[d+54>>0]=1;break}if((f|0)==1)c[d+32>>2]=1;}else Ck(0,d,e,f);while(0);return}function Ik(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;if(Ak(a,c[b+8>>2]|0,0)|0)Bk(0,b,d,e);else {a=c[a+8>>2]|0;$b[c[(c[a>>2]|0)+28>>2]&15](a,b,d,e);}return}function Kk(a,b,c){a=a|0;b=b|0;c=c|0;nw(a,b,c);return}function Lk(a){a=a|0;c[a+12>>2]=-1;c[a+16>>2]=-1;return}function Mk(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0;g=Eb;Eb=Eb+48|0;e=g+32|0;h=g+24|0;f=g;b=g+16|0;d=g+8|0;fl(h,12025);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];do if(gl(a,e)|0){b=il(hl(a)|0)|0;c[e>>2]=b;if(!b)b=0;else {if((jl(a,0)|0)<<24>>24==46){h=a+4|0;kl(f,c[a>>2]|0,c[h>>2]|0);b=ll(a,e,f)|0;c[e>>2]=b;c[a>>2]=c[h>>2];}h=(ml(a)|0)==0;b=h?b:0;}}else {fl(b,12028);c[e>>2]=c[b>>2];c[e+4>>2]=c[b+4>>2];if(!(gl(a,e)|0)){b=rl(hl(a)|0)|0;h=(ml(a)|0)==0;b=h?b:0;break}h=il(hl(a)|0)|0;c[f>>2]=h;if(((h|0)!=0?(fl(d,12033),c[e>>2]=c[d>>2],c[e+4>>2]=c[d+4>>2],gl(a,e)|0):0)?(h=nl(a,95)|0,ol(e,a,0),!(h&(pl(e)|0))):0){if((jl(a,0)|0)<<24>>24==46)c[a>>2]=c[a+4>>2];if(!(ml(a)|0))b=ql(a,12047,f)|0;else b=0;}else b=0;}while(0);Eb=g;return b|0}function Nk(a){a=a|0;Yk(a+368|0);Zk(a+332|0);_k(a+288|0);$k(a+148|0);$k(a+8|0);return}function Ok(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;if(!a){a=hk(1024)|0;if(!a)a=0;else {b=1024;e=4;}}else {b=c[b>>2]|0;e=4;}if((e|0)==4){Xk(d,a,b);a=1;}return a|0}function Pk(b,d){b=b|0;d=d|0;Xb[c[(c[b>>2]|0)+16>>2]&127](b,d);if((a[b+5>>0]|0)!=1)Xb[c[(c[b>>2]|0)+20>>2]&127](b,d);return}function Qk(b,d){b=b|0;d=d|0;var e=0,f=0;Tk(b,1);e=c[b>>2]|0;f=b+4|0;b=c[f>>2]|0;c[f>>2]=b+1;a[e+b>>0]=d;return}function Rk(a){a=a|0;return c[a+4>>2]|0}function Sk(a){a=a|0;return c[a>>2]|0}function Tk(a,b){a=a|0;b=b|0;var d=0,e=0;b=(c[a+4>>2]|0)+b|0;d=a+8|0;e=c[d>>2]|0;if(b>>>0>=e>>>0?(e=e<<1,e=e>>>0<b>>>0?b:e,c[d>>2]=e,e=jk(c[a>>2]|0,e)|0,c[a>>2]=e,(e|0)==0):0)Uk();return}function Uk(){var a=0,b=0;a=nk()|0;if((a|0?(b=c[a>>2]|0,b|0):0)?ok(b+48|0)|0:0)Vk(c[b+12>>2]|0);Vk(Wk()|0);}function Vk(a){a=a|0;var b=0;b=Eb;Eb=Eb+16|0;Tb[a&3]();rk(11985,b);}function Wk(){return 2}function Xk(a,b,d){a=a|0;b=b|0;d=d|0;c[a+4>>2]=0;c[a>>2]=b;c[a+8>>2]=d;return}function Yk(a){a=a|0;dl(a);return}function Zk(a){a=a|0;if(!(cl(a)|0))ik(c[a>>2]|0);return}function _k(a){a=a|0;if(!(bl(a)|0))ik(c[a>>2]|0);return}function $k(a){a=a|0;if(!(al(a)|0))ik(c[a>>2]|0);return}function al(a){a=a|0;return (c[a>>2]|0)==(a+12|0)|0}function bl(a){a=a|0;return (c[a>>2]|0)==(a+12|0)|0}function cl(a){a=a|0;return (c[a>>2]|0)==(a+12|0)|0}function dl(a){a=a|0;el(a);return}function el(a){a=a|0;var b=0,d=0;b=a+4096|0;while(1){d=c[b>>2]|0;if(!d)break;c[b>>2]=c[d>>2];if((a|0)!=(d|0))ik(d);}c[a>>2]=0;c[a+4>>2]=0;c[b>>2]=a;return}function fl(a,b){a=a|0;b=b|0;c[a>>2]=b;b=b+(ai(b)|0)|0;c[a+4>>2]=b;return}function gl(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;d=Eb;Eb=Eb+32|0;e=d+16|0;f=d+8|0;g=d;kl(f,c[a>>2]|0,c[a+4>>2]|0);j=b;i=c[j+4>>2]|0;h=g;c[h>>2]=c[j>>2];c[h+4>>2]=i;c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];if(Aq(f,e)|0){j=vm(b)|0;c[a>>2]=(c[a>>2]|0)+j;a=1;}else a=0;Eb=d;return a|0}function hl(a){a=a|0;return a|0}function il(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;n=Eb;Eb=Eb+64|0;g=n+48|0;h=n+40|0;j=n+24|0;k=n+20|0;l=n+16|0;e=n+8|0;m=n;switch((jl(b,0)|0)<<24>>24){case 84:case 71:{d=vv(hl(b)|0)|0;break}default:{c[h>>2]=b;wv(j,b);i=hl(b)|0;d=zs(i,j)|0;c[k>>2]=d;if((d|0)!=0?!(xv(b,j)|0):0){if(!(yv(h)|0)){c[l>>2]=0;fl(e,17380);c[g>>2]=c[e>>2];c[g+4>>2]=c[e+4>>2];do if(gl(b,g)|0){d=b+8|0;e=Zl(d)|0;while(1){if(nl(b,69)|0){f=11;break}f=nn(i)|0;c[g>>2]=f;if(!f){f=12;break}Yl(d,g);}if((f|0)==11){sn(g,b,e);e=zv(b,g)|0;c[l>>2]=e;f=13;break}else if((f|0)==12){d=0;break}}else f=13;while(0);if((f|0)==13){c[g>>2]=0;if(((a[j>>0]|0)==0?(a[j+1>>0]|0)!=0:0)?(e=rl(i)|0,c[g>>2]=e,(e|0)==0):0)d=0;else f=16;do if((f|0)==16){if(nl(b,118)|0){bq(m);d=Av(b,g,k,m,l,j+4|0,j+8|0)|0;break}d=b+8|0;e=Zl(d)|0;while(1){f=rl(i)|0;c[m>>2]=f;if(!f){f=21;break}Yl(d,m);if(yv(h)|0){f=22;break}}if((f|0)==21){d=0;break}else if((f|0)==22){sn(m,b,e);d=Av(b,g,k,m,l,j+4|0,j+8|0)|0;break}}while(0)}}}else d=0;}}Eb=n;return d|0}function jl(b,d){b=b|0;d=d|0;var e=0;e=c[b>>2]|0;if(((c[b+4>>2]|0)-e|0)>>>0>d>>>0)b=a[e+d>>0]|0;else b=0;return b|0}function kl(a,b,d){a=a|0;b=b|0;d=d|0;c[a>>2]=b;c[a+4>>2]=d;return}function ll(a,b,c){a=a|0;b=b|0;c=c|0;return rv(a+368|0,b,c)|0}function ml(a){a=a|0;return (c[a+4>>2]|0)-(c[a>>2]|0)|0}function nl(b,d){b=b|0;d=d|0;var e=0;e=c[b>>2]|0;if((e|0)!=(c[b+4>>2]|0)?(a[e>>0]|0)==d<<24>>24:0){c[b>>2]=e+1;b=1;}else b=0;return b|0}function ol(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0;g=c[d>>2]|0;if(e)nl(d,110)|0;if((ml(d)|0)!=0?(f=c[d>>2]|0,((a[f>>0]|0)+-48|0)>>>0<10):0){while(1){if(!(ml(d)|0))break;if(((a[f>>0]|0)+-48|0)>>>0>=10)break;e=f+1|0;c[d>>2]=e;f=e;}kl(b,g,f);}else tm(b);return}function pl(a){a=a|0;return (c[a>>2]|0)==(c[a+4>>2]|0)|0}function ql(a,b,c){a=a|0;b=b|0;c=c|0;return nv(a+368|0,b,c)|0}function rl(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;j=Eb;Eb=Eb+32|0;h=j+16|0;g=j+8|0;f=j;c[h>>2]=0;d=jl(b,0)|0;a:do switch(d<<24>>24|0){case 75:case 86:case 114:{i=d<<24>>24==114;d=i&1;g=(jl(b,d)|0)<<24>>24==86;d=g?(i?2:1):d;d=d+((jl(b,d)|0)<<24>>24==75&1)|0;switch((jl(b,d)|0)<<24>>24){case 70:break;case 68:{switch((jl(b,d+1|0)|0)<<24>>24){case 120:case 119:case 79:case 111:break;default:{i=5;break a}}break}default:{i=5;break a}}d=sl(hl(b)|0)|0;c[h>>2]=d;i=81;break}case 85:{i=5;break}case 118:{c[b>>2]=(c[b>>2]|0)+1;d=ul(b,12081)|0;break}case 119:{c[b>>2]=(c[b>>2]|0)+1;d=vl(b)|0;break}case 98:{c[b>>2]=(c[b>>2]|0)+1;d=ul(b,12086)|0;break}case 99:{c[b>>2]=(c[b>>2]|0)+1;d=ul(b,12091)|0;break}case 97:{c[b>>2]=(c[b>>2]|0)+1;d=wl(b,12096)|0;break}case 104:{c[b>>2]=(c[b>>2]|0)+1;d=xl(b,12108)|0;break}case 115:{c[b>>2]=(c[b>>2]|0)+1;d=yl(b,12122)|0;break}case 116:{c[b>>2]=(c[b>>2]|0)+1;d=zl(b,12128)|0;break}case 105:{c[b>>2]=(c[b>>2]|0)+1;d=Al(b,12143)|0;break}case 106:{c[b>>2]=(c[b>>2]|0)+1;d=Bl(b,12147)|0;break}case 108:{c[b>>2]=(c[b>>2]|0)+1;d=ul(b,12160)|0;break}case 109:{c[b>>2]=(c[b>>2]|0)+1;d=xl(b,12165)|0;break}case 120:{c[b>>2]=(c[b>>2]|0)+1;d=Cl(b,12179)|0;break}case 121:{c[b>>2]=(c[b>>2]|0)+1;d=Dl(b)|0;break}case 110:{c[b>>2]=(c[b>>2]|0)+1;d=El(b,12189)|0;break}case 111:{c[b>>2]=(c[b>>2]|0)+1;d=Fl(b,12198)|0;break}case 102:{c[b>>2]=(c[b>>2]|0)+1;d=yl(b,12216)|0;break}case 100:{c[b>>2]=(c[b>>2]|0)+1;d=Gl(b)|0;break}case 101:{c[b>>2]=(c[b>>2]|0)+1;d=wl(b,12222)|0;break}case 103:{c[b>>2]=(c[b>>2]|0)+1;d=Hl(b,12234)|0;break}case 122:{c[b>>2]=(c[b>>2]|0)+1;d=Al(b,12245)|0;break}case 117:{c[b>>2]=(c[b>>2]|0)+1;Il(g,b);if(pl(g)|0)d=0;else d=Jl(b,g)|0;break}case 68:do switch((jl(b,1)|0)<<24>>24|0){case 100:{c[b>>2]=(c[b>>2]|0)+2;d=Cl(b,12249)|0;break a}case 101:{c[b>>2]=(c[b>>2]|0)+2;d=Hl(b,12259)|0;break a}case 102:{c[b>>2]=(c[b>>2]|0)+2;d=Cl(b,12270)|0;break a}case 104:{c[b>>2]=(c[b>>2]|0)+2;d=Cl(b,12280)|0;break a}case 105:{c[b>>2]=(c[b>>2]|0)+2;d=El(b,12290)|0;break a}case 115:{c[b>>2]=(c[b>>2]|0)+2;d=El(b,12299)|0;break a}case 97:{c[b>>2]=(c[b>>2]|0)+2;d=ul(b,12308)|0;break a}case 99:{c[b>>2]=(c[b>>2]|0)+2;d=zl(b,12313)|0;break a}case 110:{c[b>>2]=(c[b>>2]|0)+2;d=zl(b,12328)|0;break a}case 84:case 116:{d=Kl(hl(b)|0)|0;c[h>>2]=d;i=81;break a}case 118:{d=Ll(hl(b)|0)|0;c[h>>2]=d;i=81;break a}case 112:{c[b>>2]=(c[b>>2]|0)+2;f=rl(hl(b)|0)|0;c[g>>2]=f;if(!f){d=0;break a}else {i=Ml(b,g)|0;c[h>>2]=i;i=82;break a}}case 120:case 119:case 79:case 111:{d=sl(hl(b)|0)|0;c[h>>2]=d;i=81;break a}default:{d=0;break a}}while(0);case 70:{d=sl(hl(b)|0)|0;c[h>>2]=d;i=81;break}case 65:{d=Nl(hl(b)|0)|0;c[h>>2]=d;i=81;break}case 77:{d=Ol(hl(b)|0)|0;c[h>>2]=d;i=81;break}case 84:{switch((jl(b,1)|0)<<24>>24){case 101:case 117:case 115:{d=Pl(hl(b)|0)|0;c[h>>2]=d;i=81;break a}}d=hl(b)|0;f=Ql(d)|0;c[h>>2]=f;if(f)if((a[b+360>>0]|0)!=0?(jl(b,0)|0)<<24>>24==73:0){f=Rl(d,0)|0;c[g>>2]=f;if(!f){d=0;break a}else {i=Sl(b,h,g)|0;c[h>>2]=i;i=82;break a}}else i=82;else d=0;break}case 80:{c[b>>2]=(c[b>>2]|0)+1;f=rl(hl(b)|0)|0;c[g>>2]=f;if(!f){d=0;break a}else {i=Tl(b,g)|0;c[h>>2]=i;i=82;break a}}case 82:{c[b>>2]=(c[b>>2]|0)+1;e=rl(hl(b)|0)|0;c[g>>2]=e;if(!e){d=0;break a}else {c[f>>2]=0;i=Ul(b,g,f)|0;c[h>>2]=i;i=82;break a}}case 79:{c[b>>2]=(c[b>>2]|0)+1;e=rl(hl(b)|0)|0;c[g>>2]=e;if(!e){d=0;break a}else {c[f>>2]=1;i=Ul(b,g,f)|0;c[h>>2]=i;i=82;break a}}case 67:{c[b>>2]=(c[b>>2]|0)+1;f=rl(hl(b)|0)|0;c[g>>2]=f;if(!f){d=0;break a}else {i=Vl(b,g)|0;c[h>>2]=i;i=82;break a}}case 71:{c[b>>2]=(c[b>>2]|0)+1;f=rl(hl(b)|0)|0;c[g>>2]=f;if(!f){d=0;break a}else {i=Wl(b,g)|0;c[h>>2]=i;i=82;break a}}case 83:{switch((jl(b,1)|0)<<24>>24){case 116:case 0:{i=80;break a}}e=hl(b)|0;d=Xl(e)|0;c[g>>2]=d;if(d){if((a[b+360>>0]|0)!=0?(jl(b,0)|0)<<24>>24==73:0){e=Rl(e,0)|0;c[f>>2]=e;if(!e){d=0;break a}else {i=Sl(b,g,f)|0;c[h>>2]=i;i=82;break a}}}else d=0;break}default:i=80;}while(0);if((i|0)==5){d=tl(hl(b)|0)|0;c[h>>2]=d;i=81;}else if((i|0)==80){d=Pl(hl(b)|0)|0;c[h>>2]=d;i=81;}if((i|0)==81)if(!d)d=0;else i=82;if((i|0)==82){Yl(b+148|0,h);d=c[h>>2]|0;}Eb=j;return d|0}function sl(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;o=Eb;Eb=Eb+80|0;h=o+64|0;i=o+28|0;k=o+24|0;p=o+56|0;d=o+48|0;e=o+40|0;f=o+32|0;l=o;m=o+72|0;n=o+16|0;j=o+8|0;q=ds(b)|0;c[i>>2]=q;c[k>>2]=0;fl(p,17081);c[h>>2]=c[p>>2];c[h+4>>2]=c[p+4>>2];do if(!(gl(b,h)|0)){fl(d,17093);c[h>>2]=c[d>>2];c[h+4>>2]=c[d+4>>2];if(gl(b,h)|0){q=ao(hl(b)|0)|0;c[h>>2]=q;if(!q){d=0;break}if(nl(b,69)|0){g=Xu(b,h)|0;c[k>>2]=g;g=14;break}else {d=0;break}}fl(e,17096);c[h>>2]=c[e>>2];c[h+4>>2]=c[e+4>>2];if(gl(b,h)|0){d=b+8|0;e=Zl(d)|0;while(1){if(nl(b,69)|0){g=12;break}q=rl(hl(b)|0)|0;c[h>>2]=q;if(!q){g=13;break}Yl(d,h);}if((g|0)==12){sn(h,b,e);q=Yu(b,h)|0;c[k>>2]=q;g=14;break}else if((g|0)==13){d=0;break}}else g=14;}else {g=El(b,17084)|0;c[k>>2]=g;g=14;}while(0);if((g|0)==14){fl(f,17099);c[h>>2]=c[f>>2];c[h+4>>2]=c[f+4>>2];gl(b,h)|0;if(nl(b,70)|0){nl(b,89)|0;d=hl(b)|0;q=rl(d)|0;c[l>>2]=q;if(!q)d=0;else {a[m>>0]=0;e=b+8|0;f=Zl(e)|0;while(1){if(nl(b,69)|0){g=27;break}if(!(nl(b,118)|0)){fl(n,17102);c[h>>2]=c[n>>2];c[h+4>>2]=c[n+4>>2];if(gl(b,h)|0){g=21;break}fl(j,17105);c[h>>2]=c[j>>2];c[h+4>>2]=c[j+4>>2];if(gl(b,h)|0){g=23;break}q=rl(d)|0;c[h>>2]=q;if(!q){g=26;break}Yl(e,h);}}if((g|0)==21){a[m>>0]=1;g=27;}else if((g|0)==23){a[m>>0]=2;g=27;}else if((g|0)==26)d=0;if((g|0)==27){sn(h,b,f);d=Zu(b,l,h,i,m,k)|0;}}}else d=0;}Eb=o;return d|0}function tl(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0;i=Eb;Eb=Eb+64|0;g=i+48|0;h=i+40|0;b=i+32|0;d=i;e=i+20|0;f=i+8|0;if(nl(a,85)|0){Il(h,a);do if(pl(h)|0)b=0;else {fl(b,16896);c[g>>2]=c[b>>2];c[g+4>>2]=c[b+4>>2];if(!(Aq(h,g)|0)){f=tl(hl(a)|0)|0;c[g>>2]=f;if(!f)b=0;else b=Eu(a,g,h)|0;break}No(g,h,9);tm(d);Bu(e,a,wm(g)|0);Bu(f,a+4|0,en(g)|0);Il(d,a);Cu(f);Cu(e);if(pl(d)|0)b=0;else {h=tl(hl(a)|0)|0;c[e>>2]=h;if(!h)b=0;else b=Du(a,e,d)|0;}}while(0)}else {d=ds(a)|0;c[g>>2]=d;b=rl(hl(a)|0)|0;c[h>>2]=b;if(b){if(d){b=Fu(a,h,g)|0;c[h>>2]=b;}}else b=0;}Eb=i;return b|0}function ul(a,b){a=a|0;b=b|0;return Au(a+368|0,b)|0}function vl(a){a=a|0;return zu(a+368|0,13001)|0}function wl(a,b){a=a|0;b=b|0;return yu(a+368|0,b)|0}function xl(a,b){a=a|0;b=b|0;return xu(a+368|0,b)|0}function yl(a,b){a=a|0;b=b|0;return wu(a+368|0,b)|0}function zl(a,b){a=a|0;b=b|0;return vu(a+368|0,b)|0}function Al(a,b){a=a|0;b=b|0;return uu(a+368|0,b)|0}function Bl(a,b){a=a|0;b=b|0;return tu(a+368|0,b)|0}function Cl(a,b){a=a|0;b=b|0;return su(a+368|0,b)|0}function Dl(a){a=a|0;return ru(a+368|0,16877)|0}function El(a,b){a=a|0;b=b|0;return qu(a+368|0,b)|0}function Fl(a,b){a=a|0;b=b|0;return pu(a+368|0,b)|0}function Gl(a){a=a|0;return ou(a+368|0,16870)|0}function Hl(a,b){a=a|0;b=b|0;return nu(a+368|0,b)|0}function Il(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;g=Eb;Eb=Eb+16|0;d=g+8|0;e=g;c[d>>2]=0;if(!(zq(b,d)|0)?(h=ml(b)|0,f=c[d>>2]|0,h>>>0>=f>>>0):0){h=c[b>>2]|0;kl(e,h,h+f|0);c[b>>2]=(c[b>>2]|0)+f;f=c[e+4>>2]|0;h=a;c[h>>2]=c[e>>2];c[h+4>>2]=f;}else tm(a);Eb=g;return}function Jl(a,b){a=a|0;b=b|0;return mu(a+368|0,b)|0}function Kl(a){a=a|0;var b=0,d=0,e=0;d=Eb;Eb=Eb+16|0;b=d;do if(nl(a,68)|0){if(!(nl(a,116)|0)?!(nl(a,84)|0):0){a=0;break}e=ao(hl(a)|0)|0;c[b>>2]=e;if((e|0)!=0?nl(a,69)|0:0)a=Wo(a,16860,b)|0;else a=0;}else a=0;while(0);Eb=d;return a|0}function Ll(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;f=Eb;Eb=Eb+32|0;b=f+16|0;d=f+8|0;e=f;fl(d,16735);c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];do if(gl(a,b)|0){if(((jl(a,0)|0)+-49&255)<9){ol(b,a,0);do if(nl(a,95)|0){if(nl(a,112)|0){b=_t(a,b)|0;break}d=rl(hl(a)|0)|0;c[e>>2]=d;if(!d)b=0;else b=$t(a,e,b)|0;}else b=0;while(0);break}if(nl(a,95)|0){d=rl(hl(a)|0)|0;c[b>>2]=d;if(!d)b=0;else {tm(e);b=bu(a,b,e)|0;}break}d=hl(a)|0;g=ao(d)|0;c[b>>2]=g;if((g|0)!=0?nl(a,95)|0:0){g=rl(d)|0;c[e>>2]=g;if(!g)b=0;else b=au(a,e,b)|0;}else b=0;}else b=0;while(0);Eb=f;return b|0}function Ml(a,b){a=a|0;b=b|0;return Zt(a+368|0,b)|0}function Nl(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;g=Eb;Eb=Eb+32|0;d=g+16|0;e=g;b=g+8|0;if(nl(a,65)|0){Kt(e);if((((jl(a,0)|0)<<24>>24)+-48|0)>>>0<10){ol(b,a,0);c[d>>2]=c[b>>2];c[d+4>>2]=c[b+4>>2];Lt(e,d);if(nl(a,95)|0)f=8;else b=0;}else if(!(nl(a,95)|0)){b=ao(hl(a)|0)|0;if((b|0)!=0?nl(a,95)|0:0){Mt(e,b);f=8;}else b=0;}else f=8;if((f|0)==8){f=rl(hl(a)|0)|0;c[d>>2]=f;if(!f)b=0;else b=Nt(a,d,e)|0;}}else b=0;Eb=g;return b|0}function Ol(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;f=Eb;Eb=Eb+16|0;b=f+4|0;d=f;if(nl(a,77)|0){e=hl(a)|0;g=rl(e)|0;c[b>>2]=g;if(!g)a=0;else {g=rl(e)|0;c[d>>2]=g;if(!g)a=0;else a=Dt(a,b,d)|0;}}else a=0;Eb=f;return a|0}function Pl(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0;g=Eb;Eb=Eb+48|0;e=g+32|0;f=g;h=g+24|0;b=g+16|0;d=g+8|0;tm(f);fl(h,15791);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];do if(!(gl(a,e)|0)){fl(b,15801);c[e>>2]=c[b>>2];c[e+4>>2]=c[b+4>>2];if(gl(a,e)|0){fl(f,15804);break}fl(d,15810);c[e>>2]=c[d>>2];c[e+4>>2]=c[d+4>>2];if(gl(a,e)|0)fl(f,15813);}else fl(f,15794);while(0);b=zs(hl(a)|0,0)|0;c[e>>2]=b;if(b){if(!(pl(f)|0))b=As(a,f,e)|0;}else b=0;Eb=g;return b|0}function Ql(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;i=Eb;Eb=Eb+16|0;e=i+4|0;f=i;if(nl(b,84)|0){c[e>>2]=0;if(!(nl(b,95)|0))if(!(zq(b,e)|0)?(d=(c[e>>2]|0)+1|0,c[e>>2]=d,nl(b,95)|0):0){g=d;h=5;}else d=0;else {g=0;h=5;}do if((h|0)==5){if(a[b+362>>0]|0){d=ul(b,12308)|0;break}if(a[b+361>>0]|0){d=ls(b,e)|0;c[f>>2]=d;ms(b+332|0,f);break}d=b+288|0;if(g>>>0<(Gn(d)|0)>>>0){d=ns(d,g)|0;d=c[d>>2]|0;}else d=0;}while(0)}else d=0;Eb=i;return d|0}function Rl(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;l=Eb;Eb=Eb+64|0;j=l+16|0;e=l+12|0;f=l+8|0;g=l;do if(nl(a,73)|0){h=a+288|0;if(b)ln(h);i=a+8|0;k=Zl(i)|0;while(1){if(nl(a,69)|0){d=16;break}if(b){mn(j,h);d=nn(hl(a)|0)|0;c[e>>2]=d;on(h,j);if(!d){d=12;break}Yl(i,e);c[f>>2]=d;if((Vm(d)|0)<<24>>24==28){pn(g,d);d=qn(a,g)|0;c[f>>2]=d;}rn(h,f);_k(j);}else {d=nn(hl(a)|0)|0;c[j>>2]=d;if(!d){d=15;break}Yl(i,j);}}if((d|0)==12){_k(j);b=0;break}else if((d|0)==15){b=0;break}else if((d|0)==16){sn(j,a,k);b=tn(a,j)|0;break}}else b=0;while(0);Eb=l;return b|0}function Sl(a,b,c){a=a|0;b=b|0;c=c|0;return fn(a+368|0,b,c)|0}function Tl(a,b){a=a|0;b=b|0;return Xm(a+368|0,b)|0}function Ul(a,b,c){a=a|0;b=b|0;c=c|0;return Km(a+368|0,b,c)|0}function Vl(a,b){a=a|0;b=b|0;return Jm(a+368|0,b,12702)|0}function Wl(a,b){a=a|0;b=b|0;return Fm(a+368|0,b,12634)|0}function Xl(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;f=g;a:do if(nl(a,83)|0){e=(jl(a,0)|0)<<24>>24;if(!(zh(e)|0)){if(nl(a,95)|0){b=a+148|0;if(bm(b)|0){b=0;break}b=cm(b,0)|0;b=c[b>>2]|0;break}c[f>>2]=0;if((!(dm(a,f)|0)?(b=(c[f>>2]|0)+1|0,c[f>>2]=b,nl(a,95)|0):0)?(d=a+148|0,b>>>0<(Zl(d)|0)>>>0):0){b=cm(d,b)|0;b=c[b>>2]|0;}else b=0;break}switch(e|0){case 97:{c[a>>2]=(c[a>>2]|0)+1;c[f>>2]=0;b=$l(a,f)|0;break}case 98:{c[a>>2]=(c[a>>2]|0)+1;c[f>>2]=1;b=$l(a,f)|0;break}case 115:{c[a>>2]=(c[a>>2]|0)+1;c[f>>2]=2;b=$l(a,f)|0;break}case 105:{c[a>>2]=(c[a>>2]|0)+1;c[f>>2]=3;b=$l(a,f)|0;break}case 111:{c[a>>2]=(c[a>>2]|0)+1;c[f>>2]=4;b=$l(a,f)|0;break}case 100:{c[a>>2]=(c[a>>2]|0)+1;c[f>>2]=5;b=$l(a,f)|0;break}default:{b=0;break a}}d=am(hl(a)|0,b)|0;c[f>>2]=d;if((d|0)!=(b|0)){Yl(a+148|0,f);b=d;}}else b=0;while(0);Eb=g;return b|0}function Yl(a,b){a=a|0;b=b|0;var d=0,e=0;e=a+4|0;d=c[e>>2]|0;if((d|0)==(c[a+8>>2]|0)){_l(a,(Zl(a)|0)<<1);d=c[e>>2]|0;}b=c[b>>2]|0;c[e>>2]=d+4;c[d>>2]=b;return}function Zl(a){a=a|0;return (c[a+4>>2]|0)-(c[a>>2]|0)>>2|0}function _l(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;h=Zl(a)|0;do if(!(al(a)|0)){e=jk(c[a>>2]|0,b<<2)|0;c[a>>2]=e;if(!e)Uk();else {f=e;d=a+4|0;break}}else {f=hk(b<<2)|0;if(!f)Uk();g=c[a>>2]|0;d=a+4|0;e=(c[d>>2]|0)-g|0;if(e|0)bx(f|0,g|0,e|0)|0;c[a>>2]=f;}while(0);c[d>>2]=f+(h<<2);c[a+8>>2]=f+(b<<2);return}function $l(a,b){a=a|0;b=b|0;return Am(a+368|0,b)|0}function am(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;d=g;e=g+8|0;c[d>>2]=b;while(1){if(!(nl(a,66)|0))break;Il(e,a);if(pl(e)|0){f=5;break}b=fm(a,d,e)|0;c[d>>2]=b;}if((f|0)==5)b=0;Eb=g;return b|0}function bm(a){a=a|0;return (c[a>>2]|0)==(c[a+4>>2]|0)|0}function cm(a,b){a=a|0;b=b|0;return (em(a)|0)+(b<<2)|0}function dm(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;f=jl(a,0)|0;if(f<<24>>24>47?f<<24>>24<58|(f+-65&255)<26:0){d=0;while(1){f=jl(a,0)|0;if(f<<24>>24<=47)break;if(f<<24>>24>=58)if((f+-65&255)<26)e=-55;else break;else e=-48;c[a>>2]=(c[a>>2]|0)+1;d=(d*36|0)+e+(f<<24>>24)|0;}c[b>>2]=d;d=0;}else d=1;return d|0}function em(a){a=a|0;return c[a>>2]|0}function fm(a,b,c){a=a|0;b=b|0;c=c|0;return gm(a+368|0,b,c)|0}function gm(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];im(a,b,f);Eb=e;return a|0}function hm(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;g=b+15&-16;h=a+4096|0;d=c[h>>2]|0;e=d+4|0;b=c[e>>2]|0;f=b+g|0;do if(f>>>0>4087)if(g>>>0>4088){b=ym(a,g)|0;break}else {zm(a);d=c[h>>2]|0;e=d+4|0;b=c[e>>2]|0;f=b+g|0;i=5;break}else i=5;while(0);if((i|0)==5){c[e>>2]=f;b=d+8+b|0;}return b|0}function im(b,d,e){b=b|0;d=d|0;e=e|0;var f=0;jm(b,8,a[d+5>>0]|0,a[d+6>>0]|0,a[d+7>>0]|0);c[b>>2]=4316;c[b+8>>2]=d;f=e;d=c[f+4>>2]|0;e=b+12|0;c[e>>2]=c[f>>2];c[e+4>>2]=d;return}function jm(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;c[b>>2]=4360;a[b+4>>0]=d;a[b+5>>0]=e;a[b+6>>0]=f;a[b+7>>0]=g;return}function km(a,b){return 0}function lm(a,b){return 0}function mm(a,b){return 0}function nm(a,b){a=a|0;return a|0}function om(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;d=Eb;Eb=Eb+32|0;e=d+24|0;i=d+16|0;g=d;f=d+8|0;h=c[a+8>>2]|0;Xb[c[(c[h>>2]|0)+16>>2]&127](h,b);fl(i,12343);c[e>>2]=c[i>>2];c[e+4>>2]=c[i+4>>2];um(b,e);i=a+12|0;h=c[i+4>>2]|0;a=g;c[a>>2]=c[i>>2];c[a+4>>2]=h;c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);fl(f,12349);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function pm(a,b){return}function qm(a,b){a=a|0;tm(a);return}function rm(a){return}function sm(a){a=a|0;$j(a);return}function tm(a){a=a|0;c[a>>2]=0;c[a+4>>2]=0;return}function um(a,b){a=a|0;b=b|0;var d=0,e=0;d=vm(b)|0;if(d|0){Tk(a,d);e=a+4|0;a=(c[a>>2]|0)+(c[e>>2]|0)|0;bx(a|0,wm(b)|0,d|0)|0;c[e>>2]=(c[e>>2]|0)+d;}return}function vm(a){a=a|0;return (c[a+4>>2]|0)-(c[a>>2]|0)|0}function wm(a){a=a|0;return c[a>>2]|0}function xm(a){Aa();}function ym(a,b){a=a|0;b=b|0;b=hk(b+8|0)|0;if(!b)Uk();else {a=c[a+4096>>2]|0;c[b>>2]=c[a>>2];c[b+4>>2]=0;c[a>>2]=b;return b+8|0}return 0}function zm(a){a=a|0;var b=0;b=hk(4096)|0;if(!b)Uk();else {a=a+4096|0;c[b>>2]=c[a>>2];c[b+4>>2]=0;c[a>>2]=b;return}}function Am(a,b){a=a|0;b=b|0;a=hm(a,12)|0;Bm(a,c[b>>2]|0);return a|0}function Bm(a,b){a=a|0;b=b|0;jm(a,36,1,1,1);c[a>>2]=4404;c[a+8>>2]=b;return}function Cm(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;k=Eb;Eb=Eb+64|0;d=k+48|0;e=k+40|0;f=k+32|0;g=k+24|0;h=k+16|0;i=k+8|0;j=k;switch(c[a+8>>2]|0){case 0:{fl(e,12493);c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];um(b,d);break}case 1:{fl(f,12508);c[d>>2]=c[f>>2];c[d+4>>2]=c[f+4>>2];um(b,d);break}case 2:{fl(g,12526);c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];um(b,d);break}case 3:{fl(h,12538);c[d>>2]=c[h>>2];c[d+4>>2]=c[h+4>>2];um(b,d);break}case 4:{fl(i,12551);c[d>>2]=c[i>>2];c[d+4>>2]=c[i+4>>2];um(b,d);break}case 5:{fl(j,12564);c[d>>2]=c[j>>2];c[d+4>>2]=c[j+4>>2];um(b,d);break}}Eb=k;return}function Dm(a,b){a=a|0;b=b|0;switch(c[b+8>>2]|0){case 0:{fl(a,12438);break}case 1:{fl(a,12448);break}case 2:{fl(a,12461);break}case 3:{fl(a,12468);break}case 4:{fl(a,12476);break}case 5:{fl(a,12484);break}}return}function Em(a){a=a|0;$j(a);return}function Fm(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;fl(g,d);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Gm(a,b,f);Eb=e;return a|0}function Gm(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,5,1,1,1);c[a>>2]=4448;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function Hm(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;h=c[a+8>>2]|0;Xb[c[(c[h>>2]|0)+16>>2]&127](h,b);h=a+12|0;g=c[h+4>>2]|0;a=f;c[a>>2]=c[h>>2];c[a+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Im(a){a=a|0;$j(a);return}function Jm(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;fl(g,d);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Gm(a,b,f);Eb=e;return a|0}function Km(a,b,d){a=a|0;b=b|0;d=d|0;a=hm(a,20)|0;Lm(a,c[b>>2]|0,c[d>>2]|0);return a|0}function Lm(b,d,e){b=b|0;d=d|0;e=e|0;jm(b,12,a[d+5>>0]|0,1,1);c[b>>2]=4492;c[b+8>>2]=d;c[b+12>>2]=e;a[b+16>>0]=0;return}function Mm(a,b){a=a|0;b=b|0;return Wm(c[a+8>>2]|0,b)|0}function Nm(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;l=Eb;Eb=Eb+48|0;f=l+40|0;g=l+24|0;h=l+8|0;i=l+32|0;j=l+16|0;k=l;e=b+16|0;if(!(a[e>>0]|0)){Qm(g,e,1);Rm(h,b,d);b=c[h+4>>2]|0;Xb[c[(c[b>>2]|0)+16>>2]&127](b,d);if(Sm(b,d)|0){fl(i,12713);c[f>>2]=c[i>>2];c[f+4>>2]=c[i+4>>2];um(d,f);}if(!(!(Sm(b,d)|0)?!(Tm(b,d)|0):0)){fl(j,12715);c[f>>2]=c[j>>2];c[f+4>>2]=c[j+4>>2];um(d,f);}fl(k,(c[h>>2]|0)==0?12717:12719);c[f>>2]=c[k>>2];c[f+4>>2]=c[k+4>>2];um(d,f);Um(g);}Eb=l;return}function Om(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=Eb;Eb=Eb+32|0;g=j+24|0;h=j+16|0;e=j+8|0;i=j;f=b+16|0;if(!(a[f>>0]|0)){Qm(h,f,1);Rm(e,b,d);b=c[e+4>>2]|0;if(!(!(Sm(b,d)|0)?!(Tm(b,d)|0):0)){fl(i,12711);c[g>>2]=c[i>>2];c[g+4>>2]=c[i+4>>2];um(d,g);}Xb[c[(c[b>>2]|0)+20>>2]&127](b,d);Um(h);}Eb=j;return}function Pm(a){a=a|0;$j(a);return}function Qm(b,d,e){b=b|0;d=d|0;e=e|0;c[b>>2]=d;a[b+4>>0]=a[d>>0]|0;a[b+5>>0]=1;a[d>>0]=e&1;return}function Rm(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0;e=c[b+12>>2]|0;c[a>>2]=e;f=a+4|0;b=c[b+8>>2]|0;c[f>>2]=b;while(1){b=Ob[c[(c[b>>2]|0)+12>>2]&63](b,d)|0;if((Vm(b)|0)<<24>>24!=12)break;h=c[b+8>>2]|0;c[f>>2]=h;g=c[b+12>>2]|0;g=(g|0)<(e|0)?g:e;c[a>>2]=g;b=h;e=g;}return}function Sm(b,d){b=b|0;d=d|0;var e=0;e=a[b+6>>0]|0;if(e<<24>>24==2)b=Ob[c[(c[b>>2]|0)+4>>2]&63](b,d)|0;else b=e<<24>>24==0;return b|0}function Tm(b,d){b=b|0;d=d|0;var e=0;e=a[b+7>>0]|0;if(e<<24>>24==2)b=Ob[c[(c[b>>2]|0)+8>>2]&63](b,d)|0;else b=e<<24>>24==0;return b|0}function Um(b){b=b|0;if(a[b+5>>0]|0)a[c[b>>2]>>0]=a[b+4>>0]|0;return}function Vm(b){b=b|0;return a[b+4>>0]|0}function Wm(b,d){b=b|0;d=d|0;var e=0;e=a[b+5>>0]|0;if(e<<24>>24==2)b=Ob[c[c[b>>2]>>2]&63](b,d)|0;else b=e<<24>>24==0;return b|0}function Xm(a,b){a=a|0;b=b|0;a=hm(a,12)|0;Ym(a,c[b>>2]|0);return a|0}function Ym(b,d){b=b|0;d=d|0;jm(b,11,a[d+5>>0]|0,1,1);c[b>>2]=4536;c[b+8>>2]=d;return}function Zm(a,b){a=a|0;b=b|0;return Wm(c[a+8>>2]|0,b)|0}function _m(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;m=Eb;Eb=Eb+64|0;h=m+48|0;i=m+40|0;j=m+32|0;k=m+24|0;d=m+16|0;e=m;f=m+8|0;g=a+8|0;a=c[g>>2]|0;do if((Vm(a)|0)<<24>>24==10)if(bn(a)|0){i=c[g>>2]|0;fl(d,12786);c[h>>2]=c[d>>2];c[h+4>>2]=c[d+4>>2];um(b,h);i=i+12|0;j=c[i+4>>2]|0;k=e;c[k>>2]=c[i>>2];c[k+4>>2]=j;c[h>>2]=c[e>>2];c[h+4>>2]=c[e+4>>2];um(b,h);fl(f,12790);c[h>>2]=c[f>>2];c[h+4>>2]=c[f+4>>2];um(b,h);break}else {a=c[g>>2]|0;l=4;break}else l=4;while(0);if((l|0)==4){Xb[c[(c[a>>2]|0)+16>>2]&127](a,b);if(Sm(c[g>>2]|0,b)|0){fl(i,12713);c[h>>2]=c[i>>2];c[h+4>>2]=c[i+4>>2];um(b,h);}if(!(!(Sm(c[g>>2]|0,b)|0)?!(Tm(c[g>>2]|0,b)|0):0)){fl(j,12715);c[h>>2]=c[j>>2];c[h+4>>2]=c[j+4>>2];um(b,h);}fl(k,12784);c[h>>2]=c[k>>2];c[h+4>>2]=c[k+4>>2];um(b,h);}Eb=m;return}function $m(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;h=Eb;Eb=Eb+16|0;e=h+8|0;f=h;d=a+8|0;a=c[d>>2]|0;if((Vm(a)|0)<<24>>24==10){if(!(bn(a)|0)){a=c[d>>2]|0;g=4;}}else g=4;if((g|0)==4){if(!(!(Sm(a,b)|0)?!(Tm(c[d>>2]|0,b)|0):0)){fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);}g=c[d>>2]|0;Xb[c[(c[g>>2]|0)+20>>2]&127](g,b);}Eb=h;return}function an(a){a=a|0;$j(a);return}function bn(a){a=a|0;var b=0,d=0,e=0;e=Eb;Eb=Eb+16|0;b=e+8|0;d=e;a=c[a+8>>2]|0;if((Vm(a)|0)<<24>>24==7){cn(b,a);fl(d,12772);a=dn(b,d)|0;}else a=0;Eb=e;return a|0}function cn(a,b){a=a|0;b=b|0;var d=0,e=0;e=b+8|0;d=c[e+4>>2]|0;b=a;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function dn(b,c){b=b|0;c=c|0;var d=0,e=0;d=vm(b)|0;a:do if((d|0)==(vm(c)|0)){e=wm(b)|0;d=en(b)|0;b=wm(c)|0;c=e;while(1){if((c|0)==(d|0)){b=1;break a}if((a[c>>0]|0)!=(a[b>>0]|0)){b=0;break a}b=b+1|0;c=c+1|0;}}else b=0;while(0);return b|0}function en(a){a=a|0;return c[a+4>>2]|0}function fn(a,b,d){a=a|0;b=b|0;d=d|0;a=hm(a,16)|0;gn(a,c[b>>2]|0,c[d>>2]|0);return a|0}function gn(a,b,d){a=a|0;b=b|0;d=d|0;jm(a,32,1,1,1);c[a>>2]=4580;c[a+8>>2]=b;c[a+12>>2]=d;return}function hn(a,b){a=a|0;b=b|0;Pk(c[a+8>>2]|0,b);Pk(c[a+12>>2]|0,b);return}function jn(a,b){a=a|0;b=b|0;b=c[b+8>>2]|0;Xb[c[(c[b>>2]|0)+24>>2]&127](a,b);return}function kn(a){a=a|0;$j(a);return}function ln(a){a=a|0;c[a+4>>2]=c[a>>2];return}function mn(a,b){a=a|0;b=b|0;var d=0,e=0;ks(a);if(bl(b)|0){d=_n(b)|0;e=($n(b)|0)-d|0;if(e|0)bx(c[a>>2]|0,d|0,e|0)|0;e=c[a>>2]|0;e=e+((Gn(b)|0)<<2)|0;c[a+4>>2]=e;ln(b);}else {c[a>>2]=c[b>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];Zn(b);}return}function nn(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;d=g;a:do switch((jl(a,0)|0)<<24>>24|0){case 88:{c[a>>2]=(c[a>>2]|0)+1;b=ao(hl(a)|0)|0;if(!b)b=0;else {a=nl(a,69)|0;Eb=g;return (a?b:0)|0}break}case 74:{c[a>>2]=(c[a>>2]|0)+1;b=a+8|0;e=Zl(b)|0;while(1){if(nl(a,69)|0){f=9;break}f=nn(hl(a)|0)|0;c[d>>2]=f;if(!f){f=8;break}Yl(b,d);}if((f|0)==8){b=0;break a}else if((f|0)==9){sn(d,a,e);b=bo(a,d)|0;break a}break}case 76:{if((jl(a,1)|0)<<24>>24!=90){b=co(hl(a)|0)|0;break a}c[a>>2]=(c[a>>2]|0)+2;b=il(hl(a)|0)|0;if(!b)b=0;else {a=nl(a,69)|0;b=a?b:0;}break}default:b=rl(hl(a)|0)|0;}while(0);Eb=g;return b|0}function on(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;e=bl(b)|0;d=bl(a)|0;do if(!e)if(d){c[a>>2]=c[b>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];Zn(b);break}else {f=c[a>>2]|0;c[a>>2]=c[b>>2];c[b>>2]=f;f=a+4|0;d=b+4|0;e=c[f>>2]|0;c[f>>2]=c[d>>2];c[d>>2]=e;d=a+8|0;a=b+8|0;e=c[d>>2]|0;c[d>>2]=c[a>>2];c[a>>2]=e;ln(b);break}else {if(!d){ik(c[a>>2]|0);Zn(a);}d=_n(b)|0;e=($n(b)|0)-d|0;if(e|0)bx(c[a>>2]|0,d|0,e|0)|0;f=c[a>>2]|0;f=f+((Gn(b)|0)<<2)|0;c[a+4>>2]=f;ln(b);}while(0);return}function pn(a,b){a=a|0;b=b|0;var d=0,e=0;e=b+8|0;d=c[e+4>>2]|0;b=a;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function qn(a,b){a=a|0;b=b|0;return In(a+368|0,b)|0}function rn(a,b){a=a|0;b=b|0;var d=0,e=0;e=a+4|0;d=c[e>>2]|0;if((d|0)==(c[a+8>>2]|0)){Hn(a,(Gn(a)|0)<<1);d=c[e>>2]|0;}b=c[b>>2]|0;c[e>>2]=d+4;c[d>>2]=b;return}function sn(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=b+8|0;e=(em(d)|0)+(c<<2)|0;Cn(a,b,e,Bn(d)|0);Dn(d,c);return}function tn(a,b){a=a|0;b=b|0;return un(a+368|0,b)|0}function un(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];vn(a,e);Eb=d;return a|0}function vn(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,30,1,1,1);c[a>>2]=4624;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function wn(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;g=Eb;Eb=Eb+32|0;d=g+24|0;h=g+16|0;e=g+8|0;f=g;fl(h,12897);c[d>>2]=c[h>>2];c[d+4>>2]=c[h+4>>2];um(b,d);yn(a+8|0,b);if((zn(b)|0)<<24>>24==62){fl(e,12713);c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];um(b,d);}fl(f,12790);c[d>>2]=c[f>>2];c[d+4>>2]=c[f+4>>2];um(b,d);Eb=g;return}function xn(a){a=a|0;$j(a);return}function yn(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;j=Eb;Eb=Eb+16|0;g=j+8|0;h=j;i=a+4|0;d=1;f=0;while(1){if((f|0)==(c[i>>2]|0))break;e=Rk(b)|0;if(!d){fl(h,12899);c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];um(b,g);}k=Rk(b)|0;Pk(c[(c[a>>2]|0)+(f<<2)>>2]|0,b);if((k|0)==(Rk(b)|0))An(b,e);else d=0;f=f+1|0;}Eb=j;return}function zn(b){b=b|0;var d=0;d=c[b+4>>2]|0;if(!d)b=0;else b=a[(c[b>>2]|0)+(d+-1)>>0]|0;return b|0}function An(a,b){a=a|0;b=b|0;c[a+4>>2]=b;return}function Bn(a){a=a|0;return c[a+4>>2]|0}function Cn(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;e=d-c|0;f=e>>2;d=En(b+368|0,f)|0;if(e|0)bx(d|0,c|0,e|0)|0;Fn(a,d,f);return}function Dn(a,b){a=a|0;b=b|0;c[a+4>>2]=(c[a>>2]|0)+(b<<2);return}function En(a,b){a=a|0;b=b|0;return hm(a,b<<2)|0}function Fn(a,b,d){a=a|0;b=b|0;d=d|0;c[a>>2]=b;c[a+4>>2]=d;return}function Gn(a){a=a|0;return (c[a+4>>2]|0)-(c[a>>2]|0)>>2|0}
            function cc(){sh();fi();}function dc(a){a=a|0;var b=0;b=Eb;Eb=Eb+a|0;Eb=Eb+15&-16;return b|0}function ec(){return Eb|0}function fc(a){a=a|0;Eb=a;}function gc(a,b){a=a|0;Eb=a;}function hc(a,b,d){a=a|0;b=+b;d=+d;var e=0,f=0,g=0;g=+s(b)>=1.0?(b>0.0?~~+B(+r(b/4294967296.0),4294967295.0)>>>0:~~+z((b-+(~~b>>>0))/4294967296.0)>>>0):0;e=+s(d)>=1.0?(d>0.0?~~+B(+r(d/4294967296.0),4294967295.0)>>>0:~~+z((d-+(~~d>>>0))/4294967296.0)>>>0):0;f=a;c[f>>2]=~~b>>>0;c[f+4>>2]=g;a=a+8|0;c[a>>2]=~~d>>>0;c[a+4>>2]=e;return}function ic(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0;g=a+48|0;h=a+52|0;e=c[h>>2]|0;b=c[g>>2]|0;if((e|0)!=(b|0)){f=0;do{d=c[b+(f<<2)>>2]|0;if(d){Ub[c[(c[d>>2]|0)+4>>2]&127](d);e=c[h>>2]|0;b=c[g>>2]|0;}f=f+1|0;d=e-b|0;}while(f>>>0<d>>2>>>0);if(d|0)c[h>>2]=b;}d=a+20|0;b=c[a+16>>2]|0;if((c[d>>2]|0)==(b|0))return;c[d>>2]=b;return}function jc(a){a=a|0;return (c[a+4>>2]|0)-(c[a>>2]|0)>>2|0}function kc(a){a=a|0;var b=0;b=c[a+16>>2]|0;if((b|0)==(c[a+20>>2]|0)){b=0;return b|0}b=c[b>>2]|0;return b|0}function lc(a){a=a|0;var b=0,d=0,e=0;b=c[a+48>>2]|0;e=(c[a+52>>2]|0)-b|0;d=e>>2;if((e|0)>0)return d+(((c[c[a+16>>2]>>2]|0)!=(c[b>>2]|0))<<31>>31)|0;else return d|0;}function mc(a){a=a|0;return (c[a+20>>2]|0)-(c[a+16>>2]|0)>>2|0}function nc(a){a=a|0;var b=0,d=0,e=0;b=c[a+16>>2]|0;if((b|0)!=(c[a+20>>2]|0)){e=c[b>>2]|0;return e|0}d=c[a+28>>2]|0;if(!d){e=0;return e|0}b=a;while(1){b=c[b+32>>2]|0;a=c[d+16>>2]|0;if((b|0)!=(((c[d+20>>2]|0)-a>>2)+-1|0))break;b=c[d+28>>2]|0;if(!b){b=0;e=8;break}else {a=d;d=b;b=a;}}if((e|0)==8)return b|0;e=c[a+(b+1<<2)>>2]|0;return e|0}function oc(a){a=a|0;var b=0;b=1;while(1){a=c[a+28>>2]|0;if(!a)break;else b=b^1;}return b|0}function pc(b){b=b|0;return (a[b+36>>0]|0)!=0|0}function qc(a){a=a|0;var b=0.0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;i=c[a>>2]|0;g=(c[a+4>>2]|0)-i|0;h=g>>4;if((g|0)<48){i=1;return i|0}g=h+-1|0;e=i+(g<<4)|0;g=i+(g<<4)+8|0;a=0;b=0.0;d=c[e+4>>2]|0;e=c[e>>2]|0;f=c[g+4>>2]|0;g=c[g>>2]|0;do{n=i+(a<<4)|0;m=e;e=c[n>>2]|0;l=d;d=c[n+4>>2]|0;n=i+(a<<4)+8|0;k=g;g=c[n>>2]|0;j=f;f=c[n+4>>2]|0;b=b+(+(m>>>0)+4294967296.0*+(l|0)+(+(e>>>0)+4294967296.0*+(d|0)))*(+(k>>>0)+4294967296.0*+(j|0)-(+(g>>>0)+4294967296.0*+(f|0)));a=a+1|0;}while((a|0)<(h|0));n=b*-.5>=0.0;return n|0}function rc(a){a=a|0;var b=0.0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;i=c[a>>2]|0;g=(c[a+4>>2]|0)-i|0;h=g>>4;if((g|0)<48){b=0.0;return +b}g=h+-1|0;e=i+(g<<4)|0;g=i+(g<<4)+8|0;a=0;b=0.0;d=c[e+4>>2]|0;e=c[e>>2]|0;f=c[g+4>>2]|0;g=c[g>>2]|0;do{n=i+(a<<4)|0;m=e;e=c[n>>2]|0;l=d;d=c[n+4>>2]|0;n=i+(a<<4)+8|0;k=g;g=c[n>>2]|0;j=f;f=c[n+4>>2]|0;b=b+(+(m>>>0)+4294967296.0*+(l|0)+(+(e>>>0)+4294967296.0*+(d|0)))*(+(k>>>0)+4294967296.0*+(j|0)-(+(g>>>0)+4294967296.0*+(f|0)));a=a+1|0;}while((a|0)<(h|0));b=b*-.5;return +b}function sc(a){a=a|0;return (c[a+4>>2]|0)-(c[a>>2]|0)>>4|0}function tc(a,b){a=a|0;b=b|0;var d=0.0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0.0;s=c[b>>2]|0;r=(c[b+4>>2]|0)-s>>4;if(r>>>0<3){s=0;return s|0}m=s+8|0;o=s;q=a+8|0;p=c[q>>2]|0;q=c[q+4>>2]|0;k=a;j=c[k>>2]|0;k=c[k+4>>2]|0;b=0;i=1;l=c[m>>2]|0;m=c[m+4>>2]|0;n=c[o+4>>2]|0;o=c[o>>2]|0;a:while(1){f=(i|0)==(r|0)?s:s+(i<<4)|0;g=f;e=o;o=c[g>>2]|0;a=n;n=c[g+4>>2]|0;f=f+8|0;g=l;l=c[f>>2]|0;h=m;m=c[f+4>>2]|0;if((l|0)==(p|0)&(m|0)==(q|0)){if((o|0)==(j|0)&(n|0)==(k|0)){b=-1;a=15;break}if((g|0)==(p|0)&(h|0)==(q|0)?!(((n|0)>(k|0)|(n|0)==(k|0)&o>>>0>j>>>0)^((a|0)<(k|0)|(a|0)==(k|0)&e>>>0<j>>>0)):0){b=-1;a=15;break}}do if(((h|0)<(q|0)|(h|0)==(q|0)&g>>>0<p>>>0)^((m|0)<(q|0)|(m|0)==(q|0)&l>>>0<p>>>0)){f=(n|0)>(k|0)|(n|0)==(k|0)&o>>>0>j>>>0;if((a|0)<(k|0)|(a|0)==(k|0)&e>>>0<j>>>0){if(!f)break;f=Ww(e|0,a|0,j|0,k|0)|0;t=+(f>>>0)+4294967296.0*+(F()|0);f=Ww(l|0,m|0,p|0,q|0)|0;t=(+(f>>>0)+4294967296.0*+(F()|0))*t;f=Ww(o|0,n|0,j|0,k|0)|0;d=+(f>>>0)+4294967296.0*+(F()|0);f=Ww(g|0,h|0,p|0,q|0)|0;d=t-(+(f>>>0)+4294967296.0*+(F()|0))*d;if(d!=0.0){b=((m|0)>(h|0)|(m|0)==(h|0)&l>>>0>g>>>0)^d>0.0?b:1-b|0;break}else {b=-1;a=15;break a}}if(!f){f=Ww(e|0,a|0,j|0,k|0)|0;t=+(f>>>0)+4294967296.0*+(F()|0);f=Ww(l|0,m|0,p|0,q|0)|0;t=(+(f>>>0)+4294967296.0*+(F()|0))*t;f=Ww(o|0,n|0,j|0,k|0)|0;d=+(f>>>0)+4294967296.0*+(F()|0);f=Ww(g|0,h|0,p|0,q|0)|0;d=t-(+(f>>>0)+4294967296.0*+(F()|0))*d;if(d!=0.0){b=((m|0)>(h|0)|(m|0)==(h|0)&l>>>0>g>>>0)^d>0.0?b:1-b|0;break}else {b=-1;a=15;break a}}else {b=1-b|0;break}}while(0);i=i+1|0;if(i>>>0>r>>>0){a=15;break}}if((a|0)==15)return b|0;return 0}function uc(a,b){a=a|0;b=b|0;var d=0.0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0.0;r=a+8|0;q=c[r>>2]|0;r=c[r+4>>2]|0;p=a;o=c[p>>2]|0;p=c[p+4>>2]|0;n=b;a=0;a:while(1){i=n;n=c[n+24>>2]|0;m=n+16|0;l=c[m>>2]|0;m=c[m+4>>2]|0;if((l|0)==(q|0)&(m|0)==(r|0)){g=n+8|0;f=c[g>>2]|0;g=c[g+4>>2]|0;if((f|0)==(o|0)&(g|0)==(p|0)){a=-1;s=16;break}h=i+16|0;e=c[h>>2]|0;h=c[h+4>>2]|0;if((e|0)==(q|0)&(h|0)==(r|0)){k=i+8|0;j=c[k+4>>2]|0;if(!(((g|0)>(p|0)|(g|0)==(p|0)&f>>>0>o>>>0)^((j|0)<(p|0)|((j|0)==(p|0)?(c[k>>2]|0)>>>0<o>>>0:0)))){a=-1;s=16;break}if((m|0)<(r|0)|(m|0)==(r|0)&l>>>0<q>>>0){e=q;h=r;s=9;}}else s=8;}else {e=i+16|0;h=c[e+4>>2]|0;e=c[e>>2]|0;s=8;}if((s|0)==8){s=0;if(((m|0)<(r|0)|(m|0)==(r|0)&l>>>0<q>>>0)^((h|0)<(r|0)|(h|0)==(r|0)&e>>>0<q>>>0))s=9;}do if((s|0)==9){s=0;k=i+8|0;j=c[k>>2]|0;k=c[k+4>>2]|0;g=n+8|0;f=c[g>>2]|0;g=c[g+4>>2]|0;i=(g|0)>(p|0)|(g|0)==(p|0)&f>>>0>o>>>0;if((k|0)<(p|0)|(k|0)==(p|0)&j>>>0<o>>>0){if(!i)break;k=Ww(j|0,k|0,o|0,p|0)|0;t=+(k>>>0)+4294967296.0*+(F()|0);k=Ww(l|0,m|0,q|0,r|0)|0;t=(+(k>>>0)+4294967296.0*+(F()|0))*t;k=Ww(f|0,g|0,o|0,p|0)|0;d=+(k>>>0)+4294967296.0*+(F()|0);k=Ww(e|0,h|0,q|0,r|0)|0;d=t-(+(k>>>0)+4294967296.0*+(F()|0))*d;if(d!=0.0){a=((m|0)>(h|0)|(m|0)==(h|0)&l>>>0>e>>>0)^d>0.0?a:1-a|0;break}else {a=-1;s=16;break a}}if(!i){k=Ww(j|0,k|0,o|0,p|0)|0;t=+(k>>>0)+4294967296.0*+(F()|0);k=Ww(l|0,m|0,q|0,r|0)|0;t=(+(k>>>0)+4294967296.0*+(F()|0))*t;k=Ww(f|0,g|0,o|0,p|0)|0;d=+(k>>>0)+4294967296.0*+(F()|0);k=Ww(e|0,h|0,q|0,r|0)|0;d=t-(+(k>>>0)+4294967296.0*+(F()|0))*d;if(d!=0.0){a=((m|0)>(h|0)|(m|0)==(h|0)&l>>>0>e>>>0)^d>0.0?a:1-a|0;break}else {a=-1;s=16;break a}}else {a=1-a|0;break}}while(0);if((n|0)==(b|0)){s=16;break}}if((s|0)==16)return a|0;return 0}function vc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;g=a+32|0;f=a+40|0;e=a+8|0;e=Ww(c[f>>2]|0,c[f+4>>2]|0,c[e>>2]|0,c[e+4>>2]|0)|0;f=F()|0;i=b+32|0;h=b;h=Ww(c[i>>2]|0,c[i+4>>2]|0,c[h>>2]|0,c[h+4>>2]|0)|0;i=F()|0;if(d){q=(f|0)<0;u=_w(e|0,f|0,63)|0;F()|0;j=(i|0)<0;k=_w(h|0,i|0,63)|0;F()|0;k=(u|0)==(k|0);u=Ww(0,0,e|0,f|0)|0;p=F()|0;u=q?u:e;p=q?p:f;q=Ww(0,0,h|0,i|0)|0;m=F()|0;q=j?q:h;m=j?m:i;j=Uw(m|0,0,p|0,0)|0;t=F()|0;l=Uw(q|0,0,u|0,0)|0;f=F()|0;p=Uw(q|0,0,p|0,0)|0;q=F()|0;u=Uw(m|0,0,u|0,0)|0;u=Vw(p|0,q|0,u|0,F()|0)|0;t=Vw(F()|0,0,j|0,t|0)|0;j=F()|0;u=Vw(0,u|0,l|0,f|0)|0;q=F()|0;l=Vw(t|0,j|0,(q>>>0<f>>>0|(q|0)==(f|0)&u>>>0<l>>>0)&1|0,0)|0;f=F()|0;j=(u|0)==0&(q|0)==0;t=Ww(0,0,u|0,q|0)|0;p=F()|0;m=Ww(0,0,l|0,f|0)|0;e=F()|0;n=g;s=a;s=Ww(c[n>>2]|0,c[n+4>>2]|0,c[s>>2]|0,c[s+4>>2]|0)|0;n=F()|0;a=b+40|0;o=b+8|0;o=Ww(c[a>>2]|0,c[a+4>>2]|0,c[o>>2]|0,c[o+4>>2]|0)|0;a=F()|0;g=(n|0)<0;i=_w(s|0,n|0,63)|0;F()|0;r=(a|0)<0;d=_w(o|0,a|0,63)|0;F()|0;d=(i|0)==(d|0);i=Ww(0,0,s|0,n|0)|0;b=F()|0;s=g?i:s;n=g?b:n;b=Ww(0,0,o|0,a|0)|0;g=F()|0;o=r?b:o;a=r?g:a;g=Uw(a|0,0,n|0,0)|0;r=F()|0;b=Uw(o|0,0,s|0,0)|0;i=F()|0;n=Uw(o|0,0,n|0,0)|0;o=F()|0;s=Uw(a|0,0,s|0,0)|0;s=Vw(n|0,o|0,s|0,F()|0)|0;r=Vw(F()|0,0,g|0,r|0)|0;g=F()|0;s=Vw(0,s|0,b|0,i|0)|0;o=F()|0;b=Vw(r|0,g|0,(o>>>0<i>>>0|(o|0)==(i|0)&s>>>0<b>>>0)&1|0,0)|0;i=F()|0;g=(s|0)==0&(o|0)==0;r=Ww(0,0,s|0,o|0)|0;n=F()|0;a=Ww(0,0,b|0,i|0)|0;h=F()|0;return (((k?u:t)|0)==((d?s:r)|0)?((k?q:p)|0)==((d?o:n)|0):0)&(((k?l:j?m:~l)|0)==((d?b:g?a:~b)|0)?((k?f:j?e:~f)|0)==((d?i:g?h:~i)|0):0)|0}else {s=Uw(h|0,i|0,e|0,f|0)|0;u=F()|0;t=g;r=a;r=Ww(c[t>>2]|0,c[t+4>>2]|0,c[r>>2]|0,c[r+4>>2]|0)|0;t=F()|0;p=b+40|0;q=b+8|0;q=Ww(c[p>>2]|0,c[p+4>>2]|0,c[q>>2]|0,c[q+4>>2]|0)|0;t=Uw(q|0,F()|0,r|0,t|0)|0;return (s|0)==(t|0)&(u|0)==(F()|0)|0}}function wc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,i=0,j=0.0,k=0.0,l=0.0,m=0,n=0,o=0,p=0,q=0,t=0.0,u=0.0,v=0.0;u=+g[a+48>>3];t=+g[b+48>>3];do if(u==t){f=a+24|0;e=c[f>>2]|0;f=c[f+4>>2]|0;b=d+8|0;c[b>>2]=e;c[b+4>>2]=f;b=a+40|0;if((c[b>>2]|0)==(e|0)?(c[b+4>>2]|0)==(f|0):0){f=a+32|0;e=c[f>>2]|0;f=c[f+4>>2]|0;break}else {b=a;q=c[b>>2]|0;b=c[b+4>>2]|0;a=a+8|0;e=Ww(e|0,f|0,c[a>>2]|0,c[a+4>>2]|0)|0;u=u*(+(e>>>0)+4294967296.0*+(F()|0));u=u+(u<0.0?-.5:.5);e=Vw(q|0,b|0,~~u>>>0|0,(+s(u)>=1.0?(u>0.0?~~+B(+r(u/4294967296.0),4294967295.0)>>>0:~~+z((u-+(~~u>>>0))/4294967296.0)>>>0):0)|0)|0;f=F()|0;break}}else {do if(u==0.0){f=a;e=c[f>>2]|0;f=c[f+4>>2]|0;h=d;c[h>>2]=e;c[h+4>>2]=f;h=b+8|0;i=c[h>>2]|0;h=c[h+4>>2]|0;if(t==-1.e+40){e=d+8|0;q=e;c[q>>2]=i;c[q+4>>2]=h;break}else {q=b;l=(+(e>>>0)+4294967296.0*+(f|0))/t+(+(i>>>0)+4294967296.0*+(h|0)-(+((c[q>>2]|0)>>>0)+4294967296.0*+(c[q+4>>2]|0))/t);l=l+(l<0.0?-.5:.5);i=~~l>>>0;h=+s(l)>=1.0?(l>0.0?~~+B(+r(l/4294967296.0),4294967295.0)>>>0:~~+z((l-+(~~l>>>0))/4294967296.0)>>>0):0;e=d+8|0;q=e;c[q>>2]=i;c[q+4>>2]=h;break}}else if(t==0.0){f=b;e=c[f>>2]|0;f=c[f+4>>2]|0;h=d;c[h>>2]=e;c[h+4>>2]=f;h=a+8|0;i=c[h>>2]|0;h=c[h+4>>2]|0;if(u==-1.e+40){e=d+8|0;q=e;c[q>>2]=i;c[q+4>>2]=h;break}else {q=a;l=(+(e>>>0)+4294967296.0*+(f|0))/u+(+(i>>>0)+4294967296.0*+(h|0)-(+((c[q>>2]|0)>>>0)+4294967296.0*+(c[q+4>>2]|0))/u);l=l+(l<0.0?-.5:.5);i=~~l>>>0;h=+s(l)>=1.0?(l>0.0?~~+B(+r(l/4294967296.0),4294967295.0)>>>0:~~+z((l-+(~~l>>>0))/4294967296.0)>>>0):0;e=d+8|0;q=e;c[q>>2]=i;c[q+4>>2]=h;break}}else {i=a;h=a+8|0;j=+((c[i>>2]|0)>>>0)+4294967296.0*+(c[i+4>>2]|0)-u*(+((c[h>>2]|0)>>>0)+4294967296.0*+(c[h+4>>2]|0));h=b;i=b+8|0;k=+((c[h>>2]|0)>>>0)+4294967296.0*+(c[h+4>>2]|0)-t*(+((c[i>>2]|0)>>>0)+4294967296.0*+(c[i+4>>2]|0));l=(k-j)/(u-t);v=l+(l<0.0?-.5:.5);i=~~v>>>0;h=+s(v)>=1.0?(v>0.0?~~+B(+r(v/4294967296.0),4294967295.0)>>>0:~~+z((v-+(~~v>>>0))/4294967296.0)>>>0):0;e=d+8|0;q=e;c[q>>2]=i;c[q+4>>2]=h;if(+s(+u)<+s(+t)){v=j+u*l;v=v+(v<0.0?-.5:.5);p=+s(v)>=1.0?(v>0.0?~~+B(+r(v/4294967296.0),4294967295.0)>>>0:~~+z((v-+(~~v>>>0))/4294967296.0)>>>0):0;q=d;c[q>>2]=~~v>>>0;c[q+4>>2]=p;break}else {v=k+t*l;v=v+(v<0.0?-.5:.5);p=+s(v)>=1.0?(v>0.0?~~+B(+r(v/4294967296.0),4294967295.0)>>>0:~~+z((v-+(~~v>>>0))/4294967296.0)>>>0):0;q=d;c[q>>2]=~~v>>>0;c[q+4>>2]=p;break}}while(0);q=a+40|0;n=q;f=c[n>>2]|0;n=c[n+4>>2]|0;p=b+40|0;o=p;m=c[o>>2]|0;o=c[o+4>>2]|0;if((h|0)<(n|0)|(h|0)==(n|0)&i>>>0<f>>>0|((h|0)<(o|0)|(h|0)==(o|0)&i>>>0<m>>>0)){h=(n|0)>(o|0)|(n|0)==(o|0)&f>>>0>m>>>0;i=h?f:m;h=h?n:o;o=e;c[o>>2]=i;c[o+4>>2]=h;do if(+s(+u)<+s(+t)){p=q;if((c[p>>2]|0)==(i|0)?(c[p+4>>2]|0)==(h|0):0){m=a+32|0;f=c[m>>2]|0;m=c[m+4>>2]|0;break}else {f=a;m=c[f>>2]|0;f=c[f+4>>2]|0;p=a+8|0;p=Ww(i|0,h|0,c[p>>2]|0,c[p+4>>2]|0)|0;v=u*(+(p>>>0)+4294967296.0*+(F()|0));v=v+(v<0.0?-.5:.5);f=Vw(m|0,f|0,~~v>>>0|0,(+s(v)>=1.0?(v>0.0?~~+B(+r(v/4294967296.0),4294967295.0)>>>0:~~+z((v-+(~~v>>>0))/4294967296.0)>>>0):0)|0)|0;m=F()|0;break}}else if((c[p>>2]|0)==(i|0)?(c[p+4>>2]|0)==(h|0):0){m=b+32|0;f=c[m>>2]|0;m=c[m+4>>2]|0;break}else {f=b;m=c[f>>2]|0;f=c[f+4>>2]|0;p=b+8|0;p=Ww(i|0,h|0,c[p>>2]|0,c[p+4>>2]|0)|0;v=t*(+(p>>>0)+4294967296.0*+(F()|0));v=v+(v<0.0?-.5:.5);f=Vw(m|0,f|0,~~v>>>0|0,(+s(v)>=1.0?(v>0.0?~~+B(+r(v/4294967296.0),4294967295.0)>>>0:~~+z((v-+(~~v>>>0))/4294967296.0)>>>0):0)|0)|0;m=F()|0;break}while(0);p=d;c[p>>2]=f;c[p+4>>2]=m;}m=a+24|0;f=c[m>>2]|0;m=c[m+4>>2]|0;if(!((h|0)>(m|0)|(h|0)==(m|0)&i>>>0>f>>>0))return;p=e;c[p>>2]=f;c[p+4>>2]=m;if(+s(+u)>+s(+t)){a=b+40|0;if((c[a>>2]|0)==(f|0)?(c[a+4>>2]|0)==(m|0):0){f=b+32|0;e=c[f>>2]|0;f=c[f+4>>2]|0;break}else {e=b;a=c[e>>2]|0;e=c[e+4>>2]|0;b=b+8|0;f=Ww(f|0,m|0,c[b>>2]|0,c[b+4>>2]|0)|0;v=t*(+(f>>>0)+4294967296.0*+(F()|0));v=v+(v<0.0?-.5:.5);e=Vw(a|0,e|0,~~v>>>0|0,(+s(v)>=1.0?(v>0.0?~~+B(+r(v/4294967296.0),4294967295.0)>>>0:~~+z((v-+(~~v>>>0))/4294967296.0)>>>0):0)|0)|0;f=F()|0;break}}else {b=q;if((c[b>>2]|0)==(f|0)?(c[b+4>>2]|0)==(m|0):0){f=a+32|0;e=c[f>>2]|0;f=c[f+4>>2]|0;break}else {e=a;b=c[e>>2]|0;e=c[e+4>>2]|0;a=a+8|0;f=Ww(f|0,m|0,c[a>>2]|0,c[a+4>>2]|0)|0;v=u*(+(f>>>0)+4294967296.0*+(F()|0));v=v+(v<0.0?-.5:.5);e=Vw(b|0,e|0,~~v>>>0|0,(+s(v)>=1.0?(v>0.0?~~+B(+r(v/4294967296.0),4294967295.0)>>>0:~~+z((v-+(~~v>>>0))/4294967296.0)>>>0):0)|0)|0;f=F()|0;break}}}while(0);c[d>>2]=e;c[d+4>>2]=f;return}function xc(a,b){a=a|0;b=b|0;var d=0.0,e=0,f=0,g=0,h=0,i=0,j=0.0,k=0,l=0,m=0,n=0,o=0,p=0.0,q=0.0,r=0,t=0,u=0,v=0,w=0,x=0,y=0;r=c[a+28>>2]|0;y=r+8|0;x=c[y>>2]|0;y=c[y+4>>2]|0;u=a+8|0;t=c[u>>2]|0;u=c[u+4>>2]|0;w=a+16|0;v=c[w>>2]|0;w=c[w+4>>2]|0;a:do if((x|0)==(t|0)&(y|0)==(u|0)){e=r;while(1){o=e+16|0;if((e|0)==(a|0)|((c[o>>2]|0)!=(v|0)?1:(c[o+4>>2]|0)!=(w|0))){h=x;i=y;break a}e=c[e+28>>2]|0;o=e+8|0;if(!((c[o>>2]|0)==(x|0)?(c[o+4>>2]|0)==(y|0):0)){h=x;i=y;break}}}else {e=r;h=t;i=u;}while(0);g=e+16|0;f=c[g>>2]|0;g=c[g+4>>2]|0;if((f|0)==(v|0)&(g|0)==(w|0))d=-1.e+40;else {o=e+8|0;o=Ww(c[o>>2]|0,c[o+4>>2]|0,t|0,u|0)|0;d=+(o>>>0)+4294967296.0*+(F()|0);o=Ww(f|0,g|0,v|0,w|0)|0;d=d/(+(o>>>0)+4294967296.0*+(F()|0));}q=+s(+d);e=c[a+24>>2]|0;o=e+8|0;b:do if((c[o>>2]|0)==(h|0)?(c[o+4>>2]|0)==(i|0):0){f=e;do{o=f+16|0;if((f|0)==(a|0)|((c[o>>2]|0)!=(v|0)?1:(c[o+4>>2]|0)!=(w|0)))break b;f=c[f+24>>2]|0;o=f+8|0;}while((c[o>>2]|0)==(h|0)?(c[o+4>>2]|0)==(i|0):0)}else f=e;while(0);h=f+16|0;g=c[h>>2]|0;h=c[h+4>>2]|0;if((g|0)==(v|0)&(h|0)==(w|0))d=-1.e+40;else {o=f+8|0;o=Ww(c[o>>2]|0,c[o+4>>2]|0,t|0,u|0)|0;d=+(o>>>0)+4294967296.0*+(F()|0);o=Ww(g|0,h|0,v|0,w|0)|0;d=d/(+(o>>>0)+4294967296.0*+(F()|0));}p=+s(+d);f=c[b+28>>2]|0;h=f+8|0;g=c[h>>2]|0;h=c[h+4>>2]|0;m=b+8|0;l=c[m>>2]|0;m=c[m+4>>2]|0;o=b+16|0;n=c[o>>2]|0;o=c[o+4>>2]|0;c:do if((g|0)==(l|0)&(h|0)==(m|0))while(1){k=f+16|0;if((f|0)==(b|0)|((c[k>>2]|0)!=(n|0)?1:(c[k+4>>2]|0)!=(o|0))){k=g;i=h;break c}f=c[f+28>>2]|0;k=f+8|0;if(!((c[k>>2]|0)==(g|0)?(c[k+4>>2]|0)==(h|0):0)){k=g;i=h;break}}else {k=l;i=m;}while(0);h=f+16|0;g=c[h>>2]|0;h=c[h+4>>2]|0;if((g|0)==(n|0)&(h|0)==(o|0))d=-1.e+40;else {f=f+8|0;f=Ww(c[f>>2]|0,c[f+4>>2]|0,l|0,m|0)|0;d=+(f>>>0)+4294967296.0*+(F()|0);h=Ww(g|0,h|0,n|0,o|0)|0;d=d/(+(h>>>0)+4294967296.0*+(F()|0));}j=+s(+d);f=c[b+24>>2]|0;h=f+8|0;d:do if((c[h>>2]|0)==(k|0)?(c[h+4>>2]|0)==(i|0):0)do{h=f+16|0;if((f|0)==(b|0)|((c[h>>2]|0)!=(n|0)?1:(c[h+4>>2]|0)!=(o|0)))break d;f=c[f+24>>2]|0;h=f+8|0;}while((c[h>>2]|0)==(k|0)?(c[h+4>>2]|0)==(i|0):0);while(0);h=f+16|0;g=c[h>>2]|0;h=c[h+4>>2]|0;if((g|0)==(n|0)&(h|0)==(o|0))d=-1.e+40;else {b=f+8|0;b=Ww(c[b>>2]|0,c[b+4>>2]|0,l|0,m|0)|0;d=+(b>>>0)+4294967296.0*+(F()|0);b=Ww(g|0,h|0,n|0,o|0)|0;d=d/(+(b>>>0)+4294967296.0*+(F()|0));}d=+s(+d);if((q<p?p:q)==(j<d?d:j)?(p<q?p:q)==(d<j?d:j):0){if(!a){a=0;return a|0}y=Vw(t|0,u|0,x|0,y|0)|0;d=+(y>>>0)+4294967296.0*+(F()|0);y=r+16|0;y=Ww(c[y>>2]|0,c[y+4>>2]|0,v|0,w|0)|0;d=d*(+(y>>>0)+4294967296.0*+(F()|0))+0.0;if((e|0)!=(a|0))do{w=c[e+28>>2]|0;v=w+8|0;u=e+8|0;y=e+16|0;x=c[y>>2]|0;y=c[y+4>>2]|0;e=c[e+24>>2]|0;v=Vw(c[u>>2]|0,c[u+4>>2]|0,c[v>>2]|0,c[v+4>>2]|0)|0;q=+(v>>>0)+4294967296.0*+(F()|0);w=w+16|0;y=Ww(c[w>>2]|0,c[w+4>>2]|0,x|0,y|0)|0;d=d+q*(+(y>>>0)+4294967296.0*+(F()|0));}while((e|0)!=(a|0));a=d*.5>0.0;return a|0}if(!(!(q>=j)|!(q>=d))){a=1;return a|0}if(!(p>=j)){a=0;return a|0}a=p>=d;return a|0}function yc(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;c[b>>2]=3528;i=b+8|0;h=c[i>>2]|0;k=b+12|0;c[k>>2]=h;c[b+4>>2]=h;h=b+24|0;j=b+28|0;e=c[j>>2]|0;d=c[h>>2]|0;if((e|0)==(d|0))d=e;else {g=0;do{f=c[d+(g<<2)>>2]|0;if(f){ak(f);d=c[h>>2]|0;e=c[j>>2]|0;}g=g+1|0;}while(g>>>0<e-d>>2>>>0)}c[j>>2]=d;a[b+20>>0]=0;a[b+37>>0]=0;d=c[b+56>>2]|0;if(d|0){c[b+60>>2]=d;$j(d);}d=c[b+40>>2]|0;if(d|0){c[b+44>>2]=d;$j(d);}d=c[h>>2]|0;if(d|0){c[j>>2]=d;$j(d);}d=c[i>>2]|0;if(!d)return;c[k>>2]=d;$j(d);return}function Ac(a){a=a|0;yc(a);$j(a);return}function Bc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0;c[b>>2]=3588;e=b+4|0;c[e>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;f=ai(d)|0;if(f>>>0>4294967279)fk();if(f>>>0<11){a[e+11>>0]=f;if(!f){d=e;f=d+f|0;a[f>>0]=0;return}}else {h=f+16&-16;g=Zj(h)|0;c[e>>2]=g;c[b+12>>2]=h|-2147483648;c[b+8>>2]=f;e=g;}ax(e|0,d|0,f|0)|0;h=e;h=h+f|0;a[h>>0]=0;return}function Cc(b){b=b|0;c[b>>2]=3588;b=b+4|0;if((a[b+11>>0]|0)>=0)return;$j(c[b>>2]|0);return}function Dc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,i=0.0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0.0,u=0;u=Eb;Eb=Eb+16|0;k=u;if((c[b+76>>2]|0)==-2){a:do if(d){e=b;while(1){r=e+40|0;f=c[e+80>>2]|0;s=f+8|0;if((c[r>>2]|0)==(c[s>>2]|0)?(c[r+4>>2]|0)==(c[s+4>>2]|0):0)e=f;else break}if((e|0)!=(b|0))do{if(!(+g[e+48>>3]==-1.e+40)){h=e;j=15;break a}e=c[e+84>>2]|0;}while((e|0)!=(b|0))}else {e=b;while(1){r=e+40|0;f=c[e+84>>2]|0;s=f+8|0;if((c[r>>2]|0)==(c[s>>2]|0)?(c[r+4>>2]|0)==(c[s+4>>2]|0):0)e=f;else break}if((e|0)!=(b|0))do{if(!(+g[e+48>>3]==-1.e+40)){h=e;j=15;break a}e=c[e+80>>2]|0;}while((e|0)!=(b|0))}while(0);if((j|0)==15?(h|0)!=(b|0):0){e=c[(d?b+80|0:b+84|0)>>2]|0;b=e+8|0;h=c[b+4>>2]|0;f=k;c[f>>2]=c[b>>2];c[f+4>>2]=h;c[k+8>>2]=0;c[k+12>>2]=e;c[e+64>>2]=0;e=Dc(a,e,d)|0;f=a+12|0;h=c[f>>2]|0;if((h|0)==(c[a+16>>2]|0))Je(a+8|0,k);else {c[h>>2]=c[k>>2];c[h+4>>2]=c[k+4>>2];c[h+8>>2]=c[k+8>>2];c[h+12>>2]=c[k+12>>2];c[f>>2]=(c[f>>2]|0)+16;}b=e;Eb=u;return b|0}if(d){b=c[b+80>>2]|0;Eb=u;return b|0}else {b=c[b+84>>2]|0;Eb=u;return b|0}}t=+g[b+48>>3];do if(t==-1.e+40){e=c[(d?b+84|0:b+80|0)>>2]|0;j=e;h=b;f=c[h>>2]|0;h=c[h+4>>2]|0;j=(c[j>>2]|0)!=(f|0)?1:(c[j+4>>2]|0)!=(h|0);if(!(+g[e+48>>3]==-1.e+40)){if(!j)break;k=b+32|0;a=k;j=c[a>>2]|0;a=c[a+4>>2]|0;c[k>>2]=f;c[k+4>>2]=h;k=b;c[k>>2]=j;c[k+4>>2]=a;break}if(j?(k=e+32|0,!((c[k>>2]|0)==(f|0)?(c[k+4>>2]|0)==(h|0):0)):0){k=b+32|0;a=k;j=c[a>>2]|0;a=c[a+4>>2]|0;c[k>>2]=f;c[k+4>>2]=h;k=b;c[k>>2]=j;c[k+4>>2]=a;}}while(0);h=b+40|0;e=c[h>>2]|0;h=c[h+4>>2]|0;if(d){f=c[b+80>>2]|0;s=f+8|0;if((e|0)==(c[s>>2]|0)?(h|0)==(c[s+4>>2]|0):0){e=b;while(1){if((c[f+76>>2]|0)==-2)break;r=f+40|0;h=c[f+80>>2]|0;s=h+8|0;if((c[r>>2]|0)==(c[s>>2]|0)?(c[r+4>>2]|0)==(c[s+4>>2]|0):0){e=f;f=h;}else {e=f;f=h;break}}h=e;i=+g[e+48>>3];}else {h=b;i=t;}if(i==-1.e+40?(c[f+76>>2]|0)!=-2:0){e=h;do e=c[e+84>>2]|0;while(+g[e+48>>3]==-1.e+40);s=e+32|0;q=c[s+4>>2]|0;f=f+32|0;r=c[f+4>>2]|0;f=(q|0)>(r|0)|((q|0)==(r|0)?(c[s>>2]|0)>>>0>(c[f>>2]|0)>>>0:0)?e:h;}else f=h;if((f|0)!=(b|0)){h=b;i=t;while(1){e=c[h+80>>2]|0;c[h+88>>2]=e;if(!((h|0)==(b|0)|i!=-1.e+40)?(m=h,l=c[m>>2]|0,m=c[m+4>>2]|0,s=(c[h+84>>2]|0)+32|0,!((l|0)==(c[s>>2]|0)?(m|0)==(c[s+4>>2]|0):0)):0){s=h+32|0;r=s;q=c[r>>2]|0;r=c[r+4>>2]|0;c[s>>2]=l;c[s+4>>2]=m;s=h;c[s>>2]=q;c[s+4>>2]=r;}if((f|0)==(e|0))break;h=e;i=+g[e+48>>3];}if(!((f|0)==(b|0)?1:+g[f+48>>3]!=-1.e+40)?(o=f,n=c[o>>2]|0,o=c[o+4>>2]|0,b=(c[f+84>>2]|0)+32|0,!((n|0)==(c[b>>2]|0)?(o|0)==(c[b+4>>2]|0):0)):0){b=f+32|0;s=b;r=c[s>>2]|0;s=c[s+4>>2]|0;c[b>>2]=n;c[b+4>>2]=o;b=f;c[b>>2]=r;c[b+4>>2]=s;}}e=f+80|0;}else {f=c[b+84>>2]|0;o=f+8|0;if((e|0)==(c[o>>2]|0)?(h|0)==(c[o+4>>2]|0):0){e=b;while(1){if((c[f+76>>2]|0)==-2)break;n=f+40|0;h=c[f+84>>2]|0;o=h+8|0;if((c[n>>2]|0)==(c[o>>2]|0)?(c[n+4>>2]|0)==(c[o+4>>2]|0):0){e=f;f=h;}else {e=f;f=h;break}}h=e;i=+g[e+48>>3];}else {h=b;i=t;}if(i==-1.e+40?(c[f+76>>2]|0)!=-2:0){e=h;do e=c[e+80>>2]|0;while(+g[e+48>>3]==-1.e+40);o=e+32|0;m=c[o+4>>2]|0;f=f+32|0;n=c[f+4>>2]|0;f=(m|0)<(n|0)|((m|0)==(n|0)?(c[o>>2]|0)>>>0<(c[f>>2]|0)>>>0:0)?h:e;}else f=h;if((f|0)!=(b|0)){h=b;i=t;while(1){e=c[h+84>>2]|0;c[h+88>>2]=e;if(!((h|0)==(b|0)|i!=-1.e+40)?(q=h,p=c[q>>2]|0,q=c[q+4>>2]|0,o=(c[h+80>>2]|0)+32|0,!((p|0)==(c[o>>2]|0)?(q|0)==(c[o+4>>2]|0):0)):0){o=h+32|0;n=o;m=c[n>>2]|0;n=c[n+4>>2]|0;c[o>>2]=p;c[o+4>>2]=q;o=h;c[o>>2]=m;c[o+4>>2]=n;}if((f|0)==(e|0))break;h=e;i=+g[e+48>>3];}if(!((f|0)==(b|0)?1:+g[f+48>>3]!=-1.e+40)?(s=f,r=c[s>>2]|0,s=c[s+4>>2]|0,b=(c[f+80>>2]|0)+32|0,!((r|0)==(c[b>>2]|0)?(s|0)==(c[b+4>>2]|0):0)):0){b=f+32|0;q=b;p=c[q>>2]|0;q=c[q+4>>2]|0;c[b>>2]=r;c[b+4>>2]=s;b=f;c[b>>2]=p;c[b+4>>2]=q;}}e=f+84|0;}b=c[e>>2]|0;Eb=u;return b|0}function Ec(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var h=0,i=0,j=0,k=0,l=0.0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,T=0,U=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0;K=Eb;Eb=Eb+32|0;I=K+16|0;J=K;G=f^1;if((e|0)==1&G){K=S(16)|0;Bc(K,7530);V(K|0,1024,9);}n=c[d>>2]|0;H=(c[d+4>>2]|0)-n|0;h=(H>>4)+-1|0;a:do if((H|0)>16&f){k=n;j=c[k>>2]|0;k=c[k+4>>2]|0;m=n+8|0;while(1){H=n+(h<<4)|0;if(!((c[H>>2]|0)==(j|0)?(c[H+4>>2]|0)==(k|0):0))break a;E=n+(h<<4)+8|0;H=m;if(!((c[E>>2]|0)==(c[H>>2]|0)?(c[E+4>>2]|0)==(c[H+4>>2]|0):0))break a;i=h+-1|0;if((h|0)>1)h=i;else {h=i;break}}}while(0);b:do if((h|0)>0){k=n+(h<<4)|0;j=c[k>>2]|0;k=c[k+4>>2]|0;while(1){i=h+-1|0;H=n+(i<<4)|0;if(!((j|0)==(c[H>>2]|0)?(k|0)==(c[H+4>>2]|0):0))break b;E=n+(h<<4)+8|0;H=n+(i<<4)+8|0;if(!((c[E>>2]|0)==(c[H>>2]|0)?(c[E+4>>2]|0)==(c[H+4>>2]|0):0))break b;if((h|0)>1)h=i;else {h=i;break}}}while(0);if(f?(h|0)<2:(h|0)<1){b=0;Eb=K;return b|0}i=h+1|0;H=_j(i>>>0>38347922?-1:i*112|0)|0;if(!i){o=d;k=n;}else {i=H+(i*112|0)|0;j=H;do{p=j;q=p+48|0;do{c[p>>2]=0;p=p+4|0;}while((p|0)<(q|0));j=j+112|0;}while((j|0)!=(i|0));o=d;k=c[d>>2]|0;}c[I>>2]=H;j=k+16|0;D=H+128|0;c[D>>2]=c[j>>2];c[D+4>>2]=c[j+4>>2];c[D+8>>2]=c[j+8>>2];c[D+12>>2]=c[j+12>>2];D=b+20|0;j=k;i=c[j>>2]|0;j=c[j+4>>2]|0;E=H;do if(!(a[D>>0]|0)){A=k+8|0;A=Vw(c[A>>2]|0,c[A+4>>2]|0,1073741823,0)|0;z=F()|0;C=Vw(i|0,j|0,1073741823,0)|0;B=F()|0;if(z>>>0>0|(z|0)==0&A>>>0>2147483646|(B>>>0>0|(B|0)==0&C>>>0>2147483646)){a[D>>0]=1;s=22;break}i=k+(h<<4)|0;j=c[i>>2]|0;i=c[i+4>>2]|0;C=k+(h<<4)+8|0;C=Vw(c[C>>2]|0,c[C+4>>2]|0,1073741823,0)|0;B=F()|0;if(B>>>0>0|(B|0)==0&C>>>0>2147483646){a[D>>0]=1;s=29;break}C=Vw(j|0,i|0,1073741823,0)|0;B=F()|0;if(B>>>0>0|(B|0)==0&C>>>0>2147483646){a[D>>0]=1;s=29;}else n=0;}else s=22;while(0);do if((s|0)==22){if((j|0)>2097151|(j|0)==2097151&i>>>0>4294967295){h=S(16)|0;c[h>>2]=3588;p=h+4|0;c[p>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;i=Zj(48)|0;c[p>>2]=i;p=h+12|0;c[p>>2]=-2147483600;p=h+8|0;c[p>>2]=32;p=i;j=7464;q=p+32|0;do{a[p>>0]=a[j>>0]|0;p=p+1|0;j=j+1|0;}while((p|0)<(q|0));K=i+32|0;a[K>>0]=0;V(h|0,1024,9);}C=k+8|0;C=Vw(c[C>>2]|0,c[C+4>>2]|0,-1,2097151)|0;B=F()|0;if((j|0)<-2097152|(j|0)==-2097152&i>>>0<1|(B>>>0>4194303|(B|0)==4194303&C>>>0>4294967294)){h=S(16)|0;c[h>>2]=3588;p=h+4|0;c[p>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;i=Zj(48)|0;c[p>>2]=i;p=h+12|0;c[p>>2]=-2147483600;p=h+8|0;c[p>>2]=32;p=i;j=7464;q=p+32|0;do{a[p>>0]=a[j>>0]|0;p=p+1|0;j=j+1|0;}while((p|0)<(q|0));K=i+32|0;a[K>>0]=0;V(h|0,1024,9);}else {j=k+(h<<4)|0;i=c[j+4>>2]|0;j=c[j>>2]|0;s=29;break}}while(0);if((s|0)==29){if((i|0)>2097151|(i|0)==2097151&j>>>0>4294967295){h=S(16)|0;c[h>>2]=3588;p=h+4|0;c[p>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;i=Zj(48)|0;c[p>>2]=i;p=h+12|0;c[p>>2]=-2147483600;p=h+8|0;c[p>>2]=32;p=i;j=7464;q=p+32|0;do{a[p>>0]=a[j>>0]|0;p=p+1|0;j=j+1|0;}while((p|0)<(q|0));K=i+32|0;a[K>>0]=0;V(h|0,1024,9);}C=k+(h<<4)+8|0;C=Vw(c[C>>2]|0,c[C+4>>2]|0,-1,2097151)|0;B=F()|0;if((i|0)<-2097152|(i|0)==-2097152&j>>>0<1|(B>>>0>4194303|(B|0)==4194303&C>>>0>4294967294)){h=S(16)|0;c[h>>2]=3588;p=h+4|0;c[p>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;i=Zj(48)|0;c[p>>2]=i;p=h+12|0;c[p>>2]=-2147483600;p=h+8|0;c[p>>2]=32;p=i;j=7464;q=p+32|0;do{a[p>>0]=a[j>>0]|0;p=p+1|0;j=j+1|0;}while((p|0)<(q|0));K=i+32|0;a[K>>0]=0;V(h|0,1024,9);}else n=1;}i=H+112|0;m=H+(h*112|0)|0;p=H;q=p+112|0;do{c[p>>2]=0;p=p+4|0;}while((p|0)<(q|0));c[H+80>>2]=i;c[H+84>>2]=m;j=H+16|0;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];c[j+8>>2]=c[k+8>>2];c[j+12>>2]=c[k+12>>2];c[H+76>>2]=-1;j=h+-1|0;k=H+(j*112|0)|0;d=c[o>>2]|0;i=d+(h<<4)|0;p=m;q=p+112|0;do{c[p>>2]=0;p=p+4|0;}while((p|0)<(q|0));c[H+(h*112|0)+80>>2]=H;c[H+(h*112|0)+84>>2]=k;C=H+(h*112|0)+16|0;c[C>>2]=c[i>>2];c[C+4>>2]=c[i+4>>2];c[C+8>>2]=c[i+8>>2];c[C+12>>2]=c[i+12>>2];c[H+(h*112|0)+76>>2]=-1;c:do if((h|0)>1){o=j;h=n;while(1){m=d+(o<<4)|0;j=m;i=c[j>>2]|0;j=c[j+4>>2]|0;if(!(h<<24>>24)){A=d+(o<<4)+8|0;A=Vw(c[A>>2]|0,c[A+4>>2]|0,1073741823,0)|0;z=F()|0;C=Vw(i|0,j|0,1073741823,0)|0;B=F()|0;if(z>>>0>0|(z|0)==0&A>>>0>2147483646|(B>>>0>0|(B|0)==0&C>>>0>2147483646)){a[D>>0]=1;h=1;s=39;}else h=0;}else s=39;if((s|0)==39){s=0;if((j|0)>2097151|(j|0)==2097151&i>>>0>4294967295){s=41;break}C=d+(o<<4)+8|0;C=Vw(c[C>>2]|0,c[C+4>>2]|0,-1,2097151)|0;B=F()|0;if((j|0)<-2097152|(j|0)==-2097152&i>>>0<1|(B>>>0>4194303|(B|0)==4194303&C>>>0>4294967294)){s=41;break}}j=H+((o+1|0)*112|0)|0;i=o;o=o+-1|0;k=H+(o*112|0)|0;p=H+(i*112|0)|0;q=p+112|0;do{c[p>>2]=0;p=p+4|0;}while((p|0)<(q|0));c[H+(i*112|0)+80>>2]=j;c[H+(i*112|0)+84>>2]=k;C=H+(i*112|0)+16|0;c[C>>2]=c[m>>2];c[C+4>>2]=c[m+4>>2];c[C+8>>2]=c[m+8>>2];c[C+12>>2]=c[m+12>>2];c[H+(i*112|0)+76>>2]=-1;if((i|0)<=1)break c}if((s|0)==41){h=S(16)|0;c[h>>2]=3588;p=h+4|0;c[p>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;i=Zj(48)|0;c[p>>2]=i;c[h+12>>2]=-2147483600;c[h+8>>2]=32;p=i;j=7464;q=p+32|0;do{a[p>>0]=a[j>>0]|0;p=p+1|0;j=j+1|0;}while((p|0)<(q|0));a[i+32>>0]=0;V(h|0,1024,9);}}while(0);C=b+36|0;j=H;k=H;d:while(1){n=j+16|0;h=j;m=c[n>>2]|0;n=c[n+4>>2]|0;e:while(1){i=c[h+80>>2]|0;o=h+16|0;B=i+16|0;A=c[B>>2]|0;B=c[B+4>>2]|0;if((m|0)==(A|0)&(n|0)==(B|0)?(y=h+24|0,z=i+24|0,!(((c[y>>2]|0)!=(c[z>>2]|0)?1:(c[y+4>>2]|0)!=(c[z+4>>2]|0))|(i|0)==(k|0)&G)):0){s=45;break}z=c[h+84>>2]|0;if((z|0)==(i|0)){s=66;break d}do if(f){w=z+16|0;v=c[w>>2]|0;w=c[w+4>>2]|0;y=z+24|0;x=c[y>>2]|0;y=c[y+4>>2]|0;q=o;p=c[q>>2]|0;q=c[q+4>>2]|0;s=h+24|0;r=c[s>>2]|0;s=c[s+4>>2]|0;u=i+24|0;t=c[u>>2]|0;u=c[u+4>>2]|0;L=(a[D>>0]|0)==0;m=Ww(x|0,y|0,r|0,s|0)|0;n=F()|0;o=Ww(p|0,q|0,A|0,B|0)|0;d=F()|0;if(L){o=Uw(o|0,d|0,m|0,n|0)|0;L=F()|0;n=Ww(v|0,w|0,p|0,q|0)|0;d=F()|0;m=Ww(r|0,s|0,t|0,u|0)|0;d=Uw(m|0,F()|0,n|0,d|0)|0;if(!((o|0)==(d|0)&(L|0)==(F()|0)))break}else {Y=(n|0)<0;aa=_w(m|0,n|0,63)|0;F()|0;N=(d|0)<0;O=_w(o|0,d|0,63)|0;F()|0;O=(aa|0)==(O|0);aa=Ww(0,0,m|0,n|0)|0;X=F()|0;aa=Y?aa:m;X=Y?X:n;Y=Ww(0,0,o|0,d|0)|0;T=F()|0;Y=N?Y:o;T=N?T:d;N=Uw(T|0,0,X|0,0)|0;$=F()|0;R=Uw(Y|0,0,aa|0,0)|0;m=F()|0;X=Uw(Y|0,0,X|0,0)|0;Y=F()|0;aa=Uw(T|0,0,aa|0,0)|0;aa=Vw(X|0,Y|0,aa|0,F()|0)|0;$=Vw(F()|0,0,N|0,$|0)|0;N=F()|0;aa=Vw(0,aa|0,R|0,m|0)|0;Y=F()|0;R=Vw($|0,N|0,(Y>>>0<m>>>0|(Y|0)==(m|0)&aa>>>0<R>>>0)&1|0,0)|0;m=F()|0;N=(aa|0)==0&(Y|0)==0;$=Ww(0,0,aa|0,Y|0)|0;X=F()|0;T=Ww(0,0,R|0,m|0)|0;M=F()|0;_=Ww(v|0,w|0,p|0,q|0)|0;U=F()|0;W=Ww(r|0,s|0,t|0,u|0)|0;Q=F()|0;o=(U|0)<0;L=_w(_|0,U|0,63)|0;F()|0;Z=(Q|0)<0;n=_w(W|0,Q|0,63)|0;F()|0;n=(L|0)==(n|0);L=Ww(0,0,_|0,U|0)|0;P=F()|0;_=o?L:_;U=o?P:U;P=Ww(0,0,W|0,Q|0)|0;o=F()|0;W=Z?P:W;Q=Z?o:Q;o=Uw(Q|0,0,U|0,0)|0;Z=F()|0;P=Uw(W|0,0,_|0,0)|0;L=F()|0;U=Uw(W|0,0,U|0,0)|0;W=F()|0;_=Uw(Q|0,0,_|0,0)|0;_=Vw(U|0,W|0,_|0,F()|0)|0;Z=Vw(F()|0,0,o|0,Z|0)|0;o=F()|0;_=Vw(0,_|0,P|0,L|0)|0;W=F()|0;P=Vw(Z|0,o|0,(W>>>0<L>>>0|(W|0)==(L|0)&_>>>0<P>>>0)&1|0,0)|0;L=F()|0;o=(_|0)==0&(W|0)==0;Z=Ww(0,0,_|0,W|0)|0;U=F()|0;Q=Ww(0,0,P|0,L|0)|0;d=F()|0;if(!((((O?aa:$)|0)==((n?_:Z)|0)?((O?Y:X)|0)==((n?W:U)|0):0)&(((O?R:N?T:~R)|0)==((n?P:o?Q:~P)|0)?((O?m:N?M:~m)|0)==((n?L:o?d:~L)|0):0)))break}if(!(a[C>>0]|0)){s=61;break e}m=(v|0)==(A|0)&(w|0)==(B|0);if(m&((x|0)==(t|0)&(y|0)==(u|0))){s=61;break e}if((v|0)==(p|0)&(w|0)==(q|0)&((x|0)==(r|0)&(y|0)==(s|0))){s=61;break e}if((p|0)==(A|0)&(q|0)==(B|0)&((r|0)==(t|0)&(s|0)==(u|0))){s=61;break e}if(m)if(((y|0)<(s|0)|(y|0)==(s|0)&x>>>0<r>>>0)^((s|0)<(u|0)|(s|0)==(u|0)&r>>>0<t>>>0)){s=61;break e}else break;else if(((w|0)<(q|0)|(w|0)==(q|0)&v>>>0<p>>>0)^((q|0)<(B|0)|(q|0)==(B|0)&p>>>0<A>>>0)){s=61;break e}else break}while(0);if((i|0)==(j|0)){h=j;s=66;break d}if(!f?(c[i+80>>2]|0)==(k|0):0){h=k;s=68;break d}h=i;m=A;n=B;}if((s|0)==45){if((h|0)==(i|0)){s=66;break}aa=h+84|0;$=c[aa>>2]|0;c[$+80>>2]=i;j=c[h+80>>2]|0;c[j+84>>2]=$;c[aa>>2]=0;k=(h|0)==(k|0)?i:k;}else if((s|0)==61){c[z+80>>2]=i;j=(c[h+80>>2]|0)+84|0;c[j>>2]=z;c[h+84>>2]=0;j=c[j>>2]|0;k=(h|0)==(k|0)?i:k;}}do if((s|0)==66)if(f)if((c[h+84>>2]|0)==(c[h+80>>2]|0)){s=70;break}else {s=72;break}else {i=h;h=c[h+80>>2]|0;s=68;break}while(0);if((s|0)==68)if((i|0)==(h|0))s=70;else {a[b+37>>0]=1;c[(c[k+84>>2]|0)+76>>2]=-2;s=72;}f:do if((s|0)==70){ak(H);h=0;}else if((s|0)==72){d=k+24|0;h=1;o=k;do{i=o+16|0;$=o+24|0;Z=c[$+4>>2]|0;m=o;o=c[o+80>>2]|0;n=o+24|0;aa=n;_=c[aa+4>>2]|0;if((Z|0)<(_|0)|((Z|0)==(_|0)?(c[$>>2]|0)>>>0<(c[aa>>2]|0)>>>0:0)){aa=m+32|0;c[aa>>2]=c[i>>2];c[aa+4>>2]=c[i+4>>2];c[aa+8>>2]=c[i+8>>2];c[aa+12>>2]=c[i+12>>2];aa=o+16|0;c[m>>2]=c[aa>>2];c[m+4>>2]=c[aa+4>>2];c[m+8>>2]=c[aa+8>>2];c[m+12>>2]=c[aa+12>>2];}else {c[m>>2]=c[i>>2];c[m+4>>2]=c[i+4>>2];c[m+8>>2]=c[i+8>>2];c[m+12>>2]=c[i+12>>2];$=o+16|0;aa=m+32|0;c[aa>>2]=c[$>>2];c[aa+4>>2]=c[$+4>>2];c[aa+8>>2]=c[$+8>>2];c[aa+12>>2]=c[$+12>>2];}j=m+40|0;i=m+8|0;i=Ww(c[j>>2]|0,c[j+4>>2]|0,c[i>>2]|0,c[i+4>>2]|0)|0;j=F()|0;if((i|0)==0&(j|0)==0)l=-1.e+40;else {$=m+32|0;aa=m;aa=Ww(c[$>>2]|0,c[$+4>>2]|0,c[aa>>2]|0,c[aa+4>>2]|0)|0;l=(+(aa>>>0)+4294967296.0*+(F()|0))/(+(i>>>0)+4294967296.0*+(j|0));}g[m+48>>3]=l;c[m+56>>2]=e;if(h){aa=n;h=d;h=(c[aa>>2]|0)==(c[h>>2]|0)?(c[aa+4>>2]|0)==(c[h+4>>2]|0):0;}else h=0;}while((o|0)!=(k|0));if(h){if(f){ak(H);h=0;break}j=c[k+84>>2]|0;c[j+76>>2]=-2;_=k+8|0;$=c[_+4>>2]|0;aa=J;c[aa>>2]=c[_>>2];c[aa+4>>2]=$;c[J+8>>2]=0;c[J+12>>2]=k;c[k+60>>2]=2;c[k+64>>2]=0;while(1){i=k;h=c[i>>2]|0;i=c[i+4>>2]|0;aa=j+32|0;if(!((h|0)==(c[aa>>2]|0)?(i|0)==(c[aa+4>>2]|0):0)){aa=k+32|0;$=aa;_=c[$>>2]|0;$=c[$+4>>2]|0;c[aa>>2]=h;c[aa+4>>2]=i;aa=k;c[aa>>2]=_;c[aa+4>>2]=$;}h=c[k+80>>2]|0;if((c[h+76>>2]|0)==-2)break;c[k+88>>2]=h;k=h;j=c[h+84>>2]|0;}h=b+12|0;i=c[h>>2]|0;if((i|0)==(c[b+16>>2]|0))Je(b+8|0,J);else {c[i>>2]=c[J>>2];c[i+4>>2]=c[J+4>>2];c[i+8>>2]=c[J+8>>2];c[i+12>>2]=c[J+12>>2];c[h>>2]=(c[h>>2]|0)+16;}h=b+28|0;i=c[h>>2]|0;if((i|0)==(c[b+32>>2]|0))Ke(b+24|0,I);else {c[i>>2]=c[I>>2];c[h>>2]=(c[h>>2]|0)+4;}h=1;break}h=b+28|0;i=c[h>>2]|0;if((i|0)==(c[b+32>>2]|0))Ke(b+24|0,I);else {c[i>>2]=E;c[h>>2]=(c[h>>2]|0)+4;}h=c[k+84>>2]|0;$=h;aa=h+32|0;if(((c[$>>2]|0)==(c[aa>>2]|0)?(c[$+4>>2]|0)==(c[aa+4>>2]|0):0)?($=h+8|0,aa=h+40|0,(c[$>>2]|0)==(c[aa>>2]|0)?(c[$+4>>2]|0)==(c[aa+4>>2]|0):0):0)k=c[k+80>>2]|0;o=J+8|0;d=J+12|0;p=b+12|0;q=b+16|0;r=b+8|0;m=0;while(1){g:while(1){h=c[k+84>>2]|0;$=k;aa=h;do if(((c[$>>2]|0)==(c[aa>>2]|0)?(c[$+4>>2]|0)==(c[aa+4>>2]|0):0)?($=k+8|0,aa=h+8|0,(c[$>>2]|0)==(c[aa>>2]|0)?(c[$+4>>2]|0)==(c[aa+4>>2]|0):0):0){$=k+16|0;aa=k+32|0;if(((c[$>>2]|0)==(c[aa>>2]|0)?(c[$+4>>2]|0)==(c[aa+4>>2]|0):0)?($=k+24|0,aa=k+40|0,(c[$>>2]|0)==(c[aa>>2]|0)?(c[$+4>>2]|0)==(c[aa+4>>2]|0):0):0){s=108;break}l=+g[k+48>>3];i=+g[h+48>>3]==-1.e+40;if(l==-1.e+40)if(i)s=113;else j=k;else if(i)s=113;else break g;if((s|0)==113){s=0;i=h;while(1){h=c[i+84>>2]|0;if(+g[h+48>>3]==-1.e+40)i=h;else break}j=i;l=+g[i+48>>3];}if(l==-1.e+40){i=j;do i=c[i+80>>2]|0;while(+g[i+48>>3]==-1.e+40);k=i;i=c[i+84>>2]|0;}else {k=j;i=h;}$=k+40|0;aa=i+8|0;if(!((c[$>>2]|0)==(c[aa>>2]|0)?(c[$+4>>2]|0)==(c[aa+4>>2]|0):0)){s=121;break g}}else s=108;while(0);if((s|0)==108){s=0;k=c[k+80>>2]|0;}}if((s|0)==121){s=0;$=h;Z=c[$+4>>2]|0;aa=k;_=c[aa+4>>2]|0;k=(Z|0)<(_|0)|((Z|0)==(_|0)?(c[$>>2]|0)>>>0<(c[aa>>2]|0)>>>0:0)?j:k;}if((k|0)==(m|0)){h=1;break f}m=(m|0)==0?k:m;$=k+8|0;aa=c[$+4>>2]|0;h=J;c[h>>2]=c[$>>2];c[h+4>>2]=aa;h=c[k+84>>2]|0;if(+g[k+48>>3]<+g[h+48>>3]){c[o>>2]=h;c[d>>2]=k;n=0;i=h;}else {c[o>>2]=k;c[d>>2]=h;n=1;i=k;k=h;}do if(f){h=i+64|0;if((c[i+80>>2]|0)==(k|0)){c[h>>2]=-1;h=1;break}else {c[h>>2]=1;h=-1;break}}else {c[i+64>>2]=0;h=0;}while(0);c[k+64>>2]=h;h=Dc(b,i,n)|0;if((c[h+76>>2]|0)==-2)h=Dc(b,h,n)|0;i=n^1;j=Dc(b,c[d>>2]|0,i)|0;if((c[j+76>>2]|0)==-2)j=Dc(b,j,i)|0;if((c[(c[o>>2]|0)+76>>2]|0)!=-2){if((c[(c[d>>2]|0)+76>>2]|0)==-2)c[d>>2]=0;}else c[o>>2]=0;i=c[p>>2]|0;if((i|0)==(c[q>>2]|0))Je(r,J);else {c[i>>2]=c[J>>2];c[i+4>>2]=c[J+4>>2];c[i+8>>2]=c[J+8>>2];c[i+12>>2]=c[J+12>>2];c[p>>2]=(c[p>>2]|0)+16;}k=n?h:j;}}while(0);aa=h;Eb=K;return aa|0}function Fc(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;i=b+4|0;g=c[b>>2]|0;if((c[i>>2]|0)==(g|0)){i=0;return i|0}h=0;f=0;do{f=f|(Qb[c[(c[a>>2]|0)+8>>2]&15](a,g+(h*12|0)|0,d,e)|0);h=h+1|0;g=c[b>>2]|0;}while(h>>>0<(((c[i>>2]|0)-g|0)/12|0)>>>0);return f|0}function Gc(a){a=a|0;return ((c[a+4>>2]|0)-(c[a>>2]|0)|0)/12|0|0}function Hc(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;h=c[b+8>>2]|0;c[b+12>>2]=h;c[b+4>>2]=h;h=b+24|0;i=b+28|0;e=c[i>>2]|0;d=c[h>>2]|0;if((e|0)==(d|0)){h=e;c[i>>2]=h;i=b+20|0;a[i>>0]=0;i=b+37|0;a[i>>0]=0;return}g=0;f=e;while(1){e=c[d+(g<<2)>>2]|0;if(!e)e=f;else {ak(e);d=c[h>>2]|0;e=c[i>>2]|0;}g=g+1|0;if(g>>>0>=e-d>>2>>>0)break;else f=e;}c[i>>2]=d;i=b+20|0;a[i>>0]=0;i=b+37|0;a[i>>0]=0;return}function Ic(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;x=Eb;Eb=Eb+16|0;m=x;n=a+8|0;b=c[n>>2]|0;w=a+4|0;c[w>>2]=b;o=a+12|0;d=c[o>>2]|0;if((b|0)==(d|0)){Eb=x;return}Le(b,d,m);l=a+56|0;b=c[l>>2]|0;if(!b){b=a+64|0;d=a+60|0;}else {d=a+60|0;c[d>>2]=b;$j(b);b=a+64|0;c[b>>2]=0;c[d>>2]=0;c[l>>2]=0;}c[l>>2]=0;c[d>>2]=0;c[b>>2]=0;b=c[n>>2]|0;if((b|0)!=(c[o>>2]|0)){j=a+60|0;k=a+64|0;f=0;g=0;while(1){e=b;d=c[e>>2]|0;e=c[e+4>>2]|0;i=m;c[i>>2]=d;c[i+4>>2]=e;if((f|0)==(g|0)){Oe(l,m);d=c[j>>2]|0;}else {i=f;c[i>>2]=d;c[i+4>>2]=e;d=f+8|0;c[j>>2]=d;}i=c[l>>2]|0;e=d-i|0;if((e|0)>8?(p=((e>>>3)+-2|0)/2|0,q=i+(p<<3)|0,r=d+-8|0,t=q,s=c[t>>2]|0,t=c[t+4>>2]|0,v=r,u=c[v>>2]|0,v=c[v+4>>2]|0,(t|0)<(v|0)|(t|0)==(v|0)&s>>>0<u>>>0):0){e=p;f=q;d=r;g=s;h=t;while(1){c[d>>2]=g;c[d+4>>2]=h;if(!e)break;e=(e+-1|0)/2|0;d=i+(e<<3)|0;h=d;g=c[h>>2]|0;h=c[h+4>>2]|0;if(!((h|0)<(v|0)|(h|0)==(v|0)&g>>>0<u>>>0))break;else {y=f;f=d;d=y;}}y=f;c[y>>2]=u;c[y+4>>2]=v;}d=c[b+8>>2]|0;if(d|0){y=d+16|0;c[y>>2]=c[d>>2];c[y+4>>2]=c[d+4>>2];c[y+8>>2]=c[d+8>>2];c[y+12>>2]=c[d+12>>2];c[d+60>>2]=1;c[d+76>>2]=-1;}d=c[b+12>>2]|0;if(d|0){y=d+16|0;c[y>>2]=c[d>>2];c[y+4>>2]=c[d+4>>2];c[y+8>>2]=c[d+8>>2];c[y+12>>2]=c[d+12>>2];c[d+60>>2]=2;c[d+76>>2]=-1;}b=b+16|0;if((b|0)==(c[o>>2]|0))break;f=c[j>>2]|0;g=c[k>>2]|0;}b=c[n>>2]|0;}c[a+52>>2]=0;c[w>>2]=b;Eb=x;return}function Jc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;d=c[b+8>>2]|0;w=c[b+12>>2]|0;if((d|0)==(w|0)){c[a>>2]=0;c[a+4>>2]=0;c[a+8>>2]=0;c[a+12>>2]=0;c[a+16>>2]=0;c[a+20>>2]=0;c[a+24>>2]=0;c[a+28>>2]=0;return}s=c[d+8>>2]|0;l=s;i=c[l>>2]|0;l=c[l+4>>2]|0;g=a;c[g>>2]=i;c[g+4>>2]=l;g=s+8|0;e=c[g>>2]|0;g=c[g+4>>2]|0;t=a+8|0;u=t;c[u>>2]=e;c[u+4>>2]=g;u=a+16|0;v=u;c[v>>2]=i;c[v+4>>2]=l;v=a+24|0;m=v;c[m>>2]=e;c[m+4>>2]=g;m=e;k=g;j=i;h=l;f=g;b=e;while(1){q=(f|0)<(g|0)|(f|0)==(g|0)&b>>>0<e>>>0;r=q?e:b;f=q?g:f;q=v;c[q>>2]=r;c[q+4>>2]=f;q=d+12|0;p=s;g=k;e=m;b=j;while(1){n=c[p+88>>2]|0;m=p;k=c[m>>2]|0;m=c[m+4>>2]|0;j=(m|0)<(l|0)|(m|0)==(l|0)&k>>>0<i>>>0;if(!n){k=p;i=p;}else {o=n;while(1){if(j){l=a;c[l>>2]=k;c[l+4>>2]=m;l=m;i=k;}if((m|0)>(h|0)|(m|0)==(h|0)&k>>>0>b>>>0){b=u;c[b>>2]=k;c[b+4>>2]=m;b=k;h=m;}n=c[o+88>>2]|0;m=o;k=c[m>>2]|0;m=c[m+4>>2]|0;j=(m|0)<(l|0)|(m|0)==(l|0)&k>>>0<i>>>0;if(!n)break;else o=n;}k=o;i=o;}l=j?i:a;x=c[l>>2]|0;l=c[l+4>>2]|0;o=a;c[o>>2]=x;c[o+4>>2]=l;o=i;j=c[o>>2]|0;o=c[o+4>>2]|0;n=(h|0)<(o|0)|(h|0)==(o|0)&b>>>0<j>>>0;j=n?j:b;h=n?o:h;o=u;c[o>>2]=j;c[o+4>>2]=h;o=k+32|0;n=o;i=c[n>>2]|0;n=c[n+4>>2]|0;m=(n|0)<(l|0)|(n|0)==(l|0)&i>>>0<x>>>0;i=m?i:x;l=m?n:l;n=a;c[n>>2]=i;c[n+4>>2]=l;n=c[o>>2]|0;o=c[o+4>>2]|0;m=(h|0)<(o|0)|(h|0)==(o|0)&j>>>0<n>>>0;j=m?n:j;h=m?o:h;o=u;c[o>>2]=j;c[o+4>>2]=h;o=k+40|0;m=c[o>>2]|0;o=c[o+4>>2]|0;n=(o|0)<(g|0)|(o|0)==(g|0)&m>>>0<e>>>0;e=n?m:e;g=n?o:g;o=t;c[o>>2]=e;c[o+4>>2]=g;if((p|0)!=(s|0))break;p=c[q>>2]|0;b=j;}b=d+16|0;if((b|0)==(w|0))break;s=c[d+24>>2]|0;x=s+8|0;d=b;m=e;k=g;g=c[x+4>>2]|0;b=r;e=c[x>>2]|0;}return}function Kc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;u=c[a+56>>2]|0;s=a+60|0;a=c[s>>2]|0;if((u|0)==(a|0)){u=0;return u|0}d=u;e=c[d+4>>2]|0;r=b;c[r>>2]=c[d>>2];c[r+4>>2]=e;r=u;e=a-r|0;d=e>>3;q=a+-8|0;if((e|0)>8?(p=u,o=c[p>>2]|0,p=c[p+4>>2]|0,m=q,n=c[m+4>>2]|0,l=u,c[l>>2]=c[m>>2],c[l+4>>2]=n,l=q,c[l>>2]=o,c[l+4>>2]=p,l=d+-1|0,(e|0)!=16):0){k=(d+-3|0)/2|0;a=u+8|0;d=a;if((e|0)>24){p=u+16|0;m=c[a+4>>2]|0;o=p;n=c[o+4>>2]|0;o=(m|0)<(n|0)|((m|0)==(n|0)?(c[a>>2]|0)>>>0<(c[o>>2]|0)>>>0:0);a=o?2:1;d=o?p:d;}else a=1;f=d;e=c[f>>2]|0;f=c[f+4>>2]|0;j=u;i=c[j>>2]|0;j=c[j+4>>2]|0;if(!((f|0)<(j|0)|(f|0)==(j|0)&e>>>0<i>>>0)){h=u;g=e;while(1){p=h;h=d;c[p>>2]=g;c[p+4>>2]=f;if((k|0)<(a|0))break;a=a<<1|1;f=u+(a<<3)|0;g=f;e=a+1|0;if((e|0)<(l|0)){p=f+8|0;n=f;f=c[n+4>>2]|0;o=p;m=c[o+4>>2]|0;o=(f|0)<(m|0)|((f|0)==(m|0)?(c[n>>2]|0)>>>0<(c[o>>2]|0)>>>0:0);a=o?e:a;e=o?p:g;}else e=g;f=e;g=c[f>>2]|0;f=c[f+4>>2]|0;if((f|0)<(j|0)|(f|0)==(j|0)&g>>>0<i>>>0)break;else d=e;}p=d;c[p>>2]=i;c[p+4>>2]=j;}}c[s>>2]=q;if((u|0)==(q|0)){u=1;return u|0}m=u+8|0;n=m;o=u+16|0;p=o;l=q;while(1){d=b;a=c[d>>2]|0;d=c[d+4>>2]|0;q=u;if(!((a|0)==(c[q>>2]|0)?(d|0)==(c[q+4>>2]|0):0)){a=1;d=28;break}f=l-r|0;e=f>>3;l=l+-8|0;if((f|0)>8?(k=l,q=c[k+4>>2]|0,t=u,c[t>>2]=c[k>>2],c[t+4>>2]=q,t=l,c[t>>2]=a,c[t+4>>2]=d,t=e+-1|0,(f|0)!=16):0){k=(e+-3|0)/2|0;if((f|0)>24){a=m;j=c[a+4>>2]|0;d=o;q=c[d+4>>2]|0;d=(j|0)<(q|0)|((j|0)==(q|0)?(c[a>>2]|0)>>>0<(c[d>>2]|0)>>>0:0);a=d?2:1;d=d?p:n;}else {a=1;d=n;}f=d;e=c[f>>2]|0;f=c[f+4>>2]|0;j=u;i=c[j>>2]|0;j=c[j+4>>2]|0;if(!((f|0)<(j|0)|(f|0)==(j|0)&e>>>0<i>>>0)){h=u;g=e;while(1){q=h;h=d;c[q>>2]=g;c[q+4>>2]=f;if((k|0)<(a|0))break;a=a<<1|1;e=u+(a<<3)|0;g=e;f=a+1|0;if((f|0)<(t|0)){q=e+8|0;v=e;x=c[v+4>>2]|0;e=q;w=c[e+4>>2]|0;e=(x|0)<(w|0)|((x|0)==(w|0)?(c[v>>2]|0)>>>0<(c[e>>2]|0)>>>0:0);a=e?f:a;e=e?q:g;}else e=g;f=e;g=c[f>>2]|0;f=c[f+4>>2]|0;if((f|0)<(j|0)|(f|0)==(j|0)&g>>>0<i>>>0)break;else d=e;}x=d;c[x>>2]=i;c[x+4>>2]=j;}}c[s>>2]=l;if((u|0)==(l|0)){a=1;d=28;break}}if((d|0)==28)return a|0;return 0}function Lc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;h=b+92|0;i=c[h>>2]|0;l=b+96|0;e=c[l>>2]|0;if((i|0)==(e|0))return;k=d+92|0;g=c[k>>2]|0;j=d+96|0;f=c[j>>2]|0;if((g|0)==(f|0))return;if((i|0)!=(d|0)){if((g|0)!=(b|0)){c[h>>2]=g;if(g){c[g+96>>2]=b;f=c[j>>2]|0;}c[l>>2]=f;if(f|0)c[f+92>>2]=b;c[k>>2]=i;if(i|0)c[i+96>>2]=d;c[j>>2]=e;if(!e)e=0;else c[e+92>>2]=d;}else {if(!i)e=f;else {c[i+96>>2]=d;e=c[j>>2]|0;}if(e|0)c[e+92>>2]=b;c[l>>2]=e;c[h>>2]=d;c[j>>2]=b;c[k>>2]=i;e=b;}if(!(c[l>>2]|0)){c[a+52>>2]=b;return}}else {if(g){c[g+96>>2]=b;e=c[l>>2]|0;}if(e|0)c[e+92>>2]=d;c[j>>2]=e;c[k>>2]=b;c[l>>2]=d;c[h>>2]=g;e=c[j>>2]|0;}if(e|0)return;c[a+52>>2]=d;return}function Mc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;q=Eb;Eb=Eb+16|0;l=q;f=c[b>>2]|0;j=c[f+88>>2]|0;if(!j){q=S(16)|0;Bc(q,7567);V(q|0,1024,9);}c[j+76>>2]=c[f+76>>2];i=c[f+96>>2]|0;f=c[f+92>>2]|0;c[((i|0)==0?a+52|0:i+92|0)>>2]=j;if(f|0)c[f+96>>2]=c[(c[b>>2]|0)+88>>2];k=c[b>>2]|0;j=c[k+88>>2]|0;c[j+60>>2]=c[k+60>>2];c[j+64>>2]=c[k+64>>2];c[j+68>>2]=c[k+68>>2];c[j+72>>2]=c[k+72>>2];c[b>>2]=j;k=j+16|0;c[k>>2]=c[j>>2];c[k+4>>2]=c[j+4>>2];c[k+8>>2]=c[j+8>>2];c[k+12>>2]=c[j+12>>2];c[(c[b>>2]|0)+96>>2]=i;c[(c[b>>2]|0)+92>>2]=f;f=c[b>>2]|0;if(+g[f+48>>3]==-1.e+40){Eb=q;return}b=f+40|0;f=c[b>>2]|0;b=c[b+4>>2]|0;k=l;c[k>>2]=f;c[k+4>>2]=b;k=a+56|0;i=a+60|0;j=c[i>>2]|0;if((j|0)==(c[a+64>>2]|0)){Oe(k,l);b=c[i>>2]|0;}else {l=j;c[l>>2]=f;c[l+4>>2]=b;b=j+8|0;c[i>>2]=b;}i=c[k>>2]|0;f=b-i|0;if((f|0)>8?(h=((f>>>3)+-2|0)/2|0,m=i+(h<<3)|0,d=b+-8|0,e=m,n=c[e>>2]|0,e=c[e+4>>2]|0,p=d,o=c[p>>2]|0,p=c[p+4>>2]|0,(e|0)<(p|0)|(e|0)==(p|0)&n>>>0<o>>>0):0){b=m;f=n;while(1){n=d;c[n>>2]=f;c[n+4>>2]=e;if(!h)break;h=(h+-1|0)/2|0;d=i+(h<<3)|0;e=d;f=c[e>>2]|0;e=c[e+4>>2]|0;if(!((e|0)<(p|0)|(e|0)==(p|0)&f>>>0<o>>>0))break;else {n=b;b=d;d=n;}}n=b;c[n>>2]=o;c[n+4>>2]=p;}Eb=q;return}function Nc(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Oc(a,b,c,d,d)|0}function Oc(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;o=b+128|0;if(a[o>>0]|0){o=0;return o|0}if(a[b+37>>0]|0){o=S(16)|0;Bc(o,7599);V(o|0,1024,9);}a[o>>0]=1;k=e+4|0;j=c[k>>2]|0;m=c[e>>2]|0;l=m;h=j;if((j|0)!=(m|0)){if((l|0)!=(h|0))do{i=h;h=h+-12|0;j=c[h>>2]|0;if(j|0){c[i+-8>>2]=j;$j(j);}}while((h|0)!=(l|0));c[k>>2]=l;}c[b+136>>2]=f;c[b+132>>2]=g;c[b+108>>2]=d;a[b+141>>0]=0;m=Lb[c[(c[b>>2]|0)+20>>2]&63](b)|0;if(m)Rc(b,e);f=b+40|0;g=b+44|0;h=c[g>>2]|0;i=c[f>>2]|0;if((h|0)!=(i|0)){l=b+40|0;k=0;h=i;do{h=h+(k<<2)|0;j=c[h>>2]|0;d=j+16|0;i=c[d>>2]|0;if(!i){if(j)n=20;}else {c[(c[i+28>>2]|0)+24>>2]=0;h=c[d>>2]|0;if(!h)n=20;else {do{c[d>>2]=c[h+24>>2];$j(h);h=c[d>>2]|0;}while((h|0)!=0);n=20;}}if((n|0)==20){n=0;$j(j);h=(c[l>>2]|0)+(k<<2)|0;}c[h>>2]=0;k=k+1|0;h=c[f>>2]|0;}while(k>>>0<(c[g>>2]|0)-h>>2>>>0)}c[g>>2]=h;a[o>>0]=0;o=m;return o|0}function Pc(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Qc(a,b,c,d,d)|0}function Qc(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0;m=b+128|0;if(a[m>>0]|0){m=0;return m|0}a[m>>0]=1;c[b+136>>2]=f;c[b+132>>2]=g;c[b+108>>2]=d;a[b+141>>0]=1;k=Lb[c[(c[b>>2]|0)+20>>2]&63](b)|0;if(k)Sc(b,e);i=b+40|0;j=b+44|0;d=c[j>>2]|0;f=c[i>>2]|0;if((d|0)!=(f|0)){h=b+40|0;b=0;d=f;do{d=d+(b<<2)|0;g=c[d>>2]|0;e=g+16|0;f=c[e>>2]|0;if(!f){if(g)l=11;}else {c[(c[f+28>>2]|0)+24>>2]=0;d=c[e>>2]|0;if(!d)l=11;else {do{c[e>>2]=c[d+24>>2];$j(d);d=c[e>>2]|0;}while((d|0)!=0);l=11;}}if((l|0)==11){l=0;$j(g);d=(c[h>>2]|0)+(b<<2)|0;}c[d>>2]=0;b=b+1|0;d=c[i>>2]|0;}while(b>>>0<(c[j>>2]|0)-d>>2>>>0)}c[j>>2]=d;a[m>>0]=0;m=k;return m|0}function Rc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;r=Eb;Eb=Eb+16|0;p=r;q=a+40|0;o=a+44|0;md(b,(c[o>>2]|0)-(c[q>>2]|0)>>2);d=c[o>>2]|0;a=c[q>>2]|0;if((d|0)==(a|0)){Eb=r;return}k=p+4|0;l=p+8|0;m=b+4|0;n=b+8|0;j=0;e=d;while(1){d=a+(j<<2)|0;if(!(c[(c[d>>2]|0)+16>>2]|0))d=e;else {c[p>>2]=0;c[k>>2]=0;c[l>>2]=0;d=c[(c[(c[d>>2]|0)+16>>2]|0)+28>>2]|0;if(d|0){a=d;g=0;while(1){e=g+1|0;a=c[a+24>>2]|0;if((a|0)==(d|0))break;else g=e;}if(e>>>0>=2){nd(p,e);a=0;while(1){e=d+8|0;f=c[k>>2]|0;if((f|0)==(c[l>>2]|0))Ge(p,e);else {c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];c[f+8>>2]=c[e+8>>2];c[f+12>>2]=c[e+12>>2];c[k>>2]=f+16;}if(a>>>0<g>>>0){d=c[d+28>>2]|0;a=a+1|0;}else break}h=c[m>>2]|0;if((h|0)==(c[n>>2]|0)){He(b,p);a=c[p>>2]|0;}else {c[h>>2]=0;i=h+4|0;c[i>>2]=0;e=h+8|0;c[e>>2]=0;a=c[p>>2]|0;d=(c[k>>2]|0)-a|0;f=d>>4;if(d){if(f>>>0>268435455){a=13;break}g=Zj(d)|0;c[i>>2]=g;c[h>>2]=g;c[e>>2]=g+(f<<4);a=c[p>>2]|0;d=(c[k>>2]|0)-a|0;if((d|0)>0){ax(g|0,a|0,d|0)|0;c[i>>2]=g+(d>>>4<<4);}}c[m>>2]=(c[m>>2]|0)+12;}if(a|0){c[k>>2]=a;$j(a);}}}a=c[q>>2]|0;d=c[o>>2]|0;}j=j+1|0;if(j>>>0>=d-a>>2>>>0){a=3;break}else e=d;}if((a|0)==3){Eb=r;return}else if((a|0)==13)gk();}function Sc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;v=Eb;Eb=Eb+16|0;u=v;n=d+48|0;o=d+52|0;e=c[o>>2]|0;f=c[n>>2]|0;if((e|0)!=(f|0)){h=0;g=f;do{f=c[g+(h<<2)>>2]|0;if(f){Ub[c[(c[f>>2]|0)+4>>2]&127](f);e=c[o>>2]|0;g=c[n>>2]|0;}h=h+1|0;f=e-g|0;}while(h>>>0<f>>2>>>0);if(f|0)c[o>>2]=g;}r=d+16|0;s=d+20|0;e=c[r>>2]|0;if((c[s>>2]|0)!=(e|0))c[s>>2]=e;q=b+40|0;p=b+44|0;qd(n,(c[p>>2]|0)-(c[q>>2]|0)>>2);e=c[p>>2]|0;f=c[q>>2]|0;if((e|0)==(f|0))e=0;else {m=d+56|0;l=0;while(1){i=c[f+(l<<2)>>2]|0;k=i+16|0;b=c[k>>2]|0;if(!b)g=0;else {h=b;g=0;do{g=g+1|0;h=c[h+24>>2]|0;}while((h|0)!=(b|0))}j=(a[i+5>>0]|0)!=0;if(!((g|0)<2&j)?!((g|0)<3&(j^1)):0){b=i+8|0;e=c[b>>2]|0;do if(e|0){h=a[i+4>>0]|0;f=a[e+4>>0]|0;if(h<<24>>24!=f<<24>>24?c[e+16>>2]|0:0)break;while(1){if(f<<24>>24!=h<<24>>24?c[e+16>>2]|0:0)break;f=c[e+8>>2]|0;if(!f){e=0;break}e=f;f=a[f+4>>0]|0;}c[b>>2]=e;}while(0);e=Zj(48)|0;c[e>>2]=3512;f=e+4|0;c[f>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;c[f+16>>2]=0;c[f+20>>2]=0;c[f+24>>2]=0;c[f+28>>2]=0;a[f+32>>0]=0;c[u>>2]=e;f=c[o>>2]|0;if((f|0)==(c[m>>2]|0))Ye(n,u);else {c[f>>2]=e;c[o>>2]=(c[o>>2]|0)+4;}j=c[u>>2]|0;c[i+12>>2]=j;c[j+28>>2]=0;c[j+32>>2]=0;nd(j+4|0,g);if((g|0)>0){j=0;e=c[k>>2]|0;do{e=c[e+28>>2]|0;f=c[u>>2]|0;h=e+8|0;b=f+8|0;i=c[b>>2]|0;if((i|0)==(c[f+12>>2]|0))Ge(f+4|0,h);else {c[i>>2]=c[h>>2];c[i+4>>2]=c[h+4>>2];c[i+8>>2]=c[h+8>>2];c[i+12>>2]=c[h+12>>2];c[b>>2]=(c[b>>2]|0)+16;}j=j+1|0;}while((j|0)!=(g|0))}g=c[q>>2]|0;f=c[p>>2]|0;}else {g=f;f=e;}l=l+1|0;e=f-g>>2;if(l>>>0>=e>>>0)break;else {e=f;f=g;}}}qd(r,e);e=c[q>>2]|0;if((c[p>>2]|0)==(e|0)){Eb=v;return}j=d+24|0;i=0;do{e=c[e+(i<<2)>>2]|0;b=c[e+12>>2]|0;if(b|0){do if(!(a[e+5>>0]|0)){e=c[e+8>>2]|0;if(e|0?(t=c[e+12>>2]|0,t|0):0){f=t+16|0;g=t+20|0;h=c[g>>2]|0;e=h-(c[f>>2]|0)|0;c[u>>2]=b;if((c[t+24>>2]|0)>>>0>h>>>0){c[h>>2]=b;c[g>>2]=(c[g>>2]|0)+4;}else Ie(f,u);f=t;break}f=c[s>>2]|0;e=f-(c[r>>2]|0)|0;c[u>>2]=b;if((c[j>>2]|0)>>>0>f>>>0){c[f>>2]=b;c[s>>2]=(c[s>>2]|0)+4;}else Ie(r,u);f=d;}else {a[b+36>>0]=1;f=c[s>>2]|0;e=f-(c[r>>2]|0)|0;c[u>>2]=b;if((c[j>>2]|0)>>>0>f>>>0){c[f>>2]=b;c[s>>2]=(c[s>>2]|0)+4;}else Ie(r,u);f=d;}while(0);c[b+28>>2]=f;c[b+32>>2]=e>>2;}i=i+1|0;e=c[q>>2]|0;}while(i>>>0<(c[p>>2]|0)-e>>2>>>0);Eb=v;return}function Tc(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0.0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0.0,s=0,t=0;p=Eb;Eb=Eb+32|0;i=p+8|0;o=p;Ub[c[(c[b>>2]|0)+16>>2]&127](b);c[i>>2]=i;e=i+4|0;c[e>>2]=i;f=i+8|0;c[f>>2]=0;g=b+112|0;h=b+120|0;if(c[h>>2]|0?(d=c[b+116>>2]|0,n=(c[g>>2]|0)+4|0,m=c[d>>2]|0,c[m+4>>2]=c[n>>2],c[c[n>>2]>>2]=m,c[h>>2]=0,(d|0)!=(g|0)):0){do{n=d;d=c[d+4>>2]|0;$j(n);}while((d|0)!=(g|0));d=c[f>>2]|0;if(d|0){l=c[e>>2]|0;m=c[i>>2]|0;n=m+4|0;k=c[l>>2]|0;c[k+4>>2]=c[n>>2];c[c[n>>2]>>2]=k;k=c[g>>2]|0;c[k+4>>2]=l;c[l>>2]=k;c[g>>2]=m;c[n>>2]=g;c[h>>2]=(c[h>>2]|0)+d;c[f>>2]=0;}}n=b+124|0;c[n>>2]=0;if(!(Kc(b,i)|0)){b=0;Eb=p;return b|0}Uc(b,c[i>>2]|0,c[i+4>>2]|0);i=b+12|0;k=b+4|0;l=b+84|0;m=b+88|0;while(1){if(!(Kc(b,o)|0)?(c[k>>2]|0)==(c[i>>2]|0):0){d=9;break}d=c[n>>2]|0;if(d|0)do{e=d+104|0;f=c[e>>2]|0;g=d+100|0;h=c[g>>2]|0;c[((f|0)==0?n:f+100|0)>>2]=h;if(h|0)c[h+104>>2]=f;c[g>>2]=0;c[e>>2]=0;gd(b,d);d=c[n>>2]|0;}while((d|0)!=0);d=c[m>>2]|0;e=c[l>>2]|0;if((d|0)!=(e|0)){g=0;do{f=c[e+(g<<2)>>2]|0;if(f){$j(f);e=c[l>>2]|0;d=c[m>>2]|0;}g=g+1|0;f=d-e|0;}while(g>>>0<f>>2>>>0);if(f|0)c[m>>2]=e;}d=o;e=c[d>>2]|0;d=c[d+4>>2]|0;if(!(Vc(b,e,d)|0)){d=8;break}Wc(b,e,d);Uc(b,e,d);}if((d|0)==8)k=0;else if((d|0)==9){n=b+40|0;o=b+44|0;f=c[o>>2]|0;e=c[n>>2]|0;d=e;if((f|0)!=(e|0)){l=b+140|0;m=f-e>>2;i=0;do{g=c[d+(i<<2)>>2]|0;k=c[g+16>>2]|0;if(k|0?(a[g+5>>0]|0)==0:0){h=a[l>>0]^a[g+4>>0];j=0.0;g=k;do{s=c[g+28>>2]|0;q=s+8|0;t=g+8|0;q=Vw(c[t>>2]|0,c[t+4>>2]|0,c[q>>2]|0,c[q+4>>2]|0)|0;r=+(q>>>0)+4294967296.0*+(F()|0);s=s+16|0;q=g+16|0;q=Ww(c[s>>2]|0,c[s+4>>2]|0,c[q>>2]|0,c[q+4>>2]|0)|0;j=j+r*(+(q>>>0)+4294967296.0*+(F()|0));g=c[g+24>>2]|0;}while((g|0)!=(k|0));if((h&255|0)==(j*.5>0.0|0)){g=k;do{s=g+24|0;t=g;g=c[s>>2]|0;t=t+28|0;c[s>>2]=c[t>>2];c[t>>2]=g;}while((g|0)!=(k|0))}}i=i+1|0;}while(i>>>0<m>>>0)}if((c[b+72>>2]|0)!=(c[b+76>>2]|0)){Xc(b);d=c[n>>2]|0;f=c[o>>2]|0;e=d;}if((f|0)!=(e|0)){i=0;do{d=c[d+(i<<2)>>2]|0;h=d+16|0;e=c[h>>2]|0;do if(e|0){if(!(a[d+5>>0]|0)){Yc(b,d);break}d=c[e+28>>2]|0;if((e|0)!=(d|0)){do{f=c[e+24>>2]|0;e=f;g=c[f+28>>2]|0;s=f+8|0;t=g+8|0;if(((c[s>>2]|0)==(c[t>>2]|0)?(c[s+4>>2]|0)==(c[t+4>>2]|0):0)?(s=f+16|0,t=g+16|0,(c[s>>2]|0)==(c[t>>2]|0)?(c[s+4>>2]|0)==(c[t+4>>2]|0):0):0){e=f+24|0;c[g+24>>2]=c[e>>2];c[(c[e>>2]|0)+28>>2]=g;$j(f);d=(f|0)==(d|0)?g:d;e=g;}}while((d|0)!=(e|0));if((d|0)!=(c[d+28>>2]|0))break}else d=e;$j(d);c[h>>2]=0;}while(0);i=i+1|0;d=c[n>>2]|0;}while(i>>>0<(c[o>>2]|0)-d>>2>>>0)}if(!(a[b+142>>0]|0))k=1;else {Zc(b);k=1;}}h=b+72|0;i=b+76|0;e=c[i>>2]|0;d=c[h>>2]|0;if((e|0)!=(d|0)){g=0;do{f=c[d+(g<<2)>>2]|0;if(f){$j(f);d=c[h>>2]|0;e=c[i>>2]|0;}g=g+1|0;f=e-d|0;}while(g>>>0<f>>2>>>0);if(f|0)c[i>>2]=d;}i=b+84|0;h=b+88|0;e=c[h>>2]|0;d=c[i>>2]|0;if((e|0)==(d|0)){t=k;Eb=p;return t|0}g=0;do{f=c[d+(g<<2)>>2]|0;if(f){$j(f);d=c[i>>2]|0;e=c[h>>2]|0;}g=g+1|0;f=e-d|0;}while(g>>>0<f>>2>>>0);if(!f){t=k;Eb=p;return t|0}c[h>>2]=d;t=k;Eb=p;return t|0}function Uc(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0;ra=Eb;Eb=Eb+32|0;X=ra+16|0;fa=ra;ha=b+12|0;la=b+4|0;f=c[la>>2]|0;if((f|0)==(c[ha>>2]|0)){Eb=ra;return}y=b+56|0;z=b+60|0;A=b+64|0;B=b+124|0;C=b+84|0;E=b+88|0;K=b+20|0;N=b+76|0;O=b+80|0;P=b+72|0;while(1){x=f;if(!((c[x>>2]|0)==(d|0)?(c[x+4>>2]|0)==(e|0):0)){f=99;break}c[la>>2]=f+16;w=c[f+8>>2]|0;x=c[f+12>>2]|0;o=(w|0)!=0;do if(o){dd(b,w,0);if(!x){_c(b,w);if($c(b,w)|0)m=bd(b,w,w)|0;else m=0;h=w+40|0;f=c[h>>2]|0;h=c[h+4>>2]|0;i=X;c[i>>2]=f;c[i+4>>2]=h;i=c[z>>2]|0;if((i|0)==(c[A>>2]|0)){Oe(y,X);f=c[z>>2]|0;}else {v=i;c[v>>2]=f;c[v+4>>2]=h;f=i+8|0;c[z>>2]=f;}l=c[y>>2]|0;h=f-l|0;if((h|0)>8?(ja=((h>>>3)+-2|0)/2|0,ka=l+(ja<<3)|0,ma=f+-8|0,oa=ka,na=c[oa>>2]|0,oa=c[oa+4>>2]|0,qa=ma,pa=c[qa>>2]|0,qa=c[qa+4>>2]|0,(oa|0)<(qa|0)|(oa|0)==(qa|0)&na>>>0<pa>>>0):0){h=ja;i=ka;f=ma;j=na;k=oa;while(1){v=f;c[v>>2]=j;c[v+4>>2]=k;if(!h)break;h=(h+-1|0)/2|0;f=l+(h<<3)|0;k=f;j=c[k>>2]|0;k=c[k+4>>2]|0;if(!((k|0)<(qa|0)|(k|0)==(qa|0)&j>>>0<pa>>>0))break;else {v=i;i=f;f=v;}}v=i;c[v>>2]=pa;c[v+4>>2]=qa;}break}else {dd(b,x,w);_c(b,w);c[x+68>>2]=c[w+68>>2];c[x+72>>2]=c[w+72>>2];if($c(b,w)|0)m=ad(b,w,x,w)|0;else m=0;h=w+40|0;f=c[h>>2]|0;h=c[h+4>>2]|0;i=X;c[i>>2]=f;c[i+4>>2]=h;i=c[z>>2]|0;if((i|0)==(c[A>>2]|0)){Oe(y,X);f=c[z>>2]|0;}else {v=i;c[v>>2]=f;c[v+4>>2]=h;f=i+8|0;c[z>>2]=f;}l=c[y>>2]|0;h=f-l|0;if((h|0)>8?(D=((h>>>3)+-2|0)/2|0,G=l+(D<<3)|0,H=f+-8|0,J=G,I=c[J>>2]|0,J=c[J+4>>2]|0,M=H,L=c[M>>2]|0,M=c[M+4>>2]|0,(J|0)<(M|0)|(J|0)==(M|0)&I>>>0<L>>>0):0){h=D;i=G;f=H;j=I;k=J;while(1){v=f;c[v>>2]=j;c[v+4>>2]=k;if(!h)break;h=(h+-1|0)/2|0;f=l+(h<<3)|0;k=f;j=c[k>>2]|0;k=c[k+4>>2]|0;if(!((k|0)<(M|0)|(k|0)==(M|0)&j>>>0<L>>>0))break;else {v=i;i=f;f=v;}}v=i;c[v>>2]=L;c[v+4>>2]=M;}break}}else {dd(b,x,0);_c(b,x);if($c(b,x)|0)m=bd(b,x,x)|0;else m=0;}while(0);if(x|0){n=x+48|0;if(+g[n>>3]==-1.e+40){f=c[B>>2]|0;if(!f){c[B>>2]=x;c[x+104>>2]=0;f=0;}else {c[x+104>>2]=0;c[f+104>>2]=x;c[B>>2]=x;}c[x+100>>2]=f;f=c[x+88>>2]|0;if(f|0){h=f+40|0;f=c[h>>2]|0;h=c[h+4>>2]|0;i=X;c[i>>2]=f;c[i+4>>2]=h;i=c[z>>2]|0;if((i|0)==(c[A>>2]|0)){Oe(y,X);f=c[z>>2]|0;}else {v=i;c[v>>2]=f;c[v+4>>2]=h;f=i+8|0;c[z>>2]=f;}l=c[y>>2]|0;h=f-l|0;if((h|0)>8?(Q=((h>>>3)+-2|0)/2|0,R=l+(Q<<3)|0,S=f+-8|0,U=R,T=c[U>>2]|0,U=c[U+4>>2]|0,W=S,V=c[W>>2]|0,W=c[W+4>>2]|0,(U|0)<(W|0)|(U|0)==(W|0)&T>>>0<V>>>0):0){h=Q;i=R;f=S;j=T;k=U;while(1){v=f;c[v>>2]=j;c[v+4>>2]=k;if(!h)break;h=(h+-1|0)/2|0;f=l+(h<<3)|0;k=f;j=c[k>>2]|0;k=c[k+4>>2]|0;if(!((k|0)<(W|0)|(k|0)==(W|0)&j>>>0<V>>>0))break;else {v=i;i=f;f=v;}}v=i;c[v>>2]=V;c[v+4>>2]=W;}}}else {h=x+40|0;f=c[h>>2]|0;h=c[h+4>>2]|0;i=X;c[i>>2]=f;c[i+4>>2]=h;i=c[z>>2]|0;if((i|0)==(c[A>>2]|0)){Oe(y,X);f=c[z>>2]|0;}else {v=i;c[v>>2]=f;c[v+4>>2]=h;f=i+8|0;c[z>>2]=f;}l=c[y>>2]|0;h=f-l|0;if((h|0)>8?(Y=((h>>>3)+-2|0)/2|0,Z=l+(Y<<3)|0,_=f+-8|0,aa=Z,$=c[aa>>2]|0,aa=c[aa+4>>2]|0,ca=_,ba=c[ca>>2]|0,ca=c[ca+4>>2]|0,(aa|0)<(ca|0)|(aa|0)==(ca|0)&$>>>0<ba>>>0):0){h=Y;i=Z;f=_;j=$;k=aa;while(1){v=f;c[v>>2]=j;c[v+4>>2]=k;if(!h)break;h=(h+-1|0)/2|0;f=l+(h<<3)|0;k=f;j=c[k>>2]|0;k=c[k+4>>2]|0;if(!((k|0)<(ca|0)|(k|0)==(ca|0)&j>>>0<ba>>>0))break;else {v=i;i=f;f=v;}}v=i;c[v>>2]=ba;c[v+4>>2]=ca;}}if(o){if(((m|0?+g[n>>3]==-1.e+40:0)?(da=c[E>>2]|0,ea=c[C>>2]|0,(da|0)!=(ea|0)):0)?c[x+64>>2]|0:0){l=x+32|0;k=0;f=ea;h=da;do{i=c[f+(k<<2)>>2]|0;j=c[i>>2]|0;q=j+8|0;u=c[q>>2]|0;q=c[q+4>>2]|0;i=i+8|0;p=i;v=c[p>>2]|0;p=c[p+4>>2]|0;ta=x;s=c[ta>>2]|0;ta=c[ta+4>>2]|0;n=l;r=c[n>>2]|0;n=c[n+4>>2]|0;t=(q|0)>(p|0)|(q|0)==(p|0)&u>>>0>v>>>0;sa=t?p:q;p=t?q:p;q=(ta|0)>(n|0)|(ta|0)==(n|0)&s>>>0>r>>>0;o=q?n:ta;n=q?ta:n;if(((sa|0)<(n|0)|((sa|0)==(n|0)?(t?v:u)>>>0<(q?s:r)>>>0:0))&((o|0)<(p|0)|((o|0)==(p|0)?(q?r:s)>>>0<(t?u:v)>>>0:0))){c[fa>>2]=c[i>>2];c[fa+4>>2]=c[i+4>>2];c[fa+8>>2]=c[i+8>>2];c[fa+12>>2]=c[i+12>>2];h=Zj(24)|0;f=h+8|0;c[X>>2]=h;c[h>>2]=j;c[h+4>>2]=m;c[f>>2]=c[fa>>2];c[f+4>>2]=c[fa+4>>2];c[f+8>>2]=c[fa+8>>2];c[f+12>>2]=c[fa+12>>2];f=c[N>>2]|0;if((f|0)==(c[O>>2]|0))Re(P,X);else {c[f>>2]=h;c[N>>2]=(c[N>>2]|0)+4;}f=c[C>>2]|0;h=c[E>>2]|0;}k=k+1|0;}while(k>>>0<h-f>>2>>>0)}do if((((c[w+76>>2]|0)>-1?(ga=c[w+96>>2]|0,ga|0):0)?(sa=ga+16|0,ta=w,(c[sa>>2]|0)==(c[ta>>2]|0)?(c[sa+4>>2]|0)==(c[ta+4>>2]|0):0):0)?(c[ga+76>>2]|0)>-1:0){h=ga;f=c[h>>2]|0;h=c[h+4>>2]|0;r=ga+8|0;j=ga+32|0;i=c[j>>2]|0;j=c[j+4>>2]|0;q=ga+40|0;sa=w+16|0;v=c[sa>>2]|0;sa=c[sa+4>>2]|0;l=w+24|0;k=c[l>>2]|0;l=c[l+4>>2]|0;n=w+32|0;s=w+32|0;t=c[s>>2]|0;s=c[s+4>>2]|0;p=w+40|0;o=c[p>>2]|0;p=c[p+4>>2]|0;ta=(a[K>>0]|0)==0;q=Ww(c[r>>2]|0,c[r+4>>2]|0,c[q>>2]|0,c[q+4>>2]|0)|0;r=F()|0;s=Ww(v|0,sa|0,t|0,s|0)|0;t=F()|0;if(ta){v=Uw(s|0,t|0,q|0,r|0)|0;ta=F()|0;u=Ww(f|0,h|0,i|0,j|0)|0;sa=F()|0;t=Ww(k|0,l|0,o|0,p|0)|0;sa=Uw(t|0,F()|0,u|0,sa|0)|0;if(!((v|0)==(sa|0)&(ta|0)==(F()|0)))break}else {ya=(r|0)<0;Aa=_w(q|0,r|0,63)|0;F()|0;za=(t|0)<0;ua=_w(s|0,t|0,63)|0;F()|0;ua=(Aa|0)==(ua|0);Aa=Ww(0,0,q|0,r|0)|0;xa=F()|0;Aa=ya?Aa:q;xa=ya?xa:r;ya=Ww(0,0,s|0,t|0)|0;wa=F()|0;ya=za?ya:s;wa=za?wa:t;r=Uw(wa|0,0,xa|0,0)|0;za=F()|0;va=Uw(ya|0,0,Aa|0,0)|0;t=F()|0;xa=Uw(ya|0,0,xa|0,0)|0;ya=F()|0;Aa=Uw(wa|0,0,Aa|0,0)|0;Aa=Vw(xa|0,ya|0,Aa|0,F()|0)|0;za=Vw(F()|0,0,r|0,za|0)|0;r=F()|0;Aa=Vw(0,Aa|0,va|0,t|0)|0;ya=F()|0;va=Vw(za|0,r|0,(ya>>>0<t>>>0|(ya|0)==(t|0)&Aa>>>0<va>>>0)&1|0,0)|0;t=F()|0;r=(Aa|0)==0&(ya|0)==0;za=Ww(0,0,Aa|0,ya|0)|0;xa=F()|0;wa=Ww(0,0,va|0,t|0)|0;s=F()|0;j=Ww(f|0,h|0,i|0,j|0)|0;q=F()|0;l=Ww(k|0,l|0,o|0,p|0)|0;p=F()|0;v=(q|0)<0;ta=_w(j|0,q|0,63)|0;F()|0;k=(p|0)<0;u=_w(l|0,p|0,63)|0;F()|0;u=(ta|0)==(u|0);ta=Ww(0,0,j|0,q|0)|0;o=F()|0;j=v?ta:j;o=v?o:q;q=Ww(0,0,l|0,p|0)|0;v=F()|0;l=k?q:l;p=k?v:p;v=Uw(p|0,0,o|0,0)|0;k=F()|0;q=Uw(l|0,0,j|0,0)|0;ta=F()|0;o=Uw(l|0,0,o|0,0)|0;l=F()|0;j=Uw(p|0,0,j|0,0)|0;j=Vw(o|0,l|0,j|0,F()|0)|0;k=Vw(F()|0,0,v|0,k|0)|0;v=F()|0;j=Vw(0,j|0,q|0,ta|0)|0;l=F()|0;q=Vw(k|0,v|0,(l>>>0<ta>>>0|(l|0)==(ta|0)&j>>>0<q>>>0)&1|0,0)|0;ta=F()|0;v=(j|0)==0&(l|0)==0;k=Ww(0,0,j|0,l|0)|0;o=F()|0;p=Ww(0,0,q|0,ta|0)|0;sa=F()|0;if(!((((ua?Aa:za)|0)==((u?j:k)|0)?((ua?ya:xa)|0)==((u?l:o)|0):0)&(((ua?va:r?wa:~va)|0)==((u?q:v?p:~q)|0)?((ua?t:r?s:~t)|0)==((u?ta:v?sa:~ta)|0):0)))break}if(c[w+64>>2]|0?c[ga+64>>2]|0:0){Aa=bd(b,ga,w)|0;c[fa>>2]=c[n>>2];c[fa+4>>2]=c[n+4>>2];c[fa+8>>2]=c[n+8>>2];c[fa+12>>2]=c[n+12>>2];f=Zj(24)|0;h=f+8|0;c[X>>2]=f;c[f>>2]=m;c[f+4>>2]=Aa;c[h>>2]=c[fa>>2];c[h+4>>2]=c[fa+4>>2];c[h+8>>2]=c[fa+8>>2];c[h+12>>2]=c[fa+12>>2];h=c[N>>2]|0;if((h|0)==(c[O>>2]|0))Re(P,X);else {c[h>>2]=f;c[N>>2]=(c[N>>2]|0)+4;}}}while(0);v=w+92|0;f=c[v>>2]|0;if((f|0)!=(x|0)){do if((c[x+76>>2]|0)>-1?(ia=c[x+96>>2]|0,(c[ia+76>>2]|0)>-1):0){i=ia+16|0;h=c[i>>2]|0;i=c[i+4>>2]|0;s=ia+24|0;k=ia+32|0;j=c[k>>2]|0;k=c[k+4>>2]|0;r=ia+40|0;za=x+16|0;ya=c[za>>2]|0;za=c[za+4>>2]|0;n=x+24|0;l=c[n>>2]|0;n=c[n+4>>2]|0;o=x+32|0;t=x+32|0;u=c[t>>2]|0;t=c[t+4>>2]|0;q=x+40|0;p=c[q>>2]|0;q=c[q+4>>2]|0;Aa=(a[K>>0]|0)==0;r=Ww(c[s>>2]|0,c[s+4>>2]|0,c[r>>2]|0,c[r+4>>2]|0)|0;s=F()|0;t=Ww(ya|0,za|0,u|0,t|0)|0;u=F()|0;if(Aa){ya=Uw(t|0,u|0,r|0,s|0)|0;Aa=F()|0;xa=Ww(h|0,i|0,j|0,k|0)|0;za=F()|0;wa=Ww(l|0,n|0,p|0,q|0)|0;za=Uw(wa|0,F()|0,xa|0,za|0)|0;if(!((ya|0)==(za|0)&(Aa|0)==(F()|0)))break}else {Ca=(s|0)<0;Ea=_w(r|0,s|0,63)|0;F()|0;ua=(u|0)<0;ta=_w(t|0,u|0,63)|0;F()|0;ta=(Ea|0)==(ta|0);Ea=Ww(0,0,r|0,s|0)|0;Ba=F()|0;Ea=Ca?Ea:r;Ba=Ca?Ba:s;Ca=Ww(0,0,t|0,u|0)|0;s=F()|0;Ca=ua?Ca:t;s=ua?s:u;ua=Uw(s|0,0,Ba|0,0)|0;Da=F()|0;t=Uw(Ca|0,0,Ea|0,0)|0;wa=F()|0;Ba=Uw(Ca|0,0,Ba|0,0)|0;Ca=F()|0;Ea=Uw(s|0,0,Ea|0,0)|0;Ea=Vw(Ba|0,Ca|0,Ea|0,F()|0)|0;Da=Vw(F()|0,0,ua|0,Da|0)|0;ua=F()|0;Ea=Vw(0,Ea|0,t|0,wa|0)|0;Ca=F()|0;t=Vw(Da|0,ua|0,(Ca>>>0<wa>>>0|(Ca|0)==(wa|0)&Ea>>>0<t>>>0)&1|0,0)|0;wa=F()|0;ua=(Ea|0)==0&(Ca|0)==0;Da=Ww(0,0,Ea|0,Ca|0)|0;Ba=F()|0;s=Ww(0,0,t|0,wa|0)|0;va=F()|0;Aa=Ww(h|0,i|0,j|0,k|0)|0;r=F()|0;q=Ww(l|0,n|0,p|0,q|0)|0;u=F()|0;ya=(r|0)<0;n=_w(Aa|0,r|0,63)|0;F()|0;p=(u|0)<0;xa=_w(q|0,u|0,63)|0;F()|0;xa=(n|0)==(xa|0);n=Ww(0,0,Aa|0,r|0)|0;sa=F()|0;n=ya?n:Aa;r=ya?sa:r;sa=Ww(0,0,q|0,u|0)|0;ya=F()|0;q=p?sa:q;u=p?ya:u;ya=Uw(u|0,0,r|0,0)|0;p=F()|0;sa=Uw(q|0,0,n|0,0)|0;Aa=F()|0;r=Uw(q|0,0,r|0,0)|0;q=F()|0;n=Uw(u|0,0,n|0,0)|0;n=Vw(r|0,q|0,n|0,F()|0)|0;p=Vw(F()|0,0,ya|0,p|0)|0;ya=F()|0;n=Vw(0,n|0,sa|0,Aa|0)|0;q=F()|0;sa=Vw(p|0,ya|0,(q>>>0<Aa>>>0|(q|0)==(Aa|0)&n>>>0<sa>>>0)&1|0,0)|0;Aa=F()|0;ya=(n|0)==0&(q|0)==0;p=Ww(0,0,n|0,q|0)|0;r=F()|0;u=Ww(0,0,sa|0,Aa|0)|0;za=F()|0;if(!((((ta?Ea:Da)|0)==((xa?n:p)|0)?((ta?Ca:Ba)|0)==((xa?q:r)|0):0)&(((ta?t:ua?s:~t)|0)==((xa?sa:ya?u:~sa)|0)?((ta?wa:ua?va:~wa)|0)==((xa?Aa:ya?za:~Aa)|0):0)))break}if((c[x+64>>2]|0)!=0?(c[ia+64>>2]|0)!=0:0){Ea=bd(b,ia,x)|0;c[fa>>2]=c[o>>2];c[fa+4>>2]=c[o+4>>2];c[fa+8>>2]=c[o+8>>2];c[fa+12>>2]=c[o+12>>2];h=Zj(24)|0;f=h+8|0;c[X>>2]=h;c[h>>2]=m;c[h+4>>2]=Ea;c[f>>2]=c[fa>>2];c[f+4>>2]=c[fa+4>>2];c[f+8>>2]=c[fa+8>>2];c[f+12>>2]=c[fa+12>>2];f=c[N>>2]|0;if((f|0)==(c[O>>2]|0))Re(P,X);else {c[f>>2]=h;c[N>>2]=(c[N>>2]|0)+4;}f=c[v>>2]|0;}}while(0);if(!((f|0)==0|(f|0)==(x|0))){h=w+16|0;do{ed(b,x,f,h);f=c[f+92>>2]|0;}while((f|0)!=(x|0))}}}}f=c[la>>2]|0;if((f|0)==(c[ha>>2]|0)){f=99;break}}if((f|0)==99){Eb=ra;return}}function Vc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;if(!(c[a+52>>2]|0)){a=1;return a|0}id(a,b,d);f=a+96|0;g=a+100|0;d=c[g>>2]|0;b=c[f>>2]|0;switch(d-b>>2|0){case 1:break;case 0:{a=1;return a|0}default:e=3;}do if((e|0)==3)if(jd(a)|0){d=c[g>>2]|0;b=c[f>>2]|0;break}else {a=0;return a|0}while(0);if((d|0)!=(b|0)){d=0;do{b=c[b+(d<<2)>>2]|0;e=b+4|0;ed(a,c[b>>2]|0,c[e>>2]|0,b+8|0);Lc(a,c[b>>2]|0,c[e>>2]|0);if(b|0)$j(b);d=d+1|0;b=c[f>>2]|0;}while(d>>>0<(c[g>>2]|0)-b>>2>>>0)}c[g>>2]=b;c[a+124>>2]=0;a=1;return a|0}function Wc(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0.0,t=0,u=0,v=0,w=0,x=0,y=0,A=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0;W=Eb;Eb=Eb+48|0;I=W+36|0;H=W+8|0;C=W+32|0;D=W+28|0;E=W;V=W+24|0;G=b+52|0;h=c[G>>2]|0;c[V>>2]=h;if(!h){p=b+112|0;o=b+120|0;m=b+124|0;}else {u=b+142|0;p=b+112|0;o=b+120|0;m=b+124|0;v=b+76|0;w=b+80|0;x=b+72|0;do{n=h+40|0;a:do if((c[n>>2]|0)==(d|0)?(c[n+4>>2]|0)==(e|0):0){b:do if(!(c[h+88>>2]|0)){i=c[h+80>>2]|0;n=i+32|0;l=h+32|0;k=l;j=c[k>>2]|0;k=c[k+4>>2]|0;if((((c[n>>2]|0)==(j|0)?(c[n+4>>2]|0)==(k|0):0)?(n=i+40|0,(c[n>>2]|0)==(d|0)?(c[n+4>>2]|0)==(e|0):0):0)?(c[i+88>>2]|0)==0:0){t=i;n=12;}else n=9;if((((n|0)==9?(n=0,A=c[h+84>>2]|0,i=A+32|0,(c[i>>2]|0)==(j|0)?(c[i+4>>2]|0)==(k|0):0):0)?(k=A+40|0,(c[k>>2]|0)==(d|0)?(c[k+4>>2]|0)==(e|0):0):0)?(c[A+88>>2]|0)==0:0){t=A;n=12;}do if((n|0)==12?(n=0,(c[t+76>>2]|0)!=-2):0){q=+g[t+48>>3];if((c[t+92>>2]|0)==(c[t+96>>2]|0))if(q==-1.e+40)break b;else break;else if(q!=-1.e+40)break;else break b}while(0);if(a[u>>0]|0){k=Zj(16)|0;i=l;j=c[i+4>>2]|0;l=k+8|0;c[l>>2]=c[i>>2];c[l+4>>2]=j;c[k+4>>2]=p;l=c[p>>2]|0;c[k>>2]=l;c[l+4>>2]=k;c[p>>2]=k;c[o>>2]=(c[o>>2]|0)+1;}i=c[h+96>>2]|0;ld(b,h);if(!i){h=G;break a}h=i+92|0;break a}while(0);n=c[h+88>>2]|0;if(n|0?+g[n+48>>3]==-1.e+40:0){Mc(b,V);h=c[V>>2]|0;if((c[h+76>>2]|0)>-1)bd(b,h,h)|0;i=c[m>>2]|0;if(!i){c[m>>2]=h;c[h+104>>2]=0;c[h+100>>2]=0;n=30;break}else {c[h+100>>2]=i;c[h+104>>2]=0;c[i+104>>2]=h;c[m>>2]=h;n=30;break}}j=h+32|0;i=c[j>>2]|0;j=c[j+4>>2]|0;n=29;}else {i=h;j=c[i>>2]|0;i=c[i+4>>2]|0;q=+g[h+48>>3];n=h+8|0;n=Ww(d|0,e|0,c[n>>2]|0,c[n+4>>2]|0)|0;q=q*(+(n>>>0)+4294967296.0*+(F()|0));q=q+(q<0.0?-.5:.5);i=Vw(j|0,i|0,~~q>>>0|0,(+s(q)>=1.0?(q>0.0?~~+B(+r(q/4294967296.0),4294967295.0)>>>0:~~+z((q-+(~~q>>>0))/4294967296.0)>>>0):0)|0)|0;j=F()|0;n=29;}while(0);if((n|0)==29){l=h+16|0;c[l>>2]=i;c[l+4>>2]=j;l=h+24|0;c[l>>2]=d;c[l+4>>2]=e;n=30;}if((n|0)==30){if((((((a[u>>0]|0)!=0?(y=c[h+96>>2]|0,(c[h+76>>2]|0)>-1):0)?(y|0)!=0&(c[h+64>>2]|0)!=0:0)?(c[y+76>>2]|0)>-1:0)?(l=y+16|0,n=h+16|0,(c[l>>2]|0)==(c[n>>2]|0)?(c[l+4>>2]|0)==(c[n+4>>2]|0):0):0)?(c[y+64>>2]|0)!=0:0){l=h+16|0;c[H>>2]=c[l>>2];c[H+4>>2]=c[l+4>>2];c[H+8>>2]=c[l+8>>2];c[H+12>>2]=c[l+12>>2];l=bd(b,y,H)|0;n=bd(b,h,H)|0;h=Zj(24)|0;i=h+8|0;c[I>>2]=h;c[h>>2]=l;c[h+4>>2]=n;c[i>>2]=c[H>>2];c[i+4>>2]=c[H+4>>2];c[i+8>>2]=c[H+8>>2];c[i+12>>2]=c[H+12>>2];i=c[v>>2]|0;if((i|0)==(c[w>>2]|0))Re(x,I);else {c[i>>2]=h;c[v>>2]=(c[v>>2]|0)+4;}h=c[V>>2]|0;}h=h+92|0;}h=c[h>>2]|0;c[V>>2]=h;}while((h|0)!=0)}n=b+116|0;c[C>>2]=c[n>>2];c[D>>2]=p;h=c[o>>2]|0;c[H>>2]=c[C>>2];c[I>>2]=c[D>>2];Xe(H,I,h,E)|0;h=c[m>>2]|0;if(h|0)do{i=h+104|0;j=c[i>>2]|0;k=h+100|0;l=c[k>>2]|0;c[((j|0)==0?m:j+100|0)>>2]=l;if(l|0)c[l+104>>2]=j;c[k>>2]=0;c[i>>2]=0;gd(b,h);h=c[m>>2]|0;}while((h|0)!=0);if(c[o>>2]|0?(f=c[n>>2]|0,E=(c[b+112>>2]|0)+4|0,D=c[f>>2]|0,c[D+4>>2]=c[E>>2],c[c[E>>2]>>2]=D,c[o>>2]=0,(f|0)!=(p|0)):0)do{E=f;f=c[f+4>>2]|0;$j(E);}while((f|0)!=(p|0));f=c[G>>2]|0;c[V>>2]=f;if(!f){Eb=W;return}v=b+20|0;w=b+76|0;x=b+80|0;y=b+72|0;do{h=f;G=f+40|0;c:do if(((c[G>>2]|0)==(d|0)?(c[G+4>>2]|0)==(e|0):0)?(c[f+88>>2]|0)!=0:0){if((c[f+76>>2]|0)>-1)u=bd(b,f,f+32|0)|0;else u=0;Mc(b,V);f=c[V>>2]|0;h=c[f+96>>2]|0;t=c[f+92>>2]|0;do if((((h|0?(K=h+16|0,J=c[K>>2]|0,K=c[K+4>>2]|0,G=f,(J|0)==(c[G>>2]|0)?(K|0)==(c[G+4>>2]|0):0):0)?(M=h+24|0,L=c[M>>2]|0,M=c[M+4>>2]|0,G=f+8|0,(u|0)!=0&((L|0)==(c[G>>2]|0)?(M|0)==(c[G+4>>2]|0):0)):0)?(c[h+76>>2]|0)>-1:0)?(O=h+40|0,N=c[O>>2]|0,O=c[O+4>>2]|0,(M|0)>(O|0)|(M|0)==(O|0)&L>>>0>N>>>0):0){j=f+16|0;i=c[j>>2]|0;j=c[j+4>>2]|0;n=f+24|0;l=f+32|0;k=c[l>>2]|0;l=c[l+4>>2]|0;m=f+40|0;o=h+32|0;p=c[o>>2]|0;o=c[o+4>>2]|0;G=(a[v>>0]|0)==0;m=Ww(c[n>>2]|0,c[n+4>>2]|0,c[m>>2]|0,c[m+4>>2]|0)|0;n=F()|0;o=Ww(J|0,K|0,p|0,o|0)|0;p=F()|0;if(G){D=Uw(o|0,p|0,m|0,n|0)|0;G=F()|0;A=Ww(i|0,j|0,k|0,l|0)|0;C=F()|0;E=Ww(L|0,M|0,N|0,O|0)|0;E=Uw(A|0,C|0,E|0,F()|0)|0;if(!((D|0)==(E|0)&(G|0)==(F()|0)))break}else {$=(n|0)<0;ba=_w(m|0,n|0,63)|0;F()|0;aa=(p|0)<0;X=_w(o|0,p|0,63)|0;F()|0;X=(ba|0)==(X|0);ba=Ww(0,0,m|0,n|0)|0;_=F()|0;ba=$?ba:m;_=$?_:n;$=Ww(0,0,o|0,p|0)|0;Z=F()|0;$=aa?$:o;Z=aa?Z:p;o=Uw(Z|0,0,_|0,0)|0;aa=F()|0;Y=Uw($|0,0,ba|0,0)|0;A=F()|0;_=Uw($|0,0,_|0,0)|0;$=F()|0;ba=Uw(Z|0,0,ba|0,0)|0;ba=Vw(_|0,$|0,ba|0,F()|0)|0;aa=Vw(F()|0,0,o|0,aa|0)|0;o=F()|0;ba=Vw(0,ba|0,Y|0,A|0)|0;$=F()|0;Y=Vw(aa|0,o|0,($>>>0<A>>>0|($|0)==(A|0)&ba>>>0<Y>>>0)&1|0,0)|0;A=F()|0;o=(ba|0)==0&($|0)==0;aa=Ww(0,0,ba|0,$|0)|0;_=F()|0;Z=Ww(0,0,Y|0,A|0)|0;p=F()|0;m=Ww(i|0,j|0,k|0,l|0)|0;k=F()|0;l=Ww(L|0,M|0,N|0,O|0)|0;i=F()|0;D=(k|0)<0;G=_w(m|0,k|0,63)|0;F()|0;j=(i|0)<0;C=_w(l|0,i|0,63)|0;F()|0;C=(G|0)==(C|0);G=Ww(0,0,m|0,k|0)|0;n=F()|0;m=D?G:m;k=D?n:k;n=Ww(0,0,l|0,i|0)|0;D=F()|0;l=j?n:l;i=j?D:i;D=Uw(k|0,0,i|0,0)|0;j=F()|0;n=Uw(m|0,0,l|0,0)|0;G=F()|0;l=Uw(k|0,0,l|0,0)|0;k=F()|0;i=Uw(m|0,0,i|0,0)|0;i=Vw(l|0,k|0,i|0,F()|0)|0;j=Vw(F()|0,0,D|0,j|0)|0;D=F()|0;i=Vw(0,i|0,n|0,G|0)|0;k=F()|0;n=Vw(j|0,D|0,(k>>>0<G>>>0|(k|0)==(G|0)&i>>>0<n>>>0)&1|0,0)|0;G=F()|0;D=(i|0)==0&(k|0)==0;j=Ww(0,0,i|0,k|0)|0;l=F()|0;m=Ww(0,0,n|0,G|0)|0;E=F()|0;if(!((((X?ba:aa)|0)==((C?i:j)|0)?((X?$:_)|0)==((C?k:l)|0):0)&(((X?Y:o?Z:~Y)|0)==((C?n:D?m:~n)|0)?((X?A:o?p:~A)|0)==((C?G:D?E:~G)|0):0)))break}if(c[f+64>>2]|0?c[h+64>>2]|0:0){ba=bd(b,h,f)|0;i=f+32|0;c[H>>2]=c[i>>2];c[H+4>>2]=c[i+4>>2];c[H+8>>2]=c[i+8>>2];c[H+12>>2]=c[i+12>>2];i=Zj(24)|0;h=i+8|0;c[I>>2]=i;c[i>>2]=u;c[i+4>>2]=ba;c[h>>2]=c[H>>2];c[h+4>>2]=c[H+4>>2];c[h+8>>2]=c[H+8>>2];c[h+12>>2]=c[H+12>>2];h=c[w>>2]|0;if((h|0)==(c[x>>2]|0))Re(y,I);else {c[h>>2]=i;c[w>>2]=(c[w>>2]|0)+4;}break c}}while(0);if(((((t|0)!=0?(Q=t+16|0,P=c[Q>>2]|0,Q=c[Q+4>>2]|0,ba=f,(P|0)==(c[ba>>2]|0)?(Q|0)==(c[ba+4>>2]|0):0):0)?(S=t+24|0,R=c[S>>2]|0,S=c[S+4>>2]|0,ba=f+8|0,(u|0)!=0&((R|0)==(c[ba>>2]|0)?(S|0)==(c[ba+4>>2]|0):0)):0)?(c[t+76>>2]|0)>-1:0)?(U=t+40|0,T=c[U>>2]|0,U=c[U+4>>2]|0,(S|0)>(U|0)|(S|0)==(U|0)&R>>>0>T>>>0):0){i=f+16|0;h=c[i>>2]|0;i=c[i+4>>2]|0;m=f+24|0;k=f+32|0;j=c[k>>2]|0;k=c[k+4>>2]|0;l=f+40|0;n=t+32|0;o=c[n>>2]|0;n=c[n+4>>2]|0;ba=(a[v>>0]|0)==0;l=Ww(c[m>>2]|0,c[m+4>>2]|0,c[l>>2]|0,c[l+4>>2]|0)|0;m=F()|0;n=Ww(P|0,Q|0,o|0,n|0)|0;o=F()|0;if(ba){$=Uw(n|0,o|0,l|0,m|0)|0;ba=F()|0;Z=Ww(h|0,i|0,j|0,k|0)|0;_=F()|0;aa=Ww(R|0,S|0,T|0,U|0)|0;aa=Uw(Z|0,_|0,aa|0,F()|0)|0;if(!(($|0)==(aa|0)&(ba|0)==(F()|0)))break}else {A=(m|0)<0;da=_w(l|0,m|0,63)|0;F()|0;X=(o|0)<0;G=_w(n|0,o|0,63)|0;F()|0;G=(da|0)==(G|0);da=Ww(0,0,l|0,m|0)|0;ca=F()|0;da=A?da:l;m=A?ca:m;ca=Ww(0,0,n|0,o|0)|0;A=F()|0;n=X?ca:n;A=X?A:o;X=Uw(A|0,0,m|0,0)|0;ca=F()|0;C=Uw(n|0,0,da|0,0)|0;Z=F()|0;n=Uw(n|0,0,m|0,0)|0;m=F()|0;da=Uw(A|0,0,da|0,0)|0;da=Vw(n|0,m|0,da|0,F()|0)|0;ca=Vw(F()|0,0,X|0,ca|0)|0;X=F()|0;da=Vw(0,da|0,C|0,Z|0)|0;m=F()|0;C=Vw(ca|0,X|0,(m>>>0<Z>>>0|(m|0)==(Z|0)&da>>>0<C>>>0)&1|0,0)|0;Z=F()|0;X=(da|0)==0&(m|0)==0;ca=Ww(0,0,da|0,m|0)|0;n=F()|0;A=Ww(0,0,C|0,Z|0)|0;Y=F()|0;D=Ww(h|0,i|0,j|0,k|0)|0;o=F()|0;p=Ww(R|0,S|0,T|0,U|0)|0;k=F()|0;$=(o|0)<0;ba=_w(D|0,o|0,63)|0;F()|0;l=(k|0)<0;_=_w(p|0,k|0,63)|0;F()|0;_=(ba|0)==(_|0);ba=Ww(0,0,D|0,o|0)|0;E=F()|0;D=$?ba:D;o=$?E:o;E=Ww(0,0,p|0,k|0)|0;$=F()|0;p=l?E:p;k=l?$:k;$=Uw(o|0,0,k|0,0)|0;l=F()|0;E=Uw(D|0,0,p|0,0)|0;ba=F()|0;p=Uw(o|0,0,p|0,0)|0;o=F()|0;k=Uw(D|0,0,k|0,0)|0;k=Vw(p|0,o|0,k|0,F()|0)|0;l=Vw(F()|0,0,$|0,l|0)|0;$=F()|0;k=Vw(0,k|0,E|0,ba|0)|0;o=F()|0;E=Vw(l|0,$|0,(o>>>0<ba>>>0|(o|0)==(ba|0)&k>>>0<E>>>0)&1|0,0)|0;ba=F()|0;$=(k|0)==0&(o|0)==0;l=Ww(0,0,k|0,o|0)|0;p=F()|0;D=Ww(0,0,E|0,ba|0)|0;aa=F()|0;if(!((((G?da:ca)|0)==((_?k:l)|0)?((G?m:n)|0)==((_?o:p)|0):0)&(((G?C:X?A:~C)|0)==((_?E:$?D:~E)|0)?((G?Z:X?Y:~Z)|0)==((_?ba:$?aa:~ba)|0):0)))break}if((c[f+64>>2]|0)!=0?(c[t+64>>2]|0)!=0:0){da=bd(b,t,f)|0;i=f+32|0;c[H>>2]=c[i>>2];c[H+4>>2]=c[i+4>>2];c[H+8>>2]=c[i+8>>2];c[H+12>>2]=c[i+12>>2];i=Zj(24)|0;h=i+8|0;c[I>>2]=i;c[i>>2]=u;c[i+4>>2]=da;c[h>>2]=c[H>>2];c[h+4>>2]=c[H+4>>2];c[h+8>>2]=c[H+8>>2];c[h+12>>2]=c[H+12>>2];h=c[w>>2]|0;if((h|0)==(c[x>>2]|0))Re(y,I);else {c[h>>2]=i;c[w>>2]=(c[w>>2]|0)+4;}}}}else f=h;while(0);f=c[f+92>>2]|0;c[V>>2]=f;}while((f|0)!=0);Eb=W;return}function Xc(b){b=b|0;var d=0,e=0.0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0.0;C=Eb;Eb=Eb+16|0;s=C;w=b+72|0;x=b+76|0;d=c[w>>2]|0;if((c[x>>2]|0)==(d|0)){Eb=C;return}z=b+40|0;A=b+40|0;B=b+44|0;t=b+48|0;u=b+141|0;v=b+140|0;r=0;do{i=c[d+(r<<2)>>2]|0;f=c[z>>2]|0;p=c[f+(c[c[i>>2]>>2]<<2)>>2]|0;while(1){d=c[f+(c[p>>2]<<2)>>2]|0;if((p|0)==(d|0))break;else p=d;}j=i+4|0;h=c[f+(c[c[j>>2]>>2]<<2)>>2]|0;while(1){d=c[f+(c[h>>2]<<2)>>2]|0;if((h|0)==(d|0))break;else h=d;}n=p+16|0;a:do if(((c[n>>2]|0?(y=h+16|0,c[y>>2]|0):0)?(a[p+5>>0]|0)==0:0)?(a[h+5>>0]|0)==0:0){g=(p|0)==(h|0);b:do if(g){f=p;k=p;}else {d=p;do{d=c[d+8>>2]|0;if((d|0)==(h|0)){f=h;k=h;break b}}while((d|0)!=0);d=h;do{d=c[d+8>>2]|0;if((d|0)==(p|0)){f=p;k=h;break b}}while((d|0)!=0);f=fd(p,h)|0;k=h;}while(0);if(td(b,i,p,k)|0){if(!g){c[y>>2]=0;c[k+20>>2]=0;c[h>>2]=c[p>>2];a[p+4>>0]=a[f+4>>0]|0;d=k+8|0;if((f|0)==(k|0))c[p+8>>2]=c[d>>2];c[d>>2]=p;if(!(a[u>>0]|0))break;d=c[B>>2]|0;f=c[A>>2]|0;j=f;if((d|0)==(f|0))break;g=d-f>>2;f=0;while(1){h=c[j+(f<<2)>>2]|0;i=h+8|0;d=c[i>>2]|0;c:do if(!d)d=0;else while(1){if(c[d+16>>2]|0)break c;d=c[d+8>>2]|0;if(!d){d=0;break}}while(0);if((d|0)==(k|0)&(c[h+16>>2]|0)!=0)c[i>>2]=p;f=f+1|0;if(f>>>0>=g>>>0)break a}}c[n>>2]=c[i>>2];c[p+20>>2]=0;d=Zj(24)|0;c[s>>2]=d;a[d+4>>0]=0;a[d+5>>0]=0;f=d+8|0;c[f>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;f=c[B>>2]|0;if((f|0)==(c[t>>2]|0)){Pe(A,s);l=c[B>>2]|0;}else {c[f>>2]=d;l=(c[B>>2]|0)+4|0;c[B>>2]=l;}i=c[A>>2]|0;f=(l-i>>2)+-1|0;o=c[s>>2]|0;c[o>>2]=f;m=c[j>>2]|0;g=o+16|0;c[g>>2]=m;d=m;do{c[d>>2]=f;d=c[d+28>>2]|0;}while((d|0)!=(m|0));h=c[n>>2]|0;d=m;do{f=uc(d+8|0,h)|0;if((f|0)>-1){q=30;break}d=c[d+24>>2]|0;}while((d|0)!=(m|0));if((q|0)==30?(q=0,(f|0)==0):0){d=h;while(1){g=uc(d+8|0,m)|0;if((g|0)>-1){q=43;break}d=c[d+24>>2]|0;if((d|0)==(h|0)){q=42;break}}if((q|0)==42){q=0;f=p+4|0;d=a[f>>0]|0;a[o+4>>0]=d;}else if((q|0)==43){q=0;f=p+4|0;d=a[f>>0]|0;a[o+4>>0]=d;if(!g){c[o+8>>2]=c[p+8>>2];if(!(a[u>>0]|0))break;k=i;if((l|0)==(i|0))break;i=l-i>>2;h=0;while(1){f=c[k+(h<<2)>>2]|0;j=f+8|0;d=c[j>>2]|0;d:do if(!d)d=0;else while(1){if(c[d+16>>2]|0)break d;d=c[d+8>>2]|0;if(!d){d=0;break}}while(0);g=c[f+16>>2]|0;do if((d|0)==(p|0)&(g|0)!=0){d=g;do{f=uc(d+8|0,m)|0;if((f|0)>-1){q=63;break}d=c[d+24>>2]|0;}while((d|0)!=(g|0));if((q|0)==63?(q=0,(f|0)==0):0)break;c[j>>2]=o;}while(0);h=h+1|0;if(h>>>0>=i>>>0)break a}}}d=d^1;a[f>>0]=d;m=p+8|0;c[o+8>>2]=c[m>>2];c[m>>2]=o;if(a[u>>0]|0){ud(b,p,o);d=a[f>>0]|0;h=c[n>>2]|0;}f=(a[v>>0]^d)&255;g=(h|0)==0;if(g)break;e=0.0;d=h;do{o=c[d+28>>2]|0;p=o+8|0;n=d+8|0;p=Vw(c[n>>2]|0,c[n+4>>2]|0,c[p>>2]|0,c[p+4>>2]|0)|0;D=+(p>>>0)+4294967296.0*+(F()|0);o=o+16|0;p=d+16|0;p=Ww(c[o>>2]|0,c[o+4>>2]|0,c[p>>2]|0,c[p+4>>2]|0)|0;e=e+D*(+(p>>>0)+4294967296.0*+(F()|0));d=c[d+24>>2]|0;}while((d|0)!=(h|0));if(g|(f|0)!=(e*.5>0.0|0))break;d=h;while(1){o=d+24|0;p=d;d=c[o>>2]|0;p=p+28|0;c[o>>2]=c[p>>2];c[p>>2]=d;if((d|0)==(h|0))break a}}f=o+4|0;d=a[p+4>>0]^1;a[f>>0]=d;c[o+8>>2]=p;if(!(a[u>>0]|0))h=m;else {ud(b,o,p);d=a[f>>0]|0;h=c[g>>2]|0;}f=(a[v>>0]^d)&255;g=(h|0)==0;if(!g){e=0.0;d=h;do{o=c[d+28>>2]|0;p=o+8|0;n=d+8|0;p=Vw(c[n>>2]|0,c[n+4>>2]|0,c[p>>2]|0,c[p+4>>2]|0)|0;D=+(p>>>0)+4294967296.0*+(F()|0);o=o+16|0;p=d+16|0;p=Ww(c[o>>2]|0,c[o+4>>2]|0,c[p>>2]|0,c[p+4>>2]|0)|0;e=e+D*(+(p>>>0)+4294967296.0*+(F()|0));d=c[d+24>>2]|0;}while((d|0)!=(h|0));if(!(g|(f|0)!=(e*.5>0.0|0))){d=h;do{o=d+24|0;p=d;d=c[o>>2]|0;p=p+28|0;c[o>>2]=c[p>>2];c[p>>2]=d;}while((d|0)!=(h|0))}}}}while(0);r=r+1|0;d=c[w>>2]|0;}while(r>>>0<(c[x>>2]|0)-d>>2>>>0);Eb=C;return}function Yc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0;c[d+20>>2]=0;D=d+16|0;e=c[D>>2]|0;if(!(a[b+36>>0]|0))C=(a[b+142>>0]|0)!=0;else C=1;d=e;g=d+28|0;f=c[g>>2]|0;a:do if((f|0)!=(d|0)){B=b+20|0;b=0;b:while(1){r=d+24|0;l=c[r>>2]|0;A=l;if((f|0)==(l|0)){e=f;break a}t=d+8|0;s=c[t>>2]|0;t=c[t+4>>2]|0;v=l+8|0;u=c[v>>2]|0;v=c[v+4>>2]|0;w=(s|0)==(u|0)&(t|0)==(v|0);if(w?(z=d+16|0,E=l+16|0,(c[z>>2]|0)==(c[E>>2]|0)?(c[z+4>>2]|0)==(c[E+4>>2]|0):0):0)E=23;else E=12;c:do if((E|0)==12){E=0;y=f+8|0;x=c[y>>2]|0;y=c[y+4>>2]|0;z=(x|0)==(s|0)&(y|0)==(t|0);if(z){k=d+16|0;j=c[k>>2]|0;k=c[k+4>>2]|0;i=f+16|0;h=c[i>>2]|0;i=c[i+4>>2]|0;if((j|0)==(h|0)&(k|0)==(i|0)){E=23;break}else q=j;}else {i=f+16|0;k=d+16|0;h=c[i>>2]|0;i=c[i+4>>2]|0;q=c[k>>2]|0;k=c[k+4>>2]|0;}p=l+16|0;o=c[p>>2]|0;p=c[p+4>>2]|0;G=(a[B>>0]|0)==0;j=Ww(h|0,i|0,q|0,k|0)|0;l=F()|0;m=Ww(s|0,t|0,u|0,v|0)|0;n=F()|0;if(G){m=Uw(m|0,n|0,j|0,l|0)|0;G=F()|0;l=Ww(x|0,y|0,s|0,t|0)|0;n=F()|0;j=Ww(q|0,k|0,o|0,p|0)|0;n=Uw(j|0,F()|0,l|0,n|0)|0;if((m|0)==(n|0)&(G|0)==(F()|0))E=18;}else {R=(l|0)<0;V=_w(j|0,l|0,63)|0;F()|0;I=(n|0)<0;J=_w(m|0,n|0,63)|0;F()|0;J=(V|0)==(J|0);V=Ww(0,0,j|0,l|0)|0;Q=F()|0;V=R?V:j;Q=R?Q:l;R=Ww(0,0,m|0,n|0)|0;N=F()|0;R=I?R:m;N=I?N:n;I=Uw(N|0,0,Q|0,0)|0;U=F()|0;M=Uw(R|0,0,V|0,0)|0;j=F()|0;Q=Uw(R|0,0,Q|0,0)|0;R=F()|0;V=Uw(N|0,0,V|0,0)|0;V=Vw(Q|0,R|0,V|0,F()|0)|0;U=Vw(F()|0,0,I|0,U|0)|0;I=F()|0;V=Vw(0,V|0,M|0,j|0)|0;R=F()|0;M=Vw(U|0,I|0,(R>>>0<j>>>0|(R|0)==(j|0)&V>>>0<M>>>0)&1|0,0)|0;j=F()|0;I=(V|0)==0&(R|0)==0;U=Ww(0,0,V|0,R|0)|0;Q=F()|0;N=Ww(0,0,M|0,j|0)|0;H=F()|0;T=Ww(x|0,y|0,s|0,t|0)|0;O=F()|0;P=Ww(q|0,k|0,o|0,p|0)|0;L=F()|0;m=(O|0)<0;G=_w(T|0,O|0,63)|0;F()|0;S=(L|0)<0;l=_w(P|0,L|0,63)|0;F()|0;l=(G|0)==(l|0);G=Ww(0,0,T|0,O|0)|0;K=F()|0;T=m?G:T;O=m?K:O;K=Ww(0,0,P|0,L|0)|0;m=F()|0;P=S?K:P;L=S?m:L;m=Uw(L|0,0,O|0,0)|0;S=F()|0;K=Uw(P|0,0,T|0,0)|0;G=F()|0;O=Uw(P|0,0,O|0,0)|0;P=F()|0;T=Uw(L|0,0,T|0,0)|0;T=Vw(O|0,P|0,T|0,F()|0)|0;S=Vw(F()|0,0,m|0,S|0)|0;m=F()|0;T=Vw(0,T|0,K|0,G|0)|0;P=F()|0;K=Vw(S|0,m|0,(P>>>0<G>>>0|(P|0)==(G|0)&T>>>0<K>>>0)&1|0,0)|0;G=F()|0;m=(T|0)==0&(P|0)==0;S=Ww(0,0,T|0,P|0)|0;O=F()|0;L=Ww(0,0,K|0,G|0)|0;n=F()|0;if((((J?V:U)|0)==((l?T:S)|0)?((J?R:Q)|0)==((l?P:O)|0):0)&(((J?M:I?N:~M)|0)==((l?K:m?L:~K)|0)?((J?j:I?H:~j)|0)==((l?G:m?n:~G)|0):0))E=18;}do if((E|0)==18){E=0;if(!C){E=23;break c}j=(x|0)==(u|0)&(y|0)==(v|0);if(j&((h|0)==(o|0)&(i|0)==(p|0))|z&((h|0)==(q|0)&(i|0)==(k|0))|w&((q|0)==(o|0)&(k|0)==(p|0))){E=23;break c}if(j)if(((i|0)<(k|0)|(i|0)==(k|0)&h>>>0<q>>>0)^((k|0)<(p|0)|(k|0)==(p|0)&q>>>0<o>>>0)){E=23;break c}else break;else if(((y|0)<(t|0)|(y|0)==(t|0)&x>>>0<s>>>0)^((t|0)<(v|0)|(t|0)==(v|0)&s>>>0<u>>>0)){E=23;break c}else break}while(0);if((b|0)==(d|0)){E=27;break b}b=(b|0)==0?d:b;e=A;}while(0);if((E|0)==23){E=0;c[f+24>>2]=A;c[(c[r>>2]|0)+28>>2]=c[g>>2];V=c[g>>2]|0;$j(e);b=0;e=V;}d=e;g=d+28|0;f=c[g>>2]|0;if((f|0)==(d|0)){E=6;break}}if((E|0)==6){d=e;E=7;break}else if((E|0)==27){c[D>>2]=d;return}}else E=7;while(0);if((E|0)==7)if(!e){V=0;c[D>>2]=V;return}else e=d;c[e+24>>2]=0;do{V=d;d=c[d+24>>2]|0;$j(V);}while((d|0)!=0);d=0;c[D>>2]=d;return}function Zc(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0;E=Eb;Eb=Eb+16|0;x=E;y=b+40|0;z=b+44|0;d=c[y>>2]|0;if((c[z>>2]|0)==(d|0)){Eb=E;return}C=b+48|0;D=b+141|0;w=0;do{r=c[d+(w<<2)>>2]|0;w=w+1|0;s=r+16|0;d=c[s>>2]|0;a:do if(d|0?(a[r+5>>0]|0)==0:0){t=r+4|0;u=r+8|0;q=d;do{p=q+24|0;e=c[p>>2]|0;if((e|0)==(d|0))break a;m=q+8|0;n=q+16|0;o=q+28|0;d=e;do{k=m;l=d+8|0;b:do if(((((c[k>>2]|0)==(c[l>>2]|0)?(c[k+4>>2]|0)==(c[l+4>>2]|0):0)?(k=n,l=d+16|0,(c[k>>2]|0)==(c[l>>2]|0)?(c[k+4>>2]|0)==(c[l+4>>2]|0):0):0)?(c[d+24>>2]|0)!=(q|0):0)?(A=d+28|0,B=c[A>>2]|0,(B|0)!=(q|0)):0){e=c[o>>2]|0;c[o>>2]=B;c[B+24>>2]=q;c[A>>2]=e;c[e+24>>2]=d;c[s>>2]=q;e=Zj(24)|0;c[x>>2]=e;a[e+4>>0]=0;a[e+5>>0]=0;f=e+8|0;c[f>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;f=c[z>>2]|0;if((f|0)==(c[C>>2]|0)){Pe(y,x);i=c[z>>2]|0;}else {c[f>>2]=e;i=(c[z>>2]|0)+4|0;c[z>>2]=i;}h=c[y>>2]|0;f=(i-h>>2)+-1|0;l=c[x>>2]|0;c[l>>2]=f;c[l+16>>2]=d;e=d;do{c[e>>2]=f;e=c[e+28>>2]|0;}while((e|0)!=(d|0));g=c[s>>2]|0;e=d;do{f=uc(e+8|0,g)|0;if((f|0)>-1){v=20;break}e=c[e+24>>2]|0;}while((e|0)!=(d|0));if((v|0)==20?(v=0,(f|0)==0):0){e=g;while(1){f=uc(e+8|0,d)|0;if((f|0)>-1){v=27;break}e=c[e+24>>2]|0;if((e|0)==(g|0)){v=26;break}}if((v|0)==26){v=0;d=a[t>>0]|0;a[l+4>>0]=d;}else if((v|0)==27){v=0;e=a[t>>0]|0;a[l+4>>0]=e;if(!f){c[l+8>>2]=c[u>>2];if(!(a[D>>0]|0)){d=q;break}k=h;if((i|0)==(h|0)){d=q;break}i=i-h>>2;h=0;while(1){f=c[k+(h<<2)>>2]|0;j=f+8|0;e=c[j>>2]|0;c:do if(!e)e=0;else while(1){if(c[e+16>>2]|0)break c;e=c[e+8>>2]|0;if(!e){e=0;break}}while(0);g=c[f+16>>2]|0;do if((e|0)==(r|0)&(g|0)!=0){e=g;do{f=uc(e+8|0,d)|0;if((f|0)>-1){v=41;break}e=c[e+24>>2]|0;}while((e|0)!=(g|0));if((v|0)==41?(v=0,(f|0)==0):0)break;c[j>>2]=l;}while(0);h=h+1|0;if(h>>>0>=i>>>0){d=q;break b}}}else d=e;}a[t>>0]=d^1;c[l+8>>2]=c[u>>2];c[u>>2]=l;if(!(a[D>>0]|0)){d=q;break}ud(b,r,l);d=q;break}a[l+4>>0]=a[t>>0]^1;c[l+8>>2]=r;if(!(a[D>>0]|0))d=q;else {ud(b,l,r);d=q;}}while(0);d=c[d+24>>2]|0;}while((d|0)!=(c[s>>2]|0));q=c[p>>2]|0;}while((q|0)!=(d|0))}while(0);d=c[y>>2]|0;}while(w>>>0<(c[z>>2]|0)-d>>2>>>0);Eb=E;return}function _c(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;d=c[b+96>>2]|0;a:do if(d){g=c[b+56>>2]|0;i=d;while(1){if((c[i+56>>2]|0)==(g|0)?(h=c[i+64>>2]|0,h|0):0)break;d=c[i+96>>2]|0;if(!d){j=6;break a}else i=d;}d=c[b+64>>2]|0;e=(d|0)==0;if(e?(c[a+108>>2]|0)!=1:0){c[b+68>>2]=1;d=c[i+72>>2]|0;c[b+72>>2]=d;f=i+92|0;break}if(!(c[((g|0)==0?a+136|0:a+132|0)>>2]|0)){if(e){e=c[i+96>>2]|0;if(!e)d=1;else {d=1;do{if((c[e+56>>2]|0)==(g|0))d=d^(c[e+64>>2]|0)!=0;e=c[e+96>>2]|0;}while((e|0)!=0)}d=(d^1)&1;}c[b+68>>2]=d;d=c[i+72>>2]|0;c[b+72>>2]=d;f=i+92|0;break}else {f=c[i+68>>2]|0;do if((A(h,f)|0)<0){m=((f|0)<0)<<31>>31;l=(m|0)<0;k=Ww(0,0,f|0,m|0)|0;n=F()|0;m=l?n:m;if((m|0)>0|(m|0)==0&(l?k:f)>>>0>1){n=(A(h,d)|0)<0;d=f+(n?0:d)|0;break}else {d=e?1:d;break}}else if(e){d=(f>>31|1)+f|0;break}else {n=(A(h,d)|0)<0;d=f+(n?0:d)|0;break}while(0);c[b+68>>2]=d;d=c[i+72>>2]|0;c[b+72>>2]=d;f=i+92|0;break}}else j=6;while(0);if((j|0)==6){d=c[b+64>>2]|0;e=c[b+56>>2]|0;if(!d)d=(c[((e|0)==0?a+136|0:a+132|0)>>2]|0)==3?-1:1;c[b+68>>2]=d;c[b+72>>2]=0;f=a+52|0;d=0;g=e;}e=c[f>>2]|0;f=(e|0)==(b|0);if(c[((g|0)==0?a+132|0:a+136|0)>>2]|0){if(f)return;f=b+72|0;do{d=d+(c[e+64>>2]|0)|0;e=c[e+92>>2]|0;}while((e|0)!=(b|0));c[f>>2]=d;return}if(f)return;f=b+72|0;do{if(c[e+64>>2]|0){d=(d|0)==0&1;c[f>>2]=d;}e=c[e+92>>2]|0;}while((e|0)!=(b|0));return}function $c(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;e=(c[b+56>>2]|0)==0;g=a+136|0;f=a+132|0;d=c[(e?f:g)>>2]|0;switch(c[(e?g:f)>>2]|0){case 0:{if((c[b+64>>2]|0)==0?(c[b+68>>2]|0)!=1:0){g=0;return g|0}break}case 1:{i=c[b+68>>2]|0;g=((i|0)<0)<<31>>31;h=(g|0)<0;j=Ww(0,0,i|0,g|0)|0;f=F()|0;if(!(((h?j:i)|0)==1&((h?f:g)|0)==0)){j=0;return j|0}break}case 2:{if((c[b+68>>2]|0)!=1){j=0;return j|0}break}default:if((c[b+68>>2]|0)!=-1){j=0;return j|0}}switch(c[a+108>>2]|0){case 0:switch(d|0){case 1:case 0:{j=(c[b+72>>2]|0)!=0;return j|0}case 2:{j=(c[b+72>>2]|0)>0;return j|0}default:{j=(c[b+72>>2]|0)<0;return j|0}}case 1:switch(d|0){case 1:case 0:{j=(c[b+72>>2]|0)==0;return j|0}case 2:{j=(c[b+72>>2]|0)<1;return j|0}default:{j=(c[b+72>>2]|0)>-1;return j|0}}case 2:if(e)switch(d|0){case 1:case 0:{j=(c[b+72>>2]|0)==0;return j|0}case 2:{j=(c[b+72>>2]|0)<1;return j|0}default:{j=(c[b+72>>2]|0)>-1;return j|0}}else switch(d|0){case 1:case 0:{j=(c[b+72>>2]|0)!=0;return j|0}case 2:{j=(c[b+72>>2]|0)>0;return j|0}default:{j=(c[b+72>>2]|0)<0;return j|0}}case 3:{if(c[b+64>>2]|0){j=1;return j|0}switch(d|0){case 1:case 0:{j=(c[b+72>>2]|0)==0;return j|0}case 2:{j=(c[b+72>>2]|0)<1;return j|0}default:{j=(c[b+72>>2]|0)>-1;return j|0}}}default:{j=1;return j|0}}return 0}function ad(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,t=0,u=0,v=0,w=0,x=0,y=0.0,A=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0;x=Eb;Eb=Eb+16|0;w=x;y=+g[e+48>>3];if(!(y==-1.e+40)?!(+g[d+48>>3]>y):0){h=bd(b,e,f)|0;c[d+76>>2]=c[e+76>>2];c[d+60>>2]=2;c[e+60>>2]=1;i=c[e+96>>2]|0;if((i|0)==(d|0)){v=h;j=e;i=c[d+96>>2]|0;}else {v=h;j=e;}}else {h=bd(b,d,f)|0;c[e+76>>2]=c[d+76>>2];c[d+60>>2]=1;c[e+60>>2]=2;i=c[d+96>>2]|0;if((i|0)==(e|0)){v=h;j=d;i=c[e+96>>2]|0;}else {v=h;j=d;}}if(!i){Eb=x;return v|0}if((c[i+76>>2]|0)<=-1){Eb=x;return v|0}d=i+40|0;h=c[d>>2]|0;d=c[d+4>>2]|0;n=f+8|0;m=c[n>>2]|0;n=c[n+4>>2]|0;if(!((n|0)>(d|0)|(n|0)==(d|0)&m>>>0>h>>>0)){Eb=x;return v|0}u=j+32|0;p=j+40|0;o=c[p>>2]|0;p=c[p+4>>2]|0;if(!((n|0)>(p|0)|(n|0)==(p|0)&m>>>0>o>>>0)){Eb=x;return v|0}q=i;t=c[q>>2]|0;q=c[q+4>>2]|0;y=+g[i+48>>3];l=i+8|0;l=Ww(m|0,n|0,c[l>>2]|0,c[l+4>>2]|0)|0;y=y*(+(l>>>0)+4294967296.0*+(F()|0));y=y+(y<0.0?-.5:.5);q=Vw(t|0,q|0,~~y>>>0|0,(+s(y)>=1.0?(y>0.0?~~+B(+r(y/4294967296.0),4294967295.0)>>>0:~~+z((y-+(~~y>>>0))/4294967296.0)>>>0):0)|0)|0;t=F()|0;l=j;k=c[l>>2]|0;l=c[l+4>>2]|0;y=+g[j+48>>3];e=j+8|0;e=Ww(m|0,n|0,c[e>>2]|0,c[e+4>>2]|0)|0;y=y*(+(e>>>0)+4294967296.0*+(F()|0));y=y+(y<0.0?-.5:.5);l=Vw(k|0,l|0,~~y>>>0|0,(+s(y)>=1.0?(y>0.0?~~+B(+r(y/4294967296.0),4294967295.0)>>>0:~~+z((y-+(~~y>>>0))/4294967296.0)>>>0):0)|0)|0;if(!((q|0)==(l|0)&(t|0)==(F()|0))){Eb=x;return v|0}if(!(c[j+64>>2]|0)){Eb=x;return v|0}if(!(c[i+64>>2]|0)){Eb=x;return v|0}l=i+32|0;k=c[l>>2]|0;l=c[l+4>>2]|0;e=j+32|0;j=c[e>>2]|0;e=c[e+4>>2]|0;A=(a[b+20>>0]|0)==0;h=Ww(m|0,n|0,h|0,d|0)|0;d=F()|0;e=Ww(q|0,t|0,j|0,e|0)|0;j=F()|0;if(A){j=Uw(e|0,j|0,h|0,d|0)|0;A=F()|0;l=Ww(q|0,t|0,k|0,l|0)|0;q=F()|0;t=Ww(m|0,n|0,o|0,p|0)|0;t=Uw(l|0,q|0,t|0,F()|0)|0;if(!((j|0)==(t|0)&(A|0)==(F()|0))){Eb=x;return v|0}}else {G=(d|0)<0;J=_w(h|0,d|0,63)|0;F()|0;I=(j|0)<0;C=_w(e|0,j|0,63)|0;F()|0;C=(J|0)==(C|0);J=Ww(0,0,h|0,d|0)|0;E=F()|0;J=G?J:h;E=G?E:d;G=Ww(0,0,e|0,j|0)|0;D=F()|0;G=I?G:e;D=I?D:j;d=Uw(D|0,0,E|0,0)|0;I=F()|0;h=Uw(G|0,0,J|0,0)|0;j=F()|0;E=Uw(G|0,0,E|0,0)|0;G=F()|0;J=Uw(D|0,0,J|0,0)|0;J=Vw(E|0,G|0,J|0,F()|0)|0;I=Vw(F()|0,0,d|0,I|0)|0;d=F()|0;J=Vw(0,J|0,h|0,j|0)|0;G=F()|0;h=Vw(I|0,d|0,(G>>>0<j>>>0|(G|0)==(j|0)&J>>>0<h>>>0)&1|0,0)|0;j=F()|0;d=(J|0)==0&(G|0)==0;I=Ww(0,0,J|0,G|0)|0;E=F()|0;D=Ww(0,0,h|0,j|0)|0;e=F()|0;A=Ww(q|0,t|0,k|0,l|0)|0;l=F()|0;m=Ww(m|0,n|0,o|0,p|0)|0;H=F()|0;q=(l|0)<0;n=_w(A|0,l|0,63)|0;F()|0;k=(H|0)<0;p=_w(m|0,H|0,63)|0;F()|0;p=(n|0)==(p|0);n=Ww(0,0,A|0,l|0)|0;o=F()|0;n=q?n:A;l=q?o:l;o=Ww(0,0,m|0,H|0)|0;q=F()|0;m=k?o:m;H=k?q:H;q=Uw(l|0,0,H|0,0)|0;k=F()|0;o=Uw(n|0,0,m|0,0)|0;A=F()|0;m=Uw(l|0,0,m|0,0)|0;l=F()|0;H=Uw(n|0,0,H|0,0)|0;H=Vw(m|0,l|0,H|0,F()|0)|0;k=Vw(F()|0,0,q|0,k|0)|0;q=F()|0;H=Vw(0,H|0,o|0,A|0)|0;l=F()|0;o=Vw(k|0,q|0,(l>>>0<A>>>0|(l|0)==(A|0)&H>>>0<o>>>0)&1|0,0)|0;A=F()|0;q=(H|0)==0&(l|0)==0;k=Ww(0,0,H|0,l|0)|0;m=F()|0;n=Ww(0,0,o|0,A|0)|0;t=F()|0;if(!((((C?J:I)|0)==((p?H:k)|0)?((C?G:E)|0)==((p?l:m)|0):0)&(((C?h:d?D:~h)|0)==((p?o:q?n:~o)|0)?((C?j:d?e:~j)|0)==((p?A:q?t:~A)|0):0))){Eb=x;return v|0}}i=bd(b,i,f)|0;d=Zj(24)|0;h=d+8|0;c[w>>2]=d;c[d>>2]=v;c[d+4>>2]=i;c[h>>2]=c[u>>2];c[h+4>>2]=c[u+4>>2];c[h+8>>2]=c[u+8>>2];c[h+12>>2]=c[u+12>>2];h=b+76|0;i=c[h>>2]|0;if((i|0)==(c[b+80>>2]|0))Re(b+72|0,w);else {c[i>>2]=d;c[h>>2]=(c[h>>2]|0)+4;}Eb=x;return v|0}function bd(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0;l=Eb;Eb=Eb+16|0;j=l;k=d+76|0;f=c[k>>2]|0;if((f|0)>=0){h=c[(c[b+40>>2]|0)+(f<<2)>>2]|0;b=h+16|0;i=c[b>>2]|0;g=(c[d+60>>2]|0)==1;if(g){d=e;k=i+8|0;if(((c[d>>2]|0)==(c[k>>2]|0)?(c[d+4>>2]|0)==(c[k+4>>2]|0):0)?(d=e+8|0,k=i+16|0,(c[d>>2]|0)==(c[k>>2]|0)?(c[d+4>>2]|0)==(c[k+4>>2]|0):0):0){k=i;Eb=l;return k|0}}else {f=c[i+28>>2]|0;d=e;k=f+8|0;if(((c[d>>2]|0)==(c[k>>2]|0)?(c[d+4>>2]|0)==(c[k+4>>2]|0):0)?(d=e+8|0,k=f+16|0,(c[d>>2]|0)==(c[k>>2]|0)?(c[d+4>>2]|0)==(c[k+4>>2]|0):0):0){k=f;Eb=l;return k|0}}f=Zj(32)|0;k=f+8|0;c[k>>2]=0;c[k+4>>2]=0;c[k+8>>2]=0;c[k+12>>2]=0;c[f>>2]=c[h>>2];c[k>>2]=c[e>>2];c[k+4>>2]=c[e+4>>2];c[k+8>>2]=c[e+8>>2];c[k+12>>2]=c[e+12>>2];c[f+24>>2]=i;k=i+28|0;e=c[k>>2]|0;c[f+28>>2]=e;c[e+24>>2]=f;c[k>>2]=f;if(!g){k=f;Eb=l;return k|0}c[b>>2]=f;k=f;Eb=l;return k|0}h=Zj(24)|0;c[j>>2]=h;a[h+4>>0]=0;a[h+5>>0]=0;g=h+8|0;i=b+40|0;f=b+44|0;c[g>>2]=0;c[g+4>>2]=0;c[g+8>>2]=0;c[g+12>>2]=0;g=c[f>>2]|0;if((g|0)==(c[b+48>>2]|0)){Pe(i,j);f=c[f>>2]|0;}else {c[g>>2]=h;b=(c[f>>2]|0)+4|0;c[f>>2]=b;f=b;}b=c[i>>2]|0;j=c[j>>2]|0;c[j>>2]=(f-b>>2)+-1;h=j+5|0;a[h>>0]=(c[d+64>>2]|0)==0&1;i=Zj(32)|0;g=i+8|0;c[g>>2]=0;c[g+4>>2]=0;c[g+8>>2]=0;c[g+12>>2]=0;c[j+16>>2]=i;c[i>>2]=c[j>>2];c[g>>2]=c[e>>2];c[g+4>>2]=c[e+4>>2];c[g+8>>2]=c[e+8>>2];c[g+12>>2]=c[e+12>>2];c[i+24>>2]=i;c[i+28>>2]=i;if(!(a[h>>0]|0)){f=c[d+96>>2]|0;if(f){g=0;do{h=c[f+76>>2]|0;if((h|0)>-1?(c[f+64>>2]|0)!=0:0)if(!g)g=f;else g=(c[g+76>>2]|0)==(h|0)?0:g;f=c[f+96>>2]|0;}while((f|0)!=0);if(g){g=c[b+(c[g+76>>2]<<2)>>2]|0;f=a[g+4>>0]^1;}else {f=0;g=0;}}else {f=0;g=0;}c[j+8>>2]=g;a[j+4>>0]=f;}c[k>>2]=c[j>>2];k=i;Eb=l;return k|0}function cd(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;p=d+76|0;s=c[b+40>>2]|0;t=c[s+(c[p>>2]<<2)>>2]|0;r=e+76|0;s=c[s+(c[r>>2]<<2)>>2]|0;f=t;while(1){f=c[f+8>>2]|0;if((f|0)==(s|0)){n=s;break}if(!f){u=4;break}}a:do if((u|0)==4){f=s;do{f=c[f+8>>2]|0;if((f|0)==(t|0)){n=t;break a}}while((f|0)!=0);n=fd(t,s)|0;}while(0);h=t+16|0;i=c[h>>2]|0;j=i+28|0;k=c[j>>2]|0;o=s+16|0;l=c[o>>2]|0;g=l+28|0;m=c[g>>2]|0;q=c[d+60>>2]|0;f=c[e+60>>2]|0;do if((q|0)==1){if((f|0)!=1){c[m+24>>2]=i;c[j>>2]=m;c[g>>2]=k;c[k+24>>2]=l;c[h>>2]=l;break}if(l|0){f=l;do{g=f+24|0;e=f;f=c[g>>2]|0;e=e+28|0;c[g>>2]=c[e>>2];c[e>>2]=f;}while((f|0)!=(l|0))}c[l+24>>2]=i;c[j>>2]=l;c[k+24>>2]=m;c[m+28>>2]=k;c[h>>2]=m;}else {if((f|0)!=2){c[k+24>>2]=l;c[g>>2]=k;c[j>>2]=m;c[m+24>>2]=i;break}if(l|0){f=l;do{e=f+24|0;h=f;f=c[e>>2]|0;h=h+28|0;c[e>>2]=c[h>>2];c[h>>2]=f;}while((f|0)!=(l|0))}c[k+24>>2]=m;c[m+28>>2]=k;c[l+24>>2]=i;c[j>>2]=l;}while(0);c[t+20>>2]=0;d=s+8|0;if((n|0)==(s|0)){f=c[d>>2]|0;if((f|0)!=(t|0))c[t+8>>2]=f;a[t+4>>0]=a[s+4>>0]|0;}c[o>>2]=0;c[s+20>>2]=0;c[d>>2]=t;d=c[p>>2]|0;g=c[r>>2]|0;c[p>>2]=-1;c[r>>2]=-1;f=c[b+52>>2]|0;if(!f){u=c[t>>2]|0;c[s>>2]=u;return}while(1){if((c[f+76>>2]|0)==(g|0))break;f=c[f+92>>2]|0;if(!f){u=30;break}}if((u|0)==30){u=c[t>>2]|0;c[s>>2]=u;return}c[f+76>>2]=d;c[f+60>>2]=q;u=c[t>>2]|0;c[s>>2]=u;return}function dd(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,t=0,u=0.0,v=0;j=a+52|0;k=c[j>>2]|0;l=k;if(!k){c[b+96>>2]=0;c[b+92>>2]=0;t=j;c[t>>2]=b;return}a:do if(!d){d=b+16|0;a=c[d>>2]|0;d=c[d+4>>2]|0;f=k+16|0;e=c[f>>2]|0;f=c[f+4>>2]|0;do if((a|0)==(e|0)&(d|0)==(f|0)){d=b+40|0;a=c[d>>2]|0;d=c[d+4>>2]|0;f=k+40|0;e=c[f>>2]|0;f=c[f+4>>2]|0;if((d|0)>(f|0)|(d|0)==(f|0)&a>>>0>e>>>0){o=b+32|0;q=c[o>>2]|0;o=c[o+4>>2]|0;t=k;p=c[t>>2]|0;t=c[t+4>>2]|0;u=+g[k+48>>3];n=k+8|0;n=Ww(a|0,d|0,c[n>>2]|0,c[n+4>>2]|0)|0;u=u*(+(n>>>0)+4294967296.0*+(F()|0));u=u+(u<0.0?-.5:.5);t=Vw(p|0,t|0,~~u>>>0|0,(+s(u)>=1.0?(u>0.0?~~+B(+r(u/4294967296.0),4294967295.0)>>>0:~~+z((u-+(~~u>>>0))/4294967296.0)>>>0):0)|0)|0;p=F()|0;if((o|0)<(p|0)|(o|0)==(p|0)&q>>>0<t>>>0)break;else {e=k;break a}}i=k+32|0;h=c[i>>2]|0;i=c[i+4>>2]|0;if((a|0)==(e|0)&(d|0)==(f|0)){d=b+32|0;a=c[d+4>>2]|0;d=c[d>>2]|0;}else {d=b;a=c[d>>2]|0;d=c[d+4>>2]|0;u=+g[b+48>>3];t=b+8|0;t=Ww(e|0,f|0,c[t>>2]|0,c[t+4>>2]|0)|0;u=u*(+(t>>>0)+4294967296.0*+(F()|0));u=u+(u<0.0?-.5:.5);d=Vw(a|0,d|0,~~u>>>0|0,(+s(u)>=1.0?(u>0.0?~~+B(+r(u/4294967296.0),4294967295.0)>>>0:~~+z((u-+(~~u>>>0))/4294967296.0)>>>0):0)|0)|0;a=F()|0;}if(!((i|0)>(a|0)|(i|0)==(a|0)&h>>>0>d>>>0)){e=k;break a}}else if(!((d|0)<(f|0)|(d|0)==(f|0)&a>>>0<e>>>0)){e=k;break a}while(0);c[b+96>>2]=0;c[b+92>>2]=l;c[k+96>>2]=b;t=j;c[t>>2]=b;return}else e=d;while(0);d=e+92|0;a=c[d>>2]|0;b:do if(!a)a=0;else {n=b+16|0;m=c[n>>2]|0;n=c[n+4>>2]|0;o=b+40|0;p=b+32|0;q=b+48|0;t=b+8|0;while(1){h=a+16|0;f=c[h>>2]|0;h=c[h+4>>2]|0;do if((m|0)==(f|0)&(n|0)==(h|0)){h=o;f=c[h>>2]|0;h=c[h+4>>2]|0;j=a+40|0;i=c[j>>2]|0;j=c[j+4>>2]|0;if((h|0)>(j|0)|(h|0)==(j|0)&f>>>0>i>>>0){i=p;k=c[i>>2]|0;i=c[i+4>>2]|0;l=a;j=c[l>>2]|0;l=c[l+4>>2]|0;u=+g[a+48>>3];v=a+8|0;h=Ww(f|0,h|0,c[v>>2]|0,c[v+4>>2]|0)|0;u=u*(+(h>>>0)+4294967296.0*+(F()|0));u=u+(u<0.0?-.5:.5);l=Vw(j|0,l|0,~~u>>>0|0,(+s(u)>=1.0?(u>0.0?~~+B(+r(u/4294967296.0),4294967295.0)>>>0:~~+z((u-+(~~u>>>0))/4294967296.0)>>>0):0)|0)|0;j=F()|0;if((i|0)<(j|0)|(i|0)==(j|0)&k>>>0<l>>>0)break b;else break}l=a+32|0;k=c[l>>2]|0;l=c[l+4>>2]|0;if((f|0)==(i|0)&(h|0)==(j|0)){h=p;f=c[h+4>>2]|0;h=c[h>>2]|0;}else {h=b;f=c[h>>2]|0;h=c[h+4>>2]|0;u=+g[q>>3];v=t;v=Ww(i|0,j|0,c[v>>2]|0,c[v+4>>2]|0)|0;u=u*(+(v>>>0)+4294967296.0*+(F()|0));u=u+(u<0.0?-.5:.5);h=Vw(f|0,h|0,~~u>>>0|0,(+s(u)>=1.0?(u>0.0?~~+B(+r(u/4294967296.0),4294967295.0)>>>0:~~+z((u-+(~~u>>>0))/4294967296.0)>>>0):0)|0)|0;f=F()|0;}if((l|0)>(f|0)|(l|0)==(f|0)&k>>>0>h>>>0)break b}else if((n|0)<(h|0)|(n|0)==(h|0)&m>>>0<f>>>0)break b;while(0);d=a+92|0;e=c[d>>2]|0;if(!e){e=a;a=0;break}else {v=a;a=e;e=v;}}}while(0);c[b+92>>2]=a;a=c[d>>2]|0;if(a|0)c[a+96>>2]=b;c[b+96>>2]=e;v=d;c[v>>2]=b;return}function ed(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;u=b+76|0;q=c[u>>2]|0;r=(q|0)>-1;v=d+76|0;s=c[v>>2]|0;t=(s|0)>-1;m=c[b+64>>2]|0;f=(m|0)==0;p=d+64|0;k=c[p>>2]|0;g=(k|0)==0;if(f){if(g)return}else if(!g){w=c[b+56>>2]|0;o=c[d+56>>2]|0;x=(w|0)==(o|0);do if(x){g=a+136|0;l=a+132|0;f=(w|0)==0?g:l;h=b+68|0;i=c[h>>2]|0;if(!(c[f>>2]|0)){n=d+68|0;c[h>>2]=c[n>>2];c[n>>2]=i;h=l;break}j=i+k|0;c[h>>2]=(j|0)==0?0-i|0:j;i=d+68|0;j=c[i>>2]|0;h=j-m|0;if(!h){c[i>>2]=0-j;h=l;break}else {c[i>>2]=h;h=l;break}}else {g=a+136|0;j=a+132|0;f=b+72|0;h=c[f>>2]|0;c[f>>2]=(c[((o|0)==0?g:j)>>2]|0)==0?(h|0)==0&1:h+k|0;f=(w|0)==0?g:j;h=d+72|0;i=c[h>>2]|0;if(!(c[f>>2]|0)){c[h>>2]=(i|0)==0&1;h=j;break}else {c[h>>2]=i-m;h=j;break}}while(0);n=(w|0)==0;l=c[(n?h:g)>>2]|0;o=(o|0)==0;m=c[(o?h:g)>>2]|0;g=c[(o?g:h)>>2]|0;switch(c[f>>2]|0){case 2:{h=c[b+68>>2]|0;f=h;h=((h|0)<0)<<31>>31;break}case 3:{h=0-(c[b+68>>2]|0)|0;f=h;h=((h|0)<0)<<31>>31;break}default:{f=c[b+68>>2]|0;h=((f|0)<0)<<31>>31;k=(h|0)<0;j=Ww(0,0,f|0,h|0)|0;o=F()|0;f=k?j:f;h=k?o:h;}}switch(g|0){case 2:{i=c[d+68>>2]|0;g=i;i=((i|0)<0)<<31>>31;break}case 3:{i=0-(c[d+68>>2]|0)|0;g=i;i=((i|0)<0)<<31>>31;break}default:{g=c[d+68>>2]|0;i=((g|0)<0)<<31>>31;k=(i|0)<0;j=Ww(0,0,g|0,i|0)|0;o=F()|0;g=k?j:g;i=k?o:i;}}if((s|q|0)>=0){w=i|h;do if(!(w>>>0>0|(w|0)==0&(g|f)>>>0>1)){if(!x?(c[a+108>>2]|0)!=3:0)break;bd(a,b,e)|0;bd(a,d,e)|0;a=b+60|0;b=c[a>>2]|0;d=d+60|0;c[a>>2]=c[d>>2];c[d>>2]=b;d=c[u>>2]|0;c[u>>2]=c[v>>2];c[v>>2]=d;return}while(0);bd(a,b,e)|0;if(!(c[p>>2]|0))bd(a,d,e)|0;f=c[u>>2]|0;g=c[v>>2]|0;if((f|0)==(g|0)){c[u>>2]=-1;c[v>>2]=-1;return}if((f|0)<(g|0)){cd(a,b,d);return}else {cd(a,d,b);return}}if(r){if(!(i>>>0<0|(i|0)==0&g>>>0<2))return;bd(a,b,e)|0;a=b+60|0;b=c[a>>2]|0;d=d+60|0;c[a>>2]=c[d>>2];c[d>>2]=b;d=c[u>>2]|0;c[u>>2]=c[v>>2];c[v>>2]=d;return}k=(f|0)==1&(h|0)==0;f=h>>>0<0|(h|0)==0&f>>>0<2;if(t){if(!f)return;bd(a,d,e)|0;a=b+60|0;b=c[a>>2]|0;d=d+60|0;c[a>>2]=c[d>>2];c[d>>2]=b;d=c[u>>2]|0;c[u>>2]=c[v>>2];c[v>>2]=d;return}if(!f)return;j=(g|0)==1&(i|0)==0;if(!(i>>>0<0|(i|0)==0&g>>>0<2))return;switch(l|0){case 2:{i=c[b+72>>2]|0;h=((i|0)<0)<<31>>31;break}case 3:{i=0-(c[b+72>>2]|0)|0;h=((i|0)<0)<<31>>31;break}default:{i=c[b+72>>2]|0;h=((i|0)<0)<<31>>31;u=(h|0)<0;v=Ww(0,0,i|0,h|0)|0;t=F()|0;h=u?t:h;i=u?v:i;}}switch(m|0){case 2:{g=c[d+72>>2]|0;f=((g|0)<0)<<31>>31;break}case 3:{g=0-(c[d+72>>2]|0)|0;f=((g|0)<0)<<31>>31;break}default:{g=c[d+72>>2]|0;f=((g|0)<0)<<31>>31;u=(f|0)<0;v=Ww(0,0,g|0,f|0)|0;t=F()|0;f=u?t:f;g=u?v:g;}}if(!x){ad(a,b,d,e)|0;return}if(!(k&j)){a=b+60|0;b=c[a>>2]|0;d=d+60|0;c[a>>2]=c[d>>2];c[d>>2]=b;return}switch(c[a+108>>2]|0){case 0:{if(!(((h|0)>0|(h|0)==0&i>>>0>0)&((f|0)>0|(f|0)==0&g>>>0>0)))return;ad(a,b,d,e)|0;return}case 1:{if(!(((h|0)<0|(h|0)==0&i>>>0<1)&((f|0)<0|(f|0)==0&g>>>0<1)))return;ad(a,b,d,e)|0;return}case 2:{if(!((w|0)==1&((h|0)>0|(h|0)==0&i>>>0>0)&((f|0)>0|(f|0)==0&g>>>0>0))?!(n&((h|0)<0|(h|0)==0&i>>>0<1)&((f|0)<0|(f|0)==0&g>>>0<1)):0)return;ad(a,b,d,e)|0;return}case 3:{ad(a,b,d,e)|0;return}default:return}}if((c[b+56>>2]|0)==(c[d+56>>2]|0)){if((m|0)==(k|0))return;if((c[a+108>>2]|0)!=1)return;if(f){if(!t)return;bd(a,b,e)|0;if(!r)return;c[u>>2]=-1;return}else {if(!r)return;bd(a,d,e)|0;if(!t)return;c[v>>2]=-1;return}}do if(f?(x=c[d+68>>2]|0,(((x|0)>-1?x:0-x|0)|0)==1):0){if((c[a+108>>2]|0)==1?c[d+72>>2]|0:0)break;bd(a,b,e)|0;if(!r)return;c[u>>2]=-1;return}while(0);if(!g)return;x=c[b+68>>2]|0;if((((x|0)>-1?x:0-x|0)|0)!=1)return;if((c[a+108>>2]|0)==1?c[b+72>>2]|0:0)return;bd(a,d,e)|0;if(!t)return;c[v>>2]=-1;return}function fd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;s=a+20|0;e=c[s>>2]|0;if(!e){d=c[a+16>>2]|0;e=c[d+24>>2]|0;if((e|0)!=(d|0)){f=0;do{h=e+16|0;g=c[h>>2]|0;h=c[h+4>>2]|0;j=d+16|0;i=c[j>>2]|0;j=c[j+4>>2]|0;if(!((h|0)>(j|0)|(h|0)==(j|0)&g>>>0>i>>>0)){if((g|0)==(i|0)&(h|0)==(j|0)?(l=e+8|0,k=c[l>>2]|0,l=c[l+4>>2]|0,n=d+8|0,m=c[n>>2]|0,n=c[n+4>>2]|0,!((l|0)>(n|0)|(l|0)==(n|0)&k>>>0>m>>>0)):0)if(!((l|0)<(n|0)|(l|0)==(n|0)&k>>>0<m>>>0)){if((c[e+24>>2]|0)!=(d|0))f=(c[e+28>>2]|0)==(d|0)?f:e;}else {f=0;d=e;}}else {f=0;d=e;}e=c[e+24>>2]|0;}while((e|0)!=(d|0));if(!((f|0)==0|(f|0)==(d|0))){e=d;do{h=xc(d,f)|0;e=h?e:f;h=e+8|0;g=c[h>>2]|0;h=c[h+4>>2]|0;j=e+16|0;i=c[j>>2]|0;j=c[j+4>>2]|0;do{f=c[f+24>>2]|0;n=f+8|0;}while(!(((c[n>>2]|0)==(g|0)?(c[n+4>>2]|0)==(h|0):0)?(n=f+16|0,(c[n>>2]|0)==(i|0)?(c[n+4>>2]|0)==(j|0):0):0))}while((f|0)!=(d|0));d=e;}}c[s>>2]=d;e=d;}k=b+20|0;d=c[k>>2]|0;if(!d){d=c[b+16>>2]|0;e=c[d+24>>2]|0;if((e|0)!=(d|0)){f=0;do{h=e+16|0;g=c[h>>2]|0;h=c[h+4>>2]|0;j=d+16|0;i=c[j>>2]|0;j=c[j+4>>2]|0;if(!((h|0)>(j|0)|(h|0)==(j|0)&g>>>0>i>>>0)){if((g|0)==(i|0)&(h|0)==(j|0)?(p=e+8|0,o=c[p>>2]|0,p=c[p+4>>2]|0,r=d+8|0,q=c[r>>2]|0,r=c[r+4>>2]|0,!((p|0)>(r|0)|(p|0)==(r|0)&o>>>0>q>>>0)):0)if(!((p|0)<(r|0)|(p|0)==(r|0)&o>>>0<q>>>0)){if((c[e+24>>2]|0)!=(d|0))f=(c[e+28>>2]|0)==(d|0)?f:e;}else {f=0;d=e;}}else {f=0;d=e;}e=c[e+24>>2]|0;}while((e|0)!=(d|0));if(!((f|0)==0|(f|0)==(d|0))){e=d;do{h=xc(d,f)|0;e=h?e:f;h=e+8|0;g=c[h>>2]|0;h=c[h+4>>2]|0;j=e+16|0;i=c[j>>2]|0;j=c[j+4>>2]|0;do{f=c[f+24>>2]|0;r=f+8|0;}while(!(((c[r>>2]|0)==(g|0)?(c[r+4>>2]|0)==(h|0):0)?(r=f+16|0,(c[r>>2]|0)==(i|0)?(c[r+4>>2]|0)==(j|0):0):0))}while((f|0)!=(d|0));d=e;}}c[k>>2]=d;i=c[s>>2]|0;}else i=e;f=i+16|0;e=c[f>>2]|0;f=c[f+4>>2]|0;h=d+16|0;g=c[h>>2]|0;h=c[h+4>>2]|0;if((f|0)>(h|0)|(f|0)==(h|0)&e>>>0>g>>>0){b=a;return b|0}if((f|0)<(h|0)|(f|0)==(h|0)&e>>>0<g>>>0)return b|0;f=i+8|0;e=c[f>>2]|0;f=c[f+4>>2]|0;h=d+8|0;g=c[h>>2]|0;h=c[h+4>>2]|0;if((f|0)<(h|0)|(f|0)==(h|0)&e>>>0<g>>>0){b=a;return b|0}if((f|0)>(h|0)|(f|0)==(h|0)&e>>>0>g>>>0)return b|0;if((c[i+24>>2]|0)==(i|0))return b|0;if((c[d+24>>2]|0)==(d|0)){b=a;return b|0}s=xc(i,d)|0;b=s?a:b;return b|0}function gd(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0;U=Eb;Eb=Eb+48|0;S=U+16|0;R=U;T=U+32|0;c[T>>2]=d;M=(c[d+64>>2]|0)==0;o=d;n=c[o>>2]|0;o=c[o+4>>2]|0;h=d+32|0;e=c[h>>2]|0;h=c[h+4>>2]|0;p=(o|0)<(h|0)|(o|0)==(h|0)&n>>>0<e>>>0;t=p?n:e;s=p?o:h;r=p?e:n;q=p?h:o;f=c[d+88>>2]|0;a:do if(!f){f=d;i=h;z=6;}else {e=d;while(1){if(!(+g[f+48>>3]==-1.e+40)){N=0;break a}e=c[f+88>>2]|0;if(!e)break;else {N=f;f=e;e=N;}}i=f+32|0;e=c[i>>2]|0;i=c[i+4>>2]|0;z=6;}while(0);do if((z|0)==6){h=c[f+80>>2]|0;N=h+32|0;if((((c[N>>2]|0)==(e|0)?(c[N+4>>2]|0)==(i|0):0)?(J=h+40|0,N=f+40|0,(c[J>>2]|0)==(c[N>>2]|0)?(c[J+4>>2]|0)==(c[N+4>>2]|0):0):0)?(c[h+88>>2]|0)==0:0){N=h;e=f;break}h=c[f+84>>2]|0;N=h+32|0;if((((c[N>>2]|0)==(e|0)?(c[N+4>>2]|0)==(i|0):0)?(J=h+40|0,N=f+40|0,(c[J>>2]|0)==(c[N>>2]|0)?(c[J+4>>2]|0)==(c[N+4>>2]|0):0):0)?(c[h+88>>2]|0)==0:0){N=h;e=f;break}N=0;e=f;}while(0);m=b+112|0;G=b+120|0;b:do if(c[G>>2]|0)if(p){k=b+116|0;h=c[k>>2]|0;l=m;f=h;if((m|0)==(f|0)){C=k;f=0;break}while(1){j=h+8|0;i=c[j>>2]|0;j=c[j+4>>2]|0;if((j|0)>(o|0)|(j|0)==(o|0)&i>>>0>n>>>0)break;h=c[f+4>>2]|0;f=h;if((m|0)==(f|0)){C=k;f=0;break b}}f=e+32|0;J=c[f+4>>2]|0;C=k;h=(j|0)<(J|0)|((j|0)==(J|0)?i>>>0<(c[f>>2]|0)>>>0:0)?h:l;f=0;break}else {f=m;i=b+116|0;l=c[i>>2]|0;h=l;if((m|0)==(h|0)){C=i;h=0;break}while(1){k=(c[f>>2]|0)+8|0;j=c[k>>2]|0;k=c[k+4>>2]|0;if(!((k|0)>(o|0)|(k|0)==(o|0)&j>>>0>n>>>0))break;f=c[f>>2]|0;if((f|0)==(h|0)){C=i;h=0;break b}}J=e+32|0;I=c[J+4>>2]|0;C=i;h=0;f=(k|0)>(I|0)|((k|0)==(I|0)?j>>>0>(c[J>>2]|0)>>>0:0)?f:l;break}else {C=b+116|0;h=0;f=0;}while(0);v=S+8|0;w=S+8|0;A=b+124|0;D=b+88|0;E=b+92|0;B=b+40|0;H=b+76|0;I=b+80|0;J=b+72|0;x=S+8|0;y=S+8|0;F=b+84|0;j=0;c:while(1){u=(d|0)!=(e|0);i=c[(p?d+92|0:d+96|0)>>2]|0;if(!i)i=f;else {d=j;do{d:do if(c[G>>2]|0)if(p){j=h;n=i+16|0;if((m|0)==(j|0)){j=n;l=c[j+4>>2]|0;j=c[j>>2]|0;z=54;break}if(M){l=n;k=c[l>>2]|0;l=c[l+4>>2]|0;while(1){z=h+8|0;o=c[z+4>>2]|0;if(!((o|0)<(l|0)|((o|0)==(l|0)?(c[z>>2]|0)>>>0<k>>>0:0))){z=53;break d}h=c[j+4>>2]|0;j=h;if((m|0)==(j|0)){z=53;break d}}}while(1){l=h+8|0;k=c[l>>2]|0;l=c[l+4>>2]|0;z=n;o=c[z+4>>2]|0;if(!((l|0)<(o|0)|((l|0)==(o|0)?k>>>0<(c[z>>2]|0)>>>0:0))){z=53;break d}h=c[T>>2]|0;if((c[h+76>>2]|0)>=0){o=h+8|0;V=c[o>>2]|0;o=c[o+4>>2]|0;z=S;c[z>>2]=k;c[z+4>>2]=l;z=v;c[z>>2]=V;c[z+4>>2]=o;bd(b,h,S)|0;}h=c[j+4>>2]|0;j=h;if((m|0)==(j|0)){z=53;break}}}else {j=c[C>>2]|0;o=i+16|0;if((j|0)==(f|0)){j=o;l=c[j+4>>2]|0;j=c[j>>2]|0;z=55;break}if(M){l=o;k=c[l>>2]|0;l=c[l+4>>2]|0;while(1){V=(c[f>>2]|0)+8|0;z=c[V+4>>2]|0;if(!((z|0)>(l|0)|((z|0)==(l|0)?(c[V>>2]|0)>>>0>k>>>0:0))){z=53;break d}f=c[f>>2]|0;if((j|0)==(f|0)){z=53;break d}}}while(1){l=(c[f>>2]|0)+8|0;k=c[l>>2]|0;l=c[l+4>>2]|0;V=o;z=c[V+4>>2]|0;if(!((l|0)>(z|0)|((l|0)==(z|0)?k>>>0>(c[V>>2]|0)>>>0:0))){z=53;break d}n=c[T>>2]|0;if((c[n+76>>2]|0)>=0){V=n+8|0;z=c[V>>2]|0;V=c[V+4>>2]|0;j=S;c[j>>2]=k;c[j+4>>2]=l;j=w;c[j>>2]=z;c[j+4>>2]=V;bd(b,n,S)|0;j=c[C>>2]|0;}f=c[f>>2]|0;if((j|0)==(f|0)){z=53;break}}}else z=53;while(0);if((z|0)==53){l=i+16|0;j=c[l>>2]|0;l=c[l+4>>2]|0;if(p)z=54;else z=55;}if((z|0)==54){z=0;if((l|0)>(q|0)|(l|0)==(q|0)&j>>>0>r>>>0)break}else if((z|0)==55){z=0;if((l|0)<(s|0)|(l|0)==(s|0)&j>>>0<t>>>0)break}n=i+16|0;k=c[T>>2]|0;V=k+32|0;if((((j|0)==(c[V>>2]|0)?(l|0)==(c[V+4>>2]|0):0)?(K=c[k+88>>2]|0,K|0):0)?+g[i+48>>3]<+g[K+48>>3]:0)break;if(!(M|(c[k+76>>2]|0)<0)){d=bd(b,k,n)|0;j=c[A>>2]|0;if(j|0)do{k=c[j+76>>2]|0;if((k|0)>-1?(Z=c[T>>2]|0,Y=Z,o=c[Y>>2]|0,Y=c[Y+4>>2]|0,Z=Z+32|0,V=c[Z>>2]|0,Z=c[Z+4>>2]|0,ba=j,W=c[ba>>2]|0,ba=c[ba+4>>2]|0,L=j+32|0,$=L,X=c[$>>2]|0,$=c[$+4>>2]|0,l=(Y|0)>(Z|0)|(Y|0)==(Z|0)&o>>>0>V>>>0,aa=l?Z:Y,Z=l?Y:Z,Y=(ba|0)>($|0)|(ba|0)==($|0)&W>>>0>X>>>0,_=Y?$:ba,$=Y?ba:$,((aa|0)<($|0)|((aa|0)==($|0)?(l?V:o)>>>0<(Y?W:X)>>>0:0))&((_|0)<(Z|0)|((_|0)==(Z|0)?(Y?X:W)>>>0<(l?o:V)>>>0:0))):0){k=c[(c[(c[B>>2]|0)+(k<<2)>>2]|0)+16>>2]|0;if((c[j+60>>2]|0)!=1)k=c[k+28>>2]|0;c[R>>2]=c[L>>2];c[R+4>>2]=c[L+4>>2];c[R+8>>2]=c[L+8>>2];c[R+12>>2]=c[L+12>>2];l=Zj(24)|0;ba=l+8|0;c[S>>2]=l;c[l>>2]=k;c[l+4>>2]=d;c[ba>>2]=c[R>>2];c[ba+4>>2]=c[R+4>>2];c[ba+8>>2]=c[R+8>>2];c[ba+12>>2]=c[R+12>>2];k=c[H>>2]|0;if((k|0)==(c[I>>2]|0))Re(J,S);else {c[k>>2]=l;c[H>>2]=(c[H>>2]|0)+4;}}j=c[j+100>>2]|0;}while((j|0)!=0);j=c[T>>2]|0;c[R>>2]=c[j>>2];c[R+4>>2]=c[j+4>>2];c[R+8>>2]=c[j+8>>2];c[R+12>>2]=c[j+12>>2];j=Zj(24)|0;k=j+8|0;c[S>>2]=j;c[j>>2]=d;c[j+4>>2]=0;c[k>>2]=c[R>>2];c[k+4>>2]=c[R+4>>2];c[k+8>>2]=c[R+8>>2];c[k+12>>2]=c[R+12>>2];k=c[D>>2]|0;if((k|0)==(c[E>>2]|0))Re(F,S);else {c[k>>2]=j;c[D>>2]=(c[D>>2]|0)+4;}}if(!(u|(i|0)!=(N|0))){z=76;break c}if(p){Y=n;Z=c[Y+4>>2]|0;ba=c[T>>2]|0;$=ba+24|0;_=c[$>>2]|0;$=c[$+4>>2]|0;aa=S;c[aa>>2]=c[Y>>2];c[aa+4>>2]=Z;aa=x;c[aa>>2]=_;c[aa+4>>2]=$;ed(b,ba,i,S);}else {Y=n;Z=c[Y+4>>2]|0;ba=c[T>>2]|0;$=ba+24|0;_=c[$>>2]|0;$=c[$+4>>2]|0;aa=S;c[aa>>2]=c[Y>>2];c[aa+4>>2]=Z;aa=y;c[aa>>2]=_;c[aa+4>>2]=$;ed(b,i,ba,S);}ba=i;i=c[(p?i+92|0:i+96|0)>>2]|0;Lc(b,c[T>>2]|0,ba);}while((i|0)!=0);j=d;i=f;d=c[T>>2]|0;}f=c[d+88>>2]|0;if(!f)break;if(!(+g[f+48>>3]==-1.e+40))break;Mc(b,T);d=c[T>>2]|0;if((c[d+76>>2]|0)>-1){bd(b,d,d)|0;d=c[T>>2]|0;}$=d;ba=c[$>>2]|0;$=c[$+4>>2]|0;s=d+32|0;t=c[s>>2]|0;s=c[s+4>>2]|0;aa=($|0)<(s|0)|($|0)==(s|0)&ba>>>0<t>>>0;p=aa;f=i;q=aa?s:$;r=aa?t:ba;s=aa?$:s;t=aa?ba:t;}if((z|0)==76){h=c[T>>2]|0;i=h+76|0;do if((c[i>>2]|0)>-1){e=h+32|0;bd(b,h,e)|0;if(!(c[N+64>>2]|0))bd(b,N,e)|0;e=c[i>>2]|0;d=N+76|0;f=c[d>>2]|0;if((e|0)==(f|0)){c[i>>2]=-1;c[d>>2]=-1;break}if((e|0)<(f|0)){cd(b,h,N);break}else {cd(b,N,h);break}}while(0);ba=c[T>>2]|0;e=ba+96|0;d=c[e>>2]|0;f=ba+92|0;h=c[f>>2]|0;i=(d|0)!=0;j=(h|0)!=0;if(!(!(i|j)?(c[b+52>>2]|0)!=(ba|0):0)){c[(i?d+92|0:b+52|0)>>2]=h;if(j)c[h+96>>2]=d;c[f>>2]=0;c[e>>2]=0;}e=N+96|0;d=c[e>>2]|0;f=N+92|0;h=c[f>>2]|0;i=(d|0)!=0;j=(h|0)!=0;if(!(i|j)?(c[b+52>>2]|0)!=(N|0):0){Eb=U;return}c[(i?d+92|0:b+52|0)>>2]=h;if(j)c[h+96>>2]=d;c[f>>2]=0;c[e>>2]=0;Eb=U;return}e=c[d+76>>2]|0;if(!((j|0)!=0|(e|0)<0)){e=c[(c[(c[B>>2]|0)+(e<<2)>>2]|0)+16>>2]|0;if((c[d+60>>2]|0)==1)h=e;else h=c[e+28>>2]|0;e=c[A>>2]|0;if(e){do{d=c[e+76>>2]|0;if((d|0)>-1?(X=c[T>>2]|0,Y=X,aa=c[Y>>2]|0,Y=c[Y+4>>2]|0,X=X+32|0,ba=c[X>>2]|0,X=c[X+4>>2]|0,M=e,_=c[M>>2]|0,M=c[M+4>>2]|0,O=e+32|0,V=O,Z=c[V>>2]|0,V=c[V+4>>2]|0,$=(Y|0)>(X|0)|(Y|0)==(X|0)&aa>>>0>ba>>>0,N=$?X:Y,X=$?Y:X,Y=(M|0)>(V|0)|(M|0)==(V|0)&_>>>0>Z>>>0,W=Y?V:M,V=Y?M:V,((N|0)<(V|0)|((N|0)==(V|0)?($?ba:aa)>>>0<(Y?_:Z)>>>0:0))&((W|0)<(X|0)|((W|0)==(X|0)?(Y?Z:_)>>>0<($?aa:ba)>>>0:0))):0){d=c[(c[(c[B>>2]|0)+(d<<2)>>2]|0)+16>>2]|0;if((c[e+60>>2]|0)!=1)d=c[d+28>>2]|0;c[R>>2]=c[O>>2];c[R+4>>2]=c[O+4>>2];c[R+8>>2]=c[O+8>>2];c[R+12>>2]=c[O+12>>2];f=Zj(24)|0;ba=f+8|0;c[S>>2]=f;c[f>>2]=d;c[f+4>>2]=h;c[ba>>2]=c[R>>2];c[ba+4>>2]=c[R+4>>2];c[ba+8>>2]=c[R+8>>2];c[ba+12>>2]=c[R+12>>2];d=c[H>>2]|0;if((d|0)==(c[I>>2]|0))Re(J,S);else {c[d>>2]=f;c[H>>2]=(c[H>>2]|0)+4;}}e=c[e+100>>2]|0;}while((e|0)!=0);d=c[T>>2]|0;}d=d+32|0;c[R>>2]=c[d>>2];c[R+4>>2]=c[d+4>>2];c[R+8>>2]=c[d+8>>2];c[R+12>>2]=c[d+12>>2];d=Zj(24)|0;e=d+8|0;c[S>>2]=d;c[d>>2]=h;c[d+4>>2]=0;c[e>>2]=c[R>>2];c[e+4>>2]=c[R+4>>2];c[e+8>>2]=c[R+8>>2];c[e+12>>2]=c[R+12>>2];e=c[D>>2]|0;if((e|0)==(c[E>>2]|0))Re(F,S);else {c[e>>2]=d;c[D>>2]=(c[D>>2]|0)+4;}d=c[T>>2]|0;f=c[d+88>>2]|0;e=c[d+76>>2]|0;}e=(e|0)>-1;if(!f){if(e){bd(b,d,d+32|0)|0;d=c[T>>2]|0;}e=d+96|0;f=c[e>>2]|0;h=d+92|0;i=c[h>>2]|0;j=(f|0)!=0;k=(i|0)!=0;if(!(j|k)?(c[b+52>>2]|0)!=(d|0):0){Eb=U;return}c[(j?f+92|0:b+52|0)>>2]=i;if(k)c[i+96>>2]=f;c[h>>2]=0;c[e>>2]=0;Eb=U;return}if(!e){Mc(b,T);Eb=U;return}i=bd(b,d,d+32|0)|0;Mc(b,T);f=c[T>>2]|0;if(!(c[f+64>>2]|0)){Eb=U;return}e=c[f+96>>2]|0;h=c[f+92>>2]|0;if((((((e|0?(aa=e+16|0,ba=f,(c[aa>>2]|0)==(c[ba>>2]|0)?(c[aa+4>>2]|0)==(c[ba+4>>2]|0):0):0)?(Q=e+24|0,P=c[Q>>2]|0,Q=c[Q+4>>2]|0,ba=f+8|0,(P|0)==(c[ba>>2]|0)?(Q|0)==(c[ba+4>>2]|0):0):0)?c[e+64>>2]|0:0)?(c[e+76>>2]|0)>-1:0)?(ba=e+40|0,aa=c[ba+4>>2]|0,(Q|0)>(aa|0)|((Q|0)==(aa|0)?P>>>0>(c[ba>>2]|0)>>>0:0)):0)?vc(f,e,(a[b+20>>0]|0)!=0)|0:0){ba=bd(b,e,f)|0;d=(c[T>>2]|0)+32|0;c[R>>2]=c[d>>2];c[R+4>>2]=c[d+4>>2];c[R+8>>2]=c[d+8>>2];c[R+12>>2]=c[d+12>>2];d=Zj(24)|0;e=d+8|0;c[S>>2]=d;c[d>>2]=i;c[d+4>>2]=ba;c[e>>2]=c[R>>2];c[e+4>>2]=c[R+4>>2];c[e+8>>2]=c[R+8>>2];c[e+12>>2]=c[R+12>>2];e=c[H>>2]|0;if((e|0)==(c[I>>2]|0))Re(J,S);else {c[e>>2]=d;c[H>>2]=(c[H>>2]|0)+4;}Eb=U;return}if(!h){Eb=U;return}aa=h+16|0;ba=f;if(!((c[aa>>2]|0)==(c[ba>>2]|0)?(c[aa+4>>2]|0)==(c[ba+4>>2]|0):0)){Eb=U;return}d=h+24|0;e=c[d>>2]|0;d=c[d+4>>2]|0;ba=f+8|0;if(!((e|0)==(c[ba>>2]|0)?(d|0)==(c[ba+4>>2]|0):0)){Eb=U;return}if(!(c[h+64>>2]|0)){Eb=U;return}if((c[h+76>>2]|0)<=-1){Eb=U;return}ba=h+40|0;aa=c[ba+4>>2]|0;if(!((d|0)>(aa|0)|((d|0)==(aa|0)?e>>>0>(c[ba>>2]|0)>>>0:0))){Eb=U;return}if(!(vc(f,h,(a[b+20>>0]|0)!=0)|0)){Eb=U;return}ba=bd(b,h,f)|0;d=(c[T>>2]|0)+32|0;c[R>>2]=c[d>>2];c[R+4>>2]=c[d+4>>2];c[R+8>>2]=c[d+8>>2];c[R+12>>2]=c[d+12>>2];d=Zj(24)|0;e=d+8|0;c[S>>2]=d;c[d>>2]=i;c[d+4>>2]=ba;c[e>>2]=c[R>>2];c[e+4>>2]=c[R+4>>2];c[e+8>>2]=c[R+8>>2];c[e+12>>2]=c[R+12>>2];e=c[H>>2]|0;if((e|0)==(c[I>>2]|0))Re(J,S);else {c[e>>2]=d;c[H>>2]=(c[H>>2]|0)+4;}Eb=U;return}function hd(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;j=b+100|0;k=c[j>>2]|0;i=(k|0)==0;if(i?(c[b+104>>2]|0)==0:0)return;l=d+100|0;g=c[l>>2]|0;f=(g|0)==0;if(f?(c[d+104>>2]|0)==0:0)return;if((k|0)!=(d|0)){if((g|0)!=(b|0)){e=b+104|0;h=c[e>>2]|0;c[j>>2]=g;if(!f)c[g+104>>2]=b;f=d+104|0;g=c[f>>2]|0;c[e>>2]=g;if(g|0)c[g+100>>2]=b;c[l>>2]=k;if(!i)c[k+104>>2]=d;c[f>>2]=h;if(h)c[h+100>>2]=d;}else {if(!i)c[k+104>>2]=d;e=d+104|0;f=c[e>>2]|0;if(f|0)c[f+100>>2]=b;i=b+104|0;c[i>>2]=f;c[j>>2]=d;c[e>>2]=b;c[l>>2]=k;e=i;}if(!(c[e>>2]|0)){c[a+124>>2]=b;return}}else {if(!f)c[g+104>>2]=b;e=b+104|0;f=c[e>>2]|0;if(f|0)c[f+100>>2]=d;c[d+104>>2]=f;c[l>>2]=b;c[e>>2]=d;c[j>>2]=g;}if(c[d+104>>2]|0)return;c[a+124>>2]=d;return}function id(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,t=0,u=0.0,v=0,w=0;t=Eb;Eb=Eb+32|0;o=t;p=t+16|0;j=c[a+52>>2]|0;if(!j){Eb=t;return}q=a+124|0;c[q>>2]=j;e=j;do{c[e+104>>2]=c[e+96>>2];f=e;e=c[e+92>>2]|0;c[f+100>>2]=e;n=f+40|0;if((c[n>>2]|0)==(b|0)?(c[n+4>>2]|0)==(d|0):0){i=f+32|0;h=c[i>>2]|0;i=c[i+4>>2]|0;}else {h=f;i=c[h>>2]|0;h=c[h+4>>2]|0;u=+g[f+48>>3];n=f+8|0;n=Ww(b|0,d|0,c[n>>2]|0,c[n+4>>2]|0)|0;u=u*(+(n>>>0)+4294967296.0*+(F()|0));u=u+(u<0.0?-.5:.5);h=Vw(i|0,h|0,~~u>>>0|0,(+s(u)>=1.0?(u>0.0?~~+B(+r(u/4294967296.0),4294967295.0)>>>0:~~+z((u-+(~~u>>>0))/4294967296.0)>>>0):0)|0)|0;i=F()|0;}n=f+16|0;c[n>>2]=h;c[n+4>>2]=i;}while((e|0)!=0);k=o+8|0;l=a+100|0;m=a+104|0;n=a+96|0;e=j;while(1){h=c[e+100>>2]|0;if(!h)f=0;else {f=0;i=h;do{c[o>>2]=0;c[o+4>>2]=0;c[o+8>>2]=0;c[o+12>>2]=0;h=e+16|0;w=c[h+4>>2]|0;j=i+16|0;v=c[j+4>>2]|0;if((w|0)>(v|0)|((w|0)==(v|0)?(c[h>>2]|0)>>>0>(c[j>>2]|0)>>>0:0)){wc(e,i,o);w=k;v=c[w+4>>2]|0;if((v|0)<(d|0)|((v|0)==(d|0)?(c[w>>2]|0)>>>0<b>>>0:0)){w=e+40|0;if((c[w>>2]|0)==(b|0)?(c[w+4>>2]|0)==(d|0):0){h=e+32|0;f=c[h>>2]|0;h=c[h+4>>2]|0;}else {f=e;h=c[f>>2]|0;f=c[f+4>>2]|0;u=+g[e+48>>3];w=e+8|0;w=Ww(b|0,d|0,c[w>>2]|0,c[w+4>>2]|0)|0;u=u*(+(w>>>0)+4294967296.0*+(F()|0));u=u+(u<0.0?-.5:.5);f=Vw(h|0,f|0,~~u>>>0|0,(+s(u)>=1.0?(u>0.0?~~+B(+r(u/4294967296.0),4294967295.0)>>>0:~~+z((u-+(~~u>>>0))/4294967296.0)>>>0):0)|0)|0;h=F()|0;}w=o;c[w>>2]=f;c[w+4>>2]=h;w=k;c[w>>2]=b;c[w+4>>2]=d;}f=Zj(24)|0;h=f+8|0;c[p>>2]=f;c[f>>2]=e;c[f+4>>2]=i;c[h>>2]=c[o>>2];c[h+4>>2]=c[o+4>>2];c[h+8>>2]=c[o+8>>2];c[h+12>>2]=c[o+12>>2];h=c[l>>2]|0;if((h|0)==(c[m>>2]|0))Se(n,p);else {c[h>>2]=f;c[l>>2]=(c[l>>2]|0)+4;}hd(a,e,i);f=1;}else e=i;i=c[e+100>>2]|0;}while((i|0)!=0)}e=c[e+104>>2]|0;if(!e)break;c[e+100>>2]=0;if(!f)break;e=c[q>>2]|0;}c[q>>2]=0;Eb=t;return}function jd(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;l=Eb;Eb=Eb+16|0;d=l;b=c[a+52>>2]|0;c[a+124>>2]=b;if(b|0)do{c[b+104>>2]=c[b+96>>2];k=b;b=c[b+92>>2]|0;c[k+100>>2]=b;}while((b|0)!=0);k=a+96|0;h=c[k>>2]|0;i=a+100|0;j=c[i>>2]|0;c[d>>2]=25;Te(h,j,d);d=c[k>>2]|0;i=(c[i>>2]|0)-d|0;j=i>>2;if(!i){a=1;Eb=l;return a|0}b=0;while(1){h=d+(b<<2)|0;i=c[h>>2]|0;f=c[i>>2]|0;g=c[i+4>>2]|0;if((c[f+100>>2]|0)!=(g|0)?(c[f+104>>2]|0)!=(g|0):0){e=b+1|0;a:do if(e>>>0<j>>>0)do{g=c[d+(e<<2)>>2]|0;f=c[g>>2]|0;g=c[g+4>>2]|0;if((c[f+100>>2]|0)==(g|0))break a;if((c[f+104>>2]|0)==(g|0))break a;e=e+1|0;}while(e>>>0<j>>>0);while(0);d=d+(e<<2)|0;if((e|0)==(j|0)){b=0;d=17;break}c[h>>2]=c[d>>2];c[d>>2]=i;d=c[k>>2]|0;}i=c[d+(b<<2)>>2]|0;hd(a,c[i>>2]|0,c[i+4>>2]|0);b=b+1|0;if(b>>>0>=j>>>0){b=1;d=17;break}d=c[k>>2]|0;}if((d|0)==17){Eb=l;return b|0}return 0}function kd(a,b){a=a|0;b=b|0;var d=0,e=0;d=b+16|0;e=c[d+4>>2]|0;b=a+16|0;a=c[b+4>>2]|0;return (e|0)<(a|0)|((e|0)==(a|0)?(c[d>>2]|0)>>>0<(c[b>>2]|0)>>>0:0)|0}
            function Hn(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;h=Gn(a)|0;do if(!(bl(a)|0)){e=jk(c[a>>2]|0,b<<2)|0;c[a>>2]=e;if(!e)Uk();else {f=e;d=a+4|0;break}}else {f=hk(b<<2)|0;if(!f)Uk();g=c[a>>2]|0;d=a+4|0;e=(c[d>>2]|0)-g|0;if(e|0)bx(f|0,g|0,e|0)|0;c[a>>2]=f;}while(0);c[d>>2]=f+(h<<2);c[a+8>>2]=f+(b<<2);return}function In(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Jn(a,e);Eb=d;return a|0}function Jn(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;jm(b,27,1,1,1);c[b>>2]=4668;g=b+8|0;f=c[d+4>>2]|0;h=g;c[h>>2]=c[d>>2];c[h+4>>2]=f;h=b+5|0;a[h>>0]=2;f=b+7|0;a[f>>0]=2;b=b+6|0;a[b>>0]=2;d=Kn(g)|0;e=Ln(g)|0;while(1){if((d|0)==(e|0)){i=4;break}if(Mn(c[d>>2]|0)|0)d=d+4|0;else break}if((i|0)==4)a[b>>0]=1;d=Kn(g)|0;b=Ln(g)|0;while(1){if((d|0)==(b|0)){i=8;break}if(Nn(c[d>>2]|0)|0)d=d+4|0;else break}if((i|0)==8)a[f>>0]=1;d=Kn(g)|0;b=Ln(g)|0;while(1){if((d|0)==(b|0)){i=12;break}if(On(c[d>>2]|0)|0)d=d+4|0;else break}if((i|0)==12)a[h>>0]=1;return}function Kn(a){a=a|0;return c[a>>2]|0}function Ln(a){a=a|0;return (c[a>>2]|0)+(c[a+4>>2]<<2)|0}function Mn(b){b=b|0;return (a[b+6>>0]|0)==1|0}function Nn(b){b=b|0;return (a[b+7>>0]|0)==1|0}function On(b){b=b|0;return (a[b+5>>0]|0)==1|0}function Pn(a,b){a=a|0;b=b|0;var d=0;Wn(a,b);d=c[b+12>>2]|0;a=a+8|0;if(d>>>0<(Xn(a)|0)>>>0)a=Wm(Yn(a,d)|0,b)|0;else a=0;return a|0}function Qn(a,b){a=a|0;b=b|0;var d=0;Wn(a,b);d=c[b+12>>2]|0;a=a+8|0;if(d>>>0<(Xn(a)|0)>>>0)a=Sm(Yn(a,d)|0,b)|0;else a=0;return a|0}function Rn(a,b){a=a|0;b=b|0;var d=0;Wn(a,b);d=c[b+12>>2]|0;a=a+8|0;if(d>>>0<(Xn(a)|0)>>>0)a=Tm(Yn(a,d)|0,b)|0;else a=0;return a|0}function Sn(a,b){a=a|0;b=b|0;var d=0,e=0;Wn(a,b);d=c[b+12>>2]|0;e=a+8|0;if(d>>>0<(Xn(e)|0)>>>0){a=Yn(e,d)|0;a=Ob[c[(c[a>>2]|0)+12>>2]&63](a,b)|0;}return a|0}function Tn(a,b){a=a|0;b=b|0;var d=0;Wn(a,b);d=c[b+12>>2]|0;a=a+8|0;if(d>>>0<(Xn(a)|0)>>>0){d=Yn(a,d)|0;Xb[c[(c[d>>2]|0)+16>>2]&127](d,b);}return}function Un(a,b){a=a|0;b=b|0;var d=0;Wn(a,b);d=c[b+12>>2]|0;a=a+8|0;if(d>>>0<(Xn(a)|0)>>>0){d=Yn(a,d)|0;Xb[c[(c[d>>2]|0)+20>>2]&127](d,b);}return}function Vn(a){a=a|0;$j(a);return}function Wn(a,b){a=a|0;b=b|0;var d=0;d=b+16|0;if((c[d>>2]|0)==-1){a=Xn(a+8|0)|0;c[d>>2]=a;c[b+12>>2]=0;}return}function Xn(a){a=a|0;return c[a+4>>2]|0}function Yn(a,b){a=a|0;b=b|0;return c[(c[a>>2]|0)+(b<<2)>>2]|0}function Zn(a){a=a|0;var b=0;b=a+12|0;c[a>>2]=b;c[a+4>>2]=b;c[a+8>>2]=a+44;return}function _n(a){a=a|0;return c[a>>2]|0}function $n(a){a=a|0;return c[a+4>>2]|0}function ao(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0;V=Eb;Eb=Eb+352|0;T=V+336|0;d=V+344|0;N=V+328|0;y=V+320|0;I=V+312|0;O=V+304|0;P=V+296|0;Q=V+288|0;U=V+8|0;R=V+280|0;e=V+272|0;f=V+264|0;g=V+256|0;h=V+248|0;i=V+240|0;j=V+232|0;k=V+224|0;l=V+216|0;m=V+208|0;n=V+200|0;o=V+192|0;p=V+184|0;q=V+176|0;r=V+168|0;s=V+160|0;t=V+152|0;u=V+144|0;v=V+136|0;w=V+128|0;x=V+120|0;z=V+112|0;A=V+104|0;B=V+96|0;C=V+88|0;D=V+80|0;E=V+72|0;F=V+64|0;G=V+56|0;H=V+48|0;S=V;J=V+40|0;K=V+32|0;L=V+24|0;M=V+16|0;fl(N,13428);c[T>>2]=c[N>>2];c[T+4>>2]=c[N+4>>2];N=(gl(b,T)|0)&1;a[d>>0]=N;a:do if((ml(b)|0)>>>0<2)d=0;else {N=c[b>>2]|0;do switch(a[N>>0]|0){case 76:{d=co(hl(b)|0)|0;break a}case 84:{d=Ql(hl(b)|0)|0;break a}case 102:{switch((jl(b,1)|0)<<24>>24){case 112:{g=7;break}case 76:{if((((jl(b,2)|0)<<24>>24)+-48|0)>>>0<10)g=7;else g=8;break}default:g=8;}if((g|0)==7){d=So(hl(b)|0)|0;break a}else if((g|0)==8){d=To(hl(b)|0)|0;break a}break}case 97:switch(a[N+1>>0]|0){case 97:{c[b>>2]=N+2;d=hl(b)|0;fl(y,12719);c[T>>2]=c[y>>2];c[T+4>>2]=c[y+4>>2];d=Uo(d,T)|0;break a}case 100:{c[b>>2]=N+2;d=hl(b)|0;fl(I,12717);c[T>>2]=c[I>>2];c[T+4>>2]=c[I+4>>2];d=Vo(d,T)|0;break a}case 110:{c[b>>2]=N+2;d=hl(b)|0;fl(O,12717);c[T>>2]=c[O>>2];c[T+4>>2]=c[O+4>>2];d=Uo(d,T)|0;break a}case 78:{c[b>>2]=N+2;d=hl(b)|0;fl(P,13431);c[T>>2]=c[P>>2];c[T+4>>2]=c[P+4>>2];d=Uo(d,T)|0;break a}case 83:{c[b>>2]=N+2;d=hl(b)|0;fl(Q,13434);c[T>>2]=c[Q>>2];c[T+4>>2]=c[Q+4>>2];d=Uo(d,T)|0;break a}case 116:{c[b>>2]=N+2;U=rl(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=Wo(b,13436,T)|0;break a}case 122:{c[b>>2]=N+2;U=ao(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=Wo(b,13436,T)|0;break a}default:{d=0;break a}}case 99:switch(a[N+1>>0]|0){case 99:{c[b>>2]=N+2;d=hl(b)|0;S=rl(d)|0;c[T>>2]=S;if(!S)d=0;else {S=ao(d)|0;c[U>>2]=S;if(!S)d=0;else d=Xo(b,T,U)|0;}break a}case 108:{c[b>>2]=N+2;d=hl(b)|0;S=ao(d)|0;c[T>>2]=S;do if(S){e=b+8|0;f=Zl(e)|0;while(1){if(nl(b,69)|0){g=33;break}S=ao(d)|0;c[U>>2]=S;if(!S){g=31;break}Yl(e,U);}if((g|0)==31){d=0;break}else if((g|0)==33){sn(U,b,f);d=Yo(b,T,U)|0;break}}else d=0;while(0);break a}case 109:{c[b>>2]=N+2;d=hl(b)|0;fl(R,13446);c[T>>2]=c[R>>2];c[T+4>>2]=c[R+4>>2];d=Uo(d,T)|0;break a}case 111:{c[b>>2]=N+2;d=hl(b)|0;fl(e,13448);c[T>>2]=c[e>>2];c[T+4>>2]=c[e+4>>2];d=Vo(d,T)|0;break a}case 118:{d=Zo(hl(b)|0)|0;break a}default:{d=0;break a}}case 100:switch(a[N+1>>0]|0){case 97:{c[b>>2]=N+2;S=ao(hl(b)|0)|0;c[T>>2]=S;if(!S)d=0;else {a[U>>0]=1;d=_o(b,T,d,U)|0;}break a}case 99:{c[b>>2]=N+2;d=hl(b)|0;S=rl(d)|0;c[T>>2]=S;if(!S)d=0;else {S=ao(d)|0;c[U>>2]=S;if(!S)d=0;else d=$o(b,T,U)|0;}break a}case 101:{c[b>>2]=N+2;d=hl(b)|0;fl(f,12784);c[T>>2]=c[f>>2];c[T+4>>2]=c[f+4>>2];d=Vo(d,T)|0;break a}case 108:{c[b>>2]=N+2;S=ao(hl(b)|0)|0;c[T>>2]=S;if(!S)d=0;else {a[U>>0]=0;d=_o(b,T,d,U)|0;}break a}case 110:{d=ap(hl(b)|0)|0;break a}case 115:{c[b>>2]=N+2;d=hl(b)|0;S=ao(d)|0;c[T>>2]=S;if(!S)d=0;else {S=ao(d)|0;c[U>>2]=S;if(!S)d=0;else d=bp(b,T,13450,U)|0;}break a}case 116:{c[b>>2]=N+2;d=hl(b)|0;S=ao(d)|0;c[T>>2]=S;if(!S)d=0;else {S=ao(d)|0;c[U>>2]=S;if(!S)d=0;else d=cp(b,T,U)|0;}break a}case 118:{c[b>>2]=N+2;d=hl(b)|0;fl(g,13453);c[T>>2]=c[g>>2];c[T+4>>2]=c[g+4>>2];d=Uo(d,T)|0;break a}case 86:{c[b>>2]=N+2;d=hl(b)|0;fl(h,13455);c[T>>2]=c[h>>2];c[T+4>>2]=c[h+4>>2];d=Uo(d,T)|0;break a}default:{d=0;break a}}case 101:switch(a[N+1>>0]|0){case 111:{c[b>>2]=N+2;d=hl(b)|0;fl(i,13458);c[T>>2]=c[i>>2];c[T+4>>2]=c[i+4>>2];d=Uo(d,T)|0;break a}case 79:{c[b>>2]=N+2;d=hl(b)|0;fl(j,13460);c[T>>2]=c[j>>2];c[T+4>>2]=c[j+4>>2];d=Uo(d,T)|0;break a}case 113:{c[b>>2]=N+2;d=hl(b)|0;fl(k,13463);c[T>>2]=c[k>>2];c[T+4>>2]=c[k+4>>2];d=Uo(d,T)|0;break a}default:{d=0;break a}}case 103:switch(a[N+1>>0]|0){case 101:{c[b>>2]=N+2;d=hl(b)|0;fl(l,13466);c[T>>2]=c[l>>2];c[T+4>>2]=c[l+4>>2];d=Uo(d,T)|0;break a}case 116:{c[b>>2]=N+2;d=hl(b)|0;fl(m,12790);c[T>>2]=c[m>>2];c[T+4>>2]=c[m+4>>2];d=Uo(d,T)|0;break a}default:{d=0;break a}}case 105:{switch(a[N+1>>0]|0){case 120:{c[b>>2]=N+2;d=hl(b)|0;S=ao(d)|0;c[T>>2]=S;if(!S)d=0;else {S=ao(d)|0;c[U>>2]=S;if(!S)d=0;else d=dp(b,T,U)|0;}break a}case 108:break;default:{d=0;break a}}c[b>>2]=N+2;d=b+8|0;e=Zl(d)|0;while(1){if(nl(b,69)|0){g=82;break}S=ep(hl(b)|0)|0;c[T>>2]=S;if(!S){g=81;break}Yl(d,T);}if((g|0)==81){d=0;break a}else if((g|0)==82){sn(U,b,e);d=fp(b,T,U)|0;break a}break}case 108:switch(a[N+1>>0]|0){case 101:{c[b>>2]=N+2;d=hl(b)|0;fl(n,13469);c[T>>2]=c[n>>2];c[T+4>>2]=c[n+4>>2];d=Uo(d,T)|0;break a}case 115:{c[b>>2]=N+2;d=hl(b)|0;fl(o,13472);c[T>>2]=c[o>>2];c[T+4>>2]=c[o+4>>2];d=Uo(d,T)|0;break a}case 83:{c[b>>2]=N+2;d=hl(b)|0;fl(p,13475);c[T>>2]=c[p>>2];c[T+4>>2]=c[p+4>>2];d=Uo(d,T)|0;break a}case 116:{c[b>>2]=N+2;d=hl(b)|0;fl(q,12897);c[T>>2]=c[q>>2];c[T+4>>2]=c[q+4>>2];d=Uo(d,T)|0;break a}default:{d=0;break a}}case 109:switch(a[N+1>>0]|0){case 105:{c[b>>2]=N+2;d=hl(b)|0;fl(r,13318);c[T>>2]=c[r>>2];c[T+4>>2]=c[r+4>>2];d=Uo(d,T)|0;break a}case 73:{c[b>>2]=N+2;d=hl(b)|0;fl(s,13479);c[T>>2]=c[s>>2];c[T+4>>2]=c[s+4>>2];d=Uo(d,T)|0;break a}case 108:{c[b>>2]=N+2;d=hl(b)|0;fl(t,12784);c[T>>2]=c[t>>2];c[T+4>>2]=c[t+4>>2];d=Uo(d,T)|0;break a}case 76:{c[b>>2]=N+2;d=hl(b)|0;fl(u,13482);c[T>>2]=c[u>>2];c[T+4>>2]=c[u+4>>2];d=Uo(d,T)|0;break a}case 109:{c[b>>2]=N+2;if(nl(b,95)|0){d=hl(b)|0;fl(v,13485);c[T>>2]=c[v>>2];c[T+4>>2]=c[v+4>>2];d=Vo(d,T)|0;break a}U=ao(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=gp(b,T,13485)|0;break a}default:{d=0;break a}}case 110:switch(a[N+1>>0]|0){case 119:case 97:{d=hp(hl(b)|0)|0;break a}case 101:{c[b>>2]=N+2;d=hl(b)|0;fl(w,13488);c[T>>2]=c[w>>2];c[T+4>>2]=c[w+4>>2];d=Uo(d,T)|0;break a}case 103:{c[b>>2]=N+2;d=hl(b)|0;fl(x,13318);c[T>>2]=c[x>>2];c[T+4>>2]=c[x+4>>2];d=Vo(d,T)|0;break a}case 116:{c[b>>2]=N+2;d=hl(b)|0;fl(z,13491);c[T>>2]=c[z>>2];c[T+4>>2]=c[z+4>>2];d=Vo(d,T)|0;break a}case 120:{c[b>>2]=N+2;U=ao(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=ip(b,T)|0;break a}default:{d=0;break a}}case 111:switch(a[N+1>>0]|0){case 110:{d=ap(hl(b)|0)|0;break a}case 111:{c[b>>2]=N+2;d=hl(b)|0;fl(A,13493);c[T>>2]=c[A>>2];c[T+4>>2]=c[A+4>>2];d=Uo(d,T)|0;break a}case 114:{c[b>>2]=N+2;d=hl(b)|0;fl(B,13496);c[T>>2]=c[B>>2];c[T+4>>2]=c[B+4>>2];d=Uo(d,T)|0;break a}case 82:{c[b>>2]=N+2;d=hl(b)|0;fl(C,13498);c[T>>2]=c[C>>2];c[T+4>>2]=c[C+4>>2];d=Uo(d,T)|0;break a}default:{d=0;break a}}case 112:switch(a[N+1>>0]|0){case 109:{c[b>>2]=N+2;d=hl(b)|0;fl(D,13501);c[T>>2]=c[D>>2];c[T+4>>2]=c[D+4>>2];d=Uo(d,T)|0;break a}case 108:{c[b>>2]=N+2;d=hl(b)|0;fl(E,13505);c[T>>2]=c[E>>2];c[T+4>>2]=c[E+4>>2];d=Uo(d,T)|0;break a}case 76:{c[b>>2]=N+2;d=hl(b)|0;fl(F,13507);c[T>>2]=c[F>>2];c[T+4>>2]=c[F+4>>2];d=Uo(d,T)|0;break a}case 112:{c[b>>2]=N+2;if(nl(b,95)|0){d=hl(b)|0;fl(G,13510);c[T>>2]=c[G>>2];c[T+4>>2]=c[G+4>>2];d=Vo(d,T)|0;break a}U=ao(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=gp(b,T,13510)|0;break a}case 115:{c[b>>2]=N+2;d=hl(b)|0;fl(H,13505);c[T>>2]=c[H>>2];c[T+4>>2]=c[H+4>>2];d=Vo(d,T)|0;break a}case 116:{c[b>>2]=N+2;d=hl(b)|0;S=ao(d)|0;c[T>>2]=S;if(!S)d=0;else {S=ao(d)|0;c[U>>2]=S;if(!S)d=0;else d=bp(b,T,13513,U)|0;}break a}default:{d=0;break a}}case 113:{if((a[N+1>>0]|0)!=117){d=0;break a}c[b>>2]=N+2;d=hl(b)|0;R=ao(d)|0;c[T>>2]=R;if(!R)d=0;else {R=ao(d)|0;c[U>>2]=R;if(!R)d=0;else {R=ao(d)|0;c[S>>2]=R;if(!R)d=0;else d=jp(b,T,U,S)|0;}}break a}case 114:switch(a[N+1>>0]|0){case 99:{c[b>>2]=N+2;d=hl(b)|0;S=rl(d)|0;c[T>>2]=S;if(!S)d=0;else {S=ao(d)|0;c[U>>2]=S;if(!S)d=0;else d=kp(b,T,U)|0;}break a}case 109:{c[b>>2]=N+2;d=hl(b)|0;fl(J,13516);c[T>>2]=c[J>>2];c[T+4>>2]=c[J+4>>2];d=Uo(d,T)|0;break a}case 77:{c[b>>2]=N+2;d=hl(b)|0;fl(K,13518);c[T>>2]=c[K>>2];c[T+4>>2]=c[K+4>>2];d=Uo(d,T)|0;break a}case 115:{c[b>>2]=N+2;d=hl(b)|0;fl(L,13521);c[T>>2]=c[L>>2];c[T+4>>2]=c[L+4>>2];d=Uo(d,T)|0;break a}case 83:{c[b>>2]=N+2;d=hl(b)|0;fl(M,13524);c[T>>2]=c[M>>2];c[T+4>>2]=c[M+4>>2];d=Uo(d,T)|0;break a}default:{d=0;break a}}case 115:{switch(a[N+1>>0]|0){case 99:{c[b>>2]=N+2;d=hl(b)|0;S=rl(d)|0;c[T>>2]=S;if(!S)d=0;else {S=ao(d)|0;c[U>>2]=S;if(!S)d=0;else d=lp(b,T,U)|0;}break a}case 112:{c[b>>2]=N+2;U=ao(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=Ml(b,T)|0;break a}case 114:{d=ap(hl(b)|0)|0;break a}case 116:{c[b>>2]=N+2;U=rl(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=mp(b,13528,T)|0;break a}case 122:{c[b>>2]=N+2;U=ao(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=mp(b,13528,T)|0;break a}case 90:{c[b>>2]=N+2;switch((jl(b,0)|0)<<24>>24){case 84:{U=Ql(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=np(b,T)|0;break a}case 102:{U=So(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=op(b,T)|0;break a}default:{d=0;break a}}}case 80:{c[b>>2]=N+2;d=b+8|0;e=Zl(d)|0;while(1){if(nl(b,69)|0){g=172;break}S=nn(hl(b)|0)|0;c[T>>2]=S;if(!S){g=171;break}Yl(d,T);}if((g|0)==171){d=0;break a}else if((g|0)==172){sn(U,b,e);d=pp(b,U)|0;c[T>>2]=d;d=op(b,T)|0;break a}break}default:{d=0;break a}}break}case 116:switch(a[N+1>>0]|0){case 101:{c[b>>2]=N+2;U=ao(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=mp(b,13537,T)|0;break a}case 105:{c[b>>2]=N+2;U=rl(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=mp(b,13537,T)|0;break a}case 108:{c[b>>2]=N+2;d=hl(b)|0;S=rl(d)|0;c[T>>2]=S;do if(S){e=b+8|0;f=Zl(e)|0;while(1){if(nl(b,69)|0){g=186;break}S=ep(d)|0;c[U>>2]=S;if(!S){g=185;break}Yl(e,U);}if((g|0)==185){d=0;break}else if((g|0)==186){sn(U,b,f);d=qp(b,T,U)|0;break}}else d=0;while(0);break a}case 114:{c[b>>2]=N+2;d=yl(b,13546)|0;break a}case 119:{c[b>>2]=N+2;U=ao(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=rp(b,T)|0;break a}default:{d=0;break a}}case 57:case 56:case 55:case 54:case 53:case 52:case 51:case 50:case 49:{d=ap(hl(b)|0)|0;break a}default:{d=0;break a}}while(0)}while(0);Eb=V;return d|0}function bo(a,b){a=a|0;b=b|0;return Oo(a+368|0,b)|0}function co(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;v=Eb;Eb=Eb+160|0;t=v+144|0;b=v+136|0;l=v+128|0;m=v+120|0;n=v+112|0;o=v+104|0;p=v+96|0;q=v+88|0;r=v+80|0;s=v+72|0;d=v+64|0;e=v+56|0;f=v+48|0;g=v+40|0;h=v+32|0;i=v+24|0;j=v+16|0;k=v+8|0;u=v;a:do if(nl(a,76)|0)do switch((jl(a,0)|0)<<24>>24|0){case 84:{b=0;break a}case 119:{c[a>>2]=(c[a>>2]|0)+1;a=hl(a)|0;fl(b,13001);c[t>>2]=c[b>>2];c[t+4>>2]=c[b+4>>2];b=eo(a,t)|0;break a}case 98:{fl(l,13009);c[t>>2]=c[l>>2];c[t+4>>2]=c[l+4>>2];if(gl(a,t)|0){c[t>>2]=0;b=fo(a,t)|0;break a}fl(m,13013);c[t>>2]=c[m>>2];c[t+4>>2]=c[m+4>>2];if(!(gl(a,t)|0)){b=0;break a}c[t>>2]=1;b=fo(a,t)|0;break a}case 99:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(n,12091);c[t>>2]=c[n>>2];c[t+4>>2]=c[n+4>>2];b=eo(b,t)|0;break a}case 97:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(o,12096);c[t>>2]=c[o>>2];c[t+4>>2]=c[o+4>>2];b=eo(b,t)|0;break a}case 104:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(p,12108);c[t>>2]=c[p>>2];c[t+4>>2]=c[p+4>>2];b=eo(b,t)|0;break a}case 115:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(q,12122);c[t>>2]=c[q>>2];c[t+4>>2]=c[q+4>>2];b=eo(b,t)|0;break a}case 116:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(r,12128);c[t>>2]=c[r>>2];c[t+4>>2]=c[r+4>>2];b=eo(b,t)|0;break a}case 105:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(s,18757);c[t>>2]=c[s>>2];c[t+4>>2]=c[s+4>>2];b=eo(b,t)|0;break a}case 106:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(d,13017);c[t>>2]=c[d>>2];c[t+4>>2]=c[d+4>>2];b=eo(b,t)|0;break a}case 108:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(e,13019);c[t>>2]=c[e>>2];c[t+4>>2]=c[e+4>>2];b=eo(b,t)|0;break a}case 109:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(f,13021);c[t>>2]=c[f>>2];c[t+4>>2]=c[f+4>>2];b=eo(b,t)|0;break a}case 120:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(g,13024);c[t>>2]=c[g>>2];c[t+4>>2]=c[g+4>>2];b=eo(b,t)|0;break a}case 121:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(h,13027);c[t>>2]=c[h>>2];c[t+4>>2]=c[h+4>>2];b=eo(b,t)|0;break a}case 110:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(i,12189);c[t>>2]=c[i>>2];c[t+4>>2]=c[i+4>>2];b=eo(b,t)|0;break a}case 111:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(j,12198);c[t>>2]=c[j>>2];c[t+4>>2]=c[j+4>>2];b=eo(b,t)|0;break a}case 102:{c[a>>2]=(c[a>>2]|0)+1;b=go(hl(a)|0)|0;break a}case 100:{c[a>>2]=(c[a>>2]|0)+1;b=ho(hl(a)|0)|0;break a}case 101:{c[a>>2]=(c[a>>2]|0)+1;b=io(hl(a)|0)|0;break a}case 95:{fl(k,12025);c[t>>2]=c[k>>2];c[t+4>>2]=c[k+4>>2];if(!(gl(a,t)|0)){b=0;break a}b=il(hl(a)|0)|0;if(b|0?nl(a,69)|0:0)break a;b=0;break a}default:{b=rl(hl(a)|0)|0;c[t>>2]=b;if(!b)b=0;else {ol(u,a,0);s=pl(u)|0;d=nl(a,69)|0;if(!s)if(d)b=jo(a,t,u)|0;else b=0;else b=d?b:0;}break a}}while(0);else b=0;while(0);Eb=v;return b|0}function eo(a,b){a=a|0;b=b|0;var c=0,d=0;d=Eb;Eb=Eb+16|0;c=d;ol(c,a,1);if(!(pl(c)|0)?nl(a,69)|0:0)a=Ho(a,b,c)|0;else a=0;Eb=d;return a|0}function fo(a,b){a=a|0;b=b|0;return Do(a+368|0,b)|0}function go(b){b=b|0;var d=0,e=0,f=0,g=0,h=0;h=Eb;Eb=Eb+16|0;e=h;if((ml(b)|0)>>>0<9)d=0;else {d=c[b>>2]|0;kl(e,d,d+8|0);d=wm(e)|0;f=en(e)|0;while(1){if((d|0)==(f|0)){g=5;break}if(!($h(a[d>>0]|0)|0)){d=0;break}else d=d+1|0;}if((g|0)==5){c[b>>2]=(c[b>>2]|0)+8;if(nl(b,69)|0)d=yo(b,e)|0;else d=0;}}Eb=h;return d|0}function ho(b){b=b|0;var d=0,e=0,f=0,g=0,h=0;h=Eb;Eb=Eb+16|0;e=h;if((ml(b)|0)>>>0<17)d=0;else {d=c[b>>2]|0;kl(e,d,d+16|0);d=wm(e)|0;f=en(e)|0;while(1){if((d|0)==(f|0)){g=5;break}if(!($h(a[d>>0]|0)|0)){d=0;break}else d=d+1|0;}if((g|0)==5){c[b>>2]=(c[b>>2]|0)+16;if(nl(b,69)|0)d=to(b,e)|0;else d=0;}}Eb=h;return d|0}function io(b){b=b|0;var d=0,e=0,f=0,g=0,h=0;h=Eb;Eb=Eb+16|0;e=h;if((ml(b)|0)>>>0<21)d=0;else {d=c[b>>2]|0;kl(e,d,d+20|0);d=wm(e)|0;f=en(e)|0;while(1){if((d|0)==(f|0)){g=5;break}if(!($h(a[d>>0]|0)|0)){d=0;break}else d=d+1|0;}if((g|0)==5){c[b>>2]=(c[b>>2]|0)+20;if(nl(b,69)|0)d=oo(b,e)|0;else d=0;}}Eb=h;return d|0}function jo(a,b,c){a=a|0;b=b|0;c=c|0;return ko(a+368|0,b,c)|0}function ko(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];lo(a,b,f);Eb=e;return a|0}function lo(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,60,1,1,1);c[a>>2]=4712;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function mo(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+32|0;e=d+24|0;g=d+16|0;h=d+8|0;f=d;fl(g,12715);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);fl(h,12711);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);h=a+12|0;g=c[h+4>>2]|0;a=f;c[a>>2]=c[h>>2];c[a+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function no(a){a=a|0;$j(a);return}function oo(a,b){a=a|0;b=b|0;return po(a+368|0,b)|0}function po(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];qo(a,e);Eb=d;return a|0}function qo(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,64,1,1,1);c[a>>2]=4756;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function ro(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;m=Eb;Eb=Eb+64|0;i=m+48|0;j=m+40|0;k=m;l=m+56|0;h=b+8|0;f=wm(h)|0;if(((en(h)|0)+1-f|0)>>>0>20){h=j+8|0;b=0;e=j;while(1){if((b|0)==20)break;n=a[f+b>>0]|0;o=a[f+(b|1)>>0]|0;a[e>>0]=((o+-48|0)>>>0<10?208:169)+o+(((n+-48|0)>>>0<10?0:9)+n<<4);b=b+2|0;e=e+1|0;}b=h+2|0;e=j;while(1){b=b+-1|0;if(e>>>0>=b>>>0)break;o=a[e>>0]|0;a[e>>0]=a[b>>0]|0;a[b>>0]=o;e=e+1|0;}b=k;e=b+40|0;do{c[b>>2]=0;b=b+4|0;}while((b|0)<(e|0));g[i>>3]=+g[j>>3];kl(l,k,k+(bi(k,40,13083,i)|0)|0);c[i>>2]=c[l>>2];c[i+4>>2]=c[l+4>>2];um(d,i);}Eb=m;return}function so(a){a=a|0;$j(a);return}function to(a,b){a=a|0;b=b|0;return uo(a+368|0,b)|0}function uo(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];vo(a,e);Eb=d;return a|0}function vo(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,63,1,1,1);c[a>>2]=4800;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function wo(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;m=Eb;Eb=Eb+64|0;i=m+40|0;j=m+32|0;k=m;l=m+48|0;f=b+8|0;h=wm(f)|0;if(((en(f)|0)+1-h|0)>>>0>16){b=j+8|0;e=0;f=j;while(1){if((e|0)==16)break;n=a[h+e>>0]|0;o=a[h+(e|1)>>0]|0;a[f>>0]=((o+-48|0)>>>0<10?208:169)+o+(((n+-48|0)>>>0<10?0:9)+n<<4);e=e+2|0;f=f+1|0;}e=j;while(1){b=b+-1|0;if(e>>>0>=b>>>0)break;o=a[e>>0]|0;a[e>>0]=a[b>>0]|0;a[b>>0]=o;e=e+1|0;}c[k>>2]=0;c[k+4>>2]=0;c[k+8>>2]=0;c[k+12>>2]=0;c[k+16>>2]=0;c[k+20>>2]=0;c[k+24>>2]=0;c[k+28>>2]=0;g[i>>3]=+g[j>>3];kl(l,k,k+(bi(k,32,13144,i)|0)|0);c[i>>2]=c[l>>2];c[i+4>>2]=c[l+4>>2];um(d,i);}Eb=m;return}function xo(a){a=a|0;$j(a);return}function yo(a,b){a=a|0;b=b|0;return zo(a+368|0,b)|0}function zo(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Ao(a,e);Eb=d;return a|0}function Ao(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,62,1,1,1);c[a>>2]=4844;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function Bo(b,d){b=b|0;d=d|0;var e=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;n=Eb;Eb=Eb+48|0;j=n+24|0;k=n+40|0;l=n;m=n+32|0;h=b+8|0;i=wm(h)|0;if(((en(h)|0)+1-i|0)>>>0>8){b=k+4|0;e=0;h=k;while(1){if((e|0)==8)break;o=a[i+e>>0]|0;p=a[i+(e|1)>>0]|0;a[h>>0]=((p+-48|0)>>>0<10?208:169)+p+(((o+-48|0)>>>0<10?0:9)+o<<4);e=e+2|0;h=h+1|0;}e=k;while(1){b=b+-1|0;if(e>>>0>=b>>>0)break;p=a[e>>0]|0;a[e>>0]=a[b>>0]|0;a[b>>0]=p;e=e+1|0;}c[l>>2]=0;c[l+4>>2]=0;c[l+8>>2]=0;c[l+12>>2]=0;c[l+16>>2]=0;c[l+20>>2]=0;g[j>>3]=+f[k>>2];kl(m,l,l+(bi(l,24,13203,j)|0)|0);c[j>>2]=c[m>>2];c[j+4>>2]=c[m+4>>2];um(d,j);}Eb=n;return}function Co(a){a=a|0;$j(a);return}function Do(a,b){a=a|0;b=b|0;a=hm(a,12)|0;Eo(a,(c[b>>2]|0)!=0);return a|0}function Eo(b,d){b=b|0;d=d|0;jm(b,59,1,1,1);c[b>>2]=4888;a[b+8>>0]=d&1;return}function Fo(b,d){b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g+8|0;f=g;if(!(a[b+8>>0]|0))fl(f,13268);else fl(f,13263);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(d,e);Eb=g;return}function Go(a){a=a|0;$j(a);return}function Ho(a,b,c){a=a|0;b=b|0;c=c|0;return Io(a+368|0,b,c)|0}function Io(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0;e=Eb;Eb=Eb+32|0;f=e+24|0;g=e+16|0;i=e+8|0;h=e;a=hm(a,24)|0;k=b;b=c[k+4>>2]|0;j=i;c[j>>2]=c[k>>2];c[j+4>>2]=b;j=d;b=c[j+4>>2]|0;d=h;c[d>>2]=c[j>>2];c[d+4>>2]=b;c[g>>2]=c[i>>2];c[g+4>>2]=c[i+4>>2];c[f>>2]=c[h>>2];c[f+4>>2]=c[h+4>>2];Jo(a,g,f);Eb=e;return a|0}function Jo(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;jm(a,61,1,1,1);c[a>>2]=4932;f=b;b=c[f+4>>2]|0;e=a+8|0;c[e>>2]=c[f>>2];c[e+4>>2]=b;e=d;b=c[e+4>>2]|0;d=a+16|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function Ko(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;n=Eb;Eb=Eb+64|0;m=n+56|0;e=n+48|0;f=n+16|0;g=n+40|0;h=n+32|0;i=n+24|0;j=n+8|0;k=n;l=b+8|0;if((vm(l)|0)>>>0>3){fl(e,12715);c[m>>2]=c[e>>2];c[m+4>>2]=c[e+4>>2];um(d,m);p=l;o=c[p+4>>2]|0;e=f;c[e>>2]=c[p>>2];c[e+4>>2]=o;c[m>>2]=c[f>>2];c[m+4>>2]=c[f+4>>2];um(d,m);fl(g,12711);c[m>>2]=c[g>>2];c[m+4>>2]=c[g+4>>2];um(d,m);}b=b+16|0;p=Mo(b)|0;if((a[p>>0]|0)==110){fl(h,13318);c[m>>2]=c[h>>2];c[m+4>>2]=c[h+4>>2];um(d,m);No(i,b,1);c[m>>2]=c[i>>2];c[m+4>>2]=c[i+4>>2];um(d,m);}else {i=b;o=c[i+4>>2]|0;p=j;c[p>>2]=c[i>>2];c[p+4>>2]=o;c[m>>2]=c[j>>2];c[m+4>>2]=c[j+4>>2];um(d,m);}if((vm(l)|0)>>>0<4){o=c[l+4>>2]|0;p=k;c[p>>2]=c[l>>2];c[p+4>>2]=o;c[m>>2]=c[k>>2];c[m+4>>2]=c[k+4>>2];um(d,m);}Eb=n;return}function Lo(a){a=a|0;$j(a);return}function Mo(a){a=a|0;return wm(a)|0}function No(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;e=vm(b)|0;kl(a,(c[b>>2]|0)+(e>>>0>d>>>0?d:e+-1|0)|0,c[b+4>>2]|0);return}function Oo(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Po(a,e);Eb=d;return a|0}function Po(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,28,1,1,1);c[a>>2]=4976;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function Qo(a,b){a=a|0;b=b|0;yn(a+8|0,b);return}function Ro(a){a=a|0;$j(a);return}function So(a){a=a|0;var b=0,d=0,e=0,f=0;e=Eb;Eb=Eb+32|0;b=e+16|0;f=e+8|0;d=e;fl(f,15674);c[b>>2]=c[f>>2];c[b+4>>2]=c[f+4>>2];if(!(gl(a,b)|0)){fl(d,15677);c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];if((gl(a,b)|0?(ol(b,a,0),!(pl(b)|0)):0)?nl(a,112)|0:0){ds(a)|0;ol(b,a,0);if(nl(a,95)|0)b=es(a,b)|0;else b=0;}else b=0;}else {ds(a)|0;ol(b,a,0);if(nl(a,95)|0)b=es(a,b)|0;else b=0;}Eb=e;return b|0}function To(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0;P=Eb;Eb=Eb+288|0;K=P+8|0;L=P+272|0;M=P;x=P+264|0;C=P+256|0;D=P+248|0;E=P+240|0;F=P+232|0;G=P+224|0;H=P+216|0;d=P+208|0;e=P+200|0;f=P+192|0;g=P+184|0;h=P+176|0;i=P+168|0;j=P+160|0;k=P+152|0;l=P+144|0;m=P+136|0;n=P+128|0;o=P+120|0;p=P+112|0;q=P+104|0;r=P+96|0;s=P+88|0;t=P+80|0;u=P+72|0;v=P+64|0;w=P+56|0;y=P+48|0;z=P+40|0;A=P+32|0;B=P+24|0;N=P+16|0;if(nl(b,102)|0){I=jl(b,0)|0;switch(I<<24>>24){case 76:case 108:{O=1;J=4;break}case 82:case 114:{O=0;J=4;break}default:d=0;}if((J|0)==4){a[L>>0]=O;c[b>>2]=(c[b>>2]|0)+1;tm(M);fl(x,15527);c[K>>2]=c[x>>2];c[K+4>>2]=c[x+4>>2];do if(gl(b,K)|0){fl(K,12719);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;}else {fl(C,15530);c[K>>2]=c[C>>2];c[K+4>>2]=c[C+4>>2];if(gl(b,K)|0){fl(K,12717);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(D,15533);c[K>>2]=c[D>>2];c[K+4>>2]=c[D+4>>2];if(gl(b,K)|0){fl(K,13431);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(E,15536);c[K>>2]=c[E>>2];c[K+4>>2]=c[E+4>>2];if(gl(b,K)|0){fl(K,13434);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(F,15539);c[K>>2]=c[F>>2];c[K+4>>2]=c[F+4>>2];if(gl(b,K)|0){fl(K,13446);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(G,15542);c[K>>2]=c[G>>2];c[K+4>>2]=c[G+4>>2];if(gl(b,K)|0){fl(K,13450);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(H,15545);c[K>>2]=c[H>>2];c[K+4>>2]=c[H+4>>2];if(gl(b,K)|0){fl(K,13453);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(d,15548);c[K>>2]=c[d>>2];c[K+4>>2]=c[d+4>>2];if(gl(b,K)|0){fl(K,13455);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(e,15551);c[K>>2]=c[e>>2];c[K+4>>2]=c[e+4>>2];if(gl(b,K)|0){fl(K,13458);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(f,15554);c[K>>2]=c[f>>2];c[K+4>>2]=c[f+4>>2];if(gl(b,K)|0){fl(K,13460);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(g,15557);c[K>>2]=c[g>>2];c[K+4>>2]=c[g+4>>2];if(gl(b,K)|0){fl(K,13463);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(h,15560);c[K>>2]=c[h>>2];c[K+4>>2]=c[h+4>>2];if(gl(b,K)|0){fl(K,13466);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(i,15563);c[K>>2]=c[i>>2];c[K+4>>2]=c[i+4>>2];if(gl(b,K)|0){fl(K,12790);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(j,15566);c[K>>2]=c[j>>2];c[K+4>>2]=c[j+4>>2];if(gl(b,K)|0){fl(K,13469);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(k,15569);c[K>>2]=c[k>>2];c[K+4>>2]=c[k+4>>2];if(gl(b,K)|0){fl(K,13472);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(l,15572);c[K>>2]=c[l>>2];c[K+4>>2]=c[l+4>>2];if(gl(b,K)|0){fl(K,13475);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(m,15575);c[K>>2]=c[m>>2];c[K+4>>2]=c[m+4>>2];if(gl(b,K)|0){fl(K,12897);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(n,15578);c[K>>2]=c[n>>2];c[K+4>>2]=c[n+4>>2];if(gl(b,K)|0){fl(K,13318);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(o,15581);c[K>>2]=c[o>>2];c[K+4>>2]=c[o+4>>2];if(gl(b,K)|0){fl(K,13479);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(p,15584);c[K>>2]=c[p>>2];c[K+4>>2]=c[p+4>>2];if(gl(b,K)|0){fl(K,12784);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(q,15587);c[K>>2]=c[q>>2];c[K+4>>2]=c[q+4>>2];if(gl(b,K)|0){fl(K,13482);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(r,15590);c[K>>2]=c[r>>2];c[K+4>>2]=c[r+4>>2];if(gl(b,K)|0){fl(K,13488);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(s,15593);c[K>>2]=c[s>>2];c[K+4>>2]=c[s+4>>2];if(gl(b,K)|0){fl(K,13493);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(t,15596);c[K>>2]=c[t>>2];c[K+4>>2]=c[t+4>>2];if(gl(b,K)|0){fl(K,13496);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(u,15599);c[K>>2]=c[u>>2];c[K+4>>2]=c[u+4>>2];if(gl(b,K)|0){fl(K,13498);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(v,15602);c[K>>2]=c[v>>2];c[K+4>>2]=c[v+4>>2];if(gl(b,K)|0){fl(K,13505);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(w,15605);c[K>>2]=c[w>>2];c[K+4>>2]=c[w+4>>2];if(gl(b,K)|0){fl(K,13507);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(y,15608);c[K>>2]=c[y>>2];c[K+4>>2]=c[y+4>>2];if(gl(b,K)|0){fl(K,13516);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(z,15611);c[K>>2]=c[z>>2];c[K+4>>2]=c[z+4>>2];if(gl(b,K)|0){fl(K,13518);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(A,15614);c[K>>2]=c[A>>2];c[K+4>>2]=c[A+4>>2];if(gl(b,K)|0){fl(K,13521);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(B,15617);c[K>>2]=c[B>>2];c[K+4>>2]=c[B+4>>2];if(!(gl(b,K)|0)){d=0;break}fl(K,13524);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;}while(0);if((J|0)==66){d=hl(b)|0;J=ao(d)|0;c[K>>2]=J;c[N>>2]=0;e=J;a:do if(!J)d=0;else {switch(I<<24>>24){case 76:case 82:{d=ao(d)|0;c[N>>2]=d;if(!d){d=0;break a}if(O<<24>>24){c[K>>2]=d;c[N>>2]=e;}break}}d=Zr(b,L,M,K,N)|0;}while(0)}}}else d=0;Eb=P;return d|0}function Uo(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;g=Eb;Eb=Eb+16|0;d=g+4|0;e=g;f=hl(a)|0;h=ao(f)|0;c[d>>2]=h;if(!h)a=0;else {h=ao(f)|0;c[e>>2]=h;if(!h)a=0;else a=Ur(a,d,b,e)|0;}Eb=g;return a|0}function Vo(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;e=Eb;Eb=Eb+16|0;d=e;f=ao(hl(a)|0)|0;c[d>>2]=f;if(!f)a=0;else a=Pr(a,b,d)|0;Eb=e;return a|0}function Wo(a,b,c){a=a|0;b=b|0;c=c|0;return Or(a+368|0,b,c,12711)|0}function Xo(a,b,c){a=a|0;b=b|0;c=c|0;return Nr(a+368|0,15416,b,c)|0}function Yo(a,b,c){a=a|0;b=b|0;c=c|0;return Jr(a+368|0,b,c)|0}function Zo(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0;h=Eb;Eb=Eb+32|0;f=h+24|0;e=h+16|0;g=h+8|0;b=h;fl(e,15315);c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];if(gl(a,f)|0){Qm(g,a+360|0,0);d=hl(a)|0;e=rl(d)|0;c[f>>2]=e;Um(g);do if(e){if(!(nl(a,95)|0)){e=ao(d)|0;c[g>>2]=e;if(!e)b=0;else {Cn(b,a,g,g+4|0);b=Dr(a,f,b)|0;}break}b=a+8|0;e=Zl(b)|0;while(1){if(nl(a,69)|0){d=9;break}i=ao(d)|0;c[g>>2]=i;if(!i){d=7;break}Yl(b,g);}if((d|0)==7){b=0;break}else if((d|0)==9){sn(g,a,e);b=Cr(a,f,g)|0;break}}else b=0;while(0)}else b=0;Eb=h;return b|0}function _o(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return yr(a+368|0,b,c,d)|0}function $o(a,b,c){a=a|0;b=b|0;c=c|0;return xr(a+368|0,15244,b,c)|0}function ap(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0;h=Eb;Eb=Eb+48|0;f=h+32|0;g=h+8|0;i=h+24|0;b=h+16|0;d=h;c[g>>2]=0;fl(i,14454);c[f>>2]=c[i>>2];c[f+4>>2]=c[i+4>>2];a:do if(gl(a,f)|0){b=hl(a)|0;i=Rq(b)|0;c[g>>2]=i;if(!i)b=0;else {do if((jl(a,0)|0)<<24>>24==73){i=Rl(b,0)|0;c[f>>2]=i;if(!i){b=0;break a}else {i=Sl(a,g,f)|0;c[g>>2]=i;break}}while(0);while(1){if(nl(a,69)|0)break;i=Sq(b)|0;c[f>>2]=i;if(!i){e=35;break}i=Tq(a,g,f)|0;c[g>>2]=i;}if((e|0)==35){b=0;break}i=Uq(b)|0;c[f>>2]=i;if(!i)b=0;else b=Tq(a,g,f)|0;}}else {fl(b,13428);c[f>>2]=c[b>>2];c[f+4>>2]=c[b+4>>2];e=gl(a,f)|0;fl(d,14458);c[f>>2]=c[d>>2];c[f+4>>2]=c[d+4>>2];if(!(gl(a,f)|0)){b=Uq(hl(a)|0)|0;c[g>>2]=b;if((b|0)==0|e^1)break;b=Vq(a,g)|0;c[g>>2]=b;break}b:do if((((jl(a,0)|0)<<24>>24)+-48|0)>>>0>=10){b=hl(a)|0;i=Rq(b)|0;c[g>>2]=i;if(!i){b=0;break a}if((jl(a,0)|0)<<24>>24==73){i=Rl(b,0)|0;c[f>>2]=i;if(!i){b=0;break a}else {i=Sl(a,g,f)|0;c[g>>2]=i;break}}}else {while(1){b=hl(a)|0;d=Sq(b)|0;c[f>>2]=d;if(!d)break;do if(!(c[g>>2]|0))if(e){i=Vq(a,f)|0;c[g>>2]=i;break}else {c[g>>2]=d;break}else {i=Tq(a,g,f)|0;c[g>>2]=i;}while(0);if(nl(a,69)|0)break b}b=0;break a}while(0);i=Uq(b)|0;c[f>>2]=i;if(!i)b=0;else b=Tq(a,g,f)|0;}while(0);Eb=h;return b|0}function bp(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Qq(a+368|0,b,c,d)|0}function cp(a,b,c){a=a|0;b=b|0;c=c|0;return Mq(a+368|0,b,14405,c)|0}function dp(a,b,c){a=a|0;b=b|0;c=c|0;return Iq(a+368|0,b,c)|0}function ep(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;i=Eb;Eb=Eb+16|0;e=i+8|0;f=i+4|0;g=i;a:do if((jl(b,0)|0)<<24>>24==100)switch((jl(b,1)|0)<<24>>24|0){case 105:{c[b>>2]=(c[b>>2]|0)+2;d=hl(b)|0;j=oq(d)|0;c[e>>2]=j;if(!j)d=0;else {j=ep(d)|0;c[f>>2]=j;if(!j)d=0;else {a[g>>0]=0;d=pq(b,e,f,g)|0;}}break a}case 120:{c[b>>2]=(c[b>>2]|0)+2;d=hl(b)|0;j=ao(d)|0;c[e>>2]=j;if(!j)d=0;else {j=ep(d)|0;c[f>>2]=j;if(!j)d=0;else {a[g>>0]=1;d=pq(b,e,f,g)|0;}}break a}case 88:{c[b>>2]=(c[b>>2]|0)+2;d=hl(b)|0;j=ao(d)|0;c[e>>2]=j;if(!j)d=0;else {j=ao(d)|0;c[f>>2]=j;if(!j)d=0;else {j=ep(d)|0;c[g>>2]=j;if(!j)d=0;else d=qq(b,e,f,g)|0;}}break a}default:{h=20;break a}}else h=20;while(0);if((h|0)==20)d=ao(hl(b)|0)|0;Eb=i;return d|0}function fp(a,b,c){a=a|0;b=b|0;c=c|0;return nq(a+368|0,b,c)|0}function gp(a,b,c){a=a|0;b=b|0;c=c|0;return jq(a+368|0,b,c)|0}function hp(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;m=Eb;Eb=Eb+64|0;g=m+48|0;h=m+57|0;n=m+40|0;i=m+56|0;f=m+32|0;d=m+24|0;j=m+16|0;k=m;e=m+8|0;fl(n,13428);c[g>>2]=c[n>>2];c[g+4>>2]=c[n+4>>2];n=(gl(b,g)|0)&1;a[h>>0]=n;n=(jl(b,1)|0)<<24>>24==97&1;a[i>>0]=n;fl(f,14042);c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];if(!(gl(b,g)|0)?(fl(d,14045),c[g>>2]=c[d>>2],c[g+4>>2]=c[d+4>>2],!(gl(b,g)|0)):0)d=0;else l=3;do if((l|0)==3){f=b+8|0;d=Zl(f)|0;while(1){if(nl(b,95)|0)break;n=ao(hl(b)|0)|0;c[g>>2]=n;if(!n){l=7;break}Yl(f,g);}if((l|0)==7){d=0;break}sn(j,b,d);d=hl(b)|0;n=rl(d)|0;c[k>>2]=n;do if(n){fl(e,14048);c[g>>2]=c[e>>2];c[g+4>>2]=c[e+4>>2];if(!(gl(b,g)|0)){if(!(nl(b,69)|0)){d=0;break}bq(g);d=cq(b,j,k,g,h,i)|0;break}e=Zl(f)|0;while(1){if(nl(b,69)|0){l=15;break}n=ao(d)|0;c[g>>2]=n;if(!n){l=13;break}Yl(f,g);}if((l|0)==13){d=0;break}else if((l|0)==15){sn(g,b,e);d=aq(b,j,k,g,h,i)|0;break}}else d=0;while(0)}while(0);Eb=m;return d|0}function ip(a,b){a=a|0;b=b|0;return $p(a+368|0,14031,b,12711)|0}function jp(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Xp(a+368|0,b,c,d)|0}function kp(a,b,c){a=a|0;b=b|0;c=c|0;return Wp(a+368|0,13950,b,c)|0}function lp(a,b,c){a=a|0;b=b|0;c=c|0;return Sp(a+368|0,13891,b,c)|0}function mp(a,b,c){a=a|0;b=b|0;c=c|0;return Rp(a+368|0,b,c,12711)|0}function np(a,b){a=a|0;b=b|0;return Ip(a+368|0,b)|0}function op(a,b){a=a|0;b=b|0;return Ep(a+368|0,13703,b,12711)|0}function pp(a,b){a=a|0;b=b|0;return Ap(a+368|0,b)|0}function qp(a,b,c){a=a|0;b=b|0;c=c|0;return wp(a+368|0,b,c)|0}function rp(a,b){a=a|0;b=b|0;return sp(a+368|0,b)|0}function sp(a,b){a=a|0;b=b|0;a=hm(a,12)|0;tp(a,c[b>>2]|0);return a|0}function tp(a,b){a=a|0;b=b|0;jm(a,58,1,1,1);c[a>>2]=5020;c[a+8>>2]=b;return}function up(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;fl(f,13552);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);Eb=d;return}function vp(a){a=a|0;$j(a);return}function wp(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];xp(a,b,f);Eb=e;return a|0}function xp(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,56,1,1,1);c[a>>2]=5064;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function yp(a,b){a=a|0;b=b|0;var d=0;d=c[a+8>>2]|0;if(d|0)Pk(d,b);Qk(b,123);yn(a+12|0,b);Qk(b,125);return}function zp(a){a=a|0;$j(a);return}function Ap(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Bp(a,e);Eb=d;return a|0}function Bp(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,0,1,1,1);c[a>>2]=5108;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function Cp(a,b){a=a|0;b=b|0;yn(a+8|0,b);return}function Dp(a){a=a|0;$j(a);return}function Ep(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0;f=Eb;Eb=Eb+32|0;g=f+24|0;h=f+16|0;j=f+8|0;i=f;a=hm(a,28)|0;fl(j,b);d=c[d>>2]|0;fl(i,e);c[h>>2]=c[j>>2];c[h+4>>2]=c[j+4>>2];c[g>>2]=c[i>>2];c[g+4>>2]=c[i+4>>2];Fp(a,h,d,g);Eb=f;return a|0}function Fp(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;jm(a,47,1,1,1);c[a>>2]=5152;g=b;f=c[g+4>>2]|0;b=a+8|0;c[b>>2]=c[g>>2];c[b+4>>2]=f;c[a+16>>2]=d;b=e;d=c[b+4>>2]|0;e=a+20|0;c[e>>2]=c[b>>2];c[e+4>>2]=d;return}function Gp(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;d=Eb;Eb=Eb+32|0;e=d+16|0;h=d+8|0;f=d;j=a+8|0;i=c[j+4>>2]|0;g=h;c[g>>2]=c[j>>2];c[g+4>>2]=i;c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);Pk(c[a+16>>2]|0,b);h=a+20|0;g=c[h+4>>2]|0;a=f;c[a>>2]=c[h>>2];c[a+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Hp(a){a=a|0;$j(a);return}function Ip(a,b){a=a|0;b=b|0;a=hm(a,12)|0;Jp(a,c[b>>2]|0);return a|0}function Jp(a,b){a=a|0;b=b|0;jm(a,49,1,1,1);c[a>>2]=5196;c[a+8>>2]=b;return}function Kp(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+48|0;e=d+32|0;h=d+24|0;g=d+8|0;f=d;fl(h,13765);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);Mp(g,c[a+8>>2]|0);Np(g,b);fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Lp(a){a=a|0;$j(a);return}function Mp(a,b){a=a|0;b=b|0;jm(a,29,1,1,1);c[a>>2]=5240;c[a+8>>2]=b;return}function Np(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;m=Eb;Eb=Eb+64|0;h=m+48|0;i=m+32|0;j=m+8|0;e=m+24|0;k=m;l=b+12|0;Op(i,l);d=b+16|0;Op(j,d);f=Rk(b)|0;g=a+8|0;Pk(c[g>>2]|0,b);d=c[d>>2]|0;a:do switch(d|0){case -1:{fl(e,12245);c[h>>2]=c[e>>2];c[h+4>>2]=c[e+4>>2];um(b,h);break}case 0:{An(b,f);break}default:{a=1;while(1){if(a>>>0>=d>>>0)break a;fl(k,12899);c[h>>2]=c[k>>2];c[h+4>>2]=c[k+4>>2];um(b,h);c[l>>2]=a;Pk(c[g>>2]|0,b);a=a+1|0;}}}while(0);Pp(j);Pp(i);Eb=m;return}function Op(b,d){b=b|0;d=d|0;c[b>>2]=d;c[b+4>>2]=c[d>>2];a[b+8>>0]=1;c[d>>2]=-1;return}function Pp(b){b=b|0;if(a[b+8>>0]|0)c[c[b>>2]>>2]=c[b+4>>2];return}function Qp(a){a=a|0;$j(a);return}function Rp(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0;f=Eb;Eb=Eb+32|0;g=f+24|0;h=f+16|0;j=f+8|0;i=f;a=hm(a,28)|0;fl(j,b);d=c[d>>2]|0;fl(i,e);c[h>>2]=c[j>>2];c[h+4>>2]=c[j+4>>2];c[g>>2]=c[i>>2];c[g+4>>2]=c[i+4>>2];Fp(a,h,d,g);Eb=f;return a|0}function Sp(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;f=Eb;Eb=Eb+16|0;g=f+8|0;h=f;a=hm(a,24)|0;fl(h,b);d=c[d>>2]|0;e=c[e>>2]|0;c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];Tp(a,g,d,e);Eb=f;return a|0}function Tp(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;jm(a,48,1,1,1);c[a>>2]=5284;g=b;f=c[g+4>>2]|0;b=a+8|0;c[b>>2]=c[g>>2];c[b+4>>2]=f;c[a+16>>2]=d;c[a+20>>2]=e;return}function Up(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;d=Eb;Eb=Eb+48|0;e=d+32|0;i=d;h=d+24|0;g=d+16|0;f=d+8|0;l=a+8|0;k=c[l+4>>2]|0;j=i;c[j>>2]=c[l>>2];c[j+4>>2]=k;c[e>>2]=c[i>>2];c[e+4>>2]=c[i+4>>2];um(b,e);fl(h,12897);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);h=c[a+16>>2]|0;Xb[c[(c[h>>2]|0)+16>>2]&127](h,b);fl(g,13903);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);a=c[a+20>>2]|0;Xb[c[(c[a>>2]|0)+16>>2]&127](a,b);fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Vp(a){a=a|0;$j(a);return}function Wp(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;f=Eb;Eb=Eb+16|0;g=f+8|0;h=f;a=hm(a,24)|0;fl(h,b);d=c[d>>2]|0;e=c[e>>2]|0;c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];Tp(a,g,d,e);Eb=f;return a|0}function Xp(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;a=hm(a,20)|0;Yp(a,c[b>>2]|0,c[d>>2]|0,c[e>>2]|0);return a|0}function Yp(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;jm(a,45,1,1,1);c[a>>2]=5328;c[a+8>>2]=b;c[a+12>>2]=d;c[a+16>>2]=e;return}function Zp(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;d=Eb;Eb=Eb+48|0;e=d+32|0;i=d+24|0;h=d+16|0;g=d+8|0;f=d;fl(i,12715);c[e>>2]=c[i>>2];c[e+4>>2]=c[i+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);fl(h,13967);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);Pk(c[a+12>>2]|0,b);fl(g,13973);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);Pk(c[a+16>>2]|0,b);fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function _p(a){a=a|0;$j(a);return}function $p(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0;f=Eb;Eb=Eb+32|0;g=f+24|0;h=f+16|0;j=f+8|0;i=f;a=hm(a,28)|0;fl(j,b);d=c[d>>2]|0;fl(i,e);c[h>>2]=c[j>>2];c[h+4>>2]=c[j+4>>2];c[g>>2]=c[i>>2];c[g+4>>2]=c[i+4>>2];Fp(a,h,d,g);Eb=f;return a|0}function aq(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;return iq(a+368|0,b,c,d,e,f)|0}function bq(a){a=a|0;c[a>>2]=0;c[a+4>>2]=0;return}function cq(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;return dq(a+368|0,b,c,d,e,f)|0}function dq(b,d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0,k=0,l=0,m=0,n=0,o=0;i=Eb;Eb=Eb+32|0;j=i+24|0;k=i+16|0;m=i+8|0;l=i;b=hm(b,32)|0;o=d;d=c[o+4>>2]|0;n=m;c[n>>2]=c[o>>2];c[n+4>>2]=d;e=c[e>>2]|0;n=f;d=c[n+4>>2]|0;f=l;c[f>>2]=c[n>>2];c[f+4>>2]=d;g=(a[g>>0]|0)!=0;h=(a[h>>0]|0)!=0;c[k>>2]=c[m>>2];c[k+4>>2]=c[m+4>>2];c[j>>2]=c[l>>2];c[j+4>>2]=c[l+4>>2];eq(b,k,e,j,g,h);Eb=i;return b|0}function eq(b,d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0;jm(b,51,1,1,1);c[b>>2]=5372;j=d;i=c[j+4>>2]|0;d=b+8|0;c[d>>2]=c[j>>2];c[d+4>>2]=i;c[b+16>>2]=e;d=f;e=c[d+4>>2]|0;f=b+20|0;c[f>>2]=c[d>>2];c[f+4>>2]=e;a[b+28>>0]=g&1;a[b+29>>0]=h&1;return}function fq(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;m=Eb;Eb=Eb+64|0;j=m+56|0;e=m+48|0;f=m+40|0;g=m+32|0;h=m+24|0;i=m+16|0;k=m+8|0;l=m;if(a[b+28>>0]|0){fl(e,14051);c[j>>2]=c[e>>2];c[j+4>>2]=c[e+4>>2];um(d,j);}fl(f,14063);c[j>>2]=c[f>>2];c[j+4>>2]=c[f+4>>2];um(d,j);if(a[b+29>>0]|0){fl(g,14067);c[j>>2]=c[g>>2];c[j+4>>2]=c[g+4>>2];um(d,j);}Qk(d,32);e=b+8|0;if(!(hq(e)|0)){fl(h,12715);c[j>>2]=c[h>>2];c[j+4>>2]=c[h+4>>2];um(d,j);yn(e,d);fl(i,12711);c[j>>2]=c[i>>2];c[j+4>>2]=c[i+4>>2];um(d,j);}Pk(c[b+16>>2]|0,d);e=b+20|0;if(!(hq(e)|0)){fl(k,12715);c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];um(d,j);yn(e,d);fl(l,12711);c[j>>2]=c[l>>2];c[j+4>>2]=c[l+4>>2];um(d,j);}Eb=m;return}function gq(a){a=a|0;$j(a);return}function hq(a){a=a|0;return (c[a+4>>2]|0)==0|0}function iq(b,d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0,k=0,l=0,m=0,n=0,o=0;i=Eb;Eb=Eb+32|0;j=i+24|0;k=i+16|0;m=i+8|0;l=i;b=hm(b,32)|0;o=d;d=c[o+4>>2]|0;n=m;c[n>>2]=c[o>>2];c[n+4>>2]=d;e=c[e>>2]|0;n=f;d=c[n+4>>2]|0;f=l;c[f>>2]=c[n>>2];c[f+4>>2]=d;g=(a[g>>0]|0)!=0;h=(a[h>>0]|0)!=0;c[k>>2]=c[m>>2];c[k+4>>2]=c[m+4>>2];c[j>>2]=c[l>>2];c[j+4>>2]=c[l+4>>2];eq(b,k,e,j,g,h);Eb=i;return b|0}function jq(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;fl(g,d);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];kq(a,b,f);Eb=e;return a|0}function kq(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,44,1,1,1);c[a>>2]=5416;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function lq(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+32|0;e=d+24|0;g=d+16|0;h=d+8|0;f=d;fl(g,12715);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);fl(h,12711);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);h=a+12|0;g=c[h+4>>2]|0;a=f;c[a>>2]=c[h>>2];c[a+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function mq(a){a=a|0;$j(a);return}function nq(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;b=hm(a,20)|0;h=d;a=c[h+4>>2]|0;d=g;c[d>>2]=c[h>>2];c[d+4>>2]=a;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];xp(b,0,f);Eb=e;return b|0}function oq(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0;h=Eb;Eb=Eb+32|0;b=h+24|0;d=h+16|0;e=h+8|0;f=h;c[d>>2]=0;if(!(zq(a,d)|0)?(i=ml(a)|0,g=c[d>>2]|0,(g+-1|0)>>>0<i>>>0):0){i=c[a>>2]|0;kl(e,i,i+g|0);c[a>>2]=(c[a>>2]|0)+g;fl(f,14270);c[b>>2]=c[f>>2];c[b+4>>2]=c[f+4>>2];if(Aq(e,b)|0)b=Bq(a)|0;else b=Jl(a,e)|0;}else b=0;Eb=h;return b|0}function pq(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return vq(a+368|0,b,c,d)|0}function qq(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return rq(a+368|0,b,c,d)|0}function rq(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;a=hm(a,20)|0;sq(a,c[b>>2]|0,c[d>>2]|0,c[e>>2]|0);return a|0}function sq(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;jm(a,66,1,1,1);c[a>>2]=5460;c[a+8>>2]=b;c[a+12>>2]=d;c[a+16>>2]=e;return}function tq(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;g=Eb;Eb=Eb+32|0;e=g+16|0;d=g+8|0;f=g;Qk(b,91);Pk(c[a+8>>2]|0,b);fl(d,14161);c[e>>2]=c[d>>2];c[e+4>>2]=c[d+4>>2];um(b,e);Pk(c[a+12>>2]|0,b);Qk(b,93);d=a+16|0;a=c[d>>2]|0;if(((Vm(a)|0)+-65&255)>=2){fl(f,14167);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);a=c[d>>2]|0;}Pk(a,b);Eb=g;return}function uq(a){a=a|0;$j(a);return}function vq(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;b=hm(b,20)|0;wq(b,c[d>>2]|0,c[e>>2]|0,(a[f>>0]|0)!=0);return b|0}function wq(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;jm(b,65,1,1,1);c[b>>2]=5504;c[b+8>>2]=d;c[b+12>>2]=e;a[b+16>>0]=f&1;return}function xq(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0;h=Eb;Eb=Eb+16|0;f=h+8|0;g=h;if(!(a[b+16>>0]|0)){Qk(d,46);Pk(c[b+8>>2]|0,d);}else {Qk(d,91);Pk(c[b+8>>2]|0,d);Qk(d,93);}e=b+12|0;b=c[e>>2]|0;if(((Vm(b)|0)+-65&255)>=2){fl(g,14167);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];um(d,f);b=c[e>>2]|0;}Pk(b,d);Eb=h;return}function yq(a){a=a|0;$j(a);return}function zq(a,b){a=a|0;b=b|0;var d=0,e=0;c[b>>2]=0;a:do if(((jl(a,0)|0)+-48&255)>9)a=1;else {d=0;while(1){if(((jl(a,0)|0)+-48&255)>=10){a=0;break a}c[b>>2]=d*10;e=((Hq(a)|0)<<24>>24)+-48|0;e=e+(c[b>>2]|0)|0;c[b>>2]=e;d=e;}}while(0);return a|0}function Aq(b,c){b=b|0;c=c|0;var d=0,e=0;d=vm(c)|0;a:do if(d>>>0>(vm(b)|0)>>>0)c=0;else {e=wm(c)|0;d=en(c)|0;c=wm(b)|0;b=e;while(1){if((b|0)==(d|0)){c=1;break a}if((a[b>>0]|0)!=(a[c>>0]|0)){c=0;break a}c=c+1|0;b=b+1|0;}}while(0);return c|0}function Bq(a){a=a|0;return Cq(a+368|0,14281)|0}function Cq(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function Dq(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,7,1,1,1);c[a>>2]=5548;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function Eq(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;h=a+8|0;g=c[h+4>>2]|0;a=f;c[a>>2]=c[h>>2];c[a+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Fq(a,b){a=a|0;b=b|0;var d=0,e=0;e=b+8|0;d=c[e+4>>2]|0;b=a;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function Gq(a){a=a|0;$j(a);return}function Hq(b){b=b|0;var d=0;d=c[b>>2]|0;if((d|0)==(c[b+4>>2]|0))b=0;else {c[b>>2]=d+1;b=a[d>>0]|0;}return b|0}function Iq(a,b,d){a=a|0;b=b|0;d=d|0;a=hm(a,16)|0;Jq(a,c[b>>2]|0,c[d>>2]|0);return a|0}function Jq(a,b,d){a=a|0;b=b|0;d=d|0;jm(a,43,1,1,1);c[a>>2]=5592;c[a+8>>2]=b;c[a+12>>2]=d;return}function Kq(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+32|0;e=d+24|0;h=d+16|0;g=d+8|0;f=d;fl(h,12715);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);fl(g,14347);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);Pk(c[a+12>>2]|0,b);fl(f,12349);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Lq(a){a=a|0;$j(a);return}function Mq(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;f=Eb;Eb=Eb+16|0;g=f+8|0;h=f;a=hm(a,24)|0;b=c[b>>2]|0;fl(h,d);e=c[e>>2]|0;c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];Nq(a,b,g,e);Eb=f;return a|0}function Nq(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;jm(a,46,1,1,1);c[a>>2]=5636;c[a+8>>2]=b;f=d;b=c[f+4>>2]|0;d=a+12|0;c[d>>2]=c[f>>2];c[d+4>>2]=b;c[a+20>>2]=e;return}function Oq(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;Pk(c[a+8>>2]|0,b);i=a+12|0;h=c[i+4>>2]|0;g=f;c[g>>2]=c[i>>2];c[g+4>>2]=h;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+20>>2]|0,b);Eb=d;return}function Pq(a){a=a|0;$j(a);return}function Qq(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;f=Eb;Eb=Eb+16|0;g=f+8|0;h=f;a=hm(a,24)|0;b=c[b>>2]|0;fl(h,d);e=c[e>>2]|0;c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];Nq(a,b,g,e);Eb=f;return a|0}function Rq(a){a=a|0;var b=0,d=0,e=0;e=Eb;Eb=Eb+16|0;d=e;switch((jl(a,0)|0)<<24>>24){case 84:{b=Ql(hl(a)|0)|0;c[d>>2]=b;if(!b)b=0;else Yl(a+148|0,d);break}case 68:{b=Kl(hl(a)|0)|0;c[d>>2]=b;if(!b)b=0;else Yl(a+148|0,d);break}default:b=Xl(hl(a)|0)|0;}Eb=e;return b|0}function Sq(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;d=g+4|0;e=g;f=hl(a)|0;b=oq(f)|0;c[d>>2]=b;if(b){if((jl(a,0)|0)<<24>>24==73){f=Rl(f,0)|0;c[e>>2]=f;if(!f)b=0;else b=Sl(a,d,e)|0;}}else b=0;Eb=g;return b|0}function Tq(a,b,c){a=a|0;b=b|0;c=c|0;return sr(a+368|0,b,c)|0}function Uq(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;g=Eb;Eb=Eb+32|0;e=g+24|0;b=g+16|0;d=g+8|0;f=g;do if((((jl(a,0)|0)<<24>>24)+-48|0)>>>0<10)b=Sq(hl(a)|0)|0;else {fl(b,14520);c[e>>2]=c[b>>2];c[e+4>>2]=c[b+4>>2];if(gl(a,e)|0){b=$q(hl(a)|0)|0;break}fl(d,14523);c[e>>2]=c[d>>2];c[e+4>>2]=c[d+4>>2];gl(a,e)|0;d=hl(a)|0;b=ar(d,0)|0;c[e>>2]=b;if(b){if((jl(a,0)|0)<<24>>24==73){d=Rl(d,0)|0;c[f>>2]=d;if(!d)b=0;else b=Sl(a,e,f)|0;}}else b=0;}while(0);Eb=g;return b|0}function Vq(a,b){a=a|0;b=b|0;return Wq(a+368|0,b)|0}function Wq(a,b){a=a|0;b=b|0;a=hm(a,12)|0;Xq(a,c[b>>2]|0);return a|0}function Xq(a,b){a=a|0;b=b|0;jm(a,33,1,1,1);c[a>>2]=5680;c[a+8>>2]=b;return}function Yq(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;fl(f,14461);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);Eb=d;return}function Zq(a,b){a=a|0;b=b|0;b=c[b+8>>2]|0;Xb[c[(c[b>>2]|0)+24>>2]&127](a,b);return}function _q(a){a=a|0;$j(a);return}function $q(a){a=a|0;var b=0,d=0,e=0,f=0;e=Eb;Eb=Eb+16|0;d=e;f=(((jl(a,0)|0)<<24>>24)+-48|0)>>>0<10;b=hl(a)|0;if(f)b=Sq(b)|0;else b=Rq(b)|0;c[d>>2]=b;if(!b)b=0;else b=nr(a,d)|0;Eb=e;return b|0}function ar(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;i=Eb;Eb=Eb+32|0;g=i+16|0;h=i+8|0;f=i;a:do switch((jl(b,0)|0)<<24>>24|0){case 97:switch((jl(b,1)|0)<<24>>24|0){case 97:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14526)|0;break a}case 110:case 100:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14537)|0;break a}case 78:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14547)|0;break a}case 83:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14558)|0;break a}default:{b=0;break a}}case 99:switch((jl(b,1)|0)<<24>>24|0){case 108:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14568)|0;break a}case 109:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14579)|0;break a}case 111:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14589)|0;break a}case 118:{c[b>>2]=(c[b>>2]|0)+2;Qm(g,b+360|0,0);j=b+361|0;e=(d|0)!=0;Qm(h,j,e|(a[j>>0]|0)!=0);j=rl(hl(b)|0)|0;c[f>>2]=j;if(!j)b=0;else {if(e)a[d>>0]=1;b=br(b,f)|0;}Um(h);Um(g);break a}default:{b=0;break a}}case 100:switch((jl(b,1)|0)<<24>>24|0){case 97:{c[b>>2]=(c[b>>2]|0)+2;b=Fl(b,14599)|0;break a}case 101:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14617)|0;break a}case 108:{c[b>>2]=(c[b>>2]|0)+2;b=cr(b)|0;break a}case 118:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14627)|0;break a}case 86:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14637)|0;break a}default:{b=0;break a}}case 101:switch((jl(b,1)|0)<<24>>24|0){case 111:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14648)|0;break a}case 79:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14658)|0;break a}case 113:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14669)|0;break a}default:{b=0;break a}}case 103:switch((jl(b,1)|0)<<24>>24|0){case 101:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14680)|0;break a}case 116:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14691)|0;break a}default:{b=0;break a}}case 105:{if((jl(b,1)|0)<<24>>24==120){c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14701)|0;}else b=0;break}case 108:switch((jl(b,1)|0)<<24>>24|0){case 101:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14712)|0;break a}case 105:{c[b>>2]=(c[b>>2]|0)+2;j=oq(hl(b)|0)|0;c[g>>2]=j;if(!j)b=0;else b=dr(b,g)|0;break a}case 115:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14723)|0;break a}case 83:{c[b>>2]=(c[b>>2]|0)+2;b=wl(b,14734)|0;break a}case 116:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14746)|0;break a}default:{b=0;break a}}case 109:switch((jl(b,1)|0)<<24>>24|0){case 105:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14756)|0;break a}case 73:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14766)|0;break a}case 108:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14617)|0;break a}case 76:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14777)|0;break a}case 109:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14788)|0;break a}default:{b=0;break a}}case 110:switch((jl(b,1)|0)<<24>>24|0){case 97:{c[b>>2]=(c[b>>2]|0)+2;b=zl(b,14799)|0;break a}case 101:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14814)|0;break a}case 103:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14756)|0;break a}case 116:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14825)|0;break a}case 119:{c[b>>2]=(c[b>>2]|0)+2;b=Bl(b,14835)|0;break a}default:{b=0;break a}}case 111:switch((jl(b,1)|0)<<24>>24|0){case 111:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14848)|0;break a}case 114:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14859)|0;break a}case 82:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14869)|0;break a}default:{b=0;break a}}case 112:switch((jl(b,1)|0)<<24>>24|0){case 109:{c[b>>2]=(c[b>>2]|0)+2;b=wl(b,14880)|0;break a}case 108:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14892)|0;break a}case 76:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14902)|0;break a}case 112:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14913)|0;break a}case 115:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14892)|0;break a}case 116:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14924)|0;break a}default:{b=0;break a}}case 113:{if((jl(b,1)|0)<<24>>24==117){c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14935)|0;}else b=0;break}case 114:switch((jl(b,1)|0)<<24>>24|0){case 109:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14945)|0;break a}case 77:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14955)|0;break a}case 115:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14966)|0;break a}case 83:{c[b>>2]=(c[b>>2]|0)+2;b=wl(b,14977)|0;break a}default:{b=0;break a}}case 115:{if((jl(b,1)|0)<<24>>24==115){c[b>>2]=(c[b>>2]|0)+2;b=wl(b,14989)|0;}else b=0;break}case 118:{if((((jl(b,1)|0)<<24>>24)+-48|0)>>>0<10){c[b>>2]=(c[b>>2]|0)+2;j=oq(hl(b)|0)|0;c[g>>2]=j;if(!j)b=0;else b=br(b,g)|0;}else b=0;break}default:b=0;}while(0);Eb=i;return b|0}function br(a,b){a=a|0;b=b|0;return jr(a+368|0,b)|0}function cr(a){a=a|0;return ir(a+368|0,15065)|0}function dr(a,b){a=a|0;b=b|0;return er(a+368|0,b)|0}function er(a,b){a=a|0;b=b|0;a=hm(a,12)|0;fr(a,c[b>>2]|0);return a|0}function fr(a,b){a=a|0;b=b|0;jm(a,19,1,1,1);c[a>>2]=5724;c[a+8>>2]=b;return}function gr(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;fl(f,15001);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);Eb=d;return}function hr(a){a=a|0;$j(a);return}function ir(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function jr(a,b){a=a|0;b=b|0;a=hm(a,12)|0;kr(a,c[b>>2]|0);return a|0}function kr(a,b){a=a|0;b=b|0;jm(a,4,1,1,1);c[a>>2]=5768;c[a+8>>2]=b;return}function lr(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;fl(f,15081);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);Eb=d;return}function mr(a){a=a|0;$j(a);return}function nr(a,b){a=a|0;b=b|0;return or(a+368|0,b)|0}function or(a,b){a=a|0;b=b|0;a=hm(a,12)|0;pr(a,c[b>>2]|0);return a|0}function pr(a,b){a=a|0;b=b|0;jm(a,38,1,1,1);c[a>>2]=5812;c[a+8>>2]=b;return}function qr(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;fl(f,13448);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);a=c[a+8>>2]|0;Xb[c[(c[a>>2]|0)+16>>2]&127](a,b);Eb=d;return}function rr(a){a=a|0;$j(a);return}function sr(a,b,d){a=a|0;b=b|0;d=d|0;a=hm(a,16)|0;tr(a,c[b>>2]|0,c[d>>2]|0);return a|0}function tr(a,b,d){a=a|0;b=b|0;d=d|0;jm(a,22,1,1,1);c[a>>2]=5856;c[a+8>>2]=b;c[a+12>>2]=d;return}function ur(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;Pk(c[a+8>>2]|0,b);fl(f,14461);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+12>>2]|0,b);Eb=d;return}function vr(a,b){a=a|0;b=b|0;b=c[b+12>>2]|0;Xb[c[(c[b>>2]|0)+24>>2]&127](a,b);return}function wr(a){a=a|0;$j(a);return}function xr(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;f=Eb;Eb=Eb+16|0;g=f+8|0;h=f;a=hm(a,24)|0;fl(h,b);d=c[d>>2]|0;e=c[e>>2]|0;c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];Tp(a,g,d,e);Eb=f;return a|0}function yr(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;b=hm(b,16)|0;zr(b,c[d>>2]|0,(a[e>>0]|0)!=0,(a[f>>0]|0)!=0);return b|0}function zr(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;jm(b,52,1,1,1);c[b>>2]=5900;c[b+8>>2]=d;a[b+12>>0]=e&1;a[b+13>>0]=f&1;return}function Ar(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;i=Eb;Eb=Eb+32|0;e=i+24|0;f=i+16|0;g=i+8|0;h=i;if(a[b+12>>0]|0){fl(f,14461);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(d,e);}fl(g,15257);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(d,e);if(a[b+13>>0]|0){fl(h,15264);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(d,e);}Pk(c[b+8>>2]|0,d);Eb=i;return}function Br(a){a=a|0;$j(a);return}function Cr(a,b,c){a=a|0;b=b|0;c=c|0;return Ir(a+368|0,b,c)|0}function Dr(a,b,c){a=a|0;b=b|0;c=c|0;return Er(a+368|0,b,c)|0}function Er(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Fr(a,b,f);Eb=e;return a|0}function Fr(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,55,1,1,1);c[a>>2]=5944;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function Gr(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+32|0;e=d+24|0;h=d+16|0;g=d+8|0;f=d;fl(h,12715);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);fl(g,15318);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);yn(a+12|0,b);fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Hr(a){a=a|0;$j(a);return}function Ir(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Fr(a,b,f);Eb=e;return a|0}function Jr(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Kr(a,b,f);Eb=e;return a|0}function Kr(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,50,1,1,1);c[a>>2]=5988;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function Lr(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=Eb;Eb=Eb+32|0;e=d+16|0;g=d+8|0;f=d;Pk(c[a+8>>2]|0,b);fl(g,12715);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);yn(a+12|0,b);fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Mr(a){a=a|0;$j(a);return}function Nr(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;f=Eb;Eb=Eb+16|0;g=f+8|0;h=f;a=hm(a,24)|0;fl(h,b);d=c[d>>2]|0;e=c[e>>2]|0;c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];Tp(a,g,d,e);Eb=f;return a|0}function Or(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0;f=Eb;Eb=Eb+32|0;g=f+24|0;h=f+16|0;j=f+8|0;i=f;a=hm(a,28)|0;fl(j,b);d=c[d>>2]|0;fl(i,e);c[h>>2]=c[j>>2];c[h+4>>2]=c[j+4>>2];c[g>>2]=c[i>>2];c[g+4>>2]=c[i+4>>2];Fp(a,h,d,g);Eb=f;return a|0}function Pr(a,b,c){a=a|0;b=b|0;c=c|0;return Qr(a+368|0,b,c)|0}function Qr(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;i=b;h=c[i+4>>2]|0;b=g;c[b>>2]=c[i>>2];c[b+4>>2]=h;d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Rr(a,f,d);Eb=e;return a|0}function Rr(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;jm(a,53,1,1,1);c[a>>2]=6032;f=b;e=c[f+4>>2]|0;b=a+8|0;c[b>>2]=c[f>>2];c[b+4>>2]=e;c[a+16>>2]=d;return}function Sr(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;d=Eb;Eb=Eb+32|0;e=d+24|0;h=d;g=d+16|0;f=d+8|0;k=a+8|0;j=c[k+4>>2]|0;i=h;c[i>>2]=c[k>>2];c[i+4>>2]=j;c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);fl(g,12715);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);Pk(c[a+16>>2]|0,b);fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Tr(a){a=a|0;$j(a);return}function Ur(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Vr(a+368|0,b,c,d)|0}function Vr(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0;f=Eb;Eb=Eb+16|0;g=f+8|0;h=f;a=hm(a,24)|0;b=c[b>>2]|0;j=d;i=c[j+4>>2]|0;d=h;c[d>>2]=c[j>>2];c[d+4>>2]=i;e=c[e>>2]|0;c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];Wr(a,b,g,e);Eb=f;return a|0}function Wr(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;jm(a,42,1,1,1);c[a>>2]=6076;c[a+8>>2]=b;f=d;b=c[f+4>>2]|0;d=a+12|0;c[d>>2]=c[f>>2];c[d+4>>2]=b;c[a+20>>2]=e;return}function Xr(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;m=Eb;Eb=Eb+64|0;d=m+56|0;e=m+48|0;f=m+40|0;g=m+32|0;h=m;i=m+24|0;j=m+16|0;k=m+8|0;l=a+12|0;fl(d,12790);if(dn(l,d)|0){fl(e,12715);c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];um(b,d);}fl(f,12715);c[d>>2]=c[f>>2];c[d+4>>2]=c[f+4>>2];um(b,d);Pk(c[a+8>>2]|0,b);fl(g,15474);c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];um(b,d);e=l;f=c[e+4>>2]|0;g=h;c[g>>2]=c[e>>2];c[g+4>>2]=f;c[d>>2]=c[h>>2];c[d+4>>2]=c[h+4>>2];um(b,d);fl(i,15477);c[d>>2]=c[i>>2];c[d+4>>2]=c[i+4>>2];um(b,d);Pk(c[a+20>>2]|0,b);fl(j,12711);c[d>>2]=c[j>>2];c[d+4>>2]=c[j+4>>2];um(b,d);fl(d,12790);if(dn(l,d)|0){fl(k,12711);c[d>>2]=c[k>>2];c[d+4>>2]=c[k+4>>2];um(b,d);}Eb=m;return}function Yr(a){a=a|0;$j(a);return}function Zr(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;return _r(a+368|0,b,c,d,e)|0}function _r(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0;h=Eb;Eb=Eb+16|0;i=h+8|0;j=h;b=hm(b,28)|0;d=(a[d>>0]|0)!=0;l=e;k=c[l+4>>2]|0;e=j;c[e>>2]=c[l>>2];c[e+4>>2]=k;f=c[f>>2]|0;g=c[g>>2]|0;c[i>>2]=c[j>>2];c[i+4>>2]=c[j+4>>2];$r(b,d,i,f,g);Eb=h;return b|0}function $r(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;jm(b,57,1,1,1);c[b>>2]=6120;c[b+8>>2]=f;c[b+12>>2]=g;f=c[e+4>>2]|0;g=b+16|0;c[g>>2]=c[e>>2];c[g+4>>2]=f;a[b+24>>0]=d&1;return}function as(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;m=Eb;Eb=Eb+64|0;l=m+56|0;h=m+32|0;f=m+24|0;i=m+48|0;j=m+16|0;e=m+8|0;g=m+40|0;k=m;c[h>>2]=d;c[h+4>>2]=b;Qk(d,40);if(!(a[b+24>>0]|0)){cs(h);Qk(d,32);f=b+16|0;h=f;i=c[h+4>>2]|0;j=e;c[j>>2]=c[h>>2];c[j+4>>2]=i;c[l>>2]=c[e>>2];c[l+4>>2]=c[e+4>>2];um(d,l);fl(g,15625);c[l>>2]=c[g>>2];c[l+4>>2]=c[g+4>>2];um(d,l);e=b+12|0;if(c[e>>2]|0){Qk(d,32);h=f;i=c[h+4>>2]|0;j=k;c[j>>2]=c[h>>2];c[j+4>>2]=i;c[l>>2]=c[k>>2];c[l+4>>2]=c[k+4>>2];um(d,l);Qk(d,32);Pk(c[e>>2]|0,d);}}else {e=c[b+12>>2]|0;if(!e)e=b+16|0;else {Pk(e,d);Qk(d,32);e=b+16|0;g=e;b=c[g+4>>2]|0;k=f;c[k>>2]=c[g>>2];c[k+4>>2]=b;c[l>>2]=c[f>>2];c[l+4>>2]=c[f+4>>2];um(d,l);Qk(d,32);}fl(i,15620);c[l>>2]=c[i>>2];c[l+4>>2]=c[i+4>>2];um(d,l);b=e;i=c[b+4>>2]|0;k=j;c[k>>2]=c[b>>2];c[k+4>>2]=i;c[l>>2]=c[j>>2];c[l+4>>2]=c[j+4>>2];um(d,l);Qk(d,32);cs(h);}Qk(d,41);Eb=m;return}function bs(a){a=a|0;$j(a);return}function cs(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;e=c[a+4>>2]|0;Qk(c[a>>2]|0,40);Mp(d,c[e+8>>2]|0);Pk(d,c[a>>2]|0);Qk(c[a>>2]|0,41);Eb=b;return}function ds(a){a=a|0;var b=0,d=0;d=Eb;Eb=Eb+16|0;b=d;c[b>>2]=0;if(nl(a,114)|0)js(b,4);if(nl(a,86)|0)js(b,2);if(nl(a,75)|0)js(b,1);Eb=d;return c[b>>2]|0}function es(a,b){a=a|0;b=b|0;return fs(a+368|0,b)|0}function fs(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];gs(a,e);Eb=d;return a|0}function gs(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,54,1,1,1);c[a>>2]=6164;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function hs(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+32|0;e=d+16|0;h=d+8|0;f=d;fl(h,15674);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);h=a+8|0;g=c[h+4>>2]|0;a=f;c[a>>2]=c[h>>2];c[a+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function is(a){a=a|0;$j(a);return}function js(a,b){a=a|0;b=b|0;c[a>>2]=c[a>>2]|b;return}function ks(a){a=a|0;var b=0;b=a+12|0;c[a>>2]=b;c[a+4>>2]=b;c[a+8>>2]=a+44;return}function ls(a,b){a=a|0;b=b|0;return qs(a+368|0,b)|0}function ms(a,b){a=a|0;b=b|0;var d=0,e=0;e=a+4|0;d=c[e>>2]|0;if((d|0)==(c[a+8>>2]|0)){ps(a,(os(a)|0)<<1);d=c[e>>2]|0;}b=c[b>>2]|0;c[e>>2]=d+4;c[d>>2]=b;return}function ns(a,b){a=a|0;b=b|0;return (_n(a)|0)+(b<<2)|0}function os(a){a=a|0;return (c[a+4>>2]|0)-(c[a>>2]|0)>>2|0}function ps(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;h=os(a)|0;do if(!(cl(a)|0)){e=jk(c[a>>2]|0,b<<2)|0;c[a>>2]=e;if(!e)Uk();else {f=e;d=a+4|0;break}}else {f=hk(b<<2)|0;if(!f)Uk();g=c[a>>2]|0;d=a+4|0;e=(c[d>>2]|0)-g|0;if(e|0)bx(f|0,g|0,e|0)|0;c[a>>2]=f;}while(0);c[d>>2]=f+(h<<2);c[a+8>>2]=f+(b<<2);return}function qs(a,b){a=a|0;b=b|0;a=hm(a,20)|0;rs(a,c[b>>2]|0);return a|0}function rs(b,d){b=b|0;d=d|0;jm(b,31,2,2,2);c[b>>2]=6208;c[b+8>>2]=d;c[b+12>>2]=0;a[b+16>>0]=0;return}function ss(b,d){b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g;f=b+16|0;if(!(a[f>>0]|0)){Qm(e,f,1);b=Wm(c[b+12>>2]|0,d)|0;Um(e);}else b=0;Eb=g;return b|0}function ts(b,d){b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g;f=b+16|0;if(!(a[f>>0]|0)){Qm(e,f,1);b=Sm(c[b+12>>2]|0,d)|0;Um(e);}else b=0;Eb=g;return b|0}function us(b,d){b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g;f=b+16|0;if(!(a[f>>0]|0)){Qm(e,f,1);b=Tm(c[b+12>>2]|0,d)|0;Um(e);}else b=0;Eb=g;return b|0}function vs(b,d){b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g;f=b+16|0;if(!(a[f>>0]|0)){Qm(e,f,1);b=c[b+12>>2]|0;b=Ob[c[(c[b>>2]|0)+12>>2]&63](b,d)|0;Um(e);}Eb=g;return b|0}function ws(b,d){b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g;f=b+16|0;if(!(a[f>>0]|0)){Qm(e,f,1);f=c[b+12>>2]|0;Xb[c[(c[f>>2]|0)+16>>2]&127](f,d);Um(e);}Eb=g;return}function xs(b,d){b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g;f=b+16|0;if(!(a[f>>0]|0)){Qm(e,f,1);f=c[b+12>>2]|0;Xb[c[(c[f>>2]|0)+20>>2]&127](f,d);Um(e);}Eb=g;return}function ys(a){a=a|0;$j(a);return}function zs(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=Eb;Eb=Eb+16|0;g=j+4|0;h=j;nl(b,76)|0;switch((jl(b,0)|0)<<24>>24){case 78:{e=Fs(hl(b)|0,d)|0;break}case 90:{e=Gs(hl(b)|0,d)|0;break}case 83:{if((jl(b,1)|0)<<24>>24==116)i=13;else {e=hl(b)|0;f=Xl(e)|0;c[g>>2]=f;if((f|0)!=0?(jl(b,0)|0)<<24>>24==73:0){f=(d|0)!=0;e=Rl(e,f)|0;c[h>>2]=e;if(!e)e=0;else {if(f)a[d+1>>0]=1;e=Sl(b,g,h)|0;}}else e=0;}break}default:i=13;}if((i|0)==13){f=hl(b)|0;e=Hs(f,d)|0;c[g>>2]=e;if(e){if((jl(b,0)|0)<<24>>24==73){Yl(b+148|0,g);e=(d|0)!=0;i=Rl(f,e)|0;c[h>>2]=i;if(!i)e=0;else {if(e)a[d+1>>0]=1;e=Sl(b,g,h)|0;}}}else e=0;}Eb=j;return e|0}function As(a,b,c){a=a|0;b=b|0;c=c|0;return Bs(a+368|0,b,c)|0}function Bs(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;i=b;h=c[i+4>>2]|0;b=g;c[b>>2]=c[i>>2];c[b+4>>2]=h;d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Cs(a,f,d);Eb=e;return a|0}function Cs(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;jm(a,6,1,1,1);c[a>>2]=6252;f=b;e=c[f+4>>2]|0;b=a+8|0;c[b>>2]=c[f>>2];c[b+4>>2]=e;c[a+16>>2]=d;return}function Ds(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;i=a+8|0;h=c[i+4>>2]|0;g=f;c[g>>2]=c[i>>2];c[g+4>>2]=h;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Qk(b,32);Pk(c[a+16>>2]|0,b);Eb=d;return}function Es(a){a=a|0;$j(a);return}function Fs(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;m=Eb;Eb=Eb+48|0;h=m+32|0;i=m+20|0;j=m+24|0;k=m+8|0;g=m;c[i>>2]=d;if(nl(b,78)|0){e=ds(b)|0;f=(d|0)==0;if(!f)c[d+4>>2]=e;do if(nl(b,79)|0){if(!f)a[d+8>>0]=2;}else {e=(d|0)!=0;if(nl(b,82)|0){if(!e)break;a[d+8>>0]=1;break}else {if(!e)break;a[d+8>>0]=0;break}}while(0);c[j>>2]=0;c[k>>2]=b;c[k+4>>2]=j;c[k+8>>2]=i;fl(g,15881);c[h>>2]=c[g>>2];c[h+4>>2]=c[g+4>>2];if(gl(b,h)|0){g=Al(b,16199)|0;c[j>>2]=g;}f=b+148|0;a:while(1){if(nl(b,69)|0){l=41;break}nl(b,76)|0;b:do if(nl(b,77)|0){if(!(c[j>>2]|0)){e=0;break a}}else {c:do switch((jl(b,0)|0)<<24>>24){case 84:{if(!(jt(k,Ql(hl(b)|0)|0)|0)){e=0;break a}Yl(f,j);break b}case 73:{g=Rl(hl(b)|0,(c[i>>2]|0)!=0)|0;c[h>>2]=g;if((g|0)==0|(c[j>>2]|0)==0){l=26;break a}e=Sl(b,j,h)|0;c[j>>2]=e;e=c[i>>2]|0;if(e|0)a[e+1>>0]=1;Yl(f,j);break b}case 68:{switch((jl(b,1)|0)<<24>>24){case 67:{l=39;break c}case 84:case 116:break;default:break c}if(!(jt(k,Kl(hl(b)|0)|0)|0)){e=0;break a}Yl(f,j);break b}case 83:{if((jl(b,1)|0)<<24>>24==116)l=39;else {e=Xl(hl(b)|0)|0;c[h>>2]=e;if(!(jt(k,e)|0)){l=44;break a}if((c[j>>2]|0)!=(e|0))Yl(f,h);break b}break}case 67:break;default:l=39;}while(0);if((l|0)==39){l=0;g=hl(b)|0;if(!(jt(k,Is(g,c[i>>2]|0)|0)|0)){e=0;break a}Yl(f,j);break}if(!(c[j>>2]|0)){e=0;break a}e=hl(b)|0;if(!(jt(k,kt(e,j,c[i>>2]|0)|0)|0)){e=0;break a}g=am(e,c[j>>2]|0)|0;c[j>>2]=g;if(!g){e=0;break a}Yl(f,j);}while(0)}if((l|0)==26)e=0;else if((l|0)==41)if((c[j>>2]|0)!=0?!(bm(f)|0):0){lt(f);e=c[j>>2]|0;}else e=0;else if((l|0)==44)e=0;}else e=0;Eb=m;return e|0}function Gs(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;g=Eb;Eb=Eb+16|0;d=g+8|0;e=g;if(nl(a,90)|0){f=hl(a)|0;h=il(f)|0;c[d>>2]=h;do if((h|0)!=0?nl(a,69)|0:0){if(nl(a,115)|0){h=dt(c[a>>2]|0,c[a+4>>2]|0)|0;c[a>>2]=h;h=zl(a,16139)|0;c[e>>2]=h;a=et(a,d,e)|0;break}if(!(nl(a,100)|0)){h=zs(f,b)|0;c[e>>2]=h;if(!h)a=0;else {h=dt(c[a>>2]|0,c[a+4>>2]|0)|0;c[a>>2]=h;a=et(a,d,e)|0;}break}ol(e,a,1);if(nl(a,95)|0){h=zs(f,b)|0;c[e>>2]=h;if(!h)a=0;else a=et(a,d,e)|0;}else a=0;}else a=0;while(0)}else a=0;Eb=g;return a|0}function Hs(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;f=Eb;Eb=Eb+32|0;d=f+16|0;g=f+8|0;e=f;fl(g,15877);c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];if(!(gl(a,d)|0)?(fl(e,15881),c[d>>2]=c[e>>2],c[d+4>>2]=c[e+4>>2],!(gl(a,d)|0)):0)d=Is(hl(a)|0,b)|0;else {g=Is(hl(a)|0,b)|0;c[d>>2]=g;if(!g)d=0;else d=Js(a,d)|0;}Eb=f;return d|0}function Is(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;h=Eb;Eb=Eb+16|0;f=h+8|0;d=h;e=jl(a,0)|0;do if(e<<24>>24!=85){if((e+-49&255)<9){b=oq(hl(a)|0)|0;g=12;break}fl(d,15943);c[f>>2]=c[d>>2];c[f+4>>2]=c[d+4>>2];if(!(gl(a,f)|0)){b=ar(hl(a)|0,b)|0;g=12;break}b=a+8|0;e=Zl(b)|0;while(1){d=hl(a)|0;g=oq(d)|0;c[f>>2]=g;if(!g){g=10;break}Yl(b,f);if(nl(a,69)|0){g=9;break}}if((g|0)==9){sn(f,a,e);b=Qs(a,f)|0;g=14;break}else if((g|0)==10){b=0;break}}else {b=Ps(hl(a)|0)|0;g=12;}while(0);if((g|0)==12)if(!b)b=0;else {d=hl(a)|0;g=14;}if((g|0)==14)b=am(d,b)|0;Eb=h;return b|0}function Js(a,b){a=a|0;b=b|0;return Ks(a+368|0,b)|0}function Ks(a,b){a=a|0;b=b|0;a=hm(a,12)|0;Ls(a,c[b>>2]|0);return a|0}function Ls(a,b){a=a|0;b=b|0;jm(a,34,1,1,1);c[a>>2]=6296;c[a+8>>2]=b;return}function Ms(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;fl(f,15884);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);Eb=d;return}function Ns(a,b){a=a|0;b=b|0;b=c[b+8>>2]|0;Xb[c[(c[b>>2]|0)+24>>2]&127](a,b);return}function Os(a){a=a|0;$j(a);return}function Ps(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0;i=Eb;Eb=Eb+48|0;f=i+40|0;e=i+32|0;b=i+24|0;g=i;h=i+8|0;d=i+16|0;fl(e,16004);c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];if(!(gl(a,f)|0)){fl(b,16007);c[f>>2]=c[b>>2];c[f+4>>2]=c[b+4>>2];if(gl(a,f)|0){bq(g);Qm(h,a+362|0,1);fl(d,16010);c[f>>2]=c[d>>2];c[f+4>>2]=c[d+4>>2];do if(!(gl(a,f)|0)){b=a+8|0;d=Zl(b)|0;while(1){e=rl(hl(a)|0)|0;c[f>>2]=e;if(!e){e=11;break}Yl(b,f);if(nl(a,69)|0){e=10;break}}if((e|0)==10){sn(g,a,d);e=12;break}else if((e|0)==11){b=0;break}}else e=12;while(0);if((e|0)==12){ol(f,a,0);if(nl(a,95)|0)b=Ws(a,g,f)|0;else b=0;}Um(h);}else b=0;}else {ol(f,a,0);if(nl(a,95)|0)b=Vs(a,f)|0;else b=0;}Eb=i;return b|0}function Qs(a,b){a=a|0;b=b|0;return Rs(a+368|0,b)|0}function Rs(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Ss(a,e);Eb=d;return a|0}function Ss(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,41,1,1,1);c[a>>2]=6340;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function Ts(a,b){a=a|0;b=b|0;Qk(b,91);yn(a+8|0,b);Qk(b,93);return}function Us(a){a=a|0;$j(a);return}function Vs(a,b){a=a|0;b=b|0;return $s(a+368|0,b)|0}function Ws(a,b,c){a=a|0;b=b|0;c=c|0;return Xs(a+368|0,b,c)|0}function Xs(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0;e=Eb;Eb=Eb+32|0;f=e+24|0;g=e+16|0;i=e+8|0;h=e;a=hm(a,24)|0;k=b;b=c[k+4>>2]|0;j=i;c[j>>2]=c[k>>2];c[j+4>>2]=b;j=d;b=c[j+4>>2]|0;d=h;c[d>>2]=c[j>>2];c[d+4>>2]=b;c[g>>2]=c[i>>2];c[g+4>>2]=c[i+4>>2];c[f>>2]=c[h>>2];c[f+4>>2]=c[h+4>>2];Ys(a,g,f);Eb=e;return a|0}function Ys(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;jm(a,40,1,1,1);c[a>>2]=6384;f=b;b=c[f+4>>2]|0;e=a+8|0;c[e>>2]=c[f>>2];c[e+4>>2]=b;e=d;b=c[e+4>>2]|0;d=a+16|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function Zs(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;d=Eb;Eb=Eb+48|0;e=d+32|0;k=d+24|0;h=d;g=d+16|0;f=d+8|0;fl(k,16013);c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];um(b,e);k=a+16|0;j=c[k+4>>2]|0;i=h;c[i>>2]=c[k>>2];c[i+4>>2]=j;c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);fl(g,16021);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);yn(a+8|0,b);fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function _s(a){a=a|0;$j(a);return}function $s(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];at(a,e);Eb=d;return a|0}function at(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,39,1,1,1);c[a>>2]=6428;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function bt(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;d=Eb;Eb=Eb+32|0;e=d+24|0;i=d+16|0;g=d;f=d+8|0;fl(i,16076);c[e>>2]=c[i>>2];c[e+4>>2]=c[i+4>>2];um(b,e);i=a+8|0;h=c[i+4>>2]|0;a=g;c[a>>2]=c[i>>2];c[a+4>>2]=h;c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);fl(f,16085);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function ct(a){a=a|0;$j(a);return}function dt(b,c){b=b|0;c=c|0;var d=0,e=0;a:do if((b|0)!=(c|0)){d=a[b>>0]|0;if(d<<24>>24!=95){if(((d<<24>>24)+-48|0)>>>0>=10)break;d=b;while(1){d=d+1|0;if((d|0)==(c|0)){b=c;break a}if(((a[d>>0]|0)+-48|0)>>>0>=10)break a}}d=b+1|0;if((d|0)!=(c|0)){d=a[d>>0]|0;if(((d<<24>>24)+-48|0)>>>0<10){b=b+2|0;break}if(d<<24>>24==95){d=b+2|0;while(1){if((d|0)==(c|0))break a;e=a[d>>0]|0;if(((e<<24>>24)+-48|0)>>>0>=10)break;d=d+1|0;}return (e<<24>>24==95?d+1|0:b)|0}}}while(0);return b|0}function et(a,b,c){a=a|0;b=b|0;c=c|0;return ft(a+368|0,b,c)|0}function ft(a,b,d){a=a|0;b=b|0;d=d|0;a=hm(a,16)|0;gt(a,c[b>>2]|0,c[d>>2]|0);return a|0}function gt(a,b,d){a=a|0;b=b|0;d=d|0;jm(a,24,1,1,1);c[a>>2]=6472;c[a+8>>2]=b;c[a+12>>2]=d;return}function ht(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;Pk(c[a+8>>2]|0,b);fl(f,14461);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+12>>2]|0,b);Eb=d;return}function it(a){a=a|0;$j(a);return}function jt(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;i=Eb;Eb=Eb+16|0;e=i;c[e>>2]=d;f=c[b>>2]|0;if(!d)b=0;else {h=b+4|0;g=c[h>>2]|0;if(!(c[g>>2]|0))c[g>>2]=d;else {g=xt(f,g,e)|0;c[c[h>>2]>>2]=g;}b=c[c[b+8>>2]>>2]|0;if(b|0)a[b+1>>0]=0;b=(c[c[h>>2]>>2]|0)!=0;}Eb=i;return b|0}function kt(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0;j=Eb;Eb=Eb+16|0;h=j;i=j+4|0;f=c[d>>2]|0;if((Vm(f)|0)<<24>>24==36?(g=c[f+8>>2]|0,c[h>>2]=g,(g+-2|0)>>>0<4):0){g=mt(b,h)|0;c[d>>2]=g;}a:do if(!(nl(b,67)|0))if((jl(b,0)|0)<<24>>24==68){f=jl(b,1)|0;switch(f<<24>>24){case 53:case 50:case 49:case 48:break;default:{f=0;break a}}c[h>>2]=(f<<24>>24)+-48;c[b>>2]=(c[b>>2]|0)+2;if(e|0)a[e>>0]=1;a[i>>0]=1;f=nt(b,d,i,h)|0;}else f=0;else {f=nl(b,73)|0;g=jl(b,0)|0;switch(g<<24>>24){case 53:case 51:case 50:case 49:break;default:{f=0;break a}}c[h>>2]=(g<<24>>24)+-48;c[b>>2]=(c[b>>2]|0)+1;if(e|0)a[e>>0]=1;if(f?(zs(hl(b)|0,e)|0)==0:0)f=0;else {a[i>>0]=0;f=nt(b,d,i,h)|0;}}while(0);Eb=j;return f|0}function lt(a){a=a|0;a=a+4|0;c[a>>2]=(c[a>>2]|0)+-4;return}function mt(a,b){a=a|0;b=b|0;return st(a+368|0,b)|0}function nt(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return ot(a+368|0,b,c,d)|0}function ot(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;b=hm(b,20)|0;pt(b,c[d>>2]|0,(a[e>>0]|0)!=0,c[f>>2]|0);return b|0}function pt(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;jm(b,37,1,1,1);c[b>>2]=6516;c[b+8>>2]=d;a[b+12>>0]=e&1;c[b+16>>2]=f;return}function qt(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0;h=Eb;Eb=Eb+32|0;e=h+16|0;f=h+8|0;g=h;if(a[b+12>>0]|0){fl(f,13448);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(d,e);}f=c[b+8>>2]|0;Xb[c[(c[f>>2]|0)+24>>2]&127](g,f);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(d,e);Eb=h;return}function rt(a){a=a|0;$j(a);return}function st(a,b){a=a|0;b=b|0;a=hm(a,12)|0;tt(a,c[b>>2]|0);return a|0}function tt(a,b){a=a|0;b=b|0;jm(a,35,1,1,1);c[a>>2]=6560;c[a+8>>2]=b;return}function ut(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;k=Eb;Eb=Eb+64|0;d=k+48|0;e=k+40|0;f=k+32|0;g=k+24|0;h=k+16|0;i=k+8|0;j=k;switch(c[a+8>>2]|0){case 0:{fl(e,12493);c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];um(b,d);break}case 1:{fl(f,12508);c[d>>2]=c[f>>2];c[d+4>>2]=c[f+4>>2];um(b,d);break}case 2:{fl(g,16295);c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];um(b,d);break}case 3:{fl(h,16366);c[d>>2]=c[h>>2];c[d+4>>2]=c[h+4>>2];um(b,d);break}case 4:{fl(i,16416);c[d>>2]=c[i>>2];c[d+4>>2]=c[i+4>>2];um(b,d);break}case 5:{fl(j,16466);c[d>>2]=c[j>>2];c[d+4>>2]=c[j+4>>2];um(b,d);break}}Eb=k;return}function vt(a,b){a=a|0;b=b|0;switch(c[b+8>>2]|0){case 0:{fl(a,12438);break}case 1:{fl(a,12448);break}case 2:{fl(a,12448);break}case 3:{fl(a,16252);break}case 4:{fl(a,16266);break}case 5:{fl(a,16280);break}}return}function wt(a){a=a|0;$j(a);return}function xt(a,b,c){a=a|0;b=b|0;c=c|0;return yt(a+368|0,b,c)|0}function yt(a,b,d){a=a|0;b=b|0;d=d|0;a=hm(a,16)|0;zt(a,c[b>>2]|0,c[d>>2]|0);return a|0}function zt(a,b,d){a=a|0;b=b|0;d=d|0;jm(a,23,1,1,1);c[a>>2]=6604;c[a+8>>2]=b;c[a+12>>2]=d;return}function At(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;Pk(c[a+8>>2]|0,b);fl(f,14461);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+12>>2]|0,b);Eb=d;return}function Bt(a,b){a=a|0;b=b|0;b=c[b+12>>2]|0;Xb[c[(c[b>>2]|0)+24>>2]&127](a,b);return}function Ct(a){a=a|0;$j(a);return}function Dt(a,b,c){a=a|0;b=b|0;c=c|0;return Et(a+368|0,b,c)|0}function Et(a,b,d){a=a|0;b=b|0;d=d|0;a=hm(a,16)|0;Ft(a,c[b>>2]|0,c[d>>2]|0);return a|0}function Ft(b,d,e){b=b|0;d=d|0;e=e|0;jm(b,13,a[e+5>>0]|0,1,1);c[b>>2]=6648;c[b+8>>2]=d;c[b+12>>2]=e;return}function Gt(a,b){a=a|0;b=b|0;return Wm(c[a+12>>2]|0,b)|0}function Ht(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;i=Eb;Eb=Eb+32|0;d=i+24|0;e=i+16|0;f=i+8|0;g=i;h=a+12|0;j=c[h>>2]|0;Xb[c[(c[j>>2]|0)+16>>2]&127](j,b);if(!(Sm(c[h>>2]|0,b)|0)?!(Tm(c[h>>2]|0,b)|0):0){fl(f,12713);c[d>>2]=c[f>>2];c[d+4>>2]=c[f+4>>2];um(b,d);}else {fl(e,12715);c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];um(b,d);}Pk(c[a+8>>2]|0,b);fl(g,16628);c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];um(b,d);Eb=i;return}function It(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;f=Eb;Eb=Eb+16|0;d=f+8|0;e=f;a=a+12|0;if(!(!(Sm(c[a>>2]|0,b)|0)?!(Tm(c[a>>2]|0,b)|0):0)){fl(e,12711);c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];um(b,d);}e=c[a>>2]|0;Xb[c[(c[e>>2]|0)+20>>2]&127](e,b);Eb=f;return}function Jt(a){a=a|0;$j(a);return}function Kt(a){a=a|0;c[a>>2]=0;c[a+4>>2]=0;return}function Lt(a,b){a=a|0;b=b|0;var d=0,e=0;e=wm(b)|0;b=en(b)|0;d=(b|0)==0;c[a>>2]=d?e+1|0:e;c[a+4>>2]=d?b+1|0:b;return}function Mt(a,b){a=a|0;b=b|0;c[a>>2]=b;c[a+4>>2]=0;return}function Nt(a,b,c){a=a|0;b=b|0;c=c|0;return Ot(a+368|0,b,c)|0}function Ot(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Pt(a,b,f);Eb=e;return a|0}function Pt(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,14,0,0,1);c[a>>2]=6692;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function Qt(a,b){return 1}function Rt(a,b){return 1}function St(a,b){a=a|0;b=b|0;a=c[a+8>>2]|0;Xb[c[(c[a>>2]|0)+16>>2]&127](a,b);return}function Tt(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;i=Eb;Eb=Eb+48|0;f=i+32|0;d=i+24|0;e=i+16|0;g=i+8|0;h=i;if((zn(b)|0)<<24>>24!=93){fl(d,12713);c[f>>2]=c[d>>2];c[f+4>>2]=c[d+4>>2];um(b,f);}fl(e,16688);c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];um(b,f);d=a+12|0;if(!(Vt(d)|0)){if(Xt(d)|0)Pk(Yt(d)|0,b);}else {Wt(g,d);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];um(b,f);}fl(h,12349);c[f>>2]=c[h>>2];c[f+4>>2]=c[h+4>>2];um(b,f);h=c[a+8>>2]|0;Xb[c[(c[h>>2]|0)+20>>2]&127](h,b);Eb=i;return}function Ut(a){a=a|0;$j(a);return}function Vt(a){a=a|0;if(!(c[a+4>>2]|0))a=0;else a=(c[a>>2]|0)!=0;return a|0}function Wt(a,b){a=a|0;b=b|0;kl(a,c[b>>2]|0,c[b+4>>2]|0);return}function Xt(a){a=a|0;if(!(c[a>>2]|0))a=0;else a=(c[a+4>>2]|0)==0;return a|0}function Yt(a){a=a|0;return c[a>>2]|0}function Zt(a,b){a=a|0;b=b|0;a=hm(a,12)|0;Mp(a,c[b>>2]|0);return a|0}function _t(a,b){a=a|0;b=b|0;return iu(a+368|0,b)|0}function $t(a,b,c){a=a|0;b=b|0;c=c|0;return hu(a+368|0,b,c)|0}function au(a,b,c){a=a|0;b=b|0;c=c|0;return gu(a+368|0,b,c)|0}function bu(a,b,c){a=a|0;b=b|0;c=c|0;return cu(a+368|0,b,c)|0}function cu(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;e=Eb;Eb=Eb+32|0;f=e+16|0;g=e+8|0;h=e;a=hm(a,20)|0;b=c[b>>2]|0;j=d;i=c[j+4>>2]|0;d=h;c[d>>2]=c[j>>2];c[d+4>>2]=i;c[f>>2]=c[h>>2];c[f+4>>2]=c[h+4>>2];Lt(g,f);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];du(a,b,f);Eb=e;return a|0}function du(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,25,1,1,1);c[a>>2]=6736;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function eu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;g=Eb;Eb=Eb+32|0;d=g+24|0;h=g+16|0;e=g+8|0;f=g;Pk(c[a+8>>2]|0,b);fl(h,16738);c[d>>2]=c[h>>2];c[d+4>>2]=c[h+4>>2];um(b,d);a=a+12|0;if(!(Xt(a)|0)){if(Vt(a)|0){Wt(e,a);c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];um(b,d);}}else Pk(Yt(a)|0,b);fl(f,12349);c[d>>2]=c[f>>2];c[d+4>>2]=c[f+4>>2];um(b,d);Eb=g;return}function fu(a){a=a|0;$j(a);return}function gu(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;Mt(g,c[d>>2]|0);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];du(a,b,f);Eb=e;return a|0}function hu(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;e=Eb;Eb=Eb+32|0;f=e+16|0;g=e+8|0;h=e;a=hm(a,20)|0;b=c[b>>2]|0;j=d;i=c[j+4>>2]|0;d=h;c[d>>2]=c[j>>2];c[d+4>>2]=i;c[f>>2]=c[h>>2];c[f+4>>2]=c[h+4>>2];Lt(g,f);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];du(a,b,f);Eb=e;return a|0}function iu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;d=Eb;Eb=Eb+32|0;e=d+16|0;f=d+8|0;g=d;a=hm(a,16)|0;i=b;h=c[i+4>>2]|0;b=g;c[b>>2]=c[i>>2];c[b+4>>2]=h;c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];Lt(f,e);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];ju(a,e);Eb=d;return a|0}function ju(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,26,1,1,1);c[a>>2]=6780;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function ku(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+32|0;e=d+24|0;h=d+16|0;g=d+8|0;f=d;fl(h,16794);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);Wt(g,a+8|0);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);fl(f,12349);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function lu(a){a=a|0;$j(a);return}function mu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function nu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function ou(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function pu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function qu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function ru(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function su(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function tu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function uu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function vu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function wu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function xu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function yu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function zu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function Au(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function Bu(b,d,e){b=b|0;d=d|0;e=e|0;c[b>>2]=d;c[b+4>>2]=c[d>>2];a[b+8>>0]=1;c[d>>2]=e;return}function Cu(b){b=b|0;if(a[b+8>>0]|0)c[c[b>>2]>>2]=c[b+4>>2];return}function Du(a,b,c){a=a|0;b=b|0;c=c|0;return Tu(a+368|0,b,c)|0}function Eu(a,b,c){a=a|0;b=b|0;c=c|0;return Pu(a+368|0,b,c)|0}function Fu(a,b,c){a=a|0;b=b|0;c=c|0;return Gu(a+368|0,b,c)|0}function Gu(a,b,d){a=a|0;b=b|0;d=d|0;a=hm(a,16)|0;Hu(a,c[b>>2]|0,c[d>>2]|0);return a|0}function Hu(b,d,e){b=b|0;d=d|0;e=e|0;jm(b,3,a[d+5>>0]|0,a[d+6>>0]|0,a[d+7>>0]|0);c[b>>2]=6824;c[b+8>>2]=e;c[b+12>>2]=d;return}function Iu(a,b){a=a|0;b=b|0;return Wm(c[a+12>>2]|0,b)|0}function Ju(a,b){a=a|0;b=b|0;return Sm(c[a+12>>2]|0,b)|0}function Ku(a,b){a=a|0;b=b|0;return Tm(c[a+12>>2]|0,b)|0}function Lu(a,b){a=a|0;b=b|0;var d=0;d=c[a+12>>2]|0;Xb[c[(c[d>>2]|0)+16>>2]&127](d,b);Ou(a,b);return}function Mu(a,b){a=a|0;b=b|0;a=c[a+12>>2]|0;Xb[c[(c[a>>2]|0)+20>>2]&127](a,b);return}function Nu(a){a=a|0;$j(a);return}function Ou(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;i=Eb;Eb=Eb+32|0;g=i+24|0;d=i+16|0;f=i+8|0;h=i;e=a+8|0;a=c[e>>2]|0;if(a&1){fl(d,16906);c[g>>2]=c[d>>2];c[g+4>>2]=c[d+4>>2];um(b,g);a=c[e>>2]|0;}if(a&2){fl(f,16913);c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];um(b,g);a=c[e>>2]|0;}if(a&4|0){fl(h,16923);c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];um(b,g);}Eb=i;return}function Pu(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Qu(a,b,f);Eb=e;return a|0}function Qu(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,2,1,1,1);c[a>>2]=6868;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function Ru(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+32|0;e=d+16|0;h=d+8|0;f=d;Pk(c[a+8>>2]|0,b);fl(h,12713);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);h=a+12|0;g=c[h+4>>2]|0;a=f;c[a>>2]=c[h>>2];c[a+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Su(a){a=a|0;$j(a);return}function Tu(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Uu(a,b,f);Eb=e;return a|0}function Uu(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,10,1,1,1);c[a>>2]=6912;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function Vu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;d=Eb;Eb=Eb+32|0;e=d+24|0;i=d+16|0;g=d;f=d+8|0;Pk(c[a+8>>2]|0,b);fl(i,12897);c[e>>2]=c[i>>2];c[e+4>>2]=c[i+4>>2];um(b,e);i=a+12|0;h=c[i+4>>2]|0;a=g;c[a>>2]=c[i>>2];c[a+4>>2]=h;c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);fl(f,12790);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Wu(a){a=a|0;$j(a);return}function Xu(a,b){a=a|0;b=b|0;return jv(a+368|0,b)|0}function Yu(a,b){a=a|0;b=b|0;return fv(a+368|0,b)|0}function Zu(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;return _u(a+368|0,b,c,d,e,f)|0}function _u(b,d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0,k=0,l=0,m=0;i=Eb;Eb=Eb+16|0;j=i+8|0;k=i;b=hm(b,32)|0;d=c[d>>2]|0;m=e;l=c[m+4>>2]|0;e=k;c[e>>2]=c[m>>2];c[e+4>>2]=l;f=c[f>>2]|0;g=a[g>>0]|0;h=c[h>>2]|0;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];$u(b,d,j,f,g,h);Eb=i;return b|0}function $u(b,d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0;jm(b,15,0,1,0);c[b>>2]=6956;c[b+8>>2]=d;i=e;d=c[i+4>>2]|0;e=b+12|0;c[e>>2]=c[i>>2];c[e+4>>2]=d;c[b+20>>2]=f;a[b+24>>0]=g;c[b+28>>2]=h;return}function av(a,b){return 1}function bv(a,b){return 1}function cv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=c[a+8>>2]|0;Xb[c[(c[a>>2]|0)+16>>2]&127](a,b);fl(f,12713);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function dv(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;m=Eb;Eb=Eb+64|0;i=m+56|0;e=m+48|0;g=m+40|0;f=m+32|0;h=m+24|0;j=m+16|0;k=m+8|0;l=m;fl(e,12715);c[i>>2]=c[e>>2];c[i+4>>2]=c[e+4>>2];um(d,i);yn(b+12|0,d);fl(g,12711);c[i>>2]=c[g>>2];c[i+4>>2]=c[g+4>>2];um(d,i);g=c[b+8>>2]|0;Xb[c[(c[g>>2]|0)+20>>2]&127](g,d);g=b+20|0;e=c[g>>2]|0;if(e&1){fl(f,16906);c[i>>2]=c[f>>2];c[i+4>>2]=c[f+4>>2];um(d,i);e=c[g>>2]|0;}if(e&2){fl(h,16913);c[i>>2]=c[h>>2];c[i+4>>2]=c[h+4>>2];um(d,i);e=c[g>>2]|0;}if(e&4|0){fl(j,16923);c[i>>2]=c[j>>2];c[i+4>>2]=c[j+4>>2];um(d,i);}switch(a[b+24>>0]|0){case 1:{fl(k,17108);c[i>>2]=c[k>>2];c[i+4>>2]=c[k+4>>2];um(d,i);break}case 2:{fl(l,17111);c[i>>2]=c[l>>2];c[i+4>>2]=c[l+4>>2];um(d,i);break}}e=b+28|0;if(c[e>>2]|0){Qk(d,32);Pk(c[e>>2]|0,d);}Eb=m;return}function ev(a){a=a|0;$j(a);return}function fv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];gv(a,e);Eb=d;return a|0}function gv(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,17,1,1,1);c[a>>2]=7e3;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function hv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;fl(f,17164);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);yn(a+8|0,b);Qk(b,41);Eb=d;return}function iv(a){a=a|0;$j(a);return}function jv(a,b){a=a|0;b=b|0;a=hm(a,12)|0;kv(a,c[b>>2]|0);return a|0}function kv(a,b){a=a|0;b=b|0;jm(a,16,1,1,1);c[a>>2]=7044;c[a+8>>2]=b;return}function lv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=Eb;Eb=Eb+32|0;e=d+16|0;g=d+8|0;f=d;fl(g,17228);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function mv(a){a=a|0;$j(a);return}function nv(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function ov(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;jm(a,20,1,1,1);c[a>>2]=7088;f=b;e=c[f+4>>2]|0;b=a+8|0;c[b>>2]=c[f>>2];c[b+4>>2]=e;c[a+16>>2]=d;return}function pv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;i=a+8|0;h=c[i+4>>2]|0;g=f;c[g>>2]=c[i>>2];c[g+4>>2]=h;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+16>>2]|0,b);Eb=d;return}function qv(a){a=a|0;$j(a);return}function rv(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];sv(a,b,f);Eb=e;return a|0}function sv(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,1,1,1,1);c[a>>2]=7132;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function tv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;d=Eb;Eb=Eb+32|0;e=d+24|0;i=d+16|0;g=d;f=d+8|0;Pk(c[a+8>>2]|0,b);fl(i,15477);c[e>>2]=c[i>>2];c[e+4>>2]=c[i+4>>2];um(b,e);i=a+12|0;h=c[i+4>>2]|0;a=g;c[a>>2]=c[i>>2];c[a+4>>2]=h;c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function uv(a){a=a|0;$j(a);return}function vv(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;f=Eb;Eb=Eb+16|0;e=f+8|0;b=f;a:do switch((jl(a,0)|0)<<24>>24|0){case 84:switch((jl(a,1)|0)<<24>>24|0){case 86:{c[a>>2]=(c[a>>2]|0)+2;d=rl(hl(a)|0)|0;c[e>>2]=d;if(!d)b=0;else b=Pv(a,e)|0;break a}case 84:{c[a>>2]=(c[a>>2]|0)+2;d=rl(hl(a)|0)|0;c[e>>2]=d;if(!d)b=0;else b=Qv(a,e)|0;break a}case 73:{c[a>>2]=(c[a>>2]|0)+2;d=rl(hl(a)|0)|0;c[e>>2]=d;if(!d)b=0;else b=Rv(a,e)|0;break a}case 83:{c[a>>2]=(c[a>>2]|0)+2;d=rl(hl(a)|0)|0;c[e>>2]=d;if(!d)b=0;else b=Sv(a,e)|0;break a}case 99:{c[a>>2]=(c[a>>2]|0)+2;if(Tv(a)|0){b=0;break a}if(Tv(a)|0){b=0;break a}d=il(hl(a)|0)|0;c[e>>2]=d;if(!d)b=0;else b=Uv(a,e)|0;break a}case 67:{c[a>>2]=(c[a>>2]|0)+2;d=hl(a)|0;g=rl(d)|0;c[e>>2]=g;do if(g){ol(b,a,1);if(pl(b)|0){b=0;break}if(nl(a,95)|0){g=rl(d)|0;c[b>>2]=g;if(!g)b=0;else b=Vv(a,b,e)|0;}else b=0;}else b=0;while(0);break a}case 87:{c[a>>2]=(c[a>>2]|0)+2;g=zs(hl(a)|0,0)|0;c[e>>2]=g;if(!g)b=0;else b=ql(a,17509,e)|0;break a}case 72:{c[a>>2]=(c[a>>2]|0)+2;g=zs(hl(a)|0,0)|0;c[e>>2]=g;if(!g)b=0;else b=Wv(a,e)|0;break a}default:{c[a>>2]=(c[a>>2]|0)+1;b=(jl(a,0)|0)<<24>>24==118;if(Tv(a)|0){b=0;break a}g=il(hl(a)|0)|0;c[e>>2]=g;do if(g)if(b){b=Xv(a,e)|0;break}else {b=Yv(a,e)|0;break}else b=0;while(0);break a}}case 71:{switch((jl(a,1)|0)<<24>>24|0){case 86:{c[a>>2]=(c[a>>2]|0)+2;g=zs(hl(a)|0,0)|0;c[e>>2]=g;if(!g)b=0;else b=Zv(a,e)|0;break a}case 82:break;default:{b=0;break a}}c[a>>2]=(c[a>>2]|0)+2;g=zs(hl(a)|0,0)|0;c[e>>2]=g;if(!g)b=0;else {g=dm(a,b)|0;if(g|(nl(a,95)|0))b=_v(a,e)|0;else b=0;}break}default:b=0;}while(0);Eb=f;return b|0}function wv(b,d){b=b|0;d=d|0;a[b>>0]=0;a[b+1>>0]=0;c[b+4>>2]=0;a[b+8>>0]=0;d=os(d+332|0)|0;c[b+12>>2]=d;return}function xv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;f=c[b+12>>2]|0;g=a+332|0;h=os(g)|0;d=a+288|0;b=f;while(1){if(b>>>0>=h>>>0){i=5;break}e=Mv(g,b)|0;e=c[e>>2]|0;a=c[e+8>>2]|0;if(a>>>0>=(Gn(d)|0)>>>0){b=1;break}a=ns(d,a)|0;c[e+12>>2]=c[a>>2];b=b+1|0;}if((i|0)==5){Nv(g,f);b=0;}return b|0}function yv(a){a=a|0;var b=0;a=c[a>>2]|0;if(ml(a)|0?(b=jl(a,0)|0,b<<24>>24!=69):0)return b<<24>>24==46|b<<24>>24==95|0;return 1}function zv(a,b){a=a|0;b=b|0;return Iv(a+368|0,b)|0}function Av(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;return Bv(a+368|0,b,c,d,e,f,g)|0}function Bv(b,d,e,f,g,h,i){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;var j=0,k=0,l=0,m=0,n=0;j=Eb;Eb=Eb+16|0;k=j+8|0;l=j;b=hm(b,36)|0;d=c[d>>2]|0;e=c[e>>2]|0;n=f;m=c[n+4>>2]|0;f=l;c[f>>2]=c[n>>2];c[f+4>>2]=m;g=c[g>>2]|0;h=c[h>>2]|0;i=a[i>>0]|0;c[k>>2]=c[l>>2];c[k+4>>2]=c[l+4>>2];Cv(b,d,e,k,g,h,i);Eb=j;return b|0}function Cv(b,d,e,f,g,h,i){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;jm(b,18,0,1,0);c[b>>2]=7176;c[b+8>>2]=d;c[b+12>>2]=e;d=f;e=c[d+4>>2]|0;f=b+16|0;c[f>>2]=c[d>>2];c[f+4>>2]=e;c[b+24>>2]=g;c[b+28>>2]=h;a[b+32>>0]=i;return}function Dv(a,b){return 1}function Ev(a,b){return 1}function Fv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;h=Eb;Eb=Eb+16|0;d=h+8|0;e=h;f=a+8|0;g=c[f>>2]|0;if(g|0?(Xb[c[(c[g>>2]|0)+16>>2]&127](g,b),!(Wm(c[f>>2]|0,b)|0)):0){fl(e,12713);c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];um(b,d);}Pk(c[a+12>>2]|0,b);Eb=h;return}function Gv(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;m=Eb;Eb=Eb+64|0;i=m+56|0;f=m+48|0;e=m+40|0;g=m+32|0;h=m+24|0;j=m+16|0;k=m+8|0;l=m;fl(f,12715);c[i>>2]=c[f>>2];c[i+4>>2]=c[f+4>>2];um(d,i);yn(b+16|0,d);fl(e,12711);c[i>>2]=c[e>>2];c[i+4>>2]=c[e+4>>2];um(d,i);e=c[b+8>>2]|0;if(e|0)Xb[c[(c[e>>2]|0)+20>>2]&127](e,d);f=b+28|0;e=c[f>>2]|0;if(e&1){fl(g,16906);c[i>>2]=c[g>>2];c[i+4>>2]=c[g+4>>2];um(d,i);e=c[f>>2]|0;}if(e&2){fl(h,16913);c[i>>2]=c[h>>2];c[i+4>>2]=c[h+4>>2];um(d,i);e=c[f>>2]|0;}if(e&4|0){fl(j,16923);c[i>>2]=c[j>>2];c[i+4>>2]=c[j+4>>2];um(d,i);}switch(a[b+32>>0]|0){case 1:{fl(k,17108);c[i>>2]=c[k>>2];c[i+4>>2]=c[k+4>>2];um(d,i);break}case 2:{fl(l,17111);c[i>>2]=c[l>>2];c[i+4>>2]=c[l+4>>2];um(d,i);break}}e=c[b+24>>2]|0;if(e|0)Pk(e,d);Eb=m;return}function Hv(a){a=a|0;$j(a);return}function Iv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Jv(a,e);Eb=d;return a|0}function Jv(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,9,1,1,1);c[a>>2]=7220;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function Kv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;fl(f,17447);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);yn(a+8|0,b);Qk(b,93);Eb=d;return}function Lv(a){a=a|0;$j(a);return}function Mv(a,b){a=a|0;b=b|0;return (Ov(a)|0)+(b<<2)|0}function Nv(a,b){a=a|0;b=b|0;c[a+4>>2]=(c[a>>2]|0)+(b<<2);return}function Ov(a){a=a|0;return c[a>>2]|0}function Pv(a,b){a=a|0;b=b|0;return mw(a+368|0,17826,b)|0}function Qv(a,b){a=a|0;b=b|0;return lw(a+368|0,17817,b)|0}function Rv(a,b){a=a|0;b=b|0;return kw(a+368|0,17803,b)|0}function Sv(a,b){a=a|0;b=b|0;return jw(a+368|0,17784,b)|0}function Tv(a){a=a|0;var b=0,c=0,d=0;d=Eb;Eb=Eb+16|0;b=d+8|0;c=d;if(!(nl(a,104)|0))if(nl(a,118)|0){ol(b,a,1);if(!(pl(b)|0)?nl(a,95)|0:0){ol(c,a,1);if(pl(c)|0)a=1;else a=(nl(a,95)|0)^1;}else a=1;}else a=1;else {ol(b,a,1);if(pl(b)|0)a=1;else a=(nl(a,95)|0)^1;}Eb=d;return a|0}function Uv(a,b){a=a|0;b=b|0;return iw(a+368|0,17757,b)|0}function Vv(a,b,c){a=a|0;b=b|0;c=c|0;return ew(a+368|0,b,c)|0}function Wv(a,b){a=a|0;b=b|0;return dw(a+368|0,17628,b)|0}function Xv(a,b){a=a|0;b=b|0;return cw(a+368|0,17610,b)|0}function Yv(a,b){a=a|0;b=b|0;return bw(a+368|0,17588,b)|0}function Zv(a,b){a=a|0;b=b|0;return aw(a+368|0,17568,b)|0}function _v(a,b){a=a|0;b=b|0;return $v(a+368|0,17543,b)|0}function $v(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function aw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function bw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function cw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function dw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function ew(a,b,d){a=a|0;b=b|0;d=d|0;a=hm(a,16)|0;fw(a,c[b>>2]|0,c[d>>2]|0);return a|0}function fw(a,b,d){a=a|0;b=b|0;d=d|0;jm(a,21,1,1,1);c[a>>2]=7264;c[a+8>>2]=b;c[a+12>>2]=d;return}function gw(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=Eb;Eb=Eb+32|0;e=d+16|0;g=d+8|0;f=d;fl(g,17669);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);fl(f,17694);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+12>>2]|0,b);Eb=d;return}function hw(a){a=a|0;$j(a);return}function iw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function jw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function kw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function lw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function mw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function nw(b,d,e){b=b|0;d=d|0;e=e|0;c[b>>2]=d;c[b+4>>2]=e;ow(b+8|0);ow(b+148|0);ks(b+288|0);pw(b+332|0);a[b+360>>0]=1;a[b+361>>0]=0;a[b+362>>0]=0;qw(b+368|0);return}function ow(a){a=a|0;var b=0;b=a+12|0;c[a>>2]=b;c[a+4>>2]=b;c[a+8>>2]=a+140;return}function pw(a){a=a|0;var b=0;b=a+12|0;c[a>>2]=b;c[a+4>>2]=b;c[a+8>>2]=a+28;return}function qw(a){a=a|0;rw(a);return}function rw(a){a=a|0;c[a>>2]=0;c[a+4>>2]=0;c[a+4096>>2]=a;return}function tw(a){a=a|0;c[a>>2]=7308;xw(a+4|0);return}function uw(a){a=a|0;tw(a);$j(a);return}function vw(a){a=a|0;return ww(a+4|0)|0}function ww(a){a=a|0;return c[a>>2]|0}function xw(a){a=a|0;var b=0,d=0;if((b=yw(c[a>>2]|0)|0,d=b+8|0,a=c[d>>2]|0,c[d>>2]=a+-1,(a|0)<1))$j(b);return}function yw(a){a=a|0;return a+-12|0}function zw(a){a=a|0;tw(a);$j(a);return}function Aw(a){a=a|0;$j(a);return}function Bw(a,b,c){a=a|0;b=b|0;return Ak(a,b,0)|0}function Cw(a){a=a|0;$j(a);return}function Dw(d,e,f){d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;n=Eb;Eb=Eb+64|0;l=n;do if(!(Ak(e,3368,0)|0)){if(Ew(d,e,0)|0){e=c[f>>2]|0;if(!e){e=1;break}c[f>>2]=c[e>>2];e=1;break}if((e|0)!=0?(g=Ek(e,2128,3296,0)|0,(g|0)!=0):0){e=c[f>>2]|0;if(e|0)c[f>>2]=c[e>>2];e=c[g+8>>2]|0;i=d+8|0;h=c[i>>2]|0;if((e&7&(h^7)|0)==0?((e&96^96)&h|0)==0:0){h=d+12|0;d=c[h>>2]|0;g=g+12|0;e=c[g>>2]|0;if(!(Ak(d,e,0)|0)){if(Ak(d,3360,0)|0){if(!e){e=1;break}e=(Ek(e,2128,3312,0)|0)==0;break}if(d){e=Ek(d,2128,3296,0)|0;if(e|0){if(!(c[i>>2]&1)){e=0;break}e=Fw(e,c[g>>2]|0)|0;break}e=c[h>>2]|0;if(e){e=Ek(e,2128,3328,0)|0;if(e|0){if(!(c[i>>2]&1)){e=0;break}e=Gw(e,c[g>>2]|0)|0;break}e=c[h>>2]|0;if((((e|0)!=0?(j=Ek(e,2128,2112,0)|0,(j|0)!=0):0)?(k=c[g>>2]|0,(k|0)!=0):0)?(m=Ek(k,2128,2112,0)|0,(m|0)!=0):0){c[l>>2]=m;c[l+4>>2]=0;c[l+8>>2]=j;c[l+12>>2]=-1;e=l+16|0;d=l+24|0;g=l+48|0;h=e;i=h+36|0;do{c[h>>2]=0;h=h+4|0;}while((h|0)<(i|0));b[e+36>>1]=0;a[e+38>>0]=0;c[g>>2]=1;$b[c[(c[m>>2]|0)+28>>2]&15](m,l,c[f>>2]|0,1);do if((c[d>>2]|0)==1){if(!(c[f>>2]|0)){e=1;break}c[f>>2]=c[e>>2];e=1;}else e=0;while(0)}else e=0;}else e=0;}else e=0;}else e=1;}else e=0;}else e=0;}else {c[f>>2]=0;e=1;}while(0);Eb=n;return e|0}function Ew(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;if(!(c[a+8>>2]&24))if((b|0)!=0?(e=Ek(b,2128,3280,0)|0,(e|0)!=0):0){d=(c[e+8>>2]&24|0)!=0;f=5;}else d=0;else {d=1;f=5;}if((f|0)==5)d=Ak(a,b,d)|0;return d|0}function Fw(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;while(1){if(!b){b=0;break}d=Ek(b,2128,3296,0)|0;if(!d){b=0;break}f=c[a+8>>2]|0;if(c[d+8>>2]&~f|0){b=0;break}e=a+12|0;b=c[e>>2]|0;d=d+12|0;if(Ak(b,c[d>>2]|0,0)|0){b=1;break}if((f&1|0)==0|(b|0)==0){b=0;break}a=Ek(b,2128,3296,0)|0;if(!a){h=9;break}b=c[d>>2]|0;}if((h|0)==9){b=c[e>>2]|0;if((b|0)!=0?(g=Ek(b,2128,3328,0)|0,(g|0)!=0):0)b=Gw(g,c[d>>2]|0)|0;else b=0;}return b|0}function Gw(a,b){a=a|0;b=b|0;var d=0;if((((b|0)!=0?(d=Ek(b,2128,3328,0)|0,(d|0)!=0):0)?(c[d+8>>2]&~c[a+8>>2]|0)==0:0)?Ak(c[a+12>>2]|0,c[d+12>>2]|0,0)|0:0)a=Ak(c[a+16>>2]|0,c[d+16>>2]|0,0)|0;else a=0;return a|0}function Hw(a){a=a|0;$j(a);return}function Iw(a,b,c){a=a|0;b=b|0;return Ak(a,b,0)|0}function Jw(a){a=a|0;$j(a);return}
            function Kw(b,d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;if(Ak(b,c[d+8>>2]|0,h)|0)Dk(0,d,e,f,g);else {r=d+52|0;j=a[r>>0]|0;q=d+53|0;i=a[q>>0]|0;p=c[b+12>>2]|0;m=b+16+(p<<3)|0;a[r>>0]=0;a[q>>0]=0;Ow(b+16|0,d,e,f,g,h);k=a[r>>0]|0;j=k|j;l=a[q>>0]|0;i=l|i;a:do if((p|0)>1){n=d+24|0;o=b+8|0;p=d+54|0;b=b+24|0;do{i=i&1;j=j&1;if(a[p>>0]|0)break a;if(!(k<<24>>24)){if(l<<24>>24?(c[o>>2]&1|0)==0:0)break a}else {if((c[n>>2]|0)==1)break a;if(!(c[o>>2]&2))break a}a[r>>0]=0;a[q>>0]=0;Ow(b,d,e,f,g,h);k=a[r>>0]|0;j=k|j;l=a[q>>0]|0;i=l|i;b=b+8|0;}while(b>>>0<m>>>0)}while(0);a[r>>0]=j<<24>>24!=0&1;a[q>>0]=i<<24>>24!=0&1;}return}function Lw(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;a:do if(!(Ak(b,c[d+8>>2]|0,g)|0)){if(!(Ak(b,c[d>>2]|0,g)|0)){p=c[b+12>>2]|0;k=b+16+(p<<3)|0;Pw(b+16|0,d,e,f,g);h=b+24|0;if((p|0)<=1)break;b=c[b+8>>2]|0;if((b&2|0)==0?(j=d+36|0,(c[j>>2]|0)!=1):0){if(!(b&1)){b=d+54|0;while(1){if(a[b>>0]|0)break a;if((c[j>>2]|0)==1)break a;Pw(h,d,e,f,g);h=h+8|0;if(h>>>0>=k>>>0)break a}}b=d+24|0;i=d+54|0;while(1){if(a[i>>0]|0)break a;if((c[j>>2]|0)==1?(c[b>>2]|0)==1:0)break a;Pw(h,d,e,f,g);h=h+8|0;if(h>>>0>=k>>>0)break a}}b=d+54|0;while(1){if(a[b>>0]|0)break a;Pw(h,d,e,f,g);h=h+8|0;if(h>>>0>=k>>>0)break a}}if((c[d+16>>2]|0)!=(e|0)?(p=d+20|0,(c[p>>2]|0)!=(e|0)):0){c[d+32>>2]=f;o=d+44|0;if((c[o>>2]|0)!=4){j=b+16+(c[b+12>>2]<<3)|0;k=d+52|0;f=d+53|0;l=d+54|0;m=b+8|0;n=d+24|0;h=0;i=b+16|0;b=0;b:while(1){if(i>>>0>=j>>>0){i=18;break}a[k>>0]=0;a[f>>0]=0;Ow(i,d,e,e,1,g);if(a[l>>0]|0){i=18;break}do if(a[f>>0]|0){if(!(a[k>>0]|0))if(!(c[m>>2]&1)){i=19;break b}else {b=1;break}if((c[n>>2]|0)==1){h=1;i=19;break b}if(!(c[m>>2]&2)){h=1;i=19;break b}else {h=1;b=1;}}while(0);i=i+8|0;}if((i|0)==18)if(b)i=19;else b=4;if((i|0)==19)b=3;c[o>>2]=b;if(h&1)break}c[p>>2]=e;e=d+40|0;c[e>>2]=(c[e>>2]|0)+1;if((c[d+36>>2]|0)!=1)break;if((c[d+24>>2]|0)!=2)break;a[d+54>>0]=1;break}if((f|0)==1)c[d+32>>2]=1;}else Ck(0,d,e,f);while(0);return}function Mw(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;a:do if(!(Ak(b,c[d+8>>2]|0,0)|0)){h=c[b+12>>2]|0;g=b+16+(h<<3)|0;Nw(b+16|0,d,e,f);if((h|0)>1){h=d+54|0;b=b+24|0;do{Nw(b,d,e,f);if(a[h>>0]|0)break a;b=b+8|0;}while(b>>>0<g>>>0)}}else Bk(0,d,e,f);while(0);return}function Nw(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;g=c[a+4>>2]|0;if(d){f=g>>8;if(g&1)f=c[(c[d>>2]|0)+f>>2]|0;}else f=0;a=c[a>>2]|0;$b[c[(c[a>>2]|0)+28>>2]&15](a,b,d+f|0,(g&2|0)==0?2:e);return}function Ow(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0;i=c[a+4>>2]|0;h=i>>8;if(i&1)h=c[(c[e>>2]|0)+h>>2]|0;a=c[a>>2]|0;bc[c[(c[a>>2]|0)+20>>2]&3](a,b,d,e+h|0,(i&2|0)==0?2:f,g);return}function Pw(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;h=c[a+4>>2]|0;g=h>>8;if(h&1)g=c[(c[d>>2]|0)+g>>2]|0;a=c[a>>2]|0;ac[c[(c[a>>2]|0)+24>>2]&7](a,b,d+g|0,(h&2|0)==0?2:e,f);return}function Qw(){return 0}function Rw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;f=Eb;Eb=Eb+16|0;e=f;c[e>>2]=c[d>>2];a=Pb[c[(c[a>>2]|0)+16>>2]&15](a,b,e)|0;if(a)c[d>>2]=c[e>>2];Eb=f;return a&1|0}function Sw(a){a=a|0;if(!a)a=0;else a=(Ek(a,2128,3296,0)|0)!=0&1;return a|0}function Tw(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;f=a&65535;e=b&65535;c=A(e,f)|0;d=a>>>16;a=(c>>>16)+(A(e,d)|0)|0;e=b>>>16;b=A(e,f)|0;return (E((a>>>16)+(A(e,d)|0)+(((a&65535)+b|0)>>>16)|0),a+b<<16|c&65535|0)|0}function Uw(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;e=a;f=c;c=Tw(e,f)|0;a=F()|0;return (E((A(b,f)|0)+(A(d,e)|0)+a|a&0|0),c|0|0)|0}function Vw(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;c=a+c>>>0;return (E(b+d+(c>>>0<a>>>0|0)>>>0|0),c|0)|0}function Ww(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;d=b-d-(c>>>0>a>>>0|0)>>>0;return (E(d|0),a-c>>>0|0)|0}function Xw(a){a=a|0;return (a?31-(C(a^a-1)|0)|0:32)|0}function Yw(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;l=a;j=b;k=j;h=d;n=e;i=n;if(!k){g=(f|0)!=0;if(!i){if(g){c[f>>2]=(l>>>0)%(h>>>0);c[f+4>>2]=0;}n=0;f=(l>>>0)/(h>>>0)>>>0;return (E(n|0),f)|0}else {if(!g){n=0;f=0;return (E(n|0),f)|0}c[f>>2]=a|0;c[f+4>>2]=b&0;n=0;f=0;return (E(n|0),f)|0}}g=(i|0)==0;do if(h){if(!g){g=(C(i|0)|0)-(C(k|0)|0)|0;if(g>>>0<=31){m=g+1|0;i=31-g|0;b=g-31>>31;h=m;a=l>>>(m>>>0)&b|k<<i;b=k>>>(m>>>0)&b;g=0;i=l<<i;break}if(!f){n=0;f=0;return (E(n|0),f)|0}c[f>>2]=a|0;c[f+4>>2]=j|b&0;n=0;f=0;return (E(n|0),f)|0}g=h-1|0;if(g&h|0){i=(C(h|0)|0)+33-(C(k|0)|0)|0;p=64-i|0;m=32-i|0;j=m>>31;o=i-32|0;b=o>>31;h=i;a=m-1>>31&k>>>(o>>>0)|(k<<m|l>>>(i>>>0))&b;b=b&k>>>(i>>>0);g=l<<p&j;i=(k<<p|l>>>(o>>>0))&j|l<<m&i-33>>31;break}if(f|0){c[f>>2]=g&l;c[f+4>>2]=0;}if((h|0)==1){o=j|b&0;p=a|0|0;return (E(o|0),p)|0}else {p=Xw(h|0)|0;o=k>>>(p>>>0)|0;p=k<<32-p|l>>>(p>>>0)|0;return (E(o|0),p)|0}}else {if(g){if(f|0){c[f>>2]=(k>>>0)%(h>>>0);c[f+4>>2]=0;}o=0;p=(k>>>0)/(h>>>0)>>>0;return (E(o|0),p)|0}if(!l){if(f|0){c[f>>2]=0;c[f+4>>2]=(k>>>0)%(i>>>0);}o=0;p=(k>>>0)/(i>>>0)>>>0;return (E(o|0),p)|0}g=i-1|0;if(!(g&i)){if(f|0){c[f>>2]=a|0;c[f+4>>2]=g&k|b&0;}o=0;p=k>>>((Xw(i|0)|0)>>>0);return (E(o|0),p)|0}g=(C(i|0)|0)-(C(k|0)|0)|0;if(g>>>0<=30){b=g+1|0;i=31-g|0;h=b;a=k<<i|l>>>(b>>>0);b=k>>>(b>>>0);g=0;i=l<<i;break}if(!f){o=0;p=0;return (E(o|0),p)|0}c[f>>2]=a|0;c[f+4>>2]=j|b&0;o=0;p=0;return (E(o|0),p)|0}while(0);if(!h){k=i;j=0;i=0;}else {m=d|0|0;l=n|e&0;k=Vw(m|0,l|0,-1,-1)|0;d=F()|0;j=i;i=0;do{e=j;j=g>>>31|j<<1;g=i|g<<1;e=a<<1|e>>>31|0;n=a>>>31|b<<1|0;Ww(k|0,d|0,e|0,n|0)|0;p=F()|0;o=p>>31|((p|0)<0?-1:0)<<1;i=o&1;a=Ww(e|0,n|0,o&m|0,(((p|0)<0?-1:0)>>31|((p|0)<0?-1:0)<<1)&l|0)|0;b=F()|0;h=h-1|0;}while((h|0)!=0);k=j;j=0;}h=0;if(f|0){c[f>>2]=a;c[f+4>>2]=b;}o=(g|0)>>>31|(k|h)<<1|(h<<1|g>>>31)&0|j;p=(g<<1|0>>>31)&-2|i;return (E(o|0),p)|0}function Zw(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Yw(a,b,c,d,0)|0}function _w(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){E(b>>>c|0);return a>>>c|(b&(1<<c)-1)<<32-c}E(0);return b>>>c-32|0}function $w(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){E(b<<c|(a&(1<<c)-1<<32-c)>>>32-c|0);return a<<c}E(a<<c-32|0);return 0}function ax(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;if((e|0)>=8192){ya(b|0,d|0,e|0)|0;return b|0}h=b|0;g=b+e|0;if((b&3)==(d&3)){while(b&3){if(!e)return h|0;a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;e=e-1|0;}e=g&-4|0;f=e-64|0;while((b|0)<=(f|0)){c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[b+16>>2]=c[d+16>>2];c[b+20>>2]=c[d+20>>2];c[b+24>>2]=c[d+24>>2];c[b+28>>2]=c[d+28>>2];c[b+32>>2]=c[d+32>>2];c[b+36>>2]=c[d+36>>2];c[b+40>>2]=c[d+40>>2];c[b+44>>2]=c[d+44>>2];c[b+48>>2]=c[d+48>>2];c[b+52>>2]=c[d+52>>2];c[b+56>>2]=c[d+56>>2];c[b+60>>2]=c[d+60>>2];b=b+64|0;d=d+64|0;}while((b|0)<(e|0)){c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}}else {e=g-4|0;while((b|0)<(e|0)){a[b>>0]=a[d>>0]|0;a[b+1>>0]=a[d+1>>0]|0;a[b+2>>0]=a[d+2>>0]|0;a[b+3>>0]=a[d+3>>0]|0;b=b+4|0;d=d+4|0;}}while((b|0)<(g|0)){a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;}return h|0}function bx(b,c,d){b=b|0;c=c|0;d=d|0;var e=0;if((c|0)<(b|0)&(b|0)<(c+d|0)){e=b;c=c+d|0;b=b+d|0;while((d|0)>0){b=b-1|0;c=c-1|0;d=d-1|0;a[b>>0]=a[c>>0]|0;}b=e;}else ax(b,c,d)|0;return b|0}function cx(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;h=b+e|0;d=d&255;if((e|0)>=67){while(b&3){a[b>>0]=d;b=b+1|0;}f=h&-4|0;i=d|d<<8|d<<16|d<<24;g=f-64|0;while((b|0)<=(g|0)){c[b>>2]=i;c[b+4>>2]=i;c[b+8>>2]=i;c[b+12>>2]=i;c[b+16>>2]=i;c[b+20>>2]=i;c[b+24>>2]=i;c[b+28>>2]=i;c[b+32>>2]=i;c[b+36>>2]=i;c[b+40>>2]=i;c[b+44>>2]=i;c[b+48>>2]=i;c[b+52>>2]=i;c[b+56>>2]=i;c[b+60>>2]=i;b=b+64|0;}while((b|0)<(f|0)){c[b>>2]=i;b=b+4|0;}}while((b|0)<(h|0)){a[b>>0]=d;b=b+1|0;}return h-e|0}function dx(a){a=a|0;var b=0,d=0,e=0;e=xa()|0;d=c[i>>2]|0;b=d+a|0;if((a|0)>0&(b|0)<(d|0)|(b|0)<0){Ba(b|0)|0;_(12);return -1}if((b|0)>(e|0))if(!(za(b|0)|0)){_(12);return -1}c[i>>2]=b;return d|0}function ex(a,b){a=a|0;b=b|0;return +Ib[a&7](b|0)}function fx(a,b,c){a=a|0;b=b|0;c=c|0;return +Jb[a&7](b|0,c|0)}function gx(a){a=a|0;return Kb[a&7]()|0}function hx(a,b){a=a|0;b=b|0;return Lb[a&63](b|0)|0}function ix(a,b,c,d){a=a|0;b=b|0;c=+c;d=+d;return Mb[a&3](b|0,+c,+d)|0}function jx(a,b,c,d,e,f,g){a=a|0;b=b|0;c=+c;d=d|0;e=e|0;f=f|0;g=g|0;return Nb[a&1](b|0,+c,d|0,e|0,f|0,g|0)|0}function kx(a,b,c){a=a|0;b=b|0;c=c|0;return Ob[a&63](b|0,c|0)|0}function lx(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Pb[a&15](b|0,c|0,d|0)|0}function mx(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;return Qb[a&15](b|0,c|0,d|0,e|0)|0}function nx(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;return Rb[a&7](b|0,c|0,d|0,e|0,f|0)|0}function ox(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;return Sb[a&3](b|0,c|0,d|0,e|0,f|0,g|0)|0}function px(a){a=a|0;Tb[a&3]();}function qx(a,b){a=a|0;b=b|0;Ub[a&127](b|0);}function rx(a,b,c){a=a|0;b=b|0;c=+c;Vb[a&15](b|0,+c);}function sx(a,b,c,d){a=a|0;b=b|0;c=+c;d=+d;Wb[a&1](b|0,+c,+d);}function tx(a,b,c){a=a|0;b=b|0;c=c|0;Xb[a&127](b|0,c|0);}function ux(a,b,c,d){a=a|0;b=b|0;c=c|0;d=+d;Yb[a&15](b|0,c|0,+d);}function vx(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;Zb[a&31](b|0,c|0,d|0);}function wx(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=+e;_b[a&7](b|0,c|0,d|0,+e);}function xx(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;$b[a&15](b|0,c|0,d|0,e|0);}function yx(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;ac[a&7](b|0,c|0,d|0,e|0,f|0);}function zx(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;bc[a&3](b|0,c|0,d|0,e|0,f|0,g|0);}function Ax(a){D(0);return 0.0}function Bx(a,b){D(1);return 0.0}function Cx(){D(2);return 0}function Dx(a){D(3);return 0}function Ex(a,b,c){D(4);return 0}function Fx(a,b,c,d,e,f){D(5);return 0}function Gx(a,b){D(6);return 0}function Hx(a,b,c){D(7);return 0}function Ix(a,b,c,d){D(8);return 0}function Jx(a,b,c,d,e){D(9);return 0}function Kx(a,b,c,d,e,f){D(10);return 0}function Lx(){D(11);}function Mx(){U();}function Nx(a){D(12);}function Ox(a,b){D(13);}function Px(a,b,c){D(14);}function Qx(a,b){D(15);}function Rx(a,b,c){D(16);}function Sx(a,b,c){D(17);}function Tx(a,b,c,d){D(18);}function Ux(a,b,c,d){D(19);}function Vx(a,b,c,d,e){D(20);}function Wx(a,b,c,d,e,f){D(21);}

            // EMSCRIPTEN_END_FUNCS
            var Ib=[Ax,ge,ie,rc,oe,qe,se,ue];var Jb=[Bx,hf,vg,Ng,qh,Bx,Bx,Bx];var Kb=[Cx,Of,ng,rf,Ef,cg,Cx,Cx];var Lb=[Dx,Tc,Fe,th,vw,ff,Mf,Pf,me,nc,oc,pc,mc,jg,lg,mg,og,kc,lc,qc,Lg,Pg,we,Xg,Zg,_g,$g,ye,Ae,hh,pf,sf,sc,Cf,Ff,Gc,ag,dg,jc,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx];var Mb=[Ex,kf,kh,Ex];var Nb=[Fx,Eh];var Ob=[Gx,km,lm,mm,nm,Mm,Zm,Pn,Qn,Rn,Sn,ss,ts,us,vs,Gt,Qt,Rt,Iu,Ju,Ku,av,bv,Dv,Ev,kd,df,ef,Qf,Sf,Vf,Wf,Xf,rg,tg,ug,tc,Ug,Vg,ah,fh,jh,vf,If,gg,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx];var Pb=[Hx,uh,_h,wk,Bw,Dw,Iw,wg,wf,nf,Jf,Af,hg,_f,Hx,Hx];var Qb=[Ix,Ec,vh,Fc,Nc,Pc,xf,Lf,ig,Ix,Ix,Ix,Ix,Ix,Ix,Ix];var Rb=[Jx,Rg,Sg,bh,Oc,dh,Qc,Jx];var Sb=[Kx,ch,eh,Kx];var Tb=[Lx,Mx,mk,Lx];var Ub=[Nx,xd,De,yc,Ac,Hc,Ic,Ed,Ce,Cc,Ee,pg,qg,sk,tk,uk,vk,Fk,rm,sm,xm,Em,Im,Pm,an,kn,xn,Vn,no,so,xo,Co,Go,Lo,Ro,vp,zp,Dp,Hp,Lp,Qp,Vp,_p,gq,mq,uq,yq,Gq,Lq,Pq,_q,hr,mr,rr,wr,Br,Hr,Mr,Tr,Yr,bs,is,ys,Es,Os,Us,_s,ct,it,rt,wt,Ct,Jt,Ut,fu,lu,Nu,Su,Wu,ev,iv,mv,qv,uv,Hv,Lv,hw,tw,uw,zw,Aw,Cw,Hw,Jw,gf,Nf,kg,ic,Bd,Kd,Mg,Qg,Yg,ih,wd,qf,Df,bg,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx];var Vb=[Ox,he,je,Qd,Sd,pe,re,te,ve,Ox,Ox,Ox,Ox,Ox,Ox,Ox];var Wb=[Px,hc];var Xb=[Qx,om,pm,qm,Cm,Dm,Hm,Nm,Om,_m,$m,hn,jn,wn,Tn,Un,mo,ro,wo,Bo,Fo,Ko,Qo,up,yp,Cp,Gp,Kp,Np,Up,Zp,fq,lq,tq,xq,Eq,Fq,Kq,Oq,Yq,Zq,gr,lr,qr,ur,vr,Ar,Gr,Lr,Sr,Xr,as,hs,ws,xs,Ds,Ms,Ns,Ts,Zs,bt,ht,qt,ut,vt,At,Bt,Ht,It,St,Tt,eu,ku,Lu,Mu,Ru,Vu,cv,dv,hv,lv,pv,tv,Fv,Gv,Kv,gw,$d,be,ce,ee,sg,Nd,Yd,Zd,_d,Jg,Kg,Tg,Jc,xe,ze,Be,ph,od,pd,rd,Fh,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx];var Yb=[Rx,jf,Pd,Bg,Rd,Dg,Og,Cd,Fd,rh,Rx,Rx,Rx,Rx,Rx,Rx];var Zb=[Sx,bf,cf,Rf,Tf,Ld,Md,zg,Wd,Hg,Ig,Wg,gh,tf,lf,mf,Gf,yf,zf,eg,Yf,Zf,Sx,Sx,Sx,Sx,Sx,Sx,Sx,Sx,Sx,Sx];var _b=[Tx,Ag,Cg,nh,oh,Tx,Tx,Tx];var $b=[Ux,zk,Ik,Mw,xg,yg,Ud,Vd,Gg,yd,zd,uf,Hf,fg,Ux,Ux];var ac=[Vx,yk,Hk,Lw,Eg,Fg,lh,mh];var bc=[Wx,xk,Gk,Kw];return {__ZSt18uncaught_exceptionv:Xj,___cxa_can_catch:Rw,___cxa_is_pointer_type:Sw,___embind_register_native_and_builtin_types:ii,___getTypeName:Wj,___muldi3:Uw,___udivdi3:Zw,_bitshift64Lshr:_w,_bitshift64Shl:$w,_emscripten_replace_memory:Hb,_free:ik,_i64Add:Vw,_i64Subtract:Ww,_malloc:hk,_memcpy:ax,_memmove:bx,_memset:cx,_sbrk:dx,dynCall_di:ex,dynCall_dii:fx,dynCall_i:gx,dynCall_ii:hx,dynCall_iidd:ix,dynCall_iidiiii:jx,dynCall_iii:kx,dynCall_iiii:lx,dynCall_iiiii:mx,dynCall_iiiiii:nx,dynCall_iiiiiii:ox,dynCall_v:px,dynCall_vi:qx,dynCall_vid:rx,dynCall_vidd:sx,dynCall_vii:tx,dynCall_viid:ux,dynCall_viii:vx,dynCall_viiid:wx,dynCall_viiii:xx,dynCall_viiiii:yx,dynCall_viiiiii:zx,establishStackSpace:gc,globalCtors:cc,stackAlloc:dc,stackRestore:fc,stackSave:ec}})


            // EMSCRIPTEN_END_ASM
            (asmGlobalArg,asmLibraryArg,buffer);var __ZSt18uncaught_exceptionv=Module["__ZSt18uncaught_exceptionv"]=asm["__ZSt18uncaught_exceptionv"];var ___cxa_can_catch=Module["___cxa_can_catch"]=asm["___cxa_can_catch"];var ___cxa_is_pointer_type=Module["___cxa_is_pointer_type"]=asm["___cxa_is_pointer_type"];var ___embind_register_native_and_builtin_types=Module["___embind_register_native_and_builtin_types"]=asm["___embind_register_native_and_builtin_types"];var ___getTypeName=Module["___getTypeName"]=asm["___getTypeName"];var ___muldi3=Module["___muldi3"]=asm["___muldi3"];var ___udivdi3=Module["___udivdi3"]=asm["___udivdi3"];var _bitshift64Lshr=Module["_bitshift64Lshr"]=asm["_bitshift64Lshr"];var _bitshift64Shl=Module["_bitshift64Shl"]=asm["_bitshift64Shl"];var _emscripten_replace_memory=Module["_emscripten_replace_memory"]=asm["_emscripten_replace_memory"];var _free=Module["_free"]=asm["_free"];var _i64Add=Module["_i64Add"]=asm["_i64Add"];var _i64Subtract=Module["_i64Subtract"]=asm["_i64Subtract"];var _malloc=Module["_malloc"]=asm["_malloc"];var _memcpy=Module["_memcpy"]=asm["_memcpy"];var _memmove=Module["_memmove"]=asm["_memmove"];var _memset=Module["_memset"]=asm["_memset"];var _sbrk=Module["_sbrk"]=asm["_sbrk"];var establishStackSpace=Module["establishStackSpace"]=asm["establishStackSpace"];var globalCtors=Module["globalCtors"]=asm["globalCtors"];var stackAlloc=Module["stackAlloc"]=asm["stackAlloc"];var stackRestore=Module["stackRestore"]=asm["stackRestore"];var stackSave=Module["stackSave"]=asm["stackSave"];var dynCall_di=Module["dynCall_di"]=asm["dynCall_di"];var dynCall_dii=Module["dynCall_dii"]=asm["dynCall_dii"];var dynCall_i=Module["dynCall_i"]=asm["dynCall_i"];var dynCall_ii=Module["dynCall_ii"]=asm["dynCall_ii"];var dynCall_iidd=Module["dynCall_iidd"]=asm["dynCall_iidd"];var dynCall_iidiiii=Module["dynCall_iidiiii"]=asm["dynCall_iidiiii"];var dynCall_iii=Module["dynCall_iii"]=asm["dynCall_iii"];var dynCall_iiii=Module["dynCall_iiii"]=asm["dynCall_iiii"];var dynCall_iiiii=Module["dynCall_iiiii"]=asm["dynCall_iiiii"];var dynCall_iiiiii=Module["dynCall_iiiiii"]=asm["dynCall_iiiiii"];var dynCall_iiiiiii=Module["dynCall_iiiiiii"]=asm["dynCall_iiiiiii"];var dynCall_v=Module["dynCall_v"]=asm["dynCall_v"];var dynCall_vi=Module["dynCall_vi"]=asm["dynCall_vi"];var dynCall_vid=Module["dynCall_vid"]=asm["dynCall_vid"];var dynCall_vidd=Module["dynCall_vidd"]=asm["dynCall_vidd"];var dynCall_vii=Module["dynCall_vii"]=asm["dynCall_vii"];var dynCall_viid=Module["dynCall_viid"]=asm["dynCall_viid"];var dynCall_viii=Module["dynCall_viii"]=asm["dynCall_viii"];var dynCall_viiid=Module["dynCall_viiid"]=asm["dynCall_viiid"];var dynCall_viiii=Module["dynCall_viiii"]=asm["dynCall_viiii"];var dynCall_viiiii=Module["dynCall_viiiii"]=asm["dynCall_viiiii"];var dynCall_viiiiii=Module["dynCall_viiiiii"]=asm["dynCall_viiiiii"];Module["asm"]=asm;if(memoryInitializer){if(!isDataURI(memoryInitializer)){memoryInitializer=locateFile(memoryInitializer);}{addRunDependency();var applyMemoryInitializer=function(data){if(data.byteLength)data=new Uint8Array(data);HEAPU8.set(data,GLOBAL_BASE);if(Module["memoryInitializerRequest"])delete Module["memoryInitializerRequest"].response;removeRunDependency();};var doBrowserLoad=function(){readAsync(memoryInitializer,applyMemoryInitializer,function(){throw "could not load memory initializer "+memoryInitializer});};var memoryInitializerBytes=tryParseAsDataURI(memoryInitializer);if(memoryInitializerBytes){applyMemoryInitializer(memoryInitializerBytes.buffer);}else if(Module["memoryInitializerRequest"]){var useRequest=function(){var request=Module["memoryInitializerRequest"];var response=request.response;if(request.status!==200&&request.status!==0){var data=tryParseAsDataURI(Module["memoryInitializerRequestURL"]);if(data){response=data.buffer;}else {console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: "+request.status+", retrying "+memoryInitializer);doBrowserLoad();return}}applyMemoryInitializer(response);};if(Module["memoryInitializerRequest"].response){setTimeout(useRequest,0);}else {Module["memoryInitializerRequest"].addEventListener("load",useRequest);}}else {doBrowserLoad();}}}var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller;};function run(args){if(runDependencies>0){return}preRun();if(runDependencies>0)return;function doRun(){if(calledRun)return;calledRun=true;if(ABORT)return;initRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun();}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("");},1);doRun();},1);}else {doRun();}}Module["run"]=run;function abort(what){if(Module["onAbort"]){Module["onAbort"](what);}what+="";out(what);err(what);ABORT=true;throw "abort("+what+"). Build with -s ASSERTIONS=1 for more info."}Module["abort"]=abort;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()();}}noExitRuntime=true;run();

              return Module;
            }

            var clipper = { init: init$1 };

            var jsAngusjClipperjsWeb = createCommonjsModule$1(function (module, exports) {
            var __awaiter = (commonjsGlobal$1 && commonjsGlobal$1.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
                    function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            var __generator = (commonjsGlobal$1 && commonjsGlobal$1.__generator) || function (thisArg, body) {
                var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
                return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
                function verb(n) { return function (v) { return step([n, v]); }; }
                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [op[0] & 2, t.value];
                        switch (op[0]) {
                            case 0: case 1: t = op; break;
                            case 4: _.label++; return { value: op[1], done: false };
                            case 5: _.label++; y = op[1]; op = [0]; continue;
                            case 7: op = _.ops.pop(); _.trys.pop(); continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                                if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                                if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                                if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                                if (t[2]) _.ops.pop();
                                _.trys.pop(); continue;
                        }
                        op = body.call(thisArg, _);
                    } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
                    if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
                }
            };
            Object.defineProperty(exports, "__esModule", { value: true });


            exports.ClipperError = ClipperError_1.ClipperError;


            exports.ClipType = enums.ClipType;
            exports.EndType = enums.EndType;
            exports.JoinType = enums.JoinType;
            exports.NativeClipperLibLoadedFormat = enums.NativeClipperLibLoadedFormat;
            exports.NativeClipperLibRequestedFormat = enums.NativeClipperLibRequestedFormat;
            exports.PointInPolygonResult = enums.PointInPolygonResult;
            exports.PolyFillType = enums.PolyFillType;



            exports.PolyNode = PolyNode_1.PolyNode;

            exports.PolyTree = PolyTree_1.PolyTree;
            var wasmModule;
            var asmJsModule;
            /**
             * A wrapper for the Native Clipper Library instance with all the operations available.
             */
            var ClipperLibWrapper = /** @class */ (function () {
                /**
                 * Internal constructor. Use loadNativeClipperLibInstanceAsync instead.
                 *
                 * @param instance
                 * @param format
                 */
                function ClipperLibWrapper(instance, format) {
                    this.format = format;
                    this.instance = instance;
                }
                /**
                 * Performs a polygon clipping (boolean) operation, returning the resulting Paths or throwing an error if failed.
                 *
                 * The solution parameter in this case is a Paths or PolyTree structure. The Paths structure is simpler than the PolyTree structure. Because of this it is
                 * quicker to populate and hence clipping performance is a little better (it's roughly 10% faster). However, the PolyTree data structure provides more
                 * information about the returned paths which may be important to users. Firstly, the PolyTree structure preserves nested parent-child polygon relationships
                 * (ie outer polygons owning/containing holes and holes owning/containing other outer polygons etc). Also, only the PolyTree structure can differentiate
                 * between open and closed paths since each PolyNode has an IsOpen property. (The Path structure has no member indicating whether it's open or closed.)
                 * For this reason, when open paths are passed to a Clipper object, the user must use a PolyTree object as the solution parameter, otherwise an exception
                 * will be raised.
                 *
                 * When a PolyTree object is used in a clipping operation on open paths, two ancilliary functions have been provided to quickly separate out open and
                 * closed paths from the solution - OpenPathsFromPolyTree and ClosedPathsFromPolyTree. PolyTreeToPaths is also available to convert path data to a Paths
                 * structure (irrespective of whether they're open or closed).
                 *
                 * There are several things to note about the solution paths returned:
                 * - they aren't in any specific order
                 * - they should never overlap or be self-intersecting (but see notes on rounding)
                 * - holes will be oriented opposite outer polygons
                 * - the solution fill type can be considered either EvenOdd or NonZero since it will comply with either filling rule
                 * - polygons may rarely share a common edge (though this is now very rare as of version 6)
                 *
                 * @param params - clipping operation data
                 * @return {Paths} - the resulting Paths.
                 */
                ClipperLibWrapper.prototype.clipToPaths = function (params) {
                    return clipFunctions.clipToPaths(this.instance, params);
                };
                /**
                 * Performs a polygon clipping (boolean) operation, returning the resulting PolyTree or throwing an error if failed.
                 *
                 * The solution parameter in this case is a Paths or PolyTree structure. The Paths structure is simpler than the PolyTree structure. Because of this it is
                 * quicker to populate and hence clipping performance is a little better (it's roughly 10% faster). However, the PolyTree data structure provides more
                 * information about the returned paths which may be important to users. Firstly, the PolyTree structure preserves nested parent-child polygon relationships
                 * (ie outer polygons owning/containing holes and holes owning/containing other outer polygons etc). Also, only the PolyTree structure can differentiate
                 * between open and closed paths since each PolyNode has an IsOpen property. (The Path structure has no member indicating whether it's open or closed.)
                 * For this reason, when open paths are passed to a Clipper object, the user must use a PolyTree object as the solution parameter, otherwise an exception
                 * will be raised.
                 *
                 * When a PolyTree object is used in a clipping operation on open paths, two ancilliary functions have been provided to quickly separate out open and
                 * closed paths from the solution - OpenPathsFromPolyTree and ClosedPathsFromPolyTree. PolyTreeToPaths is also available to convert path data to a Paths
                 * structure (irrespective of whether they're open or closed).
                 *
                 * There are several things to note about the solution paths returned:
                 * - they aren't in any specific order
                 * - they should never overlap or be self-intersecting (but see notes on rounding)
                 * - holes will be oriented opposite outer polygons
                 * - the solution fill type can be considered either EvenOdd or NonZero since it will comply with either filling rule
                 * - polygons may rarely share a common edge (though this is now very rare as of version 6)
                 *
                 * @param params - clipping operation data
                 * @return {PolyTree} - the resulting PolyTree or undefined.
                 */
                ClipperLibWrapper.prototype.clipToPolyTree = function (params) {
                    return clipFunctions.clipToPolyTree(this.instance, params);
                };
                /**
                 * Performs a polygon offset operation, returning the resulting Paths or undefined if failed.
                 *
                 * This method encapsulates the process of offsetting (inflating/deflating) both open and closed paths using a number of different join types
                 * and end types.
                 *
                 * Preconditions for offsetting:
                 * 1. The orientations of closed paths must be consistent such that outer polygons share the same orientation, and any holes have the opposite orientation
                 * (ie non-zero filling). Open paths must be oriented with closed outer polygons.
                 * 2. Polygons must not self-intersect.
                 *
                 * Limitations:
                 * When offsetting, small artefacts may appear where polygons overlap. To avoid these artefacts, offset overlapping polygons separately.
                 *
                 * @param params - offset operation params
                 * @return {Paths|undefined} - the resulting Paths or undefined if failed.
                 */
                ClipperLibWrapper.prototype.offsetToPaths = function (params) {
                    return offsetFunctions.offsetToPaths(this.instance, params);
                };
                /**
                 * Performs a polygon offset operation, returning the resulting PolyTree or undefined if failed.
                 *
                 * This method encapsulates the process of offsetting (inflating/deflating) both open and closed paths using a number of different join types
                 * and end types.
                 *
                 * Preconditions for offsetting:
                 * 1. The orientations of closed paths must be consistent such that outer polygons share the same orientation, and any holes have the opposite orientation
                 * (ie non-zero filling). Open paths must be oriented with closed outer polygons.
                 * 2. Polygons must not self-intersect.
                 *
                 * Limitations:
                 * When offsetting, small artefacts may appear where polygons overlap. To avoid these artefacts, offset overlapping polygons separately.
                 *
                 * @param params - offset operation params
                 * @return {PolyTree|undefined} - the resulting PolyTree or undefined if failed.
                 */
                ClipperLibWrapper.prototype.offsetToPolyTree = function (params) {
                    return offsetFunctions.offsetToPolyTree(this.instance, params);
                };
                //noinspection JSMethodCanBeStatic
                /**
                 * This function returns the area of the supplied polygon. It's assumed that the path is closed and does not self-intersect. Depending on orientation,
                 * this value may be positive or negative. If Orientation is true, then the area will be positive and conversely, if Orientation is false, then the
                 * area will be negative.
                 *
                 * @param path - The path
                 * @return {number} - Area
                 */
                ClipperLibWrapper.prototype.area = function (path) {
                    return functions.area(path);
                };
                /**
                 * Removes vertices:
                 * - that join co-linear edges, or join edges that are almost co-linear (such that if the vertex was moved no more than the specified distance the edges
                 * would be co-linear)
                 * - that are within the specified distance of an adjacent vertex
                 * - that are within the specified distance of a semi-adjacent vertex together with their out-lying vertices
                 *
                 * Vertices are semi-adjacent when they are separated by a single (out-lying) vertex.
                 *
                 * The distance parameter's default value is approximately √2 so that a vertex will be removed when adjacent or semi-adjacent vertices having their
                 * corresponding X and Y coordinates differing by no more than 1 unit. (If the egdes are semi-adjacent the out-lying vertex will be removed too.)
                 *
                 * @param path - The path to clean
                 * @param distance - How close points need to be before they are cleaned
                 * @return {Path} - The cleaned path
                 */
                ClipperLibWrapper.prototype.cleanPolygon = function (path, distance) {
                    if (distance === void 0) { distance = 1.1415; }
                    return functions.cleanPolygon(this.instance, path, distance);
                };
                /**
                 * Removes vertices:
                 * - that join co-linear edges, or join edges that are almost co-linear (such that if the vertex was moved no more than the specified distance the edges
                 * would be co-linear)
                 * - that are within the specified distance of an adjacent vertex
                 * - that are within the specified distance of a semi-adjacent vertex together with their out-lying vertices
                 *
                 * Vertices are semi-adjacent when they are separated by a single (out-lying) vertex.
                 *
                 * The distance parameter's default value is approximately √2 so that a vertex will be removed when adjacent or semi-adjacent vertices having their
                 * corresponding X and Y coordinates differing by no more than 1 unit. (If the egdes are semi-adjacent the out-lying vertex will be removed too.)
                 *
                 * @param paths - The paths to clean
                 * @param distance - How close points need to be before they are cleaned
                 * @return {Paths} - The cleaned paths
                 */
                ClipperLibWrapper.prototype.cleanPolygons = function (paths, distance) {
                    if (distance === void 0) { distance = 1.1415; }
                    return functions.cleanPolygons(this.instance, paths, distance);
                };
                //noinspection JSMethodCanBeStatic
                /**
                 * This function filters out open paths from the PolyTree structure and returns only closed paths in a Paths structure.
                 *
                 * @param polyTree
                 * @return {Paths}
                 */
                ClipperLibWrapper.prototype.closedPathsFromPolyTree = function (polyTree) {
                    return functions.closedPathsFromPolyTree(polyTree);
                };
                /**
                 *  Minkowski Difference is performed by subtracting each point in a polygon from the set of points in an open or closed path. A key feature of Minkowski
                 *  Difference is that when it's applied to two polygons, the resulting polygon will contain the coordinate space origin whenever the two polygons touch or
                 *  overlap. (This function is often used to determine when polygons collide.)
                 *
                 * @param poly1
                 * @param poly2
                 * @return {Paths}
                 */
                ClipperLibWrapper.prototype.minkowskiDiff = function (poly1, poly2) {
                    return functions.minkowskiDiff(this.instance, poly1, poly2);
                };
                /**
                 * Minkowski Addition is performed by adding each point in a polygon 'pattern' to the set of points in an open or closed path. The resulting polygon
                 * (or polygons) defines the region that the 'pattern' would pass over in moving from the beginning to the end of the 'path'.
                 *
                 * @param pattern
                 * @param path
                 * @param pathIsClosed
                 * @return {Paths}
                 */
                ClipperLibWrapper.prototype.minkowskiSumPath = function (pattern, path, pathIsClosed) {
                    return functions.minkowskiSumPath(this.instance, pattern, path, pathIsClosed);
                };
                /**
                 * Minkowski Addition is performed by adding each point in a polygon 'pattern' to the set of points in an open or closed path. The resulting polygon
                 * (or polygons) defines the region that the 'pattern' would pass over in moving from the beginning to the end of the 'path'.
                 *
                 * @param pattern
                 * @param paths
                 * @param pathIsClosed
                 * @return {Paths}
                 */
                ClipperLibWrapper.prototype.minkowskiSumPaths = function (pattern, paths, pathIsClosed) {
                    return functions.minkowskiSumPaths(this.instance, pattern, paths, pathIsClosed);
                };
                //noinspection JSMethodCanBeStatic
                /**
                 * This function filters out closed paths from the PolyTree structure and returns only open paths in a Paths structure.
                 *
                 * @param polyTree
                 * @return {ReadonlyPath[]}
                 */
                ClipperLibWrapper.prototype.openPathsFromPolyTree = function (polyTree) {
                    return functions.openPathsFromPolyTree(polyTree);
                };
                //noinspection JSMethodCanBeStatic
                /**
                 * Orientation is only important to closed paths. Given that vertices are declared in a specific order, orientation refers to the direction (clockwise or
                 * counter-clockwise) that these vertices progress around a closed path.
                 *
                 * Orientation is also dependent on axis direction:
                 * - On Y-axis positive upward displays, orientation will return true if the polygon's orientation is counter-clockwise.
                 * - On Y-axis positive downward displays, orientation will return true if the polygon's orientation is clockwise.
                 *
                 * Notes:
                 * - Self-intersecting polygons have indeterminate orientations in which case this function won't return a meaningful value.
                 * - The majority of 2D graphic display libraries (eg GDI, GDI+, XLib, Cairo, AGG, Graphics32) and even the SVG file format have their coordinate origins
                 * at the top-left corner of their respective viewports with their Y axes increasing downward. However, some display libraries (eg Quartz, OpenGL) have their
                 * coordinate origins undefined or in the classic bottom-left position with their Y axes increasing upward.
                 * - For Non-Zero filled polygons, the orientation of holes must be opposite that of outer polygons.
                 * - For closed paths (polygons) in the solution returned by the clip method, their orientations will always be true for outer polygons and false
                 * for hole polygons (unless the reverseSolution property has been enabled).
                 *
                 * @param path - Path
                 * @return {boolean}
                 */
                ClipperLibWrapper.prototype.orientation = function (path) {
                    return functions.orientation(path);
                };
                //noinspection JSMethodCanBeStatic
                /**
                 * Returns PointInPolygonResult.Outside when false, PointInPolygonResult.OnBoundary when point is on poly and PointInPolygonResult.Inside when point is in
                 * poly.
                 *
                 * It's assumed that 'poly' is closed and does not self-intersect.
                 *
                 * @param point
                 * @param path
                 * @return {PointInPolygonResult}
                 */
                ClipperLibWrapper.prototype.pointInPolygon = function (point, path) {
                    return functions.pointInPolygon(point, path);
                };
                //noinspection JSMethodCanBeStatic
                /**
                 * This function converts a PolyTree structure into a Paths structure.
                 *
                 * @param polyTree
                 * @return {Paths}
                 */
                ClipperLibWrapper.prototype.polyTreeToPaths = function (polyTree) {
                    return functions.polyTreeToPaths(polyTree);
                };
                //noinspection JSMethodCanBeStatic
                /**
                 * Reverses the vertex order (and hence orientation) in the specified path.
                 *
                 * @param path - Path to reverse, which gets overwritten rather than copied
                 */
                ClipperLibWrapper.prototype.reversePath = function (path) {
                    functions.reversePath(path);
                };
                //noinspection JSMethodCanBeStatic
                /**
                 * Reverses the vertex order (and hence orientation) in each contained path.
                 *
                 * @param paths - Paths to reverse, which get overwritten rather than copied
                 */
                ClipperLibWrapper.prototype.reversePaths = function (paths) {
                    functions.reversePaths(paths);
                };
                /**
                 * Removes self-intersections from the supplied polygon (by performing a boolean union operation using the nominated PolyFillType).
                 * Polygons with non-contiguous duplicate vertices (ie 'touching') will be split into two polygons.
                 *
                 * Note: There's currently no guarantee that polygons will be strictly simple since 'simplifying' is still a work in progress.
                 *
                 * @param path
                 * @param fillType
                 * @return {Paths} - The solution
                 */
                ClipperLibWrapper.prototype.simplifyPolygon = function (path, fillType) {
                    if (fillType === void 0) { fillType = enums.PolyFillType.EvenOdd; }
                    return functions.simplifyPolygon(this.instance, path, fillType);
                };
                /**
                 * Removes self-intersections from the supplied polygons (by performing a boolean union operation using the nominated PolyFillType).
                 * Polygons with non-contiguous duplicate vertices (ie 'vertices are touching') will be split into two polygons.
                 *
                 * Note: There's currently no guarantee that polygons will be strictly simple since 'simplifying' is still a work in progress.
                 *
                 * @param paths
                 * @param fillType
                 * @return {Paths} - The solution
                 */
                ClipperLibWrapper.prototype.simplifyPolygons = function (paths, fillType) {
                    if (fillType === void 0) { fillType = enums.PolyFillType.EvenOdd; }
                    return functions.simplifyPolygons(this.instance, paths, fillType);
                };
                //noinspection JSMethodCanBeStatic
                /**
                 * Scales a path by multiplying all its points by a number and then rounding them.
                 *
                 * @param path - Path to scale
                 * @param scale - Scale multiplier
                 * @return {Path} - The scaled path
                 */
                ClipperLibWrapper.prototype.scalePath = function (path, scale) {
                    return functions.scalePath(path, scale);
                };
                //noinspection JSMethodCanBeStatic
                /**
                 * Scales all inner paths by multiplying all its points by a number and then rounding them.
                 *
                 * @param paths - Paths to scale
                 * @param scale - Scale multiplier
                 * @return {Paths} - The scaled paths
                 */
                ClipperLibWrapper.prototype.scalePaths = function (paths, scale) {
                    return functions.scalePaths(paths, scale);
                };
                /**
                 * Max coordinate value (both positive and negative).
                 */
                ClipperLibWrapper.hiRange = constants.hiRange;
                return ClipperLibWrapper;
            }());
            exports.ClipperLibWrapper = ClipperLibWrapper;
            /**
             * Asynchronously tries to load a new native instance of the clipper library to be shared across all method invocations.
             *
             * @param format - Format to load, either WasmThenAsmJs, WasmOnly or AsmJsOnly.
             * @return {Promise<ClipperLibWrapper>} - Promise that resolves with the wrapper instance.
             */
            exports.loadNativeClipperLibInstanceAsync = function (format) { return __awaiter(void 0, void 0, void 0, function () {
                function getModuleAsync(initModule) {
                    return new Promise(function (resolve, reject) {
                        var finalModule;
                        //noinspection JSUnusedLocalSymbols
                        var moduleOverrides = {
                            noExitRuntime: true,
                            preRun: function () {
                                if (finalModule) {
                                    resolve(finalModule);
                                }
                                else {
                                    setTimeout(function () {
                                        resolve(finalModule);
                                    }, 1);
                                }
                            },
                            quit: function (code, err) {
                                reject(err);
                            }
                        };
                        finalModule = initModule(moduleOverrides);
                    });
                }
                var tryWasm, tryAsmJs, initModule, err_1, initModule, err_2;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            switch (format) {
                                case enums.NativeClipperLibRequestedFormat.WasmWithAsmJsFallback:
                                    tryWasm = true;
                                    tryAsmJs = true;
                                    break;
                                case enums.NativeClipperLibRequestedFormat.WasmOnly:
                                    tryWasm = true;
                                    tryAsmJs = false;
                                    break;
                                case enums.NativeClipperLibRequestedFormat.AsmJsOnly:
                                    tryWasm = false;
                                    tryAsmJs = true;
                                    break;
                                default:
                                    throw new ClipperError_1.ClipperError("unknown native clipper format");
                            }
                            if (!tryWasm) return [3 /*break*/, 7];
                            if (!(wasmModule instanceof Error)) return [3 /*break*/, 1];
                            return [3 /*break*/, 7];
                        case 1:
                            if (!(wasmModule === undefined)) return [3 /*break*/, 6];
                            _a.label = 2;
                        case 2:
                            _a.trys.push([2, 4, , 5]);
                            initModule = clipperWasm.init;
                            return [4 /*yield*/, getModuleAsync(initModule)];
                        case 3:
                            wasmModule = _a.sent();
                            return [2 /*return*/, new ClipperLibWrapper(wasmModule, enums.NativeClipperLibLoadedFormat.Wasm)];
                        case 4:
                            err_1 = _a.sent();
                            wasmModule = err_1;
                            return [3 /*break*/, 5];
                        case 5: return [3 /*break*/, 7];
                        case 6: return [2 /*return*/, new ClipperLibWrapper(wasmModule, enums.NativeClipperLibLoadedFormat.Wasm)];
                        case 7:
                            if (!tryAsmJs) return [3 /*break*/, 14];
                            if (!(asmJsModule instanceof Error)) return [3 /*break*/, 8];
                            return [3 /*break*/, 14];
                        case 8:
                            if (!(asmJsModule === undefined)) return [3 /*break*/, 13];
                            _a.label = 9;
                        case 9:
                            _a.trys.push([9, 11, , 12]);
                            initModule = clipper.init;
                            return [4 /*yield*/, getModuleAsync(initModule)];
                        case 10:
                            asmJsModule = _a.sent();
                            return [2 /*return*/, new ClipperLibWrapper(asmJsModule, enums.NativeClipperLibLoadedFormat.AsmJs)];
                        case 11:
                            err_2 = _a.sent();
                            asmJsModule = err_2;
                            return [3 /*break*/, 12];
                        case 12: return [3 /*break*/, 14];
                        case 13: return [2 /*return*/, new ClipperLibWrapper(asmJsModule, enums.NativeClipperLibLoadedFormat.AsmJs)];
                        case 14: throw new ClipperError_1.ClipperError("could not load native clipper in the desired format");
                    }
                });
            }); };

            });

            unwrapExports(jsAngusjClipperjsWeb);
            var jsAngusjClipperjsWeb_1 = jsAngusjClipperjsWeb.ClipperError;
            var jsAngusjClipperjsWeb_2 = jsAngusjClipperjsWeb.ClipType;
            var jsAngusjClipperjsWeb_3 = jsAngusjClipperjsWeb.EndType;
            var jsAngusjClipperjsWeb_4 = jsAngusjClipperjsWeb.JoinType;
            var jsAngusjClipperjsWeb_5 = jsAngusjClipperjsWeb.NativeClipperLibLoadedFormat;
            var jsAngusjClipperjsWeb_6 = jsAngusjClipperjsWeb.NativeClipperLibRequestedFormat;
            var jsAngusjClipperjsWeb_7 = jsAngusjClipperjsWeb.PointInPolygonResult;
            var jsAngusjClipperjsWeb_8 = jsAngusjClipperjsWeb.PolyFillType;
            var jsAngusjClipperjsWeb_9 = jsAngusjClipperjsWeb.PolyNode;
            var jsAngusjClipperjsWeb_10 = jsAngusjClipperjsWeb.PolyTree;
            var jsAngusjClipperjsWeb_11 = jsAngusjClipperjsWeb.ClipperLibWrapper;
            var jsAngusjClipperjsWeb_12 = jsAngusjClipperjsWeb.loadNativeClipperLibInstanceAsync;

            const {
              ClipType,
              NativeClipperLibRequestedFormat,
              PolyFillType,
              PolyTree,
              loadNativeClipperLibInstanceAsync,
            } = jsAngusjClipperjsWeb;

            var mediator = {
              ClipType,
              NativeClipperLibRequestedFormat,
              PolyFillType,
              PolyTree,
              loadNativeClipperLibInstanceAsync,
            };
            var mediator_1 = mediator.ClipType;
            var mediator_2 = mediator.NativeClipperLibRequestedFormat;
            var mediator_3 = mediator.PolyFillType;
            var mediator_4 = mediator.PolyTree;
            var mediator_5 = mediator.loadNativeClipperLibInstanceAsync;

            var lib = {
              ClipType: mediator_1,
              NativeClipperLibRequestedFormat: mediator_2,
              PolyFillType: mediator_3,
              PolyTree: mediator_4,
              loadNativeClipperLibInstanceAsync: mediator_5,
            };

            const {
              ClipType: ClipType$1,
              NativeClipperLibRequestedFormat: NativeClipperLibRequestedFormat$1,
              PolyFillType: PolyFillType$1,
              PolyTree: PolyTree$1,
              loadNativeClipperLibInstanceAsync: loadNativeClipperLibInstanceAsync$1,
            } = lib;

            let clipper$1;

            function IntPoint(x, y) {
              this.x = x;
              this.y = y;
            }

            // CHECK: Should this be sqrt(2)?
            const CLEAN_DISTANCE = 1;

            const RESOLUTION = 1e6;

            const toInt = (integer) => Math.round(integer * RESOLUTION);

            const fromSurfaceAsClosedPaths = (surface, normalize) => {
              const normalized = surface.map((path) => path.map(normalize));
              const integers = normalized.map((path) =>
                path.map(([X, Y]) => [toInt(X), toInt(Y), 0])
              );
              const filtered = integers.filter((path) => toPlane(path) !== undefined);
              return filtered.map((path) => ({
                data: path.map(([X, Y]) => new IntPoint(X, Y)),
                closed: true,
              }));
            };

            var earcut_1 = earcut;
            var default_1 = earcut;

            function earcut(data, holeIndices, dim) {

                dim = dim || 2;

                var hasHoles = holeIndices && holeIndices.length,
                    outerLen = hasHoles ? holeIndices[0] * dim : data.length,
                    outerNode = linkedList(data, 0, outerLen, dim, true),
                    triangles = [];

                if (!outerNode || outerNode.next === outerNode.prev) return triangles;

                var minX, minY, maxX, maxY, x, y, invSize;

                if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

                // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
                if (data.length > 80 * dim) {
                    minX = maxX = data[0];
                    minY = maxY = data[1];

                    for (var i = dim; i < outerLen; i += dim) {
                        x = data[i];
                        y = data[i + 1];
                        if (x < minX) minX = x;
                        if (y < minY) minY = y;
                        if (x > maxX) maxX = x;
                        if (y > maxY) maxY = y;
                    }

                    // minX, minY and invSize are later used to transform coords into integers for z-order calculation
                    invSize = Math.max(maxX - minX, maxY - minY);
                    invSize = invSize !== 0 ? 1 / invSize : 0;
                }

                earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

                return triangles;
            }

            // create a circular doubly linked list from polygon points in the specified winding order
            function linkedList(data, start, end, dim, clockwise) {
                var i, last;

                if (clockwise === (signedArea(data, start, end, dim) > 0)) {
                    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
                } else {
                    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
                }

                if (last && equals$2(last, last.next)) {
                    removeNode(last);
                    last = last.next;
                }

                return last;
            }

            // eliminate colinear or duplicate points
            function filterPoints(start, end) {
                if (!start) return start;
                if (!end) end = start;

                var p = start,
                    again;
                do {
                    again = false;

                    if (!p.steiner && (equals$2(p, p.next) || area(p.prev, p, p.next) === 0)) {
                        removeNode(p);
                        p = end = p.prev;
                        if (p === p.next) break;
                        again = true;

                    } else {
                        p = p.next;
                    }
                } while (again || p !== end);

                return end;
            }

            // main ear slicing loop which triangulates a polygon (given as a linked list)
            function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
                if (!ear) return;

                // interlink polygon nodes in z-order
                if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

                var stop = ear,
                    prev, next;

                // iterate through ears, slicing them one by one
                while (ear.prev !== ear.next) {
                    prev = ear.prev;
                    next = ear.next;

                    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                        // cut off the triangle
                        triangles.push(prev.i / dim);
                        triangles.push(ear.i / dim);
                        triangles.push(next.i / dim);

                        removeNode(ear);

                        // skipping the next vertex leads to less sliver triangles
                        ear = next.next;
                        stop = next.next;

                        continue;
                    }

                    ear = next;

                    // if we looped through the whole remaining polygon and can't find any more ears
                    if (ear === stop) {
                        // try filtering points and slicing again
                        if (!pass) {
                            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

                        // if this didn't work, try curing all small self-intersections locally
                        } else if (pass === 1) {
                            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

                        // as a last resort, try splitting the remaining polygon into two
                        } else if (pass === 2) {
                            splitEarcut(ear, triangles, dim, minX, minY, invSize);
                        }

                        break;
                    }
                }
            }

            // check whether a polygon node forms a valid ear with adjacent nodes
            function isEar(ear) {
                var a = ear.prev,
                    b = ear,
                    c = ear.next;

                if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

                // now make sure we don't have other points inside the potential ear
                var p = ear.next.next;

                while (p !== ear.prev) {
                    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                        area(p.prev, p, p.next) >= 0) return false;
                    p = p.next;
                }

                return true;
            }

            function isEarHashed(ear, minX, minY, invSize) {
                var a = ear.prev,
                    b = ear,
                    c = ear.next;

                if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

                // triangle bbox; min & max are calculated like this for speed
                var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
                    minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
                    maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
                    maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

                // z-order range for the current triangle bbox;
                var minZ = zOrder(minTX, minTY, minX, minY, invSize),
                    maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

                var p = ear.prevZ,
                    n = ear.nextZ;

                // look for points inside the triangle in both directions
                while (p && p.z >= minZ && n && n.z <= maxZ) {
                    if (p !== ear.prev && p !== ear.next &&
                        pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                        area(p.prev, p, p.next) >= 0) return false;
                    p = p.prevZ;

                    if (n !== ear.prev && n !== ear.next &&
                        pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                        area(n.prev, n, n.next) >= 0) return false;
                    n = n.nextZ;
                }

                // look for remaining points in decreasing z-order
                while (p && p.z >= minZ) {
                    if (p !== ear.prev && p !== ear.next &&
                        pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                        area(p.prev, p, p.next) >= 0) return false;
                    p = p.prevZ;
                }

                // look for remaining points in increasing z-order
                while (n && n.z <= maxZ) {
                    if (n !== ear.prev && n !== ear.next &&
                        pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                        area(n.prev, n, n.next) >= 0) return false;
                    n = n.nextZ;
                }

                return true;
            }

            // go through all polygon nodes and cure small local self-intersections
            function cureLocalIntersections(start, triangles, dim) {
                var p = start;
                do {
                    var a = p.prev,
                        b = p.next.next;

                    if (!equals$2(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

                        triangles.push(a.i / dim);
                        triangles.push(p.i / dim);
                        triangles.push(b.i / dim);

                        // remove two nodes involved
                        removeNode(p);
                        removeNode(p.next);

                        p = start = b;
                    }
                    p = p.next;
                } while (p !== start);

                return filterPoints(p);
            }

            // try splitting polygon into two and triangulate them independently
            function splitEarcut(start, triangles, dim, minX, minY, invSize) {
                // look for a valid diagonal that divides the polygon into two
                var a = start;
                do {
                    var b = a.next.next;
                    while (b !== a.prev) {
                        if (a.i !== b.i && isValidDiagonal(a, b)) {
                            // split the polygon in two by the diagonal
                            var c = splitPolygon(a, b);

                            // filter colinear points around the cuts
                            a = filterPoints(a, a.next);
                            c = filterPoints(c, c.next);

                            // run earcut on each half
                            earcutLinked(a, triangles, dim, minX, minY, invSize);
                            earcutLinked(c, triangles, dim, minX, minY, invSize);
                            return;
                        }
                        b = b.next;
                    }
                    a = a.next;
                } while (a !== start);
            }

            // link every hole into the outer loop, producing a single-ring polygon without holes
            function eliminateHoles(data, holeIndices, outerNode, dim) {
                var queue = [],
                    i, len, start, end, list;

                for (i = 0, len = holeIndices.length; i < len; i++) {
                    start = holeIndices[i] * dim;
                    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                    list = linkedList(data, start, end, dim, false);
                    if (list === list.next) list.steiner = true;
                    queue.push(getLeftmost(list));
                }

                queue.sort(compareX);

                // process holes from left to right
                for (i = 0; i < queue.length; i++) {
                    eliminateHole(queue[i], outerNode);
                    outerNode = filterPoints(outerNode, outerNode.next);
                }

                return outerNode;
            }

            function compareX(a, b) {
                return a.x - b.x;
            }

            // find a bridge between vertices that connects hole with an outer ring and and link it
            function eliminateHole(hole, outerNode) {
                outerNode = findHoleBridge(hole, outerNode);
                if (outerNode) {
                    var b = splitPolygon(outerNode, hole);

                    // filter collinear points around the cuts
                    filterPoints(outerNode, outerNode.next);
                    filterPoints(b, b.next);
                }
            }

            // David Eberly's algorithm for finding a bridge between hole and outer polygon
            function findHoleBridge(hole, outerNode) {
                var p = outerNode,
                    hx = hole.x,
                    hy = hole.y,
                    qx = -Infinity,
                    m;

                // find a segment intersected by a ray from the hole's leftmost point to the left;
                // segment's endpoint with lesser x will be potential connection point
                do {
                    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                        var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                        if (x <= hx && x > qx) {
                            qx = x;
                            if (x === hx) {
                                if (hy === p.y) return p;
                                if (hy === p.next.y) return p.next;
                            }
                            m = p.x < p.next.x ? p : p.next;
                        }
                    }
                    p = p.next;
                } while (p !== outerNode);

                if (!m) return null;

                if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint

                // look for points inside the triangle of hole point, segment intersection and endpoint;
                // if there are no points found, we have a valid connection;
                // otherwise choose the point of the minimum angle with the ray as connection point

                var stop = m,
                    mx = m.x,
                    my = m.y,
                    tanMin = Infinity,
                    tan;

                p = m;

                do {
                    if (hx >= p.x && p.x >= mx && hx !== p.x &&
                            pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

                        tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

                        if (locallyInside(p, hole) &&
                            (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                            m = p;
                            tanMin = tan;
                        }
                    }

                    p = p.next;
                } while (p !== stop);

                return m;
            }

            // whether sector in vertex m contains sector in vertex p in the same coordinates
            function sectorContainsSector(m, p) {
                return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
            }

            // interlink polygon nodes in z-order
            function indexCurve(start, minX, minY, invSize) {
                var p = start;
                do {
                    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
                    p.prevZ = p.prev;
                    p.nextZ = p.next;
                    p = p.next;
                } while (p !== start);

                p.prevZ.nextZ = null;
                p.prevZ = null;

                sortLinked(p);
            }

            // Simon Tatham's linked list merge sort algorithm
            // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
            function sortLinked(list) {
                var i, p, q, e, tail, numMerges, pSize, qSize,
                    inSize = 1;

                do {
                    p = list;
                    list = null;
                    tail = null;
                    numMerges = 0;

                    while (p) {
                        numMerges++;
                        q = p;
                        pSize = 0;
                        for (i = 0; i < inSize; i++) {
                            pSize++;
                            q = q.nextZ;
                            if (!q) break;
                        }
                        qSize = inSize;

                        while (pSize > 0 || (qSize > 0 && q)) {

                            if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                                e = p;
                                p = p.nextZ;
                                pSize--;
                            } else {
                                e = q;
                                q = q.nextZ;
                                qSize--;
                            }

                            if (tail) tail.nextZ = e;
                            else list = e;

                            e.prevZ = tail;
                            tail = e;
                        }

                        p = q;
                    }

                    tail.nextZ = null;
                    inSize *= 2;

                } while (numMerges > 1);

                return list;
            }

            // z-order of a point given coords and inverse of the longer side of data bbox
            function zOrder(x, y, minX, minY, invSize) {
                // coords are transformed into non-negative 15-bit integer range
                x = 32767 * (x - minX) * invSize;
                y = 32767 * (y - minY) * invSize;

                x = (x | (x << 8)) & 0x00FF00FF;
                x = (x | (x << 4)) & 0x0F0F0F0F;
                x = (x | (x << 2)) & 0x33333333;
                x = (x | (x << 1)) & 0x55555555;

                y = (y | (y << 8)) & 0x00FF00FF;
                y = (y | (y << 4)) & 0x0F0F0F0F;
                y = (y | (y << 2)) & 0x33333333;
                y = (y | (y << 1)) & 0x55555555;

                return x | (y << 1);
            }

            // find the leftmost node of a polygon ring
            function getLeftmost(start) {
                var p = start,
                    leftmost = start;
                do {
                    if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
                    p = p.next;
                } while (p !== start);

                return leftmost;
            }

            // check if a point lies within a convex triangle
            function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
                return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
                       (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
                       (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
            }

            // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
            function isValidDiagonal(a, b) {
                return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
                       (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
                        (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
                        equals$2(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
            }

            // signed area of a triangle
            function area(p, q, r) {
                return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
            }

            // check if two points are equal
            function equals$2(p1, p2) {
                return p1.x === p2.x && p1.y === p2.y;
            }

            // check if two segments intersect
            function intersects(p1, q1, p2, q2) {
                var o1 = sign(area(p1, q1, p2));
                var o2 = sign(area(p1, q1, q2));
                var o3 = sign(area(p2, q2, p1));
                var o4 = sign(area(p2, q2, q1));

                if (o1 !== o2 && o3 !== o4) return true; // general case

                if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
                if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
                if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
                if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

                return false;
            }

            // for collinear points p, q, r, check if point q lies on segment pr
            function onSegment(p, q, r) {
                return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
            }

            function sign(num) {
                return num > 0 ? 1 : num < 0 ? -1 : 0;
            }

            // check if a polygon diagonal intersects any polygon segments
            function intersectsPolygon(a, b) {
                var p = a;
                do {
                    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                            intersects(p, p.next, a, b)) return true;
                    p = p.next;
                } while (p !== a);

                return false;
            }

            // check if a polygon diagonal is locally inside the polygon
            function locallyInside(a, b) {
                return area(a.prev, a, a.next) < 0 ?
                    area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
                    area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
            }

            // check if the middle point of a polygon diagonal is inside the polygon
            function middleInside(a, b) {
                var p = a,
                    inside = false,
                    px = (a.x + b.x) / 2,
                    py = (a.y + b.y) / 2;
                do {
                    if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                            (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                        inside = !inside;
                    p = p.next;
                } while (p !== a);

                return inside;
            }

            // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
            // if one belongs to the outer ring and another to a hole, it merges it into a single ring
            function splitPolygon(a, b) {
                var a2 = new Node(a.i, a.x, a.y),
                    b2 = new Node(b.i, b.x, b.y),
                    an = a.next,
                    bp = b.prev;

                a.next = b;
                b.prev = a;

                a2.next = an;
                an.prev = a2;

                b2.next = a2;
                a2.prev = b2;

                bp.next = b2;
                b2.prev = bp;

                return b2;
            }

            // create a node and optionally link it with previous one (in a circular doubly linked list)
            function insertNode(i, x, y, last) {
                var p = new Node(i, x, y);

                if (!last) {
                    p.prev = p;
                    p.next = p;

                } else {
                    p.next = last.next;
                    p.prev = last;
                    last.next.prev = p;
                    last.next = p;
                }
                return p;
            }

            function removeNode(p) {
                p.next.prev = p.prev;
                p.prev.next = p.next;

                if (p.prevZ) p.prevZ.nextZ = p.nextZ;
                if (p.nextZ) p.nextZ.prevZ = p.prevZ;
            }

            function Node(i, x, y) {
                // vertex index in coordinates array
                this.i = i;

                // vertex coordinates
                this.x = x;
                this.y = y;

                // previous and next vertex nodes in a polygon ring
                this.prev = null;
                this.next = null;

                // z-order curve value
                this.z = null;

                // previous and next nodes in z-order
                this.prevZ = null;
                this.nextZ = null;

                // indicates whether this is a steiner point
                this.steiner = false;
            }

            // return a percentage difference between the polygon area and its triangulation area;
            // used to verify correctness of triangulation
            earcut.deviation = function (data, holeIndices, dim, triangles) {
                var hasHoles = holeIndices && holeIndices.length;
                var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

                var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
                if (hasHoles) {
                    for (var i = 0, len = holeIndices.length; i < len; i++) {
                        var start = holeIndices[i] * dim;
                        var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                        polygonArea -= Math.abs(signedArea(data, start, end, dim));
                    }
                }

                var trianglesArea = 0;
                for (i = 0; i < triangles.length; i += 3) {
                    var a = triangles[i] * dim;
                    var b = triangles[i + 1] * dim;
                    var c = triangles[i + 2] * dim;
                    trianglesArea += Math.abs(
                        (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
                        (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
                }

                return polygonArea === 0 && trianglesArea === 0 ? 0 :
                    Math.abs((trianglesArea - polygonArea) / polygonArea);
            };

            function signedArea(data, start, end, dim) {
                var sum = 0;
                for (var i = start, j = end - dim; i < end; i += dim) {
                    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
                    j = i;
                }
                return sum;
            }

            // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
            earcut.flatten = function (data) {
                var dim = data[0][0].length,
                    result = {vertices: [], holes: [], dimensions: dim},
                    holeIndex = 0;

                for (var i = 0; i < data.length; i++) {
                    for (var j = 0; j < data[i].length; j++) {
                        for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
                    }
                    if (i > 0) {
                        holeIndex += data[i - 1].length;
                        result.holes.push(holeIndex);
                    }
                }
                return result;
            };
            earcut_1.default = default_1;

            const makeConvex = (surface, normalize = createNormalize2()) => {
              if (surface.length === 0) {
                return [];
              }
              const subjectInputs = fromSurfaceAsClosedPaths(surface, normalize);
              if (subjectInputs.length === 0) {
                return [];
              }
              const request = {
                clipType: ClipType$1.Union,
                subjectInputs,
                subjectFillType: PolyFillType$1.Positive,
              };
              const result = clipper$1.clipToPolyTree(request);
              const convexSurface = [];

              // eslint-disable-next-line camelcase
              const walkContour = ({ contour, childs }) => {
                const earContour = [];
                const holes = [];
                for (const { x, y } of clipper$1.cleanPolygon(contour, CLEAN_DISTANCE)) {
                  earContour.push(x, y);
                }
                // eslint-disable-next-line camelcase
                for (const child of childs) {
                  walkHole(child, earContour, holes);
                }
                const triangles = earcut_1(earContour, holes);
                for (let i = 0; i < triangles.length; i += 3) {
                  const a = triangles[i + 0];
                  const b = triangles[i + 1];
                  const c = triangles[i + 2];
                  const triangle = [
                    normalize([
                      earContour[a * 2 + 0] / RESOLUTION,
                      earContour[a * 2 + 1] / RESOLUTION,
                      0,
                    ]),
                    normalize([
                      earContour[b * 2 + 0] / RESOLUTION,
                      earContour[b * 2 + 1] / RESOLUTION,
                      0,
                    ]),
                    normalize([
                      earContour[c * 2 + 0] / RESOLUTION,
                      earContour[c * 2 + 1] / RESOLUTION,
                      0,
                    ]),
                  ];
                  convexSurface.push(triangle);
                }
              };

              // eslint-disable-next-line camelcase
              const walkHole = ({ contour, childs }, earContour, holes) => {
                const start = earContour.length;
                for (const { x, y } of clipper$1.cleanPolygon(contour, CLEAN_DISTANCE)) {
                  earContour.push(x, y);
                }
                if (earContour.length > start) {
                  holes.push(start >>> 1);
                }
                // eslint-disable-next-line camelcase
                for (const child of childs) {
                  walkContour(child);
                }
              };

              for (const child of result.childs) {
                walkContour(child);
              }

              const normalized = convexSurface
                .map((path) => path.map(normalize))
                .filter((path) => toPlane(path) !== undefined);
              const rectified = [];
              for (const polygon of normalized) {
                if (isClockwise(polygon)) {
                  rectified.push(flip(polygon));
                } else {
                  rectified.push(polygon);
                }
              }
              return normalized;
            };

            /**
             * Creates a new unbounded 2D line initialized with the given values.
             *
             * This is a 2d plane, similar to the [x, y, z, w] form of the 3d plane.
             *
             * @param {Number} x X coordinate of the unit normal
             * @param {Number} y Y coordinate of the unit normal
             * @param {Number} w length (positive) of the normal segment
             * @returns {line2} a new unbounded 2D line
             */
            const fromValues$2 = (x = 0, y = 1, w = 0) => [x, y, w];

            /**
             * Create a new 2D line that passes through the given points
             *
             * @param {vec2} p1 start point of the 2D line
             * @param {vec2} p2 end point of the 2D line
             * @returns {line2} a new unbounded 2D line
             */
            const fromPoints$2 = (p1, p2) => {
              const direction = subtract$1(p2, p1);
              const normalizedNormal = normalize$1(normal(direction));
              const distance = dot$1(p1, normalizedNormal);
              const values = fromValues$2(normalizedNormal[0], normalizedNormal[1], distance);
              return values;
            };

            /**
             * Return the point of intersection between the given lines.
             *
             * The point will have Infinity values if the lines are parallel.
             * The point will have NaN values if the lines are the same.
             *
             * @param {line2} line1 a 2D line for reference
             * @param {line2} line2 a 2D line for reference
             * @return {vec2} the point of intersection
             */
            const intersect = (line1, line2) =>
              solve2Linear(line1[0], line1[1], line2[0], line2[1], line1[2], line2[2]);

            // returns an array of two Vector3Ds (minimum coordinates and maximum coordinates)
            const measureBoundingBox$1 = (surface) => {
              if (surface.measureBoundingBox === undefined) {
                let max = [-Infinity, -Infinity, 0];
                let min = [Infinity, Infinity, 0];
                for (const polygon of surface) {
                  for (const point of polygon) {
                    if (point[0] < min[0]) min[0] = point[0];
                    if (point[1] < min[1]) min[1] = point[1];
                    if (point[0] > max[0]) max[0] = point[0];
                    if (point[1] > max[1]) max[1] = point[1];
                  }
                }
                surface.measureBoundingBox = [min, max];
              }
              return surface.measureBoundingBox;
            };

            // move to tagged

            const fromPathImpl = (path) => [path];

            const fromPath = cache(fromPathImpl);

            const THRESHOLD = 0.99999;

            /**
             * equalsPlane
             *
             * @function
             * @param {Plane} a
             * @param {Plane} b
             * @returns {boolean} b
             */
            const equalsPlane = (a, b) => {
              if (a === undefined || b === undefined) {
                return false;
              }
              const t = dot(a, b);
              if (t >= THRESHOLD) {
                return true;
              } else {
                return false;
              }
            };

            /**
             * getPlanesOfPoint
             *
             * @param {Point} point
             * @returns {Plane[]}
             */
            const getPlanesOfPoint = (planesOfPoint, point) => {
              if (!Array.isArray(point)) {
                throw Error(`die: Expected point`);
              }
              let planes = planesOfPoint.get(point);
              if (planes === undefined) {
                planes = [];
                planesOfPoint.set(point, planes);
              }
              return planes;
            };

            const fromSolidToJunctions = (solid, normalize) => {
              const polygons = [];
              for (const surface of solid) {
                polygons.push(...surface);
              }
              return fromPolygonsToJunctions(polygons, normalize);
            };

            const fromPolygonsToJunctions = (polygons, normalize) => {
              const planesOfPoint = new Map();

              /**
               * considerJunction
               *
               * @param {Point} point
               * @param {Plane} planeOfPath
               * @returns {undefined}
               */
              const considerJunction = (point, planeOfPolygon) => {
                let planes = getPlanesOfPoint(planesOfPoint, point);
                for (const plane of planes) {
                  if (equalsPlane(plane, planeOfPolygon)) {
                    return;
                  }
                }
                planes.push(planeOfPolygon);
                // A point can be at the corner of more than three polygons.
              };

              for (const polygon of polygons) {
                for (const point of polygon) {
                  considerJunction(normalize(point), toPlane(polygon));
                }
              }

              return planesOfPoint;
            };

            /**
             * junctionSelector
             *
             * @function
             * @param {Solid} solid
             * @param {Normalizer} normalize
             * @returns {PointSelector}
             */
            const junctionSelector = (junctions, normalize) => {
              const select = (point) => getPlanesOfPoint(junctions, point).length >= 3;

              return select;
            };

            /**
             * clean
             * @param {Edge} loop
             * @returns {Edge|undefined}
             */
            const clean = (loop) => {
              /** @type {Edge} */
              let link = loop;
              do {
                if (link.start === false) {
                  throw Error(`die: start is false`);
                }
                if (link.next === undefined) {
                  throw Error(`die: ${link.id} ${link.dead}`);
                }
                if (link.to !== undefined) {
                  throw Error(`die: to`);
                }
                while (link.next.twin === link.next.next) {
                  if (link.next === link.next.next.next) {
                    // The loop is degenerate.
                    return undefined;
                  }
                  // We have found a degenerate spur -- trim it off.
                  link.next.cleaned = true;
                  link.next.next.cleaned = true;
                  link.next = link.next.next.next;
                  // Make sure we walk around the loop to this point again,
                  // in case this exposed another spur.
                  loop = link;
                }
                link = link.next;
                link.face = loop;
              } while (link !== loop);

              // Check that the spurs are gone.
              let violations = 0;
              do {
                const twin = link.twin;
                if (twin === undefined || twin.face !== link.face) ; else if (twin.next.next === link.next) {
                  // The twin links backward along a spur.
                  // These should have been removed in the cleaning phase.
                  violations += 1;
                }
                link = link.next;
              } while (link !== loop);

              if (violations > 0) {
                throw Error(`die: twin links backward along a spur ${violations}`);
              }
              return link.face;
            };

            // This produces a half-edge link.

            /**
             * createEdge
             *
             * @function
             * @param {Point=} start
             * @param {Edge=} face
             * @param {Edge=} next
             * @param {Edge=} twin
             * @param {Edge[]=} holes
             * @param {Plane=} plane
             * @param {number=} id
             * @param {boolean=} dead
             * @param {boolean=} spurLinkage
             * @returns {Edge}
             */
            const createEdge = (
              start = [0, 0, 0],
              face,
              next,
              twin,
              holes,
              plane,
              id,
              dead,
              spurLinkage
            ) => ({ start, face, next, twin, holes, plane, id, dead, spurLinkage });

            /**
             * @typedef {function(Edge):undefined} Thunk
             * @returns {undefined}
             */

            /* @type {function(Edge, Thunk):undefined} */

            /**
             * eachLink
             *
             * @function
             * @param {Edge} loop
             * @param {Thunk} thunk
             * @returns {undefined}
             */
            const eachLink = (loop, thunk) => {
              let link = loop;
              do {
                thunk(link);
                if (link.dead === true) {
                  throw Error('die/dead');
                }
                if (link.next === undefined) {
                  throw Error('die/next');
                }
                link = link.next;
              } while (link !== loop);
            };

            let id = 0;

            /**
             * fromSolid
             *
             * @function
             * @param {Solid} solid
             * @param {Normalizer} normalize
             * @param {boolean} closed
             * @returns {Loops}
             */
            const fromSolid = (solid, normalize, closed = true, verbose = false) => {
              const twinMap = new Map();
              /**
               * getTwins
               *
               * @param {Point} point
               * @returns {Edge[]}
               */
              const getTwins = (point) => {
                let twins = twinMap.get(point);
                if (twins === undefined) {
                  twins = [];
                  twinMap.set(point, twins);
                }
                return twins;
              };
              const loops = [];

              for (const surface of solid) {
                for (const path of surface) {
                  let first;
                  let last;
                  for (let nth = 0; nth < path.length; nth++) {
                    const thisPoint = normalize(path[nth]);
                    const nextPoint = normalize(path[(nth + 1) % path.length]);
                    const edge = createEdge(thisPoint);
                    edge.id = id++;
                    // nextPoint will be the start of the twin.
                    getTwins(nextPoint).push(edge);
                    if (first === undefined) {
                      first = edge;
                    }
                    if (last !== undefined) {
                      last.next = edge;
                    }
                    // Any arbitrary link will serve for face identity.
                    edge.face = first;
                    last = edge;
                  }
                  if (first === undefined) {
                    throw Error(`die: ${JSON.stringify(path)}`);
                  }
                  // Close the loop.
                  last.next = first;
                  // And collect the closed loop.
                  loops.push(first);
                }
              }

              // Bridge the edges.
              for (const loop of loops) {
                let link = loop;
                do {
                  if (link.twin === undefined) {
                    const candidates = twinMap.get(link.start);
                    if (candidates === undefined) {
                      throw Error('die');
                    }
                    for (const candidate of candidates) {
                      if (candidate.start === link.next.start) {
                        if (candidate.twin === undefined) {
                          candidate.twin = link;
                          link.twin = candidate;
                        } else {
                          throw Error('die');
                        }
                      }
                    }
                  }
                  link = link.next;
                } while (link !== loop);
              }

              let holeCount = 0;
              let edgeCount = 0;

              if (closed) {
                for (const loop of loops) {
                  if (loop.face === undefined) continue;
                  eachLink(loop, (edge) => {
                    edgeCount += 1;
                    if (edge.twin === undefined) {
                      // A hole in the 2-manifold.
                      holeCount += 1;
                    }
                  });
                }
              }

              if (verbose && holeCount > 0) {
                console.log(`QQ/halfedge/fromSolid/holeCount: ${holeCount}`);
                console.log(`QQ/halfedge/fromSolid/edgeCount: ${edgeCount}`);
              }

              return loops;
            };

            /**
             * fromSurface
             *
             * @function
             * @param {Surface} surface
             * @param {Normalizer} normalize
             * @returns {Loops}
             */
            const fromSurface = (surface, normalize) =>
              fromSolid([surface], normalize, /* closed= */ false);

            /**
             * @typedef {import("./types").Edge} Edge
             * @typedef {import("./types").Plane} Plane
             */

            const X$4 = 0;
            const Y$4 = 1;
            const Z$3 = 2;
            const W$6 = 3;

            /**
             * toPlane
             *
             * @function
             * @param {Edge} loop
             * @param {boolean} recompute
             * @returns {Plane}
             */
            const toPlane$1 = (loop, recompute = false) => {
              if (loop.face.plane === undefined || recompute) {
                loop.face.plane = toPlaneFromLoop(loop.face);
              }
              return loop.face.plane;
            };

            /**
             * Newell's method for computing the plane of a polygon.
             *
             * @function
             * @param {Edge} start
             * @returns {Plane}
             */
            const toPlaneFromLoop = (start) => {
              const normal = [0, 0, 0];
              const reference = [0, 0, 0];
              // Run around the ring.
              let size = 0;
              let link = start;
              do {
                const lastPoint = link.start;
                const thisPoint = link.next.start;
                if (lastPoint !== thisPoint) {
                  normal[X$4] +=
                    (lastPoint[Y$4] - thisPoint[Y$4]) * (lastPoint[Z$3] + thisPoint[Z$3]);
                  normal[Y$4] +=
                    (lastPoint[Z$3] - thisPoint[Z$3]) * (lastPoint[X$4] + thisPoint[X$4]);
                  normal[Z$3] +=
                    (lastPoint[X$4] - thisPoint[X$4]) * (lastPoint[Y$4] + thisPoint[Y$4]);
                  reference[X$4] += lastPoint[X$4];
                  reference[Y$4] += lastPoint[Y$4];
                  reference[Z$3] += lastPoint[Z$3];
                  size += 1;
                }
                link = link.next;
              } while (link !== start);
              const factor = 1 / length(normal);
              const plane = scale(factor, normal);
              plane[W$6] = (dot(reference, normal) * factor) / size;
              if (isNaN(plane[X$4])) {
                return undefined;
              } else {
                return plane;
              }
            };

            /**
             * @typedef {import("./types").Edge} Edge
             * @typedef {import("./types").Loops} Loops
             */

            const merged = Symbol('merged');

            /**
             * merge
             *
             * @function
             * @param {Loops} loops
             * @returns {Loops}
             */
            const merge = (loops) => {
              const faces = new Set();
              for (const loop of loops) {
                faces.add(loop.face);
              }
              /**
               * walk
               *
               * @param {Edge} loop
               * @returns {Edge}
               */
              const walk = (loop) => {
                if (loop[merged] || loop.next === undefined) return;
                eachLink(loop, (link) => {
                  link[merged] = true;
                });
                let link = loop;
                do {
                  if (link.face !== link.next.face) {
                    throw Error('die');
                  }
                  const twin = link.twin;
                  if (twin === undefined) ; else if (twin.face === link.face) ; else if (link.next === twin) ; else if (equalsPlane(toPlane$1(link), toPlane$1(twin))) {
                    faces.delete(link.face);
                    faces.delete(twin.face);
                    // Merge the loops.
                    const linkNext = link.next;
                    const twinNext = twin.next;

                    if (linkNext.dead) throw Error('die');
                    if (twinNext.dead) throw Error('die');
                    if (twin.twin !== link) throw Error('die');

                    if (twinNext === link) throw Error('die');
                    if (linkNext === twin) throw Error('die');

                    link.twin = undefined;
                    twin.twin = undefined;

                    Object.assign(link, twinNext);
                    link.from = twinNext;
                    twinNext.to = link;

                    Object.assign(twin, linkNext);
                    twin.from = linkNext;
                    linkNext.to = twin;

                    if (link.twin) {
                      link.twin.twin = link;
                    }
                    if (twin.twin) {
                      twin.twin.twin = twin;
                    }

                    if (twin.next === twin) throw Error('die');

                    linkNext.face = undefined;
                    linkNext.next = undefined;
                    linkNext.twin = undefined;
                    linkNext.dead = true;
                    linkNext.id -= 1000000;

                    twinNext.face = undefined;
                    twinNext.next = undefined;
                    twinNext.twin = undefined;
                    twinNext.dead = true;
                    twinNext.id -= 1000000;

                    // Ensure we do a complete pass over the merged loop.
                    loop = link;

                    if (faces.has(loop)) {
                      throw Error('die');
                    }
                    faces.add(loop);

                    // Update face affinity to detect self-merging.
                    do {
                      link.face = loop;
                      link = link.next;
                    } while (link !== loop);
                  }
                  if (link.next === undefined) {
                    throw Error('die');
                  }
                  link = link.next;
                  if (link.to !== undefined) {
                    throw Error('die');
                  }
                } while (link !== loop);
                while (link !== link.face) link = link.face;
                return link.face;
              };

              // Test preconditions.
              for (const loop of loops) {
                let link = loop;
                let face = link.face;
                let containsFace = false;
                do {
                  if (link.twin) {
                    if (link.twin.start !== link.next.start) throw Error('die');
                    if (link.twin.next.start !== link.start) throw Error('die');
                  }
                  if (link.dead) {
                    throw Error('die');
                  }
                  if (link === face) {
                    containsFace = true;
                  }
                  link = link.next;
                } while (link !== loop);
                if (containsFace === false) {
                  throw Error('die: Does not contain face');
                }
              }

              const seen = new Set();
              const filtered = [];
              for (const loop of loops.map(walk)) {
                if (loop === undefined) continue;
                if (loop.next === undefined) continue;
                if (loop.face === undefined) continue;
                if (loop.dead !== undefined) continue;
                // Test postconditions.
                let link = loop;
                do {
                  if (link.face.id !== loop.face.id) throw Error('die');
                  link = link.next;
                } while (link !== loop);
                if (seen.has(loop.face)) ; else {
                  seen.add(loop.face);
                  // We're getting the wrong ones in here, sometimes.
                  filtered.push(loop);
                }
              }
              return filtered;
            };

            /**
             * walk
             *
             * @param {Edge} loop
             * @param holes
             * @returns {Edge}
             */
            const splitBridges = (uncleanedLoop, holes) => {
              const loop = clean(uncleanedLoop);
              if (loop.face.holes) {
                throw Error('die');
              }
              let link = loop;
              do {
                if (link.holes) {
                  throw Error('die');
                }
                const twin = link.twin;
                if (twin === undefined || twin.face !== link.face) ; else if (twin.next.next === link.next) {
                  // The twin links backward along a spur.
                  // These should have been removed in the cleaning phase.
                  // throw Error(`die: ${toDot([link])}`);
                  throw Error(`die: ${link.face.id}`);
                } else if (link.next === twin) {
                  // Spur
                  throw Error('die');
                } else {
                  // Found a self-linkage.
                  if (twin === link) throw Error('die');
                  if (twin.twin !== link) throw Error('die');
                  const linkPlane = toPlane$1(link);
                  const linkNext = link.next;
                  const twinNext = twin.next;
                  link.twin = undefined;
                  Object.assign(link, twinNext);
                  twin.twin = undefined;
                  Object.assign(twin, linkNext);

                  if (link.twin) {
                    link.twin.twin = link;
                  }
                  if (twin.twin) {
                    twin.twin.twin = twin;
                  }

                  // One loop was merged with itself, producing a new hole.
                  // But we're not sure which loop is the hole and which is the loop around the hole.

                  // Elect new faces.
                  eachLink(link, (edge) => {
                    edge.face = link;
                  });
                  eachLink(twin, (edge) => {
                    edge.face = twin;
                  });

                  // Check the orientations to see which is the hole.
                  const newLinkPlane = toPlane$1(link, /* recompute= */ true);
                  const newTwinPlane = toPlane$1(twin, /* recompute= */ true);

                  if (newLinkPlane === undefined) {
                    throw Error('die');
                  } else if (newTwinPlane === undefined) {
                    throw Error('die');
                  } else if (equalsPlane(linkPlane, newLinkPlane)) {
                    // The twin loop is the hole.
                    if (!equalsPlane(linkPlane, newTwinPlane)) {
                      // But they have the same orientation, which means that it isn't a bridge,
                      throw Error('die');
                    }
                    splitBridges(link, holes);
                    splitBridges(twin, holes);
                  } else {
                    // The link loop is the hole.
                    if (!equalsPlane(linkPlane, newLinkPlane)) {
                      // But they have the same orientation, which means that it isn't a hole,
                      // but a region connected by a degenerate bridge.
                      throw Error('die');
                    }
                    splitBridges(link, holes);
                    splitBridges(twin, holes);
                  }
                  // We've delegated hole collection.
                  return;
                }
                link = link.next;
              } while (link !== loop);

              holes.push(link.face);
            };

            /**
             * split
             *
             * @function
             * @param {Loops} loops
             * @returns {Loops}
             */
            const split = (loops) => {
              /**
               * walk
               *
               * @param {Edge} loop
               * @param isHole
               * @returns {Edge}
               */
              const walk = (loop, isHole = false) => {
                let link = loop;
                do {
                  let twin = link.twin;
                  if (twin === undefined || twin.face !== link.face) ; else if (twin.next.next === link.next) {
                    // The bridge is going backward -- catch it on the next cycle.
                    loop = link;
                  } else if (twin === link.next) {
                    // Spur
                    throw Error('die/spur1');
                  } else if (twin.next === link) {
                    // Spur
                    throw Error('die/spur2');
                  } else {
                    // Remember any existing holes, when the face migrates.
                    const holes = link.face.holes || [];
                    link.face.holes = undefined;

                    // Found a self-linkage.
                    if (twin === link) throw Error('die');
                    if (twin.twin !== link) throw Error('die');
                    const linkPlane = toPlane$1(link);
                    const linkNext = link.next;
                    const twinNext = twin.next;
                    link.twin = undefined;
                    Object.assign(link, twinNext);
                    twin.twin = undefined;
                    Object.assign(twin, linkNext);

                    if (link.twin) {
                      link.twin.twin = link;
                    }
                    if (twin.twin) {
                      twin.twin.twin = twin;
                    }

                    // One loop was merged with itself, producing a new hole.
                    // But we're not sure which loop is the hole and which is the loop around the hole.

                    // Elect new faces.
                    eachLink(link, (edge) => {
                      edge.face = link;
                    });
                    eachLink(twin, (edge) => {
                      edge.face = twin;
                    });

                    // Now that the loops are separated, clean up any residual canals.
                    link = clean(link);
                    twin = clean(twin);

                    // Check the orientations to see which is the hole.
                    const newLinkPlane = toPlane$1(link, /* recompute= */ true);
                    const newTwinPlane = toPlane$1(twin, /* recompute= */ true);

                    if (newLinkPlane === undefined) {
                      // The link loop is a degenerate hole.
                      // This is probably nibbling away at the end of a canal.
                      twin.face.holes = holes;
                      loop = link = twin;
                    } else if (newTwinPlane === undefined) {
                      // The twin loop is a degenerate hole.
                      // This is probably nibbling away at the end of a canal.
                      link.face.holes = holes;
                      loop = link;
                    } else if (equalsPlane(linkPlane, newLinkPlane)) {
                      // The twin loop is the hole.
                      if (equalsPlane(linkPlane, newTwinPlane)) {
                        // But they have the same orientation, which means that it isn't a hole,
                        // but a region connected by a degenerate bridge.
                        throw Error('die');
                      }
                      splitBridges(twin, holes);
                      link.face.holes = holes;
                      loop = link;
                    } else {
                      // The link loop is the hole.
                      if (equalsPlane(linkPlane, newLinkPlane)) {
                        // But they have the same orientation, which means that it isn't a hole,
                        // but a region connected by a degenerate bridge.
                        throw Error('die');
                      }
                      splitBridges(link, holes);
                      twin.face.holes = holes;
                      // Switch to traversing the non-hole portion of the loop.
                      loop = link = twin;
                    }
                  }
                  link = link.next;
                } while (link !== loop);
                return link.face;
              };

              const splitLoops = loops.map(walk);

              return splitLoops;
            };

            var earcut_1$1 = earcut$1;
            var default_1$1 = earcut$1;

            function earcut$1(data, holeIndices, dim) {

                dim = dim || 2;

                var hasHoles = holeIndices && holeIndices.length,
                    outerLen = hasHoles ? holeIndices[0] * dim : data.length,
                    outerNode = linkedList$1(data, 0, outerLen, dim, true),
                    triangles = [];

                if (!outerNode || outerNode.next === outerNode.prev) return triangles;

                var minX, minY, maxX, maxY, x, y, invSize;

                if (hasHoles) outerNode = eliminateHoles$1(data, holeIndices, outerNode, dim);

                // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
                if (data.length > 80 * dim) {
                    minX = maxX = data[0];
                    minY = maxY = data[1];

                    for (var i = dim; i < outerLen; i += dim) {
                        x = data[i];
                        y = data[i + 1];
                        if (x < minX) minX = x;
                        if (y < minY) minY = y;
                        if (x > maxX) maxX = x;
                        if (y > maxY) maxY = y;
                    }

                    // minX, minY and invSize are later used to transform coords into integers for z-order calculation
                    invSize = Math.max(maxX - minX, maxY - minY);
                    invSize = invSize !== 0 ? 1 / invSize : 0;
                }

                earcutLinked$1(outerNode, triangles, dim, minX, minY, invSize);

                return triangles;
            }

            // create a circular doubly linked list from polygon points in the specified winding order
            function linkedList$1(data, start, end, dim, clockwise) {
                var i, last;

                if (clockwise === (signedArea$1(data, start, end, dim) > 0)) {
                    for (i = start; i < end; i += dim) last = insertNode$1(i, data[i], data[i + 1], last);
                } else {
                    for (i = end - dim; i >= start; i -= dim) last = insertNode$1(i, data[i], data[i + 1], last);
                }

                if (last && equals$3(last, last.next)) {
                    removeNode$1(last);
                    last = last.next;
                }

                return last;
            }

            // eliminate colinear or duplicate points
            function filterPoints$1(start, end) {
                if (!start) return start;
                if (!end) end = start;

                var p = start,
                    again;
                do {
                    again = false;

                    if (!p.steiner && (equals$3(p, p.next) || area$1(p.prev, p, p.next) === 0)) {
                        removeNode$1(p);
                        p = end = p.prev;
                        if (p === p.next) break;
                        again = true;

                    } else {
                        p = p.next;
                    }
                } while (again || p !== end);

                return end;
            }

            // main ear slicing loop which triangulates a polygon (given as a linked list)
            function earcutLinked$1(ear, triangles, dim, minX, minY, invSize, pass) {
                if (!ear) return;

                // interlink polygon nodes in z-order
                if (!pass && invSize) indexCurve$1(ear, minX, minY, invSize);

                var stop = ear,
                    prev, next;

                // iterate through ears, slicing them one by one
                while (ear.prev !== ear.next) {
                    prev = ear.prev;
                    next = ear.next;

                    if (invSize ? isEarHashed$1(ear, minX, minY, invSize) : isEar$1(ear)) {
                        // cut off the triangle
                        triangles.push(prev.i / dim);
                        triangles.push(ear.i / dim);
                        triangles.push(next.i / dim);

                        removeNode$1(ear);

                        // skipping the next vertex leads to less sliver triangles
                        ear = next.next;
                        stop = next.next;

                        continue;
                    }

                    ear = next;

                    // if we looped through the whole remaining polygon and can't find any more ears
                    if (ear === stop) {
                        // try filtering points and slicing again
                        if (!pass) {
                            earcutLinked$1(filterPoints$1(ear), triangles, dim, minX, minY, invSize, 1);

                        // if this didn't work, try curing all small self-intersections locally
                        } else if (pass === 1) {
                            ear = cureLocalIntersections$1(filterPoints$1(ear), triangles, dim);
                            earcutLinked$1(ear, triangles, dim, minX, minY, invSize, 2);

                        // as a last resort, try splitting the remaining polygon into two
                        } else if (pass === 2) {
                            splitEarcut$1(ear, triangles, dim, minX, minY, invSize);
                        }

                        break;
                    }
                }
            }

            // check whether a polygon node forms a valid ear with adjacent nodes
            function isEar$1(ear) {
                var a = ear.prev,
                    b = ear,
                    c = ear.next;

                if (area$1(a, b, c) >= 0) return false; // reflex, can't be an ear

                // now make sure we don't have other points inside the potential ear
                var p = ear.next.next;

                while (p !== ear.prev) {
                    if (pointInTriangle$1(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                        area$1(p.prev, p, p.next) >= 0) return false;
                    p = p.next;
                }

                return true;
            }

            function isEarHashed$1(ear, minX, minY, invSize) {
                var a = ear.prev,
                    b = ear,
                    c = ear.next;

                if (area$1(a, b, c) >= 0) return false; // reflex, can't be an ear

                // triangle bbox; min & max are calculated like this for speed
                var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
                    minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
                    maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
                    maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

                // z-order range for the current triangle bbox;
                var minZ = zOrder$1(minTX, minTY, minX, minY, invSize),
                    maxZ = zOrder$1(maxTX, maxTY, minX, minY, invSize);

                var p = ear.prevZ,
                    n = ear.nextZ;

                // look for points inside the triangle in both directions
                while (p && p.z >= minZ && n && n.z <= maxZ) {
                    if (p !== ear.prev && p !== ear.next &&
                        pointInTriangle$1(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                        area$1(p.prev, p, p.next) >= 0) return false;
                    p = p.prevZ;

                    if (n !== ear.prev && n !== ear.next &&
                        pointInTriangle$1(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                        area$1(n.prev, n, n.next) >= 0) return false;
                    n = n.nextZ;
                }

                // look for remaining points in decreasing z-order
                while (p && p.z >= minZ) {
                    if (p !== ear.prev && p !== ear.next &&
                        pointInTriangle$1(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                        area$1(p.prev, p, p.next) >= 0) return false;
                    p = p.prevZ;
                }

                // look for remaining points in increasing z-order
                while (n && n.z <= maxZ) {
                    if (n !== ear.prev && n !== ear.next &&
                        pointInTriangle$1(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                        area$1(n.prev, n, n.next) >= 0) return false;
                    n = n.nextZ;
                }

                return true;
            }

            // go through all polygon nodes and cure small local self-intersections
            function cureLocalIntersections$1(start, triangles, dim) {
                var p = start;
                do {
                    var a = p.prev,
                        b = p.next.next;

                    if (!equals$3(a, b) && intersects$1(a, p, p.next, b) && locallyInside$1(a, b) && locallyInside$1(b, a)) {

                        triangles.push(a.i / dim);
                        triangles.push(p.i / dim);
                        triangles.push(b.i / dim);

                        // remove two nodes involved
                        removeNode$1(p);
                        removeNode$1(p.next);

                        p = start = b;
                    }
                    p = p.next;
                } while (p !== start);

                return filterPoints$1(p);
            }

            // try splitting polygon into two and triangulate them independently
            function splitEarcut$1(start, triangles, dim, minX, minY, invSize) {
                // look for a valid diagonal that divides the polygon into two
                var a = start;
                do {
                    var b = a.next.next;
                    while (b !== a.prev) {
                        if (a.i !== b.i && isValidDiagonal$1(a, b)) {
                            // split the polygon in two by the diagonal
                            var c = splitPolygon$1(a, b);

                            // filter colinear points around the cuts
                            a = filterPoints$1(a, a.next);
                            c = filterPoints$1(c, c.next);

                            // run earcut on each half
                            earcutLinked$1(a, triangles, dim, minX, minY, invSize);
                            earcutLinked$1(c, triangles, dim, minX, minY, invSize);
                            return;
                        }
                        b = b.next;
                    }
                    a = a.next;
                } while (a !== start);
            }

            // link every hole into the outer loop, producing a single-ring polygon without holes
            function eliminateHoles$1(data, holeIndices, outerNode, dim) {
                var queue = [],
                    i, len, start, end, list;

                for (i = 0, len = holeIndices.length; i < len; i++) {
                    start = holeIndices[i] * dim;
                    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                    list = linkedList$1(data, start, end, dim, false);
                    if (list === list.next) list.steiner = true;
                    queue.push(getLeftmost$1(list));
                }

                queue.sort(compareX$1);

                // process holes from left to right
                for (i = 0; i < queue.length; i++) {
                    eliminateHole$1(queue[i], outerNode);
                    outerNode = filterPoints$1(outerNode, outerNode.next);
                }

                return outerNode;
            }

            function compareX$1(a, b) {
                return a.x - b.x;
            }

            // find a bridge between vertices that connects hole with an outer ring and and link it
            function eliminateHole$1(hole, outerNode) {
                outerNode = findHoleBridge$1(hole, outerNode);
                if (outerNode) {
                    var b = splitPolygon$1(outerNode, hole);

                    // filter collinear points around the cuts
                    filterPoints$1(outerNode, outerNode.next);
                    filterPoints$1(b, b.next);
                }
            }

            // David Eberly's algorithm for finding a bridge between hole and outer polygon
            function findHoleBridge$1(hole, outerNode) {
                var p = outerNode,
                    hx = hole.x,
                    hy = hole.y,
                    qx = -Infinity,
                    m;

                // find a segment intersected by a ray from the hole's leftmost point to the left;
                // segment's endpoint with lesser x will be potential connection point
                do {
                    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                        var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                        if (x <= hx && x > qx) {
                            qx = x;
                            if (x === hx) {
                                if (hy === p.y) return p;
                                if (hy === p.next.y) return p.next;
                            }
                            m = p.x < p.next.x ? p : p.next;
                        }
                    }
                    p = p.next;
                } while (p !== outerNode);

                if (!m) return null;

                if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint

                // look for points inside the triangle of hole point, segment intersection and endpoint;
                // if there are no points found, we have a valid connection;
                // otherwise choose the point of the minimum angle with the ray as connection point

                var stop = m,
                    mx = m.x,
                    my = m.y,
                    tanMin = Infinity,
                    tan;

                p = m;

                do {
                    if (hx >= p.x && p.x >= mx && hx !== p.x &&
                            pointInTriangle$1(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

                        tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

                        if (locallyInside$1(p, hole) &&
                            (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector$1(m, p)))))) {
                            m = p;
                            tanMin = tan;
                        }
                    }

                    p = p.next;
                } while (p !== stop);

                return m;
            }

            // whether sector in vertex m contains sector in vertex p in the same coordinates
            function sectorContainsSector$1(m, p) {
                return area$1(m.prev, m, p.prev) < 0 && area$1(p.next, m, m.next) < 0;
            }

            // interlink polygon nodes in z-order
            function indexCurve$1(start, minX, minY, invSize) {
                var p = start;
                do {
                    if (p.z === null) p.z = zOrder$1(p.x, p.y, minX, minY, invSize);
                    p.prevZ = p.prev;
                    p.nextZ = p.next;
                    p = p.next;
                } while (p !== start);

                p.prevZ.nextZ = null;
                p.prevZ = null;

                sortLinked$1(p);
            }

            // Simon Tatham's linked list merge sort algorithm
            // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
            function sortLinked$1(list) {
                var i, p, q, e, tail, numMerges, pSize, qSize,
                    inSize = 1;

                do {
                    p = list;
                    list = null;
                    tail = null;
                    numMerges = 0;

                    while (p) {
                        numMerges++;
                        q = p;
                        pSize = 0;
                        for (i = 0; i < inSize; i++) {
                            pSize++;
                            q = q.nextZ;
                            if (!q) break;
                        }
                        qSize = inSize;

                        while (pSize > 0 || (qSize > 0 && q)) {

                            if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                                e = p;
                                p = p.nextZ;
                                pSize--;
                            } else {
                                e = q;
                                q = q.nextZ;
                                qSize--;
                            }

                            if (tail) tail.nextZ = e;
                            else list = e;

                            e.prevZ = tail;
                            tail = e;
                        }

                        p = q;
                    }

                    tail.nextZ = null;
                    inSize *= 2;

                } while (numMerges > 1);

                return list;
            }

            // z-order of a point given coords and inverse of the longer side of data bbox
            function zOrder$1(x, y, minX, minY, invSize) {
                // coords are transformed into non-negative 15-bit integer range
                x = 32767 * (x - minX) * invSize;
                y = 32767 * (y - minY) * invSize;

                x = (x | (x << 8)) & 0x00FF00FF;
                x = (x | (x << 4)) & 0x0F0F0F0F;
                x = (x | (x << 2)) & 0x33333333;
                x = (x | (x << 1)) & 0x55555555;

                y = (y | (y << 8)) & 0x00FF00FF;
                y = (y | (y << 4)) & 0x0F0F0F0F;
                y = (y | (y << 2)) & 0x33333333;
                y = (y | (y << 1)) & 0x55555555;

                return x | (y << 1);
            }

            // find the leftmost node of a polygon ring
            function getLeftmost$1(start) {
                var p = start,
                    leftmost = start;
                do {
                    if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
                    p = p.next;
                } while (p !== start);

                return leftmost;
            }

            // check if a point lies within a convex triangle
            function pointInTriangle$1(ax, ay, bx, by, cx, cy, px, py) {
                return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
                       (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
                       (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
            }

            // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
            function isValidDiagonal$1(a, b) {
                return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon$1(a, b) && // dones't intersect other edges
                       (locallyInside$1(a, b) && locallyInside$1(b, a) && middleInside$1(a, b) && // locally visible
                        (area$1(a.prev, a, b.prev) || area$1(a, b.prev, b)) || // does not create opposite-facing sectors
                        equals$3(a, b) && area$1(a.prev, a, a.next) > 0 && area$1(b.prev, b, b.next) > 0); // special zero-length case
            }

            // signed area of a triangle
            function area$1(p, q, r) {
                return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
            }

            // check if two points are equal
            function equals$3(p1, p2) {
                return p1.x === p2.x && p1.y === p2.y;
            }

            // check if two segments intersect
            function intersects$1(p1, q1, p2, q2) {
                var o1 = sign$1(area$1(p1, q1, p2));
                var o2 = sign$1(area$1(p1, q1, q2));
                var o3 = sign$1(area$1(p2, q2, p1));
                var o4 = sign$1(area$1(p2, q2, q1));

                if (o1 !== o2 && o3 !== o4) return true; // general case

                if (o1 === 0 && onSegment$1(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
                if (o2 === 0 && onSegment$1(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
                if (o3 === 0 && onSegment$1(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
                if (o4 === 0 && onSegment$1(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

                return false;
            }

            // for collinear points p, q, r, check if point q lies on segment pr
            function onSegment$1(p, q, r) {
                return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
            }

            function sign$1(num) {
                return num > 0 ? 1 : num < 0 ? -1 : 0;
            }

            // check if a polygon diagonal intersects any polygon segments
            function intersectsPolygon$1(a, b) {
                var p = a;
                do {
                    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                            intersects$1(p, p.next, a, b)) return true;
                    p = p.next;
                } while (p !== a);

                return false;
            }

            // check if a polygon diagonal is locally inside the polygon
            function locallyInside$1(a, b) {
                return area$1(a.prev, a, a.next) < 0 ?
                    area$1(a, b, a.next) >= 0 && area$1(a, a.prev, b) >= 0 :
                    area$1(a, b, a.prev) < 0 || area$1(a, a.next, b) < 0;
            }

            // check if the middle point of a polygon diagonal is inside the polygon
            function middleInside$1(a, b) {
                var p = a,
                    inside = false,
                    px = (a.x + b.x) / 2,
                    py = (a.y + b.y) / 2;
                do {
                    if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                            (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                        inside = !inside;
                    p = p.next;
                } while (p !== a);

                return inside;
            }

            // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
            // if one belongs to the outer ring and another to a hole, it merges it into a single ring
            function splitPolygon$1(a, b) {
                var a2 = new Node$1(a.i, a.x, a.y),
                    b2 = new Node$1(b.i, b.x, b.y),
                    an = a.next,
                    bp = b.prev;

                a.next = b;
                b.prev = a;

                a2.next = an;
                an.prev = a2;

                b2.next = a2;
                a2.prev = b2;

                bp.next = b2;
                b2.prev = bp;

                return b2;
            }

            // create a node and optionally link it with previous one (in a circular doubly linked list)
            function insertNode$1(i, x, y, last) {
                var p = new Node$1(i, x, y);

                if (!last) {
                    p.prev = p;
                    p.next = p;

                } else {
                    p.next = last.next;
                    p.prev = last;
                    last.next.prev = p;
                    last.next = p;
                }
                return p;
            }

            function removeNode$1(p) {
                p.next.prev = p.prev;
                p.prev.next = p.next;

                if (p.prevZ) p.prevZ.nextZ = p.nextZ;
                if (p.nextZ) p.nextZ.prevZ = p.prevZ;
            }

            function Node$1(i, x, y) {
                // vertex index in coordinates array
                this.i = i;

                // vertex coordinates
                this.x = x;
                this.y = y;

                // previous and next vertex nodes in a polygon ring
                this.prev = null;
                this.next = null;

                // z-order curve value
                this.z = null;

                // previous and next nodes in z-order
                this.prevZ = null;
                this.nextZ = null;

                // indicates whether this is a steiner point
                this.steiner = false;
            }

            // return a percentage difference between the polygon area and its triangulation area;
            // used to verify correctness of triangulation
            earcut$1.deviation = function (data, holeIndices, dim, triangles) {
                var hasHoles = holeIndices && holeIndices.length;
                var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

                var polygonArea = Math.abs(signedArea$1(data, 0, outerLen, dim));
                if (hasHoles) {
                    for (var i = 0, len = holeIndices.length; i < len; i++) {
                        var start = holeIndices[i] * dim;
                        var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                        polygonArea -= Math.abs(signedArea$1(data, start, end, dim));
                    }
                }

                var trianglesArea = 0;
                for (i = 0; i < triangles.length; i += 3) {
                    var a = triangles[i] * dim;
                    var b = triangles[i + 1] * dim;
                    var c = triangles[i + 2] * dim;
                    trianglesArea += Math.abs(
                        (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
                        (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
                }

                return polygonArea === 0 && trianglesArea === 0 ? 0 :
                    Math.abs((trianglesArea - polygonArea) / polygonArea);
            };

            function signedArea$1(data, start, end, dim) {
                var sum = 0;
                for (var i = start, j = end - dim; i < end; i += dim) {
                    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
                    j = i;
                }
                return sum;
            }

            // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
            earcut$1.flatten = function (data) {
                var dim = data[0][0].length,
                    result = {vertices: [], holes: [], dimensions: dim},
                    holeIndex = 0;

                for (var i = 0; i < data.length; i++) {
                    for (var j = 0; j < data[i].length; j++) {
                        for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
                    }
                    if (i > 0) {
                        holeIndex += data[i - 1].length;
                        result.holes.push(holeIndex);
                    }
                }
                return result;
            };
            earcut_1$1.default = default_1$1;

            /**
             * @typedef {import("./types").Edge} Edge
             * @typedef {import("./types").Path} Path
             * @typedef {import("./types").Plane} Plane
             * @typedef {import("./types").PointSelector} PointSelector
             * @typedef {import("./types").Polygons} Polygons
             */

            const X$1$3 = 0;
            const Y$1$3 = 1;
            const Z$1$2 = 2;

            /**
             * buildContourXy
             *
             * @function
             * @param {Path} points
             * @param {number[]} contour
             * @param {Edge} loop
             * @param {PointSelector} selectJunction
             * @returns {number}
             */
            const buildContourXy = (points, contour, loop, selectJunction) => {
              const index = contour.length >>> 1;
              let link = loop;
              do {
                if (link.start !== link.next.start && selectJunction(link.start)) {
                  points.push(link.start);
                  contour.push(link.start[X$1$3], link.start[Y$1$3]);
                }
                link = link.next;
              } while (link !== loop);
              return index;
            };

            /**
             * buildContourXz
             *
             * @function
             * @param {Path} points
             * @param {number[]} contour
             * @param {Edge} loop
             * @param {PointSelector} selectJunction
             * @returns {number}
             */
            const buildContourXz = (points, contour, loop, selectJunction) => {
              const index = contour.length >>> 1;
              let link = loop;
              do {
                if (link.start !== link.next.start && selectJunction(link.start)) {
                  points.push(link.start);
                  contour.push(link.start[X$1$3], link.start[Z$1$2]);
                }
                link = link.next;
              } while (link !== loop);
              return index;
            };

            /**
             * buildContourYz
             *
             * @function
             * @param {Path} points
             * @param {number[]} contour
             * @param {Edge} loop
             * @param {PointSelector} selectJunction
             * @returns {number}
             */
            const buildContourYz = (points, contour, loop, selectJunction) => {
              const index = contour.length >>> 1;
              let link = loop;
              do {
                if (link.start !== link.next.start && selectJunction(link.start)) {
                  points.push(link.start);
                  contour.push(link.start[Y$1$3], link.start[Z$1$2]);
                }
                link = link.next;
              } while (link !== loop);
              return index;
            };

            /**
             * selectBuildContour
             *
             * @function
             * @param {Plane} plane
             * @returns {function}
             */
            const selectBuildContour = (plane) => {
              const tZ = dot(plane, [0, 0, 1, 0]);
              if (tZ >= 0.5) {
                // Best aligned with the Z axis.
                return buildContourXy;
              } else if (tZ <= -0.5) {
                return buildContourXy;
              }
              const tY = dot(plane, [0, 1, 0, 0]);
              if (tY >= 0.5) {
                // Best aligned with the Y axis.
                return buildContourXz;
              } else if (tY <= -0.5) {
                return buildContourXz;
              }
              const tX = dot(plane, [1, 0, 0, 0]);
              if (tX >= 0) {
                return buildContourYz;
              } else {
                return buildContourYz;
              }
            };

            /**
             * pushConvexPolygons
             *
             * @function
             * @param {Polygons} polygons
             * @param {Edge} loop
             * @param {PointSelector} selectJunction
             * @returns {undefined}
             */
            const pushConvexPolygons = (
              polygons,
              loop,
              selectJunction,
              concavePolygons
            ) => {
              const plane = toPlane$1(loop);
              const buildContour = selectBuildContour(plane);
              const points = [];
              const contour = [];
              buildContour(points, contour, loop, selectJunction);
              concavePolygons.push(...points);
              const holes = [];
              if (loop.face.holes) {
                for (const hole of loop.face.holes) {
                  const index = buildContour(points, contour, hole, selectJunction);
                  if (index !== contour.length >>> 1) {
                    holes.push(index);
                  }
                }
              }
              const triangles = earcut_1$1(contour, holes);
              for (let i = 0; i < triangles.length; i += 3) {
                const a = triangles[i + 0];
                const b = triangles[i + 1];
                const c = triangles[i + 2];
                const triangle = [points[a], points[b], points[c]];
                const trianglePlane = toPlane(triangle);
                if (trianglePlane === undefined) {
                  // Degenerate.
                  continue;
                }
                if (dot(trianglePlane, plane) < 0) {
                  polygons.push(flip$2(triangle));
                } else {
                  polygons.push(triangle);
                }
              }
            };

            /**
             * @typedef {import("./types").Edge} Edge
             * @typedef {import("./types").Loops} Loops
             * @typedef {import("./types").PointSelector} PointSelector
             * @typedef {import("./types").Solid} Solid
             */

            const walked = Symbol('walked');

            /*
            const pushPolygon = (polygons, loop) => {
              const polygon = [];
              eachLink(loop, link => polygon.push(link.start));
              polygons.push(polygon);
            };
            */

            // FIX: Coplanar surface coherence.
            /**
             * toSolid
             *
             * @function
             * @param {Loops} loops
             * @param {PointSelector} selectJunction
             * @returns {Solid}
             */
            const toSolid = (loops, selectJunction) => {
              const solid = [];

              // Note holes so that we don't try to render them.
              // FIX: Remove this tracking.
              const holes = new Set();
              for (const loop of loops) {
                if (loop === undefined || loop.dead || loop.face === undefined) continue;
                if (loop.face.holes) {
                  for (const hole of loop.face.holes) {
                    holes.add(hole.face);
                  }
                }
              }

              /**
               * walk
               *
               * @param {Edge} loop
               * @returns {undefined}
               */
              const walk = (loop) => {
                if (
                  loop === undefined ||
                  loop.dead ||
                  loop[walked] ||
                  loop.face === undefined
                ) {
                  return;
                }
                if (holes.has(loop.face)) return;
                eachLink(loop, (link) => {
                  link[walked] = true;
                });
                eachLink(loop, (link) => walk(link.twin));
                const polygons = [];
                const concavePolygons = [];
                pushConvexPolygons(polygons, loop, selectJunction, concavePolygons);
                solid.push(polygons);
              };

              for (const loop of loops) {
                walk(loop.face);
              }

              return solid;
            };

            /**
             * CleanSolid produces a defragmented version of a solid, while maintaining watertightness.
             *
             * @function
             * @param {Solid} solid
             * @param {Normalizer} normalize
             * @returns {Solid}
             */

            const fromSolidToCleanSolid = (
              solid,
              normalize,
              isJunction = junctionSelector(fromSolidToJunctions(solid, normalize))
            ) =>
              fromLoopsToCleanSolid(
                fromSolid(solid, normalize, /* closed= */ true),
                normalize,
                isJunction
              );

            const fromLoopsToCleanSolid = (loops, normalize, isJunction) => {
              const mergedLoops = merge(loops);
              /** @type {Edge[]} */
              const cleanedLoops = mergedLoops.map(clean);
              const splitLoops = split(cleanedLoops);
              const cleanedSolid = toSolid(splitLoops, isJunction);
              return cleanedSolid;
            };

            /**
             * @typedef {import("./types").Loops} Loops
             * @typedef {import("./types").Polygons} Polygons
             */

            /**
             * toPolygons
             *
             * @function
             * @param {Loops} loops
             * @returns {Polygons}
             */
            const toPolygons = (loops, includeFaces = true, includeHoles = true) => {
              const polygons = [];
              const faces = [];
              for (const loop of loops) {
                if (includeFaces) {
                  faces.push(loop.face);
                }
                if (loop.face.holes && includeHoles) {
                  faces.push(...loop.face.holes);
                }
              }
              for (const face of faces) {
                const polygon = [];
                eachLink(face, (edge) => {
                  if (edge.face !== undefined) {
                    polygon.push(edge.start);
                  }
                });
                pushWhenValid(polygons, polygon);
              }
              return polygons;
            };

            /**
             * @typedef {import("./types").Normalizer} Normalizer
             * @typedef {import("./types").Solid} Solid
             */

            /**
             * Produces the outline of a surface.
             *
             * @function
             * @param {Surface} surface
             * @param {Normalizer} normalize
             * @returns {Surface}
             */
            const outlineSurface = (
              surface,
              normalize,
              includeFaces = true,
              includeHoles = true
            ) => {
              const loops = fromSurface(surface, normalize);
              const mergedLoops = merge(loops);
              const cleanedLoops = mergedLoops.map(clean);
              const splitLoops = split(cleanedLoops);
              return toPolygons(splitLoops, includeFaces, includeHoles);
            };

            /**
             * @typedef {import("./types").Normalizer} Normalizer
             * @typedef {import("./types").Solid} Solid
             */

            /**
             * Produces the outline of a solid.
             *
             * @function
             * @param {Surface} surface
             * @param {Normalizer} normalize
             * @returns {Surface}
             */
            const outlineSolid = (solid, normalize) => {
              const loops = fromSolid(solid, normalize);
              const mergedLoops = merge(loops);
              const cleanedLoops = mergedLoops.map(clean);
              const splitLoops = split(cleanedLoops);
              return toPolygons(splitLoops);
            };

            // export const toPlane = (surface) => toPlaneOfPolygon(surface[0]);
            const canonicalize$5 = (surface) => {
              const canonicalizedSurface = surface.map(canonicalize$3);
              if (canonicalizedSurface.plane) {
                throw Error('die');
              }
              return canonicalizedSurface;
            };

            // Transforms
            const transform$4 = (matrix, surface) =>
              surface.map((polygon) => transform$3(matrix, polygon));
            const translate$1 = (vector, surface) =>
              transform$4(fromTranslation(vector), surface);

            // FIX: This is incorrect, since it assumes the first non-degenerate polygon is representative.

            const toPlane$2 = (surface) => {
              if (surface.plane !== undefined) {
                return surface.plane;
              } else {
                for (const polygon of surface) {
                  const plane = toPlane(polygon);
                  if (plane !== undefined) {
                    surface.plane = plane;
                    return surface.plane;
                  }
                }
              }
            };

            const EPSILON$1 = 1e-5;

            const COPLANAR = 0; // Neither front nor back.
            const FRONT = 1;
            const BACK = 2;
            const SPANNING = 3; // Both front and back.

            const toType = (plane, point) => {
              let t = signedDistanceToPoint(plane, point);
              if (t < -EPSILON$1) {
                return BACK;
              } else if (t > EPSILON$1) {
                return FRONT;
              } else {
                return COPLANAR;
              }
            };

            const pointType = [];

            const cutSurface = (
              plane,
              coplanarFrontSurfaces,
              coplanarBackSurfaces,
              frontSurfaces,
              backSurfaces,
              frontEdges,
              backEdges,
              surface
            ) => {
              const surfacePlane = toPlane$2(surface);
              if (surfacePlane === undefined) {
                // Degenerate.
                return;
              }
              let coplanarFrontPolygons;
              let coplanarBackPolygons;
              let frontPolygons;
              let backPolygons;
              for (let polygon of surface) {
                pointType.length = 0;
                let polygonType = COPLANAR;
                if (!equals$1(surfacePlane, plane)) {
                  for (const point of polygon) {
                    const type = toType(plane, point);
                    polygonType |= type;
                    pointType.push(type);
                  }
                }

                // Put the polygon in the correct list, splitting it when necessary.
                switch (polygonType) {
                  case COPLANAR: {
                    if (dot(plane, surfacePlane) > 0) {
                      if (coplanarFrontPolygons === undefined) {
                        coplanarFrontPolygons = [];
                      }
                      coplanarFrontPolygons.push(polygon);
                    } else {
                      if (coplanarBackPolygons === undefined) {
                        coplanarBackPolygons = [];
                      }
                      coplanarBackPolygons.push(polygon);
                    }
                    break;
                  }
                  case FRONT: {
                    if (frontPolygons === undefined) {
                      frontPolygons = [];
                    }
                    frontPolygons.push(polygon);
                    let startPoint = polygon[polygon.length - 1];
                    let startType = pointType[polygon.length - 1];
                    for (let nth = 0; nth < polygon.length; nth++) {
                      const endPoint = polygon[nth];
                      const endType = pointType[nth];
                      if (startType === COPLANAR && endType === COPLANAR) {
                        frontEdges.push([startPoint, endPoint]);
                      }
                      startPoint = endPoint;
                      startType = endType;
                    }
                    break;
                  }
                  case BACK: {
                    if (backPolygons === undefined) {
                      backPolygons = [];
                    }
                    backPolygons.push(polygon);
                    let startPoint = polygon[polygon.length - 1];
                    let startType = pointType[polygon.length - 1];
                    for (let nth = 0; nth < polygon.length; nth++) {
                      const endPoint = polygon[nth];
                      const endType = pointType[nth];
                      if (startType === COPLANAR && endType === COPLANAR) {
                        backEdges.push([startPoint, endPoint]);
                      }
                      startPoint = endPoint;
                      startType = endType;
                    }
                    break;
                  }
                  case SPANNING: {
                    // Make a local copy so that mutation does not propagate.
                    polygon = polygon.slice();
                    let backPoints = [];
                    let frontPoints = [];
                    // Add the colinear spanning point to the polygon.
                    {
                      let last = polygon.length - 1;
                      for (let current = 0; current < polygon.length; last = current++) {
                        const lastType = pointType[last];
                        const lastPoint = polygon[last];
                        if ((lastType | pointType[current]) === SPANNING) {
                          // Break spanning segments at the point of intersection.
                          const rawSpanPoint = splitLineSegmentByPlane(
                            plane,
                            lastPoint,
                            polygon[current]
                          );
                          const spanPoint = subtract(
                            rawSpanPoint,
                            scale(signedDistanceToPoint(surfacePlane, rawSpanPoint), plane)
                          );
                          // Note: Destructive modification of polygon here.
                          polygon.splice(current, 0, spanPoint);
                          pointType.splice(current, 0, COPLANAR);
                        }
                      }
                    }
                    // Spanning points have been inserted.
                    {
                      let last = polygon.length - 1;
                      let lastCoplanar = polygon[pointType.lastIndexOf(COPLANAR)];
                      for (let current = 0; current < polygon.length; last = current++) {
                        const point = polygon[current];
                        const type = pointType[current];
                        const lastType = pointType[last];
                        const lastPoint = polygon[last];
                        if (type !== FRONT) {
                          backPoints.push(point);
                        }
                        if (type !== BACK) {
                          frontPoints.push(point);
                        }
                        if (type === COPLANAR) {
                          if (lastType === COPLANAR) {
                            frontEdges.push([lastPoint, point]);
                            backEdges.push([lastPoint, point]);
                          } else if (lastType === BACK) {
                            frontEdges.push([lastCoplanar, point]);
                          } else if (lastType === FRONT) {
                            backEdges.push([lastCoplanar, point]);
                          }
                          lastCoplanar = point;
                        }
                      }
                    }
                    if (frontPoints.length >= 3) {
                      // Add the polygon that sticks out the front of the plane.
                      if (frontPolygons === undefined) {
                        frontPolygons = [];
                      }
                      frontPolygons.push(frontPoints);
                    }
                    if (backPoints.length >= 3) {
                      // Add the polygon that sticks out the back of the plane.
                      if (backPolygons === undefined) {
                        backPolygons = [];
                      }
                      backPolygons.push(backPoints);
                    }
                    break;
                  }
                }
              }
              if (coplanarFrontPolygons !== undefined) {
                coplanarFrontSurfaces.push(coplanarFrontPolygons);
              }
              if (coplanarBackPolygons !== undefined) {
                coplanarBackSurfaces.push(coplanarBackPolygons);
              }
              if (frontPolygons !== undefined) {
                frontSurfaces.push(frontPolygons);
              }
              if (backPolygons !== undefined) {
                backSurfaces.push(backPolygons);
              }
            };

            const cutImpl = (planeSurface, surface) => {
              const front = [];
              const back = [];
              const frontEdges = [];
              const backEdges = [];

              cutSurface(
                toPlane$2(planeSurface),
                front,
                back,
                front,
                back,
                frontEdges,
                backEdges,
                surface
              );
              if (frontEdges.some((edge) => edge[1] === undefined)) {
                throw Error(`die/end/missing: ${JSON.stringify(frontEdges)}`);
              }

              return [].concat(...back);
            };

            const cut = cacheCut(cutImpl);

            const eachPoint = (thunk, surface) => {
              for (const polygon of surface) {
                for (const [x = 0, y = 0, z = 0] of polygon) {
                  thunk([x, y, z]);
                }
              }
            };

            /**
             * Transforms each polygon of the surface.
             *
             * @param {Polygons} original - the Polygons to transform.
             * @param {Function} [transform=identity] - function used to transform the polygons.
             * @returns {Polygons} a copy with transformed polygons.
             */
            const map$2 = (original, transform) => {
              if (original === undefined) {
                original = [];
              }
              if (transform === undefined) {
                transform = (_) => _;
              }
              return original.map((polygon) => transform(polygon));
            };

            const flip$4 = (surface) => map$2(surface, flip$2);

            const fromPlane = (plane) => [toPolygon(plane)];

            const THRESHOLD$1 = 1e-5;

            const watertight = Symbol('watertight');

            const X$5 = 0;
            const Y$5 = 1;
            const Z$4 = 2;

            const orderVertices = (a, b) => {
              const dX = a[X$5] - b[X$5];
              if (dX !== 0) return dX;
              const dY = a[Y$5] - b[Y$5];
              if (dY !== 0) return dY;
              const dZ = a[Z$4] - b[Z$4];
              return dZ;
            };

            const makeWatertight = (surface, normalize, threshold = THRESHOLD$1) => {
              if (!surface[watertight]) {
                if (isWatertight(surface)) {
                  surface[watertight] = surface;
                }
              }

              if (!surface[watertight]) {
                if (normalize === undefined) {
                  normalize = createNormalize3(1 / threshold);
                }

                const vertices = new Set();
                for (const path of surface) {
                  const reconciledPath = [];
                  for (const point of path) {
                    const reconciledPoint = normalize(point);
                    reconciledPath.push(reconciledPoint);
                    vertices.add(reconciledPoint);
                  }
                  if (toPlane(reconciledPath) !== undefined) ;
                }

                const orderedVertices = [...vertices];
                orderedVertices.sort(orderVertices);
                for (let i = 0; i < orderedVertices.length; i++) {
                  orderedVertices[i].index = i;
                }

                const watertightPaths = [];
                for (const path of surface) {
                  const watertightPath = [];
                  for (const [start, end] of getEdges(path)) {
                    watertightPath.push(start);
                    const span = distance(start, end);
                    const colinear = [];
                    // let limit = Math.max(start.index, end.index);
                    // for (let i = Math.min(start.index, end.index); i < limit; i++) {
                    for (let i = 0; i < orderedVertices.length; i++) {
                      const vertex = orderedVertices[i];
                      // FIX: Threshold
                      if (
                        Math.abs(distance(start, vertex) + distance(vertex, end) - span) <
                        threshold
                      ) {
                        colinear.push(vertex);
                      }
                    }
                    // Arrange by distance from start.
                    colinear.sort((a, b) => distance(start, a) - distance(start, b));
                    // Insert into the path.
                    watertightPath.push(...colinear);
                  }
                  pushWhenValid(watertightPaths, watertightPath);
                }

                surface[watertight] = watertightPaths;
              }

              return surface[watertight];
            };

            const isWatertight = (surface) => {
              const edges = new Set();
              for (const path of surface) {
                for (const [start, end] of getEdges(path)) {
                  edges.add(`${JSON.stringify([start, end])}`);
                }
              }
              for (const path of surface) {
                for (const [start, end] of getEdges(path)) {
                  if (!edges.has(`${JSON.stringify([end, start])}`)) {
                    return false;
                  }
                }
              }
              return true;
            };

            // export { fromSurfaceToCleanSurface as makeConvex } from './jsxcad-geometry-halfedge.js';

            // Cut the corners to produce triangles.
            const triangulateConvexPolygon = (polygon) => {
              const surface = [];
              for (let i = 2; i < polygon.length; i++) {
                surface.push([polygon[0], polygon[i - 1], polygon[i]]);
              }
              return surface;
            };

            const makeConvex$1 = (surface, normalize3 = createNormalize3(), plane) => {
              if (surface.length === undefined) {
                throw Error('die');
              }
              if (surface.length === 0) {
                // An empty surface is not non-convex.
                return surface;
              }
              if (surface.length === 1) {
                const polygon = surface[0];
                if (polygon.length === 3) {
                  // A triangle is already convex.
                  return surface;
                }
                if (polygon.length > 3 && isConvex(polygon)) {
                  return triangulateConvexPolygon(polygon.map(normalize3));
                }
              }
              if (plane === undefined) {
                plane = toPlane$2(surface);
                if (plane === undefined) {
                  return [];
                }
              }
              const [to, from] = toXYPlaneTransforms(plane);
              const z0Surface = transform$4(
                to,
                surface.map((path) => path.map(normalize3))
              );
              const convexZ0Surface = makeConvex(z0Surface);
              const convexSurface = transform$4(from, convexZ0Surface).map((path) =>
                path.map(normalize3)
              );
              return makeWatertight(convexSurface);
            };

            const measureArea$2 = (surface) => {
              // CHECK: That this handles negative area properly.
              let total = 0;
              for (const polygon of surface) {
                total += measureArea$1(polygon);
              }
              return total;
            };

            // returns an array of two Vector3Ds (minimum coordinates and maximum coordinates)
            const measureBoundingBox$2 = (surface) => {
              if (surface.measureBoundingBox === undefined) {
                const min = [Infinity, Infinity, Infinity];
                const max = [-Infinity, -Infinity, -Infinity];
                for (const path of surface) {
                  for (const point of path) {
                    if (point[0] < min[0]) min[0] = point[0];
                    if (point[1] < min[1]) min[1] = point[1];
                    if (point[2] < min[2]) min[2] = point[2];
                    if (point[0] > max[0]) max[0] = point[0];
                    if (point[1] > max[1]) max[1] = point[1];
                    if (point[2] > max[2]) max[2] = point[2];
                  }
                }
                surface.measureBoundingBox = [min, max];
              }
              return surface.measureBoundingBox;
            };

            const transformImpl = (matrix, polygons) =>
              polygons.map((polygon) => transform$3(matrix, polygon));

            const transform$1$1 = cacheTransform(transformImpl);

            const THRESHOLD$2 = 1e-5;

            // We expect a solid of reconciled triangles.

            const X$6 = 0;
            const Y$6 = 1;
            const Z$5 = 2;

            const orderVertices$1 = (a, b) => {
              const dX = a[X$6] - b[X$6];
              if (dX !== 0) return dX;
              const dY = a[Y$6] - b[Y$6];
              if (dY !== 0) return dY;
              const dZ = a[Z$5] - b[Z$5];
              return dZ;
            };

            const makeWatertight$1 = (solid, normalize, threshold = THRESHOLD$2) => {
              if (normalize === undefined) {
                normalize = createNormalize3(1 / threshold);
              }

              const vertices = new Set();

              const reconciledSolid = [];
              for (const surface of solid) {
                const reconciledSurface = [];
                for (const path of surface) {
                  const reconciledPath = [];
                  for (const point of path) {
                    const reconciledPoint = normalize(point);
                    reconciledPath.push(reconciledPoint);
                    vertices.add(reconciledPoint);
                  }
                  if (toPlane(reconciledPath) !== undefined) {
                    // Filter degenerates.
                    reconciledSurface.push(reconciledPath);
                  }
                }
                reconciledSolid.push(reconciledSurface);
              }

              const orderedVertices = [...vertices];
              orderedVertices.sort(orderVertices$1);
              for (let i = 0; i < orderedVertices.length; i++) {
                orderedVertices[i].index = i;
              }

              const watertightSolid = [];
              for (const surface of reconciledSolid) {
                const watertightPaths = [];
                for (const path of surface) {
                  const watertightPath = [];
                  for (const [start, end] of getEdges(path)) {
                    watertightPath.push(start);
                    const span = distance(start, end);
                    const colinear = [];
                    // let limit = Math.max(start.index, end.index);
                    // for (let i = Math.min(start.index, end.index); i <= limit; i++) {
                    for (let i = 0; i < orderedVertices.length; i++) {
                      const vertex = orderedVertices[i];
                      // FIX: Threshold
                      if (
                        Math.abs(distance(start, vertex) + distance(vertex, end) - span) <
                        threshold
                      ) {
                        colinear.push(vertex);
                      }
                    }
                    // Arrange by distance from start.
                    colinear.sort((a, b) => distance(start, a) - distance(start, b));
                    // Insert into the path.
                    watertightPath.push(...colinear);
                  }
                  pushWhenValid(watertightPaths, watertightPath);
                }
                watertightSolid.push(watertightPaths);
              }

              return watertightSolid;
            };

            const isWatertight$1 = (solid) => {
              const edges = new Set();
              for (const surface of solid) {
                for (const path of surface) {
                  for (const [start, end] of getEdges(path)) {
                    edges.add(`${JSON.stringify([start, end])}`);
                  }
                }
              }
              for (const surface of solid) {
                for (const path of surface) {
                  for (const [start, end] of getEdges(path)) {
                    if (!edges.has(`${JSON.stringify([end, start])}`)) {
                      return false;
                    }
                  }
                }
              }
              return true;
            };

            const transform$5 = (matrix, solid) =>
              solid.map((surface) => transform$4(matrix, surface));

            const alignVertices = (solid, normalize3 = createNormalize3()) => {
              const aligned = solid.map((surface) =>
                surface
                  .map((polygon) => deduplicate(polygon.map(normalize3)))
                  .filter((polygon) => polygon.length >= 3)
                  .filter((polygon) => toPlane(polygon) !== undefined)
              );
              return aligned;
            };

            const canonicalize$6 = (solid) => solid.map(canonicalize$5);

            // returns an array of two Vector3Ds (minimum coordinates and maximum coordinates)
            const measureBoundingBox$3 = (solid) => {
              if (solid.measureBoundingBox === undefined) {
                const min = [Infinity, Infinity, Infinity];
                const max = [-Infinity, -Infinity, -Infinity];
                for (const surface of solid) {
                  const [minSurface, maxSurface] = measureBoundingBox$2(surface);
                  if (minSurface[0] < min[0]) min[0] = minSurface[0];
                  if (minSurface[1] < min[1]) min[1] = minSurface[1];
                  if (minSurface[2] < min[2]) min[2] = minSurface[2];
                  if (maxSurface[0] > max[0]) max[0] = maxSurface[0];
                  if (maxSurface[1] > max[1]) max[1] = maxSurface[1];
                  if (maxSurface[2] > max[2]) max[2] = maxSurface[2];
                }
                solid.measureBoundingBox = [min, max];
              }
              return solid.measureBoundingBox;
            };

            const eachPoint$1 = (thunk, solid) => {
              for (const surface of solid) {
                eachPoint(thunk, surface);
              }
            };

            // Expects aligned vertices.

            const findOpenEdges = (solid, isOpen = true) => {
              const test = (closed) => (isOpen ? !closed : closed);

              const edges = new Set();
              for (const surface of solid) {
                for (const face of surface) {
                  for (const edge of getEdges(face)) {
                    edges.add(JSON.stringify(edge));
                  }
                }
              }
              const openEdges = [];
              for (const surface of solid) {
                for (const face of surface) {
                  for (const [start, end] of getEdges(face)) {
                    if (test(edges.has(JSON.stringify([end, start])))) {
                      openEdges.push([start, end]);
                    }
                  }
                }
              }
              return openEdges;
            };

            const flip$5 = (solid) => solid.map((surface) => flip$4(surface));

            /** @type {function(Polygon[],Normalizer):Solid} */
            const fromPolygons = (polygons, normalize = createNormalize3()) => {
              const watertightSolid = makeWatertight$1([polygons], normalize);
              const cleanedSolid = fromSolidToCleanSolid(watertightSolid, normalize);
              return cleanedSolid;
            };

            const LARGE = 1e2; // works
            // const LARGE = 1e7; // works
            // const LARGE = 1e8; // works
            // const LARGE = 1e9; // works
            // const LARGE = 1e10; // shows defects

            const fromSurface$1 = (surface, normalize) => {
              const solid = [];
              const normal = toPlane$2(surface);
              if (normal === undefined) {
                // The surface is degenerate.
                return [];
              }
              const top = scale(LARGE, normal);
              const bottom = scale(0, normal);
              for (const path of outlineSurface(surface, normalize)) {
                for (const [start, end] of getEdges(path)) {
                  // Build a large wall.
                  solid.push([
                    [add(start, top), add(start, bottom), add(end, bottom), add(end, top)],
                  ]);
                }
              }
              // Build a tall prism.
              solid.push(
                translate$1(bottom, flip$4(surface)),
                translate$1(top, surface)
              );
              return solid;
            };

            const reconcile = (solid, normalize = createNormalize3()) =>
              alignVertices(solid, normalize);

            // Relax the coplanar arrangement into polygon soup.
            const toPolygons$1 = (solid) => {
              const polygons = [];
              for (const surface of solid) {
                polygons.push(...surface);
              }
              return polygons;
            };

            const transform$6 = (matrix, paths) =>
              paths.map((path) => transform$1(matrix, path));

            const canonicalize$7 = (paths) => {
              let canonicalized = paths.map(canonicalize$1);
              if (paths.properties !== undefined) {
                // Transfer properties.
                canonicalized.properties = paths.properties;
              }
              return canonicalized;
            };

            // FIX: Determine the correct behaviour here.

            const difference = (pathset, ...pathsets) => pathset;

            const eachPoint$2 = (thunk, paths) => {
              for (const path of paths) {
                for (const point of path) {
                  if (point !== null) {
                    thunk(point);
                  }
                }
              }
            };

            const flip$6 = (paths) => paths.map(flip);

            const segment = (paths, start, end) => {
              const segments = [];
              let segment = [];
              let position = 0;
              let collecting = false;
              for (const path of paths) {
                for (const [first, second] of getEdges(path)) {
                  const vector = subtract(second, first);
                  const nextPosition = position + length(vector);
                  if (collecting === false) {
                    if (nextPosition >= start) {
                      const point = add(first, scale(start - position, normalize(vector)));
                      // The segments are always open paths.
                      segment.push(null, point);
                      if (start - position < 0) {
                        throw Error('die');
                      }
                      collecting = true;
                    }
                  }
                  if (collecting === true) {
                    if (position > start && segment.length === 0) {
                      segment.push(first);
                    }
                    if (nextPosition >= end) {
                      const point = add(first, scale(end - position, normalize(vector)));
                      segment.push(point);
                      segments.push(segment);
                      return segments;
                    } else {
                      segment.push(second);
                    }
                  }
                  position = nextPosition;
                }
                if (segment.length > 0) {
                  segments.push(segment);
                  segment = [];
                }
              }
              return segments;
            };

            // FIX: Deduplication.

            const union = (...pathsets) => [].concat(...pathsets);
            const translate$2 = ([x = 0, y = 0, z = 0], paths) =>
              transform$6(fromTranslation([x, y, z]), paths);

            const transform$7 = (matrix, points) =>
              points.map((point) => transform(matrix, point));
            const translate$3 = ([x = 0, y = 0, z = 0], points) =>
              transform$7(fromTranslation([x, y, z]), points);

            const canonicalize$8 = (points) => points.map(canonicalize);

            const eachPoint$3 = (thunk, points) => {
              for (const point of points) {
                thunk(point);
              }
            };

            const union$1 = (...geometries) => [].concat(...geometries);

            const flip$7 = (points) => points;

            function clone(point) { //TODO: use gl-vec2 for this
                return [point[0], point[1]]
            }

            function vec2(x, y) {
                return [x, y]
            }

            var _function = function createBezierBuilder(opt) {
                opt = opt||{};

                var RECURSION_LIMIT = typeof opt.recursion === 'number' ? opt.recursion : 8;
                var FLT_EPSILON = typeof opt.epsilon === 'number' ? opt.epsilon : 1.19209290e-7;
                var PATH_DISTANCE_EPSILON = typeof opt.pathEpsilon === 'number' ? opt.pathEpsilon : 1.0;

                var curve_angle_tolerance_epsilon = typeof opt.angleEpsilon === 'number' ? opt.angleEpsilon : 0.01;
                var m_angle_tolerance = opt.angleTolerance || 0;
                var m_cusp_limit = opt.cuspLimit || 0;

                return function bezierCurve(start, c1, c2, end, scale, points) {
                    if (!points)
                        points = [];

                    scale = typeof scale === 'number' ? scale : 1.0;
                    var distanceTolerance = PATH_DISTANCE_EPSILON / scale;
                    distanceTolerance *= distanceTolerance;
                    begin(start, c1, c2, end, points, distanceTolerance);
                    return points
                }


                ////// Based on:
                ////// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp

                function begin(start, c1, c2, end, points, distanceTolerance) {
                    points.push(clone(start));
                    var x1 = start[0],
                        y1 = start[1],
                        x2 = c1[0],
                        y2 = c1[1],
                        x3 = c2[0],
                        y3 = c2[1],
                        x4 = end[0],
                        y4 = end[1];
                    recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, 0);
                    points.push(clone(end));
                }

                function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
                    if(level > RECURSION_LIMIT) 
                        return

                    var pi = Math.PI;

                    // Calculate all the mid-points of the line segments
                    //----------------------
                    var x12   = (x1 + x2) / 2;
                    var y12   = (y1 + y2) / 2;
                    var x23   = (x2 + x3) / 2;
                    var y23   = (y2 + y3) / 2;
                    var x34   = (x3 + x4) / 2;
                    var y34   = (y3 + y4) / 2;
                    var x123  = (x12 + x23) / 2;
                    var y123  = (y12 + y23) / 2;
                    var x234  = (x23 + x34) / 2;
                    var y234  = (y23 + y34) / 2;
                    var x1234 = (x123 + x234) / 2;
                    var y1234 = (y123 + y234) / 2;

                    if(level > 0) { // Enforce subdivision first time
                        // Try to approximate the full cubic curve by a single straight line
                        //------------------
                        var dx = x4-x1;
                        var dy = y4-y1;

                        var d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
                        var d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);

                        var da1, da2;

                        if(d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
                            // Regular care
                            //-----------------
                            if((d2 + d3)*(d2 + d3) <= distanceTolerance * (dx*dx + dy*dy)) {
                                // If the curvature doesn't exceed the distanceTolerance value
                                // we tend to finish subdivisions.
                                //----------------------
                                if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                                    points.push(vec2(x1234, y1234));
                                    return
                                }

                                // Angle & Cusp Condition
                                //----------------------
                                var a23 = Math.atan2(y3 - y2, x3 - x2);
                                da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
                                da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
                                if(da1 >= pi) da1 = 2*pi - da1;
                                if(da2 >= pi) da2 = 2*pi - da2;

                                if(da1 + da2 < m_angle_tolerance) {
                                    // Finally we can stop the recursion
                                    //----------------------
                                    points.push(vec2(x1234, y1234));
                                    return
                                }

                                if(m_cusp_limit !== 0.0) {
                                    if(da1 > m_cusp_limit) {
                                        points.push(vec2(x2, y2));
                                        return
                                    }

                                    if(da2 > m_cusp_limit) {
                                        points.push(vec2(x3, y3));
                                        return
                                    }
                                }
                            }
                        }
                        else {
                            if(d2 > FLT_EPSILON) {
                                // p1,p3,p4 are collinear, p2 is considerable
                                //----------------------
                                if(d2 * d2 <= distanceTolerance * (dx*dx + dy*dy)) {
                                    if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                                        points.push(vec2(x1234, y1234));
                                        return
                                    }

                                    // Angle Condition
                                    //----------------------
                                    da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
                                    if(da1 >= pi) da1 = 2*pi - da1;

                                    if(da1 < m_angle_tolerance) {
                                        points.push(vec2(x2, y2));
                                        points.push(vec2(x3, y3));
                                        return
                                    }

                                    if(m_cusp_limit !== 0.0) {
                                        if(da1 > m_cusp_limit) {
                                            points.push(vec2(x2, y2));
                                            return
                                        }
                                    }
                                }
                            }
                            else if(d3 > FLT_EPSILON) {
                                // p1,p2,p4 are collinear, p3 is considerable
                                //----------------------
                                if(d3 * d3 <= distanceTolerance * (dx*dx + dy*dy)) {
                                    if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                                        points.push(vec2(x1234, y1234));
                                        return
                                    }

                                    // Angle Condition
                                    //----------------------
                                    da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
                                    if(da1 >= pi) da1 = 2*pi - da1;

                                    if(da1 < m_angle_tolerance) {
                                        points.push(vec2(x2, y2));
                                        points.push(vec2(x3, y3));
                                        return
                                    }

                                    if(m_cusp_limit !== 0.0) {
                                        if(da1 > m_cusp_limit)
                                        {
                                            points.push(vec2(x3, y3));
                                            return
                                        }
                                    }
                                }
                            }
                            else {
                                // Collinear case
                                //-----------------
                                dx = x1234 - (x1 + x4) / 2;
                                dy = y1234 - (y1 + y4) / 2;
                                if(dx*dx + dy*dy <= distanceTolerance) {
                                    points.push(vec2(x1234, y1234));
                                    return
                                }
                            }
                        }
                    }

                    // Continue subdivision
                    //----------------------
                    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1); 
                    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1); 
                }
            };

            var adaptiveBezierCurve = _function();
            var adaptiveBezierCurve_1 = adaptiveBezierCurve.bezier;

            function unwrapExports$1 (x) {
            	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
            }

            function createCommonjsModule$2(fn, module) {
            	return module = { exports: {} }, fn(module, module.exports), module.exports;
            }

            var subtract_1 = subtract$2;

            /**
             * Subtracts vector b from vector a
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {vec3} out
             */
            function subtract$2(out, a, b) {
                out[0] = a[0] - b[0];
                out[1] = a[1] - b[1];
                out[2] = a[2] - b[2];
                return out
            }

            var cross_1 = cross$1;

            /**
             * Computes the cross product of two vec3's
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {vec3} out
             */
            function cross$1(out, a, b) {
                var ax = a[0], ay = a[1], az = a[2],
                    bx = b[0], by = b[1], bz = b[2];

                out[0] = ay * bz - az * by;
                out[1] = az * bx - ax * bz;
                out[2] = ax * by - ay * bx;
                return out
            }

            var squaredLength_1 = squaredLength$1;

            /**
             * Calculates the squared length of a vec3
             *
             * @param {vec3} a vector to calculate squared length of
             * @returns {Number} squared length of a
             */
            function squaredLength$1(a) {
                var x = a[0],
                    y = a[1],
                    z = a[2];
                return x*x + y*y + z*z
            }

            var ab = [];
            var ap = [];
            var cr = [];

            var squared = function (p, a, b) {
              // // == vector solution
              // var normalize = require('gl-vec3/normalize')
              // var scaleAndAdd = require('gl-vec3/scaleAndAdd')
              // var dot = require('gl-vec3/dot')
              // var squaredDistance = require('gl-vec3/squaredDistance')
              // // n = vector `ab` normalized
              // var n = []
              // // projection = projection of `point` on `n`
              // var projection = []
              // normalize(n, subtract(n, a, b))
              // scaleAndAdd(projection, a, n, dot(n, p))
              // return squaredDistance(projection, p)

              // == parallelogram solution
              //
              //            s
              //      __a________b__
              //       /   |    /
              //      /   h|   /
              //     /_____|__/
              //    p
              //
              //  s = b - a
              //  area = s * h
              //  |ap x s| = s * h
              //  h = |ap x s| / s
              //
              subtract_1(ab, b, a);
              subtract_1(ap, p, a);
              var area = squaredLength_1(cross_1(cr, ap, ab));
              var s = squaredLength_1(ab);
              if (s === 0) {
                throw Error('a and b are the same point')
              }
              return area / s
            };

            var pointLineDistance = function (point, a, b) {
              return Math.sqrt(squared(point, a, b))
            };

            var normalize_1 = normalize$2;

            /**
             * Normalize a vec3
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a vector to normalize
             * @returns {vec3} out
             */
            function normalize$2(out, a) {
                var x = a[0],
                    y = a[1],
                    z = a[2];
                var len = x*x + y*y + z*z;
                if (len > 0) {
                    //TODO: evaluate use of glm_invsqrt here?
                    len = 1 / Math.sqrt(len);
                    out[0] = a[0] * len;
                    out[1] = a[1] * len;
                    out[2] = a[2] * len;
                }
                return out
            }

            var tmp = [0, 0, 0];

            var getPlaneNormal = planeNormal;

            function planeNormal (out, point1, point2, point3) {
              subtract_1(out, point1, point2);
              subtract_1(tmp, point2, point3);
              cross_1(out, out, tmp);
              return normalize_1(out, out)
            }

            var dot_1 = dot$2;

            /**
             * Calculates the dot product of two vec3's
             *
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {Number} dot product of a and b
             */
            function dot$2(a, b) {
                return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
            }

            var VertexList_1 = createCommonjsModule$2(function (module, exports) {

            Object.defineProperty(exports, "__esModule", {
              value: true
            });

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var VertexList = function () {
              function VertexList() {
                _classCallCheck(this, VertexList);

                this.head = null;
                this.tail = null;
              }

              _createClass(VertexList, [{
                key: "clear",
                value: function clear() {
                  this.head = this.tail = null;
                }

                /**
                 * Inserts a `node` before `target`, it's assumed that
                 * `target` belongs to this doubly linked list
                 *
                 * @param {*} target
                 * @param {*} node
                 */

              }, {
                key: "insertBefore",
                value: function insertBefore(target, node) {
                  node.prev = target.prev;
                  node.next = target;
                  if (!node.prev) {
                    this.head = node;
                  } else {
                    node.prev.next = node;
                  }
                  target.prev = node;
                }

                /**
                 * Inserts a `node` after `target`, it's assumed that
                 * `target` belongs to this doubly linked list
                 *
                 * @param {Vertex} target
                 * @param {Vertex} node
                 */

              }, {
                key: "insertAfter",
                value: function insertAfter(target, node) {
                  node.prev = target;
                  node.next = target.next;
                  if (!node.next) {
                    this.tail = node;
                  } else {
                    node.next.prev = node;
                  }
                  target.next = node;
                }

                /**
                 * Appends a `node` to the end of this doubly linked list
                 * Note: `node.next` will be unlinked from `node`
                 * Note: if `node` is part of another linked list call `addAll` instead
                 *
                 * @param {*} node
                 */

              }, {
                key: "add",
                value: function add(node) {
                  if (!this.head) {
                    this.head = node;
                  } else {
                    this.tail.next = node;
                  }
                  node.prev = this.tail;
                  // since node is the new end it doesn't have a next node
                  node.next = null;
                  this.tail = node;
                }

                /**
                 * Appends a chain of nodes where `node` is the head,
                 * the difference with `add` is that it correctly sets the position
                 * of the node list `tail` property
                 *
                 * @param {*} node
                 */

              }, {
                key: "addAll",
                value: function addAll(node) {
                  if (!this.head) {
                    this.head = node;
                  } else {
                    this.tail.next = node;
                  }
                  node.prev = this.tail;

                  // find the end of the list
                  while (node.next) {
                    node = node.next;
                  }
                  this.tail = node;
                }

                /**
                 * Deletes a `node` from this linked list, it's assumed that `node` is a
                 * member of this linked list
                 *
                 * @param {*} node
                 */

              }, {
                key: "remove",
                value: function remove(node) {
                  if (!node.prev) {
                    this.head = node.next;
                  } else {
                    node.prev.next = node.next;
                  }

                  if (!node.next) {
                    this.tail = node.prev;
                  } else {
                    node.next.prev = node.prev;
                  }
                }

                /**
                 * Removes a chain of nodes whose head is `a` and whose tail is `b`,
                 * it's assumed that `a` and `b` belong to this list and also that `a`
                 * comes before `b` in the linked list
                 *
                 * @param {*} a
                 * @param {*} b
                 */

              }, {
                key: "removeChain",
                value: function removeChain(a, b) {
                  if (!a.prev) {
                    this.head = b.next;
                  } else {
                    a.prev.next = b.next;
                  }

                  if (!b.next) {
                    this.tail = a.prev;
                  } else {
                    b.next.prev = a.prev;
                  }
                }
              }, {
                key: "first",
                value: function first() {
                  return this.head;
                }
              }, {
                key: "isEmpty",
                value: function isEmpty() {
                  return !this.head;
                }
              }]);

              return VertexList;
            }();

            exports.default = VertexList;
            module.exports = exports["default"];
            });

            unwrapExports$1(VertexList_1);

            var Vertex_1 = createCommonjsModule$2(function (module, exports) {

            Object.defineProperty(exports, "__esModule", {
              value: true
            });

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var Vertex = function Vertex(point, index) {
              _classCallCheck(this, Vertex);

              this.point = point;
              // index in the input array
              this.index = index;
              // vertex is a double linked list node
              this.next = null;
              this.prev = null;
              // the face that is able to see this point
              this.face = null;
            };

            exports.default = Vertex;
            module.exports = exports["default"];
            });

            unwrapExports$1(Vertex_1);

            var add_1 = add$1;

            /**
             * Adds two vec3's
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {vec3} out
             */
            function add$1(out, a, b) {
                out[0] = a[0] + b[0];
                out[1] = a[1] + b[1];
                out[2] = a[2] + b[2];
                return out
            }

            var copy_1 = copy;

            /**
             * Copy the values from one vec3 to another
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the source vector
             * @returns {vec3} out
             */
            function copy(out, a) {
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                return out
            }

            var length_1 = length$1;

            /**
             * Calculates the length of a vec3
             *
             * @param {vec3} a vector to calculate length of
             * @returns {Number} length of a
             */
            function length$1(a) {
                var x = a[0],
                    y = a[1],
                    z = a[2];
                return Math.sqrt(x*x + y*y + z*z)
            }

            var scale_1 = scale$3;

            /**
             * Scales a vec3 by a scalar number
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the vector to scale
             * @param {Number} b amount to scale the vector by
             * @returns {vec3} out
             */
            function scale$3(out, a, b) {
                out[0] = a[0] * b;
                out[1] = a[1] * b;
                out[2] = a[2] * b;
                return out
            }

            var scaleAndAdd_1 = scaleAndAdd;

            /**
             * Adds two vec3's after scaling the second operand by a scalar value
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @param {Number} scale the amount to scale b by before adding
             * @returns {vec3} out
             */
            function scaleAndAdd(out, a, b, scale) {
                out[0] = a[0] + (b[0] * scale);
                out[1] = a[1] + (b[1] * scale);
                out[2] = a[2] + (b[2] * scale);
                return out
            }

            var distance_1 = distance$1;

            /**
             * Calculates the euclidian distance between two vec3's
             *
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {Number} distance between a and b
             */
            function distance$1(a, b) {
                var x = b[0] - a[0],
                    y = b[1] - a[1],
                    z = b[2] - a[2];
                return Math.sqrt(x*x + y*y + z*z)
            }

            var squaredDistance_1 = squaredDistance$1;

            /**
             * Calculates the squared euclidian distance between two vec3's
             *
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {Number} squared distance between a and b
             */
            function squaredDistance$1(a, b) {
                var x = b[0] - a[0],
                    y = b[1] - a[1],
                    z = b[2] - a[2];
                return x*x + y*y + z*z
            }

            var global$1$3 = (typeof global$1 !== "undefined" ? global$1 :
                        typeof self !== "undefined" ? self :
                        typeof window !== "undefined" ? window : {});

            // shim for using process in browser
            // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

            function defaultSetTimout$2() {
                throw new Error('setTimeout has not been defined');
            }
            function defaultClearTimeout$2 () {
                throw new Error('clearTimeout has not been defined');
            }
            var cachedSetTimeout$2 = defaultSetTimout$2;
            var cachedClearTimeout$2 = defaultClearTimeout$2;
            if (typeof global$1$3.setTimeout === 'function') {
                cachedSetTimeout$2 = setTimeout;
            }
            if (typeof global$1$3.clearTimeout === 'function') {
                cachedClearTimeout$2 = clearTimeout;
            }

            function runTimeout$2(fun) {
                if (cachedSetTimeout$2 === setTimeout) {
                    //normal enviroments in sane situations
                    return setTimeout(fun, 0);
                }
                // if setTimeout wasn't available but was latter defined
                if ((cachedSetTimeout$2 === defaultSetTimout$2 || !cachedSetTimeout$2) && setTimeout) {
                    cachedSetTimeout$2 = setTimeout;
                    return setTimeout(fun, 0);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedSetTimeout$2(fun, 0);
                } catch(e){
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                        return cachedSetTimeout$2.call(null, fun, 0);
                    } catch(e){
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                        return cachedSetTimeout$2.call(this, fun, 0);
                    }
                }


            }
            function runClearTimeout$2(marker) {
                if (cachedClearTimeout$2 === clearTimeout) {
                    //normal enviroments in sane situations
                    return clearTimeout(marker);
                }
                // if clearTimeout wasn't available but was latter defined
                if ((cachedClearTimeout$2 === defaultClearTimeout$2 || !cachedClearTimeout$2) && clearTimeout) {
                    cachedClearTimeout$2 = clearTimeout;
                    return clearTimeout(marker);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedClearTimeout$2(marker);
                } catch (e){
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                        return cachedClearTimeout$2.call(null, marker);
                    } catch (e){
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                        // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                        return cachedClearTimeout$2.call(this, marker);
                    }
                }



            }
            var queue$2 = [];
            var draining$2 = false;
            var currentQueue$2;
            var queueIndex$2 = -1;

            function cleanUpNextTick$2() {
                if (!draining$2 || !currentQueue$2) {
                    return;
                }
                draining$2 = false;
                if (currentQueue$2.length) {
                    queue$2 = currentQueue$2.concat(queue$2);
                } else {
                    queueIndex$2 = -1;
                }
                if (queue$2.length) {
                    drainQueue$2();
                }
            }

            function drainQueue$2() {
                if (draining$2) {
                    return;
                }
                var timeout = runTimeout$2(cleanUpNextTick$2);
                draining$2 = true;

                var len = queue$2.length;
                while(len) {
                    currentQueue$2 = queue$2;
                    queue$2 = [];
                    while (++queueIndex$2 < len) {
                        if (currentQueue$2) {
                            currentQueue$2[queueIndex$2].run();
                        }
                    }
                    queueIndex$2 = -1;
                    len = queue$2.length;
                }
                currentQueue$2 = null;
                draining$2 = false;
                runClearTimeout$2(timeout);
            }
            function nextTick$2(fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for (var i = 1; i < arguments.length; i++) {
                        args[i - 1] = arguments[i];
                    }
                }
                queue$2.push(new Item$2(fun, args));
                if (queue$2.length === 1 && !draining$2) {
                    runTimeout$2(drainQueue$2);
                }
            }
            // v8 likes predictible objects
            function Item$2(fun, array) {
                this.fun = fun;
                this.array = array;
            }
            Item$2.prototype.run = function () {
                this.fun.apply(null, this.array);
            };
            var title$2 = 'browser';
            var platform$2 = 'browser';
            var browser$2 = true;
            var env$2 = {};
            var argv$2 = [];
            var version$2 = ''; // empty string to avoid regexp issues
            var versions$2 = {};
            var release$2 = {};
            var config$2 = {};

            function noop$2() {}

            var on$2 = noop$2;
            var addListener$2 = noop$2;
            var once$2 = noop$2;
            var off$2 = noop$2;
            var removeListener$2 = noop$2;
            var removeAllListeners$2 = noop$2;
            var emit$3 = noop$2;

            function binding$2(name) {
                throw new Error('process.binding is not supported');
            }

            function cwd$2 () { return '/' }
            function chdir$2 (dir) {
                throw new Error('process.chdir is not supported');
            }function umask$2() { return 0; }

            // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
            var performance$2 = global$1$3.performance || {};
            var performanceNow$2 =
              performance$2.now        ||
              performance$2.mozNow     ||
              performance$2.msNow      ||
              performance$2.oNow       ||
              performance$2.webkitNow  ||
              function(){ return (new Date()).getTime() };

            // generate timestamp or delta
            // see http://nodejs.org/api/process.html#process_process_hrtime
            function hrtime$2(previousTimestamp){
              var clocktime = performanceNow$2.call(performance$2)*1e-3;
              var seconds = Math.floor(clocktime);
              var nanoseconds = Math.floor((clocktime%1)*1e9);
              if (previousTimestamp) {
                seconds = seconds - previousTimestamp[0];
                nanoseconds = nanoseconds - previousTimestamp[1];
                if (nanoseconds<0) {
                  seconds--;
                  nanoseconds += 1e9;
                }
              }
              return [seconds,nanoseconds]
            }

            var startTime$2 = new Date();
            function uptime$2() {
              var currentTime = new Date();
              var dif = currentTime - startTime$2;
              return dif / 1000;
            }

            var process$2 = {
              nextTick: nextTick$2,
              title: title$2,
              browser: browser$2,
              env: env$2,
              argv: argv$2,
              version: version$2,
              versions: versions$2,
              on: on$2,
              addListener: addListener$2,
              once: once$2,
              off: off$2,
              removeListener: removeListener$2,
              removeAllListeners: removeAllListeners$2,
              emit: emit$3,
              binding: binding$2,
              cwd: cwd$2,
              chdir: chdir$2,
              umask: umask$2,
              hrtime: hrtime$2,
              platform: platform$2,
              release: release$2,
              config: config$2,
              uptime: uptime$2
            };

            var browser$1$1 = true;

            /**
             * Helpers.
             */

            var s = 1000;
            var m = s * 60;
            var h = m * 60;
            var d = h * 24;
            var w = d * 7;
            var y = d * 365.25;

            /**
             * Parse or format the given `val`.
             *
             * Options:
             *
             *  - `long` verbose formatting [false]
             *
             * @param {String|Number} val
             * @param {Object} [options]
             * @throws {Error} throw an error if val is not a non-empty string or a number
             * @return {String|Number}
             * @api public
             */

            var ms = function(val, options) {
              options = options || {};
              var type = typeof val;
              if (type === 'string' && val.length > 0) {
                return parse(val);
              } else if (type === 'number' && isFinite(val)) {
                return options.long ? fmtLong(val) : fmtShort(val);
              }
              throw new Error(
                'val is not a non-empty string or a valid number. val=' +
                  JSON.stringify(val)
              );
            };

            /**
             * Parse the given `str` and return milliseconds.
             *
             * @param {String} str
             * @return {Number}
             * @api private
             */

            function parse(str) {
              str = String(str);
              if (str.length > 100) {
                return;
              }
              var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
                str
              );
              if (!match) {
                return;
              }
              var n = parseFloat(match[1]);
              var type = (match[2] || 'ms').toLowerCase();
              switch (type) {
                case 'years':
                case 'year':
                case 'yrs':
                case 'yr':
                case 'y':
                  return n * y;
                case 'weeks':
                case 'week':
                case 'w':
                  return n * w;
                case 'days':
                case 'day':
                case 'd':
                  return n * d;
                case 'hours':
                case 'hour':
                case 'hrs':
                case 'hr':
                case 'h':
                  return n * h;
                case 'minutes':
                case 'minute':
                case 'mins':
                case 'min':
                case 'm':
                  return n * m;
                case 'seconds':
                case 'second':
                case 'secs':
                case 'sec':
                case 's':
                  return n * s;
                case 'milliseconds':
                case 'millisecond':
                case 'msecs':
                case 'msec':
                case 'ms':
                  return n;
                default:
                  return undefined;
              }
            }

            /**
             * Short format for `ms`.
             *
             * @param {Number} ms
             * @return {String}
             * @api private
             */

            function fmtShort(ms) {
              var msAbs = Math.abs(ms);
              if (msAbs >= d) {
                return Math.round(ms / d) + 'd';
              }
              if (msAbs >= h) {
                return Math.round(ms / h) + 'h';
              }
              if (msAbs >= m) {
                return Math.round(ms / m) + 'm';
              }
              if (msAbs >= s) {
                return Math.round(ms / s) + 's';
              }
              return ms + 'ms';
            }

            /**
             * Long format for `ms`.
             *
             * @param {Number} ms
             * @return {String}
             * @api private
             */

            function fmtLong(ms) {
              var msAbs = Math.abs(ms);
              if (msAbs >= d) {
                return plural(ms, msAbs, d, 'day');
              }
              if (msAbs >= h) {
                return plural(ms, msAbs, h, 'hour');
              }
              if (msAbs >= m) {
                return plural(ms, msAbs, m, 'minute');
              }
              if (msAbs >= s) {
                return plural(ms, msAbs, s, 'second');
              }
              return ms + ' ms';
            }

            /**
             * Pluralization helper.
             */

            function plural(ms, msAbs, n, name) {
              var isPlural = msAbs >= n * 1.5;
              return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
            }

            /**
             * This is the common logic for both the Node.js and web browser
             * implementations of `debug()`.
             */
            function setup(env) {
              createDebug.debug = createDebug;
              createDebug.default = createDebug;
              createDebug.coerce = coerce;
              createDebug.disable = disable;
              createDebug.enable = enable;
              createDebug.enabled = enabled;
              createDebug.humanize = ms;
              Object.keys(env).forEach(function (key) {
                createDebug[key] = env[key];
              });
              /**
              * Active `debug` instances.
              */

              createDebug.instances = [];
              /**
              * The currently active debug mode names, and names to skip.
              */

              createDebug.names = [];
              createDebug.skips = [];
              /**
              * Map of special "%n" handling functions, for the debug "format" argument.
              *
              * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
              */

              createDebug.formatters = {};
              /**
              * Selects a color for a debug namespace
              * @param {String} namespace The namespace string for the for the debug instance to be colored
              * @return {Number|String} An ANSI color code for the given namespace
              * @api private
              */

              function selectColor(namespace) {
                var hash = 0;

                for (var i = 0; i < namespace.length; i++) {
                  hash = (hash << 5) - hash + namespace.charCodeAt(i);
                  hash |= 0; // Convert to 32bit integer
                }

                return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
              }

              createDebug.selectColor = selectColor;
              /**
              * Create a debugger with the given `namespace`.
              *
              * @param {String} namespace
              * @return {Function}
              * @api public
              */

              function createDebug(namespace) {
                var prevTime;

                function debug() {
                  // Disabled?
                  if (!debug.enabled) {
                    return;
                  }

                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }

                  var self = debug; // Set `diff` timestamp

                  var curr = Number(new Date());
                  var ms = curr - (prevTime || curr);
                  self.diff = ms;
                  self.prev = prevTime;
                  self.curr = curr;
                  prevTime = curr;
                  args[0] = createDebug.coerce(args[0]);

                  if (typeof args[0] !== 'string') {
                    // Anything else let's inspect with %O
                    args.unshift('%O');
                  } // Apply any `formatters` transformations


                  var index = 0;
                  args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
                    // If we encounter an escaped % then don't increase the array index
                    if (match === '%%') {
                      return match;
                    }

                    index++;
                    var formatter = createDebug.formatters[format];

                    if (typeof formatter === 'function') {
                      var val = args[index];
                      match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

                      args.splice(index, 1);
                      index--;
                    }

                    return match;
                  }); // Apply env-specific formatting (colors, etc.)

                  createDebug.formatArgs.call(self, args);
                  var logFn = self.log || createDebug.log;
                  logFn.apply(self, args);
                }

                debug.namespace = namespace;
                debug.enabled = createDebug.enabled(namespace);
                debug.useColors = createDebug.useColors();
                debug.color = selectColor(namespace);
                debug.destroy = destroy;
                debug.extend = extend; // Debug.formatArgs = formatArgs;
                // debug.rawLog = rawLog;
                // env-specific initialization logic for debug instances

                if (typeof createDebug.init === 'function') {
                  createDebug.init(debug);
                }

                createDebug.instances.push(debug);
                return debug;
              }

              function destroy() {
                var index = createDebug.instances.indexOf(this);

                if (index !== -1) {
                  createDebug.instances.splice(index, 1);
                  return true;
                }

                return false;
              }

              function extend(namespace, delimiter) {
                return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
              }
              /**
              * Enables a debug mode by namespaces. This can include modes
              * separated by a colon and wildcards.
              *
              * @param {String} namespaces
              * @api public
              */


              function enable(namespaces) {
                createDebug.save(namespaces);
                createDebug.names = [];
                createDebug.skips = [];
                var i;
                var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
                var len = split.length;

                for (i = 0; i < len; i++) {
                  if (!split[i]) {
                    // ignore empty strings
                    continue;
                  }

                  namespaces = split[i].replace(/\*/g, '.*?');

                  if (namespaces[0] === '-') {
                    createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
                  } else {
                    createDebug.names.push(new RegExp('^' + namespaces + '$'));
                  }
                }

                for (i = 0; i < createDebug.instances.length; i++) {
                  var instance = createDebug.instances[i];
                  instance.enabled = createDebug.enabled(instance.namespace);
                }
              }
              /**
              * Disable debug output.
              *
              * @api public
              */


              function disable() {
                createDebug.enable('');
              }
              /**
              * Returns true if the given mode name is enabled, false otherwise.
              *
              * @param {String} name
              * @return {Boolean}
              * @api public
              */


              function enabled(name) {
                if (name[name.length - 1] === '*') {
                  return true;
                }

                var i;
                var len;

                for (i = 0, len = createDebug.skips.length; i < len; i++) {
                  if (createDebug.skips[i].test(name)) {
                    return false;
                  }
                }

                for (i = 0, len = createDebug.names.length; i < len; i++) {
                  if (createDebug.names[i].test(name)) {
                    return true;
                  }
                }

                return false;
              }
              /**
              * Coerce `val`.
              *
              * @param {Mixed} val
              * @return {Mixed}
              * @api private
              */


              function coerce(val) {
                if (val instanceof Error) {
                  return val.stack || val.message;
                }

                return val;
              }

              createDebug.enable(createDebug.load());
              return createDebug;
            }

            var common = setup;

            var browser$2$1 = createCommonjsModule$2(function (module, exports) {

            function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

            /* eslint-env browser */

            /**
             * This is the web browser implementation of `debug()`.
             */
            exports.log = log;
            exports.formatArgs = formatArgs;
            exports.save = save;
            exports.load = load;
            exports.useColors = useColors;
            exports.storage = localstorage();
            /**
             * Colors.
             */

            exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
            /**
             * Currently only WebKit-based Web Inspectors, Firefox >= v31,
             * and the Firebug extension (any Firefox version) are known
             * to support "%c" CSS customizations.
             *
             * TODO: add a `localStorage` variable to explicitly enable/disable colors
             */
            // eslint-disable-next-line complexity

            function useColors() {
              // NB: In an Electron preload script, document will be defined but not fully
              // initialized. Since we know we're in Chrome, we'll just detect this case
              // explicitly
              if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
                return true;
              } // Internet Explorer and Edge do not support colors.


              if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
                return false;
              } // Is webkit? http://stackoverflow.com/a/16459606/376773
              // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


              return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
              typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
              // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
              typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
              typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
            }
            /**
             * Colorize log arguments if enabled.
             *
             * @api public
             */


            function formatArgs(args) {
              args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

              if (!this.useColors) {
                return;
              }

              var c = 'color: ' + this.color;
              args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
              // arguments passed either before or after the %c, so we need to
              // figure out the correct index to insert the CSS into

              var index = 0;
              var lastC = 0;
              args[0].replace(/%[a-zA-Z%]/g, function (match) {
                if (match === '%%') {
                  return;
                }

                index++;

                if (match === '%c') {
                  // We only are interested in the *last* %c
                  // (the user may have provided their own)
                  lastC = index;
                }
              });
              args.splice(lastC, 0, c);
            }
            /**
             * Invokes `console.log()` when available.
             * No-op when `console.log` is not a "function".
             *
             * @api public
             */


            function log() {
              var _console;

              // This hackery is required for IE8/9, where
              // the `console.log` function doesn't have 'apply'
              return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
            }
            /**
             * Save `namespaces`.
             *
             * @param {String} namespaces
             * @api private
             */


            function save(namespaces) {
              try {
                if (namespaces) {
                  exports.storage.setItem('debug', namespaces);
                } else {
                  exports.storage.removeItem('debug');
                }
              } catch (error) {// Swallow
                // XXX (@Qix-) should we be logging these?
              }
            }
            /**
             * Load `namespaces`.
             *
             * @return {String} returns the previously persisted debug modes
             * @api private
             */


            function load() {
              var r;

              try {
                r = exports.storage.getItem('debug');
              } catch (error) {} // Swallow
              // XXX (@Qix-) should we be logging these?
              // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


              if (!r && typeof process$2 !== 'undefined' && 'env' in process$2) {
                r = process$2.env.DEBUG;
              }

              return r;
            }
            /**
             * Localstorage attempts to return the localstorage.
             *
             * This is necessary because safari throws
             * when a user disables cookies/localstorage
             * and you attempt to access it.
             *
             * @return {LocalStorage}
             * @api private
             */


            function localstorage() {
              try {
                // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
                // The Browser also has localStorage in the global context.
                return localStorage;
              } catch (error) {// Swallow
                // XXX (@Qix-) should we be logging these?
              }
            }

            module.exports = common(exports);
            var formatters = module.exports.formatters;
            /**
             * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
             */

            formatters.j = function (v) {
              try {
                return JSON.stringify(v);
              } catch (error) {
                return '[UnexpectedJSONParseError]: ' + error.message;
              }
            };
            });
            var browser_1 = browser$2$1.log;
            var browser_2 = browser$2$1.formatArgs;
            var browser_3 = browser$2$1.save;
            var browser_4 = browser$2$1.load;
            var browser_5 = browser$2$1.useColors;
            var browser_6 = browser$2$1.storage;
            var browser_7 = browser$2$1.colors;

            // MIT lisence
            // from https://github.com/substack/tty-browserify/blob/1ba769a6429d242f36226538835b4034bf6b7886/index.js

            function isatty() {
              return false;
            }

            function ReadStream() {
              throw new Error('tty.ReadStream is not implemented');
            }

            function WriteStream() {
              throw new Error('tty.ReadStream is not implemented');
            }

            var tty = {
              isatty: isatty,
              ReadStream: ReadStream,
              WriteStream: WriteStream
            };

            var lookup = [];
            var revLookup = [];
            var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
            var inited = false;
            function init$2 () {
              inited = true;
              var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
              for (var i = 0, len = code.length; i < len; ++i) {
                lookup[i] = code[i];
                revLookup[code.charCodeAt(i)] = i;
              }

              revLookup['-'.charCodeAt(0)] = 62;
              revLookup['_'.charCodeAt(0)] = 63;
            }

            function toByteArray (b64) {
              if (!inited) {
                init$2();
              }
              var i, j, l, tmp, placeHolders, arr;
              var len = b64.length;

              if (len % 4 > 0) {
                throw new Error('Invalid string. Length must be a multiple of 4')
              }

              // the number of equal signs (place holders)
              // if there are two placeholders, than the two characters before it
              // represent one byte
              // if there is only one, then the three characters before it represent 2 bytes
              // this is just a cheap hack to not do indexOf twice
              placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

              // base64 is 4/3 + up to two characters of the original data
              arr = new Arr(len * 3 / 4 - placeHolders);

              // if there are placeholders, only get up to the last complete 4 chars
              l = placeHolders > 0 ? len - 4 : len;

              var L = 0;

              for (i = 0, j = 0; i < l; i += 4, j += 3) {
                tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
                arr[L++] = (tmp >> 16) & 0xFF;
                arr[L++] = (tmp >> 8) & 0xFF;
                arr[L++] = tmp & 0xFF;
              }

              if (placeHolders === 2) {
                tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
                arr[L++] = tmp & 0xFF;
              } else if (placeHolders === 1) {
                tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
                arr[L++] = (tmp >> 8) & 0xFF;
                arr[L++] = tmp & 0xFF;
              }

              return arr
            }

            function tripletToBase64 (num) {
              return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
            }

            function encodeChunk (uint8, start, end) {
              var tmp;
              var output = [];
              for (var i = start; i < end; i += 3) {
                tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
                output.push(tripletToBase64(tmp));
              }
              return output.join('')
            }

            function fromByteArray (uint8) {
              if (!inited) {
                init$2();
              }
              var tmp;
              var len = uint8.length;
              var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
              var output = '';
              var parts = [];
              var maxChunkLength = 16383; // must be multiple of 3

              // go through the array every three bytes, we'll deal with trailing stuff later
              for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
              }

              // pad the end with zeros, but make sure to not forget the extra bytes
              if (extraBytes === 1) {
                tmp = uint8[len - 1];
                output += lookup[tmp >> 2];
                output += lookup[(tmp << 4) & 0x3F];
                output += '==';
              } else if (extraBytes === 2) {
                tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
                output += lookup[tmp >> 10];
                output += lookup[(tmp >> 4) & 0x3F];
                output += lookup[(tmp << 2) & 0x3F];
                output += '=';
              }

              parts.push(output);

              return parts.join('')
            }

            function read$1 (buffer, offset, isLE, mLen, nBytes) {
              var e, m;
              var eLen = nBytes * 8 - mLen - 1;
              var eMax = (1 << eLen) - 1;
              var eBias = eMax >> 1;
              var nBits = -7;
              var i = isLE ? (nBytes - 1) : 0;
              var d = isLE ? -1 : 1;
              var s = buffer[offset + i];

              i += d;

              e = s & ((1 << (-nBits)) - 1);
              s >>= (-nBits);
              nBits += eLen;
              for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

              m = e & ((1 << (-nBits)) - 1);
              e >>= (-nBits);
              nBits += mLen;
              for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

              if (e === 0) {
                e = 1 - eBias;
              } else if (e === eMax) {
                return m ? NaN : ((s ? -1 : 1) * Infinity)
              } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
              }
              return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
            }

            function write$1 (buffer, value, offset, isLE, mLen, nBytes) {
              var e, m, c;
              var eLen = nBytes * 8 - mLen - 1;
              var eMax = (1 << eLen) - 1;
              var eBias = eMax >> 1;
              var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
              var i = isLE ? 0 : (nBytes - 1);
              var d = isLE ? 1 : -1;
              var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

              value = Math.abs(value);

              if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e = eMax;
              } else {
                e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e)) < 1) {
                  e--;
                  c *= 2;
                }
                if (e + eBias >= 1) {
                  value += rt / c;
                } else {
                  value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                  e++;
                  c /= 2;
                }

                if (e + eBias >= eMax) {
                  m = 0;
                  e = eMax;
                } else if (e + eBias >= 1) {
                  m = (value * c - 1) * Math.pow(2, mLen);
                  e = e + eBias;
                } else {
                  m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                  e = 0;
                }
              }

              for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

              e = (e << mLen) | m;
              eLen += mLen;
              for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

              buffer[offset + i - d] |= s * 128;
            }

            var toString = {}.toString;

            var isArray$1 = Array.isArray || function (arr) {
              return toString.call(arr) == '[object Array]';
            };

            var INSPECT_MAX_BYTES = 50;

            /**
             * If `Buffer.TYPED_ARRAY_SUPPORT`:
             *   === true    Use Uint8Array implementation (fastest)
             *   === false   Use Object implementation (most compatible, even IE6)
             *
             * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
             * Opera 11.6+, iOS 4.2+.
             *
             * Due to various browser bugs, sometimes the Object implementation will be used even
             * when the browser supports typed arrays.
             *
             * Note:
             *
             *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
             *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
             *
             *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
             *
             *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
             *     incorrect length in some situations.

             * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
             * get the Object implementation, which is slower but behaves correctly.
             */
            Buffer.TYPED_ARRAY_SUPPORT = global$1$3.TYPED_ARRAY_SUPPORT !== undefined
              ? global$1$3.TYPED_ARRAY_SUPPORT
              : true;

            function kMaxLength () {
              return Buffer.TYPED_ARRAY_SUPPORT
                ? 0x7fffffff
                : 0x3fffffff
            }

            function createBuffer (that, length) {
              if (kMaxLength() < length) {
                throw new RangeError('Invalid typed array length')
              }
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                // Return an augmented `Uint8Array` instance, for best performance
                that = new Uint8Array(length);
                that.__proto__ = Buffer.prototype;
              } else {
                // Fallback: Return an object instance of the Buffer class
                if (that === null) {
                  that = new Buffer(length);
                }
                that.length = length;
              }

              return that
            }

            /**
             * The Buffer constructor returns instances of `Uint8Array` that have their
             * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
             * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
             * and the `Uint8Array` methods. Square bracket notation works as expected -- it
             * returns a single octet.
             *
             * The `Uint8Array` prototype remains unmodified.
             */

            function Buffer (arg, encodingOrOffset, length) {
              if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
                return new Buffer(arg, encodingOrOffset, length)
              }

              // Common case.
              if (typeof arg === 'number') {
                if (typeof encodingOrOffset === 'string') {
                  throw new Error(
                    'If encoding is specified then the first argument must be a string'
                  )
                }
                return allocUnsafe(this, arg)
              }
              return from(this, arg, encodingOrOffset, length)
            }

            Buffer.poolSize = 8192; // not used by this implementation

            // TODO: Legacy, not needed anymore. Remove in next major version.
            Buffer._augment = function (arr) {
              arr.__proto__ = Buffer.prototype;
              return arr
            };

            function from (that, value, encodingOrOffset, length) {
              if (typeof value === 'number') {
                throw new TypeError('"value" argument must not be a number')
              }

              if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
                return fromArrayBuffer(that, value, encodingOrOffset, length)
              }

              if (typeof value === 'string') {
                return fromString(that, value, encodingOrOffset)
              }

              return fromObject(that, value)
            }

            /**
             * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
             * if value is a number.
             * Buffer.from(str[, encoding])
             * Buffer.from(array)
             * Buffer.from(buffer)
             * Buffer.from(arrayBuffer[, byteOffset[, length]])
             **/
            Buffer.from = function (value, encodingOrOffset, length) {
              return from(null, value, encodingOrOffset, length)
            };

            if (Buffer.TYPED_ARRAY_SUPPORT) {
              Buffer.prototype.__proto__ = Uint8Array.prototype;
              Buffer.__proto__ = Uint8Array;
            }

            function assertSize (size) {
              if (typeof size !== 'number') {
                throw new TypeError('"size" argument must be a number')
              } else if (size < 0) {
                throw new RangeError('"size" argument must not be negative')
              }
            }

            function alloc (that, size, fill, encoding) {
              assertSize(size);
              if (size <= 0) {
                return createBuffer(that, size)
              }
              if (fill !== undefined) {
                // Only pay attention to encoding if it's a string. This
                // prevents accidentally sending in a number that would
                // be interpretted as a start offset.
                return typeof encoding === 'string'
                  ? createBuffer(that, size).fill(fill, encoding)
                  : createBuffer(that, size).fill(fill)
              }
              return createBuffer(that, size)
            }

            /**
             * Creates a new filled Buffer instance.
             * alloc(size[, fill[, encoding]])
             **/
            Buffer.alloc = function (size, fill, encoding) {
              return alloc(null, size, fill, encoding)
            };

            function allocUnsafe (that, size) {
              assertSize(size);
              that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
              if (!Buffer.TYPED_ARRAY_SUPPORT) {
                for (var i = 0; i < size; ++i) {
                  that[i] = 0;
                }
              }
              return that
            }

            /**
             * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
             * */
            Buffer.allocUnsafe = function (size) {
              return allocUnsafe(null, size)
            };
            /**
             * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
             */
            Buffer.allocUnsafeSlow = function (size) {
              return allocUnsafe(null, size)
            };

            function fromString (that, string, encoding) {
              if (typeof encoding !== 'string' || encoding === '') {
                encoding = 'utf8';
              }

              if (!Buffer.isEncoding(encoding)) {
                throw new TypeError('"encoding" must be a valid string encoding')
              }

              var length = byteLength(string, encoding) | 0;
              that = createBuffer(that, length);

              var actual = that.write(string, encoding);

              if (actual !== length) {
                // Writing a hex string, for example, that contains invalid characters will
                // cause everything after the first invalid character to be ignored. (e.g.
                // 'abxxcd' will be treated as 'ab')
                that = that.slice(0, actual);
              }

              return that
            }

            function fromArrayLike (that, array) {
              var length = array.length < 0 ? 0 : checked(array.length) | 0;
              that = createBuffer(that, length);
              for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255;
              }
              return that
            }

            function fromArrayBuffer (that, array, byteOffset, length) {
              array.byteLength; // this throws if `array` is not a valid ArrayBuffer

              if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError('\'offset\' is out of bounds')
              }

              if (array.byteLength < byteOffset + (length || 0)) {
                throw new RangeError('\'length\' is out of bounds')
              }

              if (byteOffset === undefined && length === undefined) {
                array = new Uint8Array(array);
              } else if (length === undefined) {
                array = new Uint8Array(array, byteOffset);
              } else {
                array = new Uint8Array(array, byteOffset, length);
              }

              if (Buffer.TYPED_ARRAY_SUPPORT) {
                // Return an augmented `Uint8Array` instance, for best performance
                that = array;
                that.__proto__ = Buffer.prototype;
              } else {
                // Fallback: Return an object instance of the Buffer class
                that = fromArrayLike(that, array);
              }
              return that
            }

            function fromObject (that, obj) {
              if (internalIsBuffer(obj)) {
                var len = checked(obj.length) | 0;
                that = createBuffer(that, len);

                if (that.length === 0) {
                  return that
                }

                obj.copy(that, 0, 0, len);
                return that
              }

              if (obj) {
                if ((typeof ArrayBuffer !== 'undefined' &&
                    obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
                  if (typeof obj.length !== 'number' || isnan(obj.length)) {
                    return createBuffer(that, 0)
                  }
                  return fromArrayLike(that, obj)
                }

                if (obj.type === 'Buffer' && isArray$1(obj.data)) {
                  return fromArrayLike(that, obj.data)
                }
              }

              throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
            }

            function checked (length) {
              // Note: cannot use `length < kMaxLength()` here because that fails when
              // length is NaN (which is otherwise coerced to zero.)
              if (length >= kMaxLength()) {
                throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                                     'size: 0x' + kMaxLength().toString(16) + ' bytes')
              }
              return length | 0
            }
            Buffer.isBuffer = isBuffer;
            function internalIsBuffer (b) {
              return !!(b != null && b._isBuffer)
            }

            Buffer.compare = function compare (a, b) {
              if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
                throw new TypeError('Arguments must be Buffers')
              }

              if (a === b) return 0

              var x = a.length;
              var y = b.length;

              for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                  x = a[i];
                  y = b[i];
                  break
                }
              }

              if (x < y) return -1
              if (y < x) return 1
              return 0
            };

            Buffer.isEncoding = function isEncoding (encoding) {
              switch (String(encoding).toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'latin1':
                case 'binary':
                case 'base64':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return true
                default:
                  return false
              }
            };

            Buffer.concat = function concat (list, length) {
              if (!isArray$1(list)) {
                throw new TypeError('"list" argument must be an Array of Buffers')
              }

              if (list.length === 0) {
                return Buffer.alloc(0)
              }

              var i;
              if (length === undefined) {
                length = 0;
                for (i = 0; i < list.length; ++i) {
                  length += list[i].length;
                }
              }

              var buffer = Buffer.allocUnsafe(length);
              var pos = 0;
              for (i = 0; i < list.length; ++i) {
                var buf = list[i];
                if (!internalIsBuffer(buf)) {
                  throw new TypeError('"list" argument must be an Array of Buffers')
                }
                buf.copy(buffer, pos);
                pos += buf.length;
              }
              return buffer
            };

            function byteLength (string, encoding) {
              if (internalIsBuffer(string)) {
                return string.length
              }
              if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
                  (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
                return string.byteLength
              }
              if (typeof string !== 'string') {
                string = '' + string;
              }

              var len = string.length;
              if (len === 0) return 0

              // Use a for loop to avoid recursion
              var loweredCase = false;
              for (;;) {
                switch (encoding) {
                  case 'ascii':
                  case 'latin1':
                  case 'binary':
                    return len
                  case 'utf8':
                  case 'utf-8':
                  case undefined:
                    return utf8ToBytes(string).length
                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return len * 2
                  case 'hex':
                    return len >>> 1
                  case 'base64':
                    return base64ToBytes(string).length
                  default:
                    if (loweredCase) return utf8ToBytes(string).length // assume utf8
                    encoding = ('' + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer.byteLength = byteLength;

            function slowToString (encoding, start, end) {
              var loweredCase = false;

              // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
              // property of a typed array.

              // This behaves neither like String nor Uint8Array in that we set start/end
              // to their upper/lower bounds if the value passed is out of range.
              // undefined is handled specially as per ECMA-262 6th Edition,
              // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
              if (start === undefined || start < 0) {
                start = 0;
              }
              // Return early if start > this.length. Done here to prevent potential uint32
              // coercion fail below.
              if (start > this.length) {
                return ''
              }

              if (end === undefined || end > this.length) {
                end = this.length;
              }

              if (end <= 0) {
                return ''
              }

              // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
              end >>>= 0;
              start >>>= 0;

              if (end <= start) {
                return ''
              }

              if (!encoding) encoding = 'utf8';

              while (true) {
                switch (encoding) {
                  case 'hex':
                    return hexSlice(this, start, end)

                  case 'utf8':
                  case 'utf-8':
                    return utf8Slice(this, start, end)

                  case 'ascii':
                    return asciiSlice(this, start, end)

                  case 'latin1':
                  case 'binary':
                    return latin1Slice(this, start, end)

                  case 'base64':
                    return base64Slice(this, start, end)

                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return utf16leSlice(this, start, end)

                  default:
                    if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                    encoding = (encoding + '').toLowerCase();
                    loweredCase = true;
                }
              }
            }

            // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
            // Buffer instances.
            Buffer.prototype._isBuffer = true;

            function swap (b, n, m) {
              var i = b[n];
              b[n] = b[m];
              b[m] = i;
            }

            Buffer.prototype.swap16 = function swap16 () {
              var len = this.length;
              if (len % 2 !== 0) {
                throw new RangeError('Buffer size must be a multiple of 16-bits')
              }
              for (var i = 0; i < len; i += 2) {
                swap(this, i, i + 1);
              }
              return this
            };

            Buffer.prototype.swap32 = function swap32 () {
              var len = this.length;
              if (len % 4 !== 0) {
                throw new RangeError('Buffer size must be a multiple of 32-bits')
              }
              for (var i = 0; i < len; i += 4) {
                swap(this, i, i + 3);
                swap(this, i + 1, i + 2);
              }
              return this
            };

            Buffer.prototype.swap64 = function swap64 () {
              var len = this.length;
              if (len % 8 !== 0) {
                throw new RangeError('Buffer size must be a multiple of 64-bits')
              }
              for (var i = 0; i < len; i += 8) {
                swap(this, i, i + 7);
                swap(this, i + 1, i + 6);
                swap(this, i + 2, i + 5);
                swap(this, i + 3, i + 4);
              }
              return this
            };

            Buffer.prototype.toString = function toString () {
              var length = this.length | 0;
              if (length === 0) return ''
              if (arguments.length === 0) return utf8Slice(this, 0, length)
              return slowToString.apply(this, arguments)
            };

            Buffer.prototype.equals = function equals (b) {
              if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
              if (this === b) return true
              return Buffer.compare(this, b) === 0
            };

            Buffer.prototype.inspect = function inspect () {
              var str = '';
              var max = INSPECT_MAX_BYTES;
              if (this.length > 0) {
                str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
                if (this.length > max) str += ' ... ';
              }
              return '<Buffer ' + str + '>'
            };

            Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
              if (!internalIsBuffer(target)) {
                throw new TypeError('Argument must be a Buffer')
              }

              if (start === undefined) {
                start = 0;
              }
              if (end === undefined) {
                end = target ? target.length : 0;
              }
              if (thisStart === undefined) {
                thisStart = 0;
              }
              if (thisEnd === undefined) {
                thisEnd = this.length;
              }

              if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                throw new RangeError('out of range index')
              }

              if (thisStart >= thisEnd && start >= end) {
                return 0
              }
              if (thisStart >= thisEnd) {
                return -1
              }
              if (start >= end) {
                return 1
              }

              start >>>= 0;
              end >>>= 0;
              thisStart >>>= 0;
              thisEnd >>>= 0;

              if (this === target) return 0

              var x = thisEnd - thisStart;
              var y = end - start;
              var len = Math.min(x, y);

              var thisCopy = this.slice(thisStart, thisEnd);
              var targetCopy = target.slice(start, end);

              for (var i = 0; i < len; ++i) {
                if (thisCopy[i] !== targetCopy[i]) {
                  x = thisCopy[i];
                  y = targetCopy[i];
                  break
                }
              }

              if (x < y) return -1
              if (y < x) return 1
              return 0
            };

            // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
            // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
            //
            // Arguments:
            // - buffer - a Buffer to search
            // - val - a string, Buffer, or number
            // - byteOffset - an index into `buffer`; will be clamped to an int32
            // - encoding - an optional encoding, relevant is val is a string
            // - dir - true for indexOf, false for lastIndexOf
            function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
              // Empty buffer means no match
              if (buffer.length === 0) return -1

              // Normalize byteOffset
              if (typeof byteOffset === 'string') {
                encoding = byteOffset;
                byteOffset = 0;
              } else if (byteOffset > 0x7fffffff) {
                byteOffset = 0x7fffffff;
              } else if (byteOffset < -0x80000000) {
                byteOffset = -0x80000000;
              }
              byteOffset = +byteOffset;  // Coerce to Number.
              if (isNaN(byteOffset)) {
                // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                byteOffset = dir ? 0 : (buffer.length - 1);
              }

              // Normalize byteOffset: negative offsets start from the end of the buffer
              if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
              if (byteOffset >= buffer.length) {
                if (dir) return -1
                else byteOffset = buffer.length - 1;
              } else if (byteOffset < 0) {
                if (dir) byteOffset = 0;
                else return -1
              }

              // Normalize val
              if (typeof val === 'string') {
                val = Buffer.from(val, encoding);
              }

              // Finally, search either indexOf (if dir is true) or lastIndexOf
              if (internalIsBuffer(val)) {
                // Special case: looking for empty string/buffer always fails
                if (val.length === 0) {
                  return -1
                }
                return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
              } else if (typeof val === 'number') {
                val = val & 0xFF; // Search for a byte value [0-255]
                if (Buffer.TYPED_ARRAY_SUPPORT &&
                    typeof Uint8Array.prototype.indexOf === 'function') {
                  if (dir) {
                    return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
                  } else {
                    return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
                  }
                }
                return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
              }

              throw new TypeError('val must be string, number or Buffer')
            }

            function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
              var indexSize = 1;
              var arrLength = arr.length;
              var valLength = val.length;

              if (encoding !== undefined) {
                encoding = String(encoding).toLowerCase();
                if (encoding === 'ucs2' || encoding === 'ucs-2' ||
                    encoding === 'utf16le' || encoding === 'utf-16le') {
                  if (arr.length < 2 || val.length < 2) {
                    return -1
                  }
                  indexSize = 2;
                  arrLength /= 2;
                  valLength /= 2;
                  byteOffset /= 2;
                }
              }

              function read (buf, i) {
                if (indexSize === 1) {
                  return buf[i]
                } else {
                  return buf.readUInt16BE(i * indexSize)
                }
              }

              var i;
              if (dir) {
                var foundIndex = -1;
                for (i = byteOffset; i < arrLength; i++) {
                  if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                    if (foundIndex === -1) foundIndex = i;
                    if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
                  } else {
                    if (foundIndex !== -1) i -= i - foundIndex;
                    foundIndex = -1;
                  }
                }
              } else {
                if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                for (i = byteOffset; i >= 0; i--) {
                  var found = true;
                  for (var j = 0; j < valLength; j++) {
                    if (read(arr, i + j) !== read(val, j)) {
                      found = false;
                      break
                    }
                  }
                  if (found) return i
                }
              }

              return -1
            }

            Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
              return this.indexOf(val, byteOffset, encoding) !== -1
            };

            Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
            };

            Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
            };

            function hexWrite (buf, string, offset, length) {
              offset = Number(offset) || 0;
              var remaining = buf.length - offset;
              if (!length) {
                length = remaining;
              } else {
                length = Number(length);
                if (length > remaining) {
                  length = remaining;
                }
              }

              // must be an even number of digits
              var strLen = string.length;
              if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

              if (length > strLen / 2) {
                length = strLen / 2;
              }
              for (var i = 0; i < length; ++i) {
                var parsed = parseInt(string.substr(i * 2, 2), 16);
                if (isNaN(parsed)) return i
                buf[offset + i] = parsed;
              }
              return i
            }

            function utf8Write (buf, string, offset, length) {
              return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
            }

            function asciiWrite (buf, string, offset, length) {
              return blitBuffer(asciiToBytes(string), buf, offset, length)
            }

            function latin1Write (buf, string, offset, length) {
              return asciiWrite(buf, string, offset, length)
            }

            function base64Write (buf, string, offset, length) {
              return blitBuffer(base64ToBytes(string), buf, offset, length)
            }

            function ucs2Write (buf, string, offset, length) {
              return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
            }

            Buffer.prototype.write = function write (string, offset, length, encoding) {
              // Buffer#write(string)
              if (offset === undefined) {
                encoding = 'utf8';
                length = this.length;
                offset = 0;
              // Buffer#write(string, encoding)
              } else if (length === undefined && typeof offset === 'string') {
                encoding = offset;
                length = this.length;
                offset = 0;
              // Buffer#write(string, offset[, length][, encoding])
              } else if (isFinite(offset)) {
                offset = offset | 0;
                if (isFinite(length)) {
                  length = length | 0;
                  if (encoding === undefined) encoding = 'utf8';
                } else {
                  encoding = length;
                  length = undefined;
                }
              // legacy write(string, encoding, offset, length) - remove in v0.13
              } else {
                throw new Error(
                  'Buffer.write(string, encoding, offset[, length]) is no longer supported'
                )
              }

              var remaining = this.length - offset;
              if (length === undefined || length > remaining) length = remaining;

              if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                throw new RangeError('Attempt to write outside buffer bounds')
              }

              if (!encoding) encoding = 'utf8';

              var loweredCase = false;
              for (;;) {
                switch (encoding) {
                  case 'hex':
                    return hexWrite(this, string, offset, length)

                  case 'utf8':
                  case 'utf-8':
                    return utf8Write(this, string, offset, length)

                  case 'ascii':
                    return asciiWrite(this, string, offset, length)

                  case 'latin1':
                  case 'binary':
                    return latin1Write(this, string, offset, length)

                  case 'base64':
                    // Warning: maxLength not taken into account in base64Write
                    return base64Write(this, string, offset, length)

                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return ucs2Write(this, string, offset, length)

                  default:
                    if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                    encoding = ('' + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            };

            Buffer.prototype.toJSON = function toJSON () {
              return {
                type: 'Buffer',
                data: Array.prototype.slice.call(this._arr || this, 0)
              }
            };

            function base64Slice (buf, start, end) {
              if (start === 0 && end === buf.length) {
                return fromByteArray(buf)
              } else {
                return fromByteArray(buf.slice(start, end))
              }
            }

            function utf8Slice (buf, start, end) {
              end = Math.min(buf.length, end);
              var res = [];

              var i = start;
              while (i < end) {
                var firstByte = buf[i];
                var codePoint = null;
                var bytesPerSequence = (firstByte > 0xEF) ? 4
                  : (firstByte > 0xDF) ? 3
                  : (firstByte > 0xBF) ? 2
                  : 1;

                if (i + bytesPerSequence <= end) {
                  var secondByte, thirdByte, fourthByte, tempCodePoint;

                  switch (bytesPerSequence) {
                    case 1:
                      if (firstByte < 0x80) {
                        codePoint = firstByte;
                      }
                      break
                    case 2:
                      secondByte = buf[i + 1];
                      if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                        if (tempCodePoint > 0x7F) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break
                    case 3:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break
                    case 4:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      fourthByte = buf[i + 3];
                      if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                          codePoint = tempCodePoint;
                        }
                      }
                  }
                }

                if (codePoint === null) {
                  // we did not generate a valid codePoint so insert a
                  // replacement char (U+FFFD) and advance only 1 byte
                  codePoint = 0xFFFD;
                  bytesPerSequence = 1;
                } else if (codePoint > 0xFFFF) {
                  // encode to utf16 (surrogate pair dance)
                  codePoint -= 0x10000;
                  res.push(codePoint >>> 10 & 0x3FF | 0xD800);
                  codePoint = 0xDC00 | codePoint & 0x3FF;
                }

                res.push(codePoint);
                i += bytesPerSequence;
              }

              return decodeCodePointsArray(res)
            }

            // Based on http://stackoverflow.com/a/22747272/680742, the browser with
            // the lowest limit is Chrome, with 0x10000 args.
            // We go 1 magnitude less, for safety
            var MAX_ARGUMENTS_LENGTH = 0x1000;

            function decodeCodePointsArray (codePoints) {
              var len = codePoints.length;
              if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
              }

              // Decode in chunks to avoid "call stack size exceeded".
              var res = '';
              var i = 0;
              while (i < len) {
                res += String.fromCharCode.apply(
                  String,
                  codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                );
              }
              return res
            }

            function asciiSlice (buf, start, end) {
              var ret = '';
              end = Math.min(buf.length, end);

              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i] & 0x7F);
              }
              return ret
            }

            function latin1Slice (buf, start, end) {
              var ret = '';
              end = Math.min(buf.length, end);

              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i]);
              }
              return ret
            }

            function hexSlice (buf, start, end) {
              var len = buf.length;

              if (!start || start < 0) start = 0;
              if (!end || end < 0 || end > len) end = len;

              var out = '';
              for (var i = start; i < end; ++i) {
                out += toHex(buf[i]);
              }
              return out
            }

            function utf16leSlice (buf, start, end) {
              var bytes = buf.slice(start, end);
              var res = '';
              for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
              }
              return res
            }

            Buffer.prototype.slice = function slice (start, end) {
              var len = this.length;
              start = ~~start;
              end = end === undefined ? len : ~~end;

              if (start < 0) {
                start += len;
                if (start < 0) start = 0;
              } else if (start > len) {
                start = len;
              }

              if (end < 0) {
                end += len;
                if (end < 0) end = 0;
              } else if (end > len) {
                end = len;
              }

              if (end < start) end = start;

              var newBuf;
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                newBuf = this.subarray(start, end);
                newBuf.__proto__ = Buffer.prototype;
              } else {
                var sliceLen = end - start;
                newBuf = new Buffer(sliceLen, undefined);
                for (var i = 0; i < sliceLen; ++i) {
                  newBuf[i] = this[i + start];
                }
              }

              return newBuf
            };

            /*
             * Need to make sure that buffer isn't trying to write out of bounds.
             */
            function checkOffset (offset, ext, length) {
              if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
              if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
            }

            Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);

              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul;
              }

              return val
            };

            Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) {
                checkOffset(offset, byteLength, this.length);
              }

              var val = this[offset + --byteLength];
              var mul = 1;
              while (byteLength > 0 && (mul *= 0x100)) {
                val += this[offset + --byteLength] * mul;
              }

              return val
            };

            Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 1, this.length);
              return this[offset]
            };

            Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              return this[offset] | (this[offset + 1] << 8)
            };

            Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              return (this[offset] << 8) | this[offset + 1]
            };

            Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);

              return ((this[offset]) |
                  (this[offset + 1] << 8) |
                  (this[offset + 2] << 16)) +
                  (this[offset + 3] * 0x1000000)
            };

            Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);

              return (this[offset] * 0x1000000) +
                ((this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                this[offset + 3])
            };

            Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);

              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul;
              }
              mul *= 0x80;

              if (val >= mul) val -= Math.pow(2, 8 * byteLength);

              return val
            };

            Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset(offset, byteLength, this.length);

              var i = byteLength;
              var mul = 1;
              var val = this[offset + --i];
              while (i > 0 && (mul *= 0x100)) {
                val += this[offset + --i] * mul;
              }
              mul *= 0x80;

              if (val >= mul) val -= Math.pow(2, 8 * byteLength);

              return val
            };

            Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 1, this.length);
              if (!(this[offset] & 0x80)) return (this[offset])
              return ((0xff - this[offset] + 1) * -1)
            };

            Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              var val = this[offset] | (this[offset + 1] << 8);
              return (val & 0x8000) ? val | 0xFFFF0000 : val
            };

            Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 2, this.length);
              var val = this[offset + 1] | (this[offset] << 8);
              return (val & 0x8000) ? val | 0xFFFF0000 : val
            };

            Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);

              return (this[offset]) |
                (this[offset + 1] << 8) |
                (this[offset + 2] << 16) |
                (this[offset + 3] << 24)
            };

            Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);

              return (this[offset] << 24) |
                (this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                (this[offset + 3])
            };

            Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return read$1(this, offset, true, 23, 4)
            };

            Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 4, this.length);
              return read$1(this, offset, false, 23, 4)
            };

            Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 8, this.length);
              return read$1(this, offset, true, 52, 8)
            };

            Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
              if (!noAssert) checkOffset(offset, 8, this.length);
              return read$1(this, offset, false, 52, 8)
            };

            function checkInt (buf, value, offset, ext, max, min) {
              if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
              if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
              if (offset + ext > buf.length) throw new RangeError('Index out of range')
            }

            Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
              }

              var mul = 1;
              var i = 0;
              this[offset] = value & 0xFF;
              while (++i < byteLength && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xFF;
              }

              return offset + byteLength
            };

            Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt(this, value, offset, byteLength, maxBytes, 0);
              }

              var i = byteLength - 1;
              var mul = 1;
              this[offset + i] = value & 0xFF;
              while (--i >= 0 && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xFF;
              }

              return offset + byteLength
            };

            Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
              if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
              this[offset] = (value & 0xff);
              return offset + 1
            };

            function objectWriteUInt16 (buf, value, offset, littleEndian) {
              if (value < 0) value = 0xffff + value + 1;
              for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
                buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
                  (littleEndian ? i : 1 - i) * 8;
              }
            }

            Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff);
                this[offset + 1] = (value >>> 8);
              } else {
                objectWriteUInt16(this, value, offset, true);
              }
              return offset + 2
            };

            Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 8);
                this[offset + 1] = (value & 0xff);
              } else {
                objectWriteUInt16(this, value, offset, false);
              }
              return offset + 2
            };

            function objectWriteUInt32 (buf, value, offset, littleEndian) {
              if (value < 0) value = 0xffffffff + value + 1;
              for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
                buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
              }
            }

            Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset + 3] = (value >>> 24);
                this[offset + 2] = (value >>> 16);
                this[offset + 1] = (value >>> 8);
                this[offset] = (value & 0xff);
              } else {
                objectWriteUInt32(this, value, offset, true);
              }
              return offset + 4
            };

            Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 24);
                this[offset + 1] = (value >>> 16);
                this[offset + 2] = (value >>> 8);
                this[offset + 3] = (value & 0xff);
              } else {
                objectWriteUInt32(this, value, offset, false);
              }
              return offset + 4
            };

            Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);

                checkInt(this, value, offset, byteLength, limit - 1, -limit);
              }

              var i = 0;
              var mul = 1;
              var sub = 0;
              this[offset] = value & 0xFF;
              while (++i < byteLength && (mul *= 0x100)) {
                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
              }

              return offset + byteLength
            };

            Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);

                checkInt(this, value, offset, byteLength, limit - 1, -limit);
              }

              var i = byteLength - 1;
              var mul = 1;
              var sub = 0;
              this[offset + i] = value & 0xFF;
              while (--i >= 0 && (mul *= 0x100)) {
                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
              }

              return offset + byteLength
            };

            Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
              if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
              if (value < 0) value = 0xff + value + 1;
              this[offset] = (value & 0xff);
              return offset + 1
            };

            Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff);
                this[offset + 1] = (value >>> 8);
              } else {
                objectWriteUInt16(this, value, offset, true);
              }
              return offset + 2
            };

            Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 8);
                this[offset + 1] = (value & 0xff);
              } else {
                objectWriteUInt16(this, value, offset, false);
              }
              return offset + 2
            };

            Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff);
                this[offset + 1] = (value >>> 8);
                this[offset + 2] = (value >>> 16);
                this[offset + 3] = (value >>> 24);
              } else {
                objectWriteUInt32(this, value, offset, true);
              }
              return offset + 4
            };

            Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
              if (value < 0) value = 0xffffffff + value + 1;
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 24);
                this[offset + 1] = (value >>> 16);
                this[offset + 2] = (value >>> 8);
                this[offset + 3] = (value & 0xff);
              } else {
                objectWriteUInt32(this, value, offset, false);
              }
              return offset + 4
            };

            function checkIEEE754 (buf, value, offset, ext, max, min) {
              if (offset + ext > buf.length) throw new RangeError('Index out of range')
              if (offset < 0) throw new RangeError('Index out of range')
            }

            function writeFloat (buf, value, offset, littleEndian, noAssert) {
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 4);
              }
              write$1(buf, value, offset, littleEndian, 23, 4);
              return offset + 4
            }

            Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
              return writeFloat(this, value, offset, true, noAssert)
            };

            Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
              return writeFloat(this, value, offset, false, noAssert)
            };

            function writeDouble (buf, value, offset, littleEndian, noAssert) {
              if (!noAssert) {
                checkIEEE754(buf, value, offset, 8);
              }
              write$1(buf, value, offset, littleEndian, 52, 8);
              return offset + 8
            }

            Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
              return writeDouble(this, value, offset, true, noAssert)
            };

            Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
              return writeDouble(this, value, offset, false, noAssert)
            };

            // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
            Buffer.prototype.copy = function copy (target, targetStart, start, end) {
              if (!start) start = 0;
              if (!end && end !== 0) end = this.length;
              if (targetStart >= target.length) targetStart = target.length;
              if (!targetStart) targetStart = 0;
              if (end > 0 && end < start) end = start;

              // Copy 0 bytes; we're done
              if (end === start) return 0
              if (target.length === 0 || this.length === 0) return 0

              // Fatal error conditions
              if (targetStart < 0) {
                throw new RangeError('targetStart out of bounds')
              }
              if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
              if (end < 0) throw new RangeError('sourceEnd out of bounds')

              // Are we oob?
              if (end > this.length) end = this.length;
              if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
              }

              var len = end - start;
              var i;

              if (this === target && start < targetStart && targetStart < end) {
                // descending copy from end
                for (i = len - 1; i >= 0; --i) {
                  target[i + targetStart] = this[i + start];
                }
              } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                // ascending copy from start
                for (i = 0; i < len; ++i) {
                  target[i + targetStart] = this[i + start];
                }
              } else {
                Uint8Array.prototype.set.call(
                  target,
                  this.subarray(start, start + len),
                  targetStart
                );
              }

              return len
            };

            // Usage:
            //    buffer.fill(number[, offset[, end]])
            //    buffer.fill(buffer[, offset[, end]])
            //    buffer.fill(string[, offset[, end]][, encoding])
            Buffer.prototype.fill = function fill (val, start, end, encoding) {
              // Handle string cases:
              if (typeof val === 'string') {
                if (typeof start === 'string') {
                  encoding = start;
                  start = 0;
                  end = this.length;
                } else if (typeof end === 'string') {
                  encoding = end;
                  end = this.length;
                }
                if (val.length === 1) {
                  var code = val.charCodeAt(0);
                  if (code < 256) {
                    val = code;
                  }
                }
                if (encoding !== undefined && typeof encoding !== 'string') {
                  throw new TypeError('encoding must be a string')
                }
                if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                  throw new TypeError('Unknown encoding: ' + encoding)
                }
              } else if (typeof val === 'number') {
                val = val & 255;
              }

              // Invalid ranges are not set to a default, so can range check early.
              if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError('Out of range index')
              }

              if (end <= start) {
                return this
              }

              start = start >>> 0;
              end = end === undefined ? this.length : end >>> 0;

              if (!val) val = 0;

              var i;
              if (typeof val === 'number') {
                for (i = start; i < end; ++i) {
                  this[i] = val;
                }
              } else {
                var bytes = internalIsBuffer(val)
                  ? val
                  : utf8ToBytes(new Buffer(val, encoding).toString());
                var len = bytes.length;
                for (i = 0; i < end - start; ++i) {
                  this[i + start] = bytes[i % len];
                }
              }

              return this
            };

            // HELPER FUNCTIONS
            // ================

            var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

            function base64clean (str) {
              // Node strips out invalid characters like \n and \t from the string, base64-js does not
              str = stringtrim(str).replace(INVALID_BASE64_RE, '');
              // Node converts strings with length < 2 to ''
              if (str.length < 2) return ''
              // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
              while (str.length % 4 !== 0) {
                str = str + '=';
              }
              return str
            }

            function stringtrim (str) {
              if (str.trim) return str.trim()
              return str.replace(/^\s+|\s+$/g, '')
            }

            function toHex (n) {
              if (n < 16) return '0' + n.toString(16)
              return n.toString(16)
            }

            function utf8ToBytes (string, units) {
              units = units || Infinity;
              var codePoint;
              var length = string.length;
              var leadSurrogate = null;
              var bytes = [];

              for (var i = 0; i < length; ++i) {
                codePoint = string.charCodeAt(i);

                // is surrogate component
                if (codePoint > 0xD7FF && codePoint < 0xE000) {
                  // last char was a lead
                  if (!leadSurrogate) {
                    // no lead yet
                    if (codePoint > 0xDBFF) {
                      // unexpected trail
                      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                      continue
                    } else if (i + 1 === length) {
                      // unpaired lead
                      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                      continue
                    }

                    // valid lead
                    leadSurrogate = codePoint;

                    continue
                  }

                  // 2 leads in a row
                  if (codePoint < 0xDC00) {
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    leadSurrogate = codePoint;
                    continue
                  }

                  // valid surrogate pair
                  codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
                } else if (leadSurrogate) {
                  // valid bmp char, but last char was a lead
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                }

                leadSurrogate = null;

                // encode utf8
                if (codePoint < 0x80) {
                  if ((units -= 1) < 0) break
                  bytes.push(codePoint);
                } else if (codePoint < 0x800) {
                  if ((units -= 2) < 0) break
                  bytes.push(
                    codePoint >> 0x6 | 0xC0,
                    codePoint & 0x3F | 0x80
                  );
                } else if (codePoint < 0x10000) {
                  if ((units -= 3) < 0) break
                  bytes.push(
                    codePoint >> 0xC | 0xE0,
                    codePoint >> 0x6 & 0x3F | 0x80,
                    codePoint & 0x3F | 0x80
                  );
                } else if (codePoint < 0x110000) {
                  if ((units -= 4) < 0) break
                  bytes.push(
                    codePoint >> 0x12 | 0xF0,
                    codePoint >> 0xC & 0x3F | 0x80,
                    codePoint >> 0x6 & 0x3F | 0x80,
                    codePoint & 0x3F | 0x80
                  );
                } else {
                  throw new Error('Invalid code point')
                }
              }

              return bytes
            }

            function asciiToBytes (str) {
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                // Node's code seems to be doing this and not & 0x7F..
                byteArray.push(str.charCodeAt(i) & 0xFF);
              }
              return byteArray
            }

            function utf16leToBytes (str, units) {
              var c, hi, lo;
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                if ((units -= 2) < 0) break

                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
              }

              return byteArray
            }


            function base64ToBytes (str) {
              return toByteArray(base64clean(str))
            }

            function blitBuffer (src, dst, offset, length) {
              for (var i = 0; i < length; ++i) {
                if ((i + offset >= dst.length) || (i >= src.length)) break
                dst[i + offset] = src[i];
              }
              return i
            }

            function isnan (val) {
              return val !== val // eslint-disable-line no-self-compare
            }


            // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
            // The _isBuffer check is for Safari 5-7 support, because it's missing
            // Object.prototype.constructor. Remove this eventually
            function isBuffer(obj) {
              return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
            }

            function isFastBuffer (obj) {
              return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
            }

            // For Node v0.10 support. Remove this eventually.
            function isSlowBuffer (obj) {
              return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
            }

            var inherits;
            if (typeof Object.create === 'function'){
              inherits = function inherits(ctor, superCtor) {
                // implementation from standard node.js 'util' module
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                  constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
              };
            } else {
              inherits = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function () {};
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
              };
            }
            var inherits$1 = inherits;

            var formatRegExp = /%[sdj%]/g;
            function format(f) {
              if (!isString(f)) {
                var objects = [];
                for (var i = 0; i < arguments.length; i++) {
                  objects.push(inspect(arguments[i]));
                }
                return objects.join(' ');
              }

              var i = 1;
              var args = arguments;
              var len = args.length;
              var str = String(f).replace(formatRegExp, function(x) {
                if (x === '%%') return '%';
                if (i >= len) return x;
                switch (x) {
                  case '%s': return String(args[i++]);
                  case '%d': return Number(args[i++]);
                  case '%j':
                    try {
                      return JSON.stringify(args[i++]);
                    } catch (_) {
                      return '[Circular]';
                    }
                  default:
                    return x;
                }
              });
              for (var x = args[i]; i < len; x = args[++i]) {
                if (isNull(x) || !isObject(x)) {
                  str += ' ' + x;
                } else {
                  str += ' ' + inspect(x);
                }
              }
              return str;
            }

            // Mark that a method should not be used.
            // Returns a modified function which warns once by default.
            // If --no-deprecation is set, then it is a no-op.
            function deprecate(fn, msg) {
              // Allow for deprecating things in the process of starting up.
              if (isUndefined(global$1$3.process)) {
                return function() {
                  return deprecate(fn, msg).apply(this, arguments);
                };
              }

              var warned = false;
              function deprecated() {
                if (!warned) {
                  {
                    console.error(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }

              return deprecated;
            }

            var debugs = {};
            var debugEnviron;
            function debuglog(set) {
              if (isUndefined(debugEnviron))
                debugEnviron = process$2.env.NODE_DEBUG || '';
              set = set.toUpperCase();
              if (!debugs[set]) {
                if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                  var pid = 0;
                  debugs[set] = function() {
                    var msg = format.apply(null, arguments);
                    console.error('%s %d: %s', set, pid, msg);
                  };
                } else {
                  debugs[set] = function() {};
                }
              }
              return debugs[set];
            }

            /**
             * Echos the value of a value. Trys to print the value out
             * in the best way possible given the different types.
             *
             * @param {Object} obj The object to print out.
             * @param {Object} opts Optional options object that alters the output.
             */
            /* legacy: obj, showHidden, depth, colors*/
            function inspect(obj, opts) {
              // default options
              var ctx = {
                seen: [],
                stylize: stylizeNoColor
              };
              // legacy...
              if (arguments.length >= 3) ctx.depth = arguments[2];
              if (arguments.length >= 4) ctx.colors = arguments[3];
              if (isBoolean(opts)) {
                // legacy...
                ctx.showHidden = opts;
              } else if (opts) {
                // got an "options" object
                _extend(ctx, opts);
              }
              // set default options
              if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
              if (isUndefined(ctx.depth)) ctx.depth = 2;
              if (isUndefined(ctx.colors)) ctx.colors = false;
              if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
              if (ctx.colors) ctx.stylize = stylizeWithColor;
              return formatValue(ctx, obj, ctx.depth);
            }

            // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
            inspect.colors = {
              'bold' : [1, 22],
              'italic' : [3, 23],
              'underline' : [4, 24],
              'inverse' : [7, 27],
              'white' : [37, 39],
              'grey' : [90, 39],
              'black' : [30, 39],
              'blue' : [34, 39],
              'cyan' : [36, 39],
              'green' : [32, 39],
              'magenta' : [35, 39],
              'red' : [31, 39],
              'yellow' : [33, 39]
            };

            // Don't use 'blue' not visible on cmd.exe
            inspect.styles = {
              'special': 'cyan',
              'number': 'yellow',
              'boolean': 'yellow',
              'undefined': 'grey',
              'null': 'bold',
              'string': 'green',
              'date': 'magenta',
              // "name": intentionally not styling
              'regexp': 'red'
            };


            function stylizeWithColor(str, styleType) {
              var style = inspect.styles[styleType];

              if (style) {
                return '\u001b[' + inspect.colors[style][0] + 'm' + str +
                       '\u001b[' + inspect.colors[style][1] + 'm';
              } else {
                return str;
              }
            }


            function stylizeNoColor(str, styleType) {
              return str;
            }


            function arrayToHash(array) {
              var hash = {};

              array.forEach(function(val, idx) {
                hash[val] = true;
              });

              return hash;
            }


            function formatValue(ctx, value, recurseTimes) {
              // Provide a hook for user-specified inspect functions.
              // Check that value is an object with an inspect function on it
              if (ctx.customInspect &&
                  value &&
                  isFunction(value.inspect) &&
                  // Filter out the util module, it's inspect function is special
                  value.inspect !== inspect &&
                  // Also filter out any prototype objects using the circular check.
                  !(value.constructor && value.constructor.prototype === value)) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString(ret)) {
                  ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
              }

              // Primitive types cannot have properties
              var primitive = formatPrimitive(ctx, value);
              if (primitive) {
                return primitive;
              }

              // Look up the keys of the object.
              var keys = Object.keys(value);
              var visibleKeys = arrayToHash(keys);

              if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
              }

              // IE doesn't make error fields non-enumerable
              // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
              if (isError(value)
                  && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                return formatError(value);
              }

              // Some type of object without properties can be shortcutted.
              if (keys.length === 0) {
                if (isFunction(value)) {
                  var name = value.name ? ': ' + value.name : '';
                  return ctx.stylize('[Function' + name + ']', 'special');
                }
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                }
                if (isDate(value)) {
                  return ctx.stylize(Date.prototype.toString.call(value), 'date');
                }
                if (isError(value)) {
                  return formatError(value);
                }
              }

              var base = '', array = false, braces = ['{', '}'];

              // Make Array say that they are Array
              if (isArray$1$1(value)) {
                array = true;
                braces = ['[', ']'];
              }

              // Make functions say that they are functions
              if (isFunction(value)) {
                var n = value.name ? ': ' + value.name : '';
                base = ' [Function' + n + ']';
              }

              // Make RegExps say that they are RegExps
              if (isRegExp(value)) {
                base = ' ' + RegExp.prototype.toString.call(value);
              }

              // Make dates with properties first say the date
              if (isDate(value)) {
                base = ' ' + Date.prototype.toUTCString.call(value);
              }

              // Make error with message first say the error
              if (isError(value)) {
                base = ' ' + formatError(value);
              }

              if (keys.length === 0 && (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
              }

              if (recurseTimes < 0) {
                if (isRegExp(value)) {
                  return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                } else {
                  return ctx.stylize('[Object]', 'special');
                }
              }

              ctx.seen.push(value);

              var output;
              if (array) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
              } else {
                output = keys.map(function(key) {
                  return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                });
              }

              ctx.seen.pop();

              return reduceToSingleString(output, base, braces);
            }


            function formatPrimitive(ctx, value) {
              if (isUndefined(value))
                return ctx.stylize('undefined', 'undefined');
              if (isString(value)) {
                var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                         .replace(/'/g, "\\'")
                                                         .replace(/\\"/g, '"') + '\'';
                return ctx.stylize(simple, 'string');
              }
              if (isNumber(value))
                return ctx.stylize('' + value, 'number');
              if (isBoolean(value))
                return ctx.stylize('' + value, 'boolean');
              // For some reason typeof null is "object", so special case here.
              if (isNull(value))
                return ctx.stylize('null', 'null');
            }


            function formatError(value) {
              return '[' + Error.prototype.toString.call(value) + ']';
            }


            function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
              var output = [];
              for (var i = 0, l = value.length; i < l; ++i) {
                if (hasOwnProperty$1(value, String(i))) {
                  output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                      String(i), true));
                } else {
                  output.push('');
                }
              }
              keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                  output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                      key, true));
                }
              });
              return output;
            }


            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
              var name, str, desc;
              desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
              if (desc.get) {
                if (desc.set) {
                  str = ctx.stylize('[Getter/Setter]', 'special');
                } else {
                  str = ctx.stylize('[Getter]', 'special');
                }
              } else {
                if (desc.set) {
                  str = ctx.stylize('[Setter]', 'special');
                }
              }
              if (!hasOwnProperty$1(visibleKeys, key)) {
                name = '[' + key + ']';
              }
              if (!str) {
                if (ctx.seen.indexOf(desc.value) < 0) {
                  if (isNull(recurseTimes)) {
                    str = formatValue(ctx, desc.value, null);
                  } else {
                    str = formatValue(ctx, desc.value, recurseTimes - 1);
                  }
                  if (str.indexOf('\n') > -1) {
                    if (array) {
                      str = str.split('\n').map(function(line) {
                        return '  ' + line;
                      }).join('\n').substr(2);
                    } else {
                      str = '\n' + str.split('\n').map(function(line) {
                        return '   ' + line;
                      }).join('\n');
                    }
                  }
                } else {
                  str = ctx.stylize('[Circular]', 'special');
                }
              }
              if (isUndefined(name)) {
                if (array && key.match(/^\d+$/)) {
                  return str;
                }
                name = JSON.stringify('' + key);
                if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                  name = name.substr(1, name.length - 2);
                  name = ctx.stylize(name, 'name');
                } else {
                  name = name.replace(/'/g, "\\'")
                             .replace(/\\"/g, '"')
                             .replace(/(^"|"$)/g, "'");
                  name = ctx.stylize(name, 'string');
                }
              }

              return name + ': ' + str;
            }


            function reduceToSingleString(output, base, braces) {
              var length = output.reduce(function(prev, cur) {
                if (cur.indexOf('\n') >= 0) ;
                return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
              }, 0);

              if (length > 60) {
                return braces[0] +
                       (base === '' ? '' : base + '\n ') +
                       ' ' +
                       output.join(',\n  ') +
                       ' ' +
                       braces[1];
              }

              return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
            }


            // NOTE: These type checking functions intentionally don't use `instanceof`
            // because it is fragile and can be easily faked with `Object.create()`.
            function isArray$1$1(ar) {
              return Array.isArray(ar);
            }

            function isBoolean(arg) {
              return typeof arg === 'boolean';
            }

            function isNull(arg) {
              return arg === null;
            }

            function isNullOrUndefined(arg) {
              return arg == null;
            }

            function isNumber(arg) {
              return typeof arg === 'number';
            }

            function isString(arg) {
              return typeof arg === 'string';
            }

            function isSymbol(arg) {
              return typeof arg === 'symbol';
            }

            function isUndefined(arg) {
              return arg === void 0;
            }

            function isRegExp(re) {
              return isObject(re) && objectToString(re) === '[object RegExp]';
            }

            function isObject(arg) {
              return typeof arg === 'object' && arg !== null;
            }

            function isDate(d) {
              return isObject(d) && objectToString(d) === '[object Date]';
            }

            function isError(e) {
              return isObject(e) &&
                  (objectToString(e) === '[object Error]' || e instanceof Error);
            }

            function isFunction(arg) {
              return typeof arg === 'function';
            }

            function isPrimitive(arg) {
              return arg === null ||
                     typeof arg === 'boolean' ||
                     typeof arg === 'number' ||
                     typeof arg === 'string' ||
                     typeof arg === 'symbol' ||  // ES6 symbol
                     typeof arg === 'undefined';
            }

            function isBuffer$1(maybeBuf) {
              return isBuffer(maybeBuf);
            }

            function objectToString(o) {
              return Object.prototype.toString.call(o);
            }


            function pad(n) {
              return n < 10 ? '0' + n.toString(10) : n.toString(10);
            }


            var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                          'Oct', 'Nov', 'Dec'];

            // 26 Feb 16:19:34
            function timestamp() {
              var d = new Date();
              var time = [pad(d.getHours()),
                          pad(d.getMinutes()),
                          pad(d.getSeconds())].join(':');
              return [d.getDate(), months[d.getMonth()], time].join(' ');
            }


            // log is just a thin wrapper to console.log that prepends a timestamp
            function log$1() {
              console.log('%s - %s', timestamp(), format.apply(null, arguments));
            }

            function _extend(origin, add) {
              // Don't do anything if add isn't an object
              if (!add || !isObject(add)) return origin;

              var keys = Object.keys(add);
              var i = keys.length;
              while (i--) {
                origin[keys[i]] = add[keys[i]];
              }
              return origin;
            }
            function hasOwnProperty$1(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }

            var util = {
              inherits: inherits$1,
              _extend: _extend,
              log: log$1,
              isBuffer: isBuffer$1,
              isPrimitive: isPrimitive,
              isFunction: isFunction,
              isError: isError,
              isDate: isDate,
              isObject: isObject,
              isRegExp: isRegExp,
              isUndefined: isUndefined,
              isSymbol: isSymbol,
              isString: isString,
              isNumber: isNumber,
              isNullOrUndefined: isNullOrUndefined,
              isNull: isNull,
              isBoolean: isBoolean,
              isArray: isArray$1$1,
              inspect: inspect,
              deprecate: deprecate,
              format: format,
              debuglog: debuglog
            };

            var hasFlag = (flag, argv = process$2.argv) => {
            	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
            	const position = argv.indexOf(prefix + flag);
            	const terminatorPosition = argv.indexOf('--');
            	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
            };

            const {env: env$1$1} = process$2;

            let forceColor;
            if (hasFlag('no-color') ||
            	hasFlag('no-colors') ||
            	hasFlag('color=false') ||
            	hasFlag('color=never')) {
            	forceColor = 0;
            } else if (hasFlag('color') ||
            	hasFlag('colors') ||
            	hasFlag('color=true') ||
            	hasFlag('color=always')) {
            	forceColor = 1;
            }

            if ('FORCE_COLOR' in env$1$1) {
            	if (env$1$1.FORCE_COLOR === 'true') {
            		forceColor = 1;
            	} else if (env$1$1.FORCE_COLOR === 'false') {
            		forceColor = 0;
            	} else {
            		forceColor = env$1$1.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env$1$1.FORCE_COLOR, 10), 3);
            	}
            }

            function translateLevel(level) {
            	if (level === 0) {
            		return false;
            	}

            	return {
            		level,
            		hasBasic: true,
            		has256: level >= 2,
            		has16m: level >= 3
            	};
            }

            function supportsColor(haveStream, streamIsTTY) {
            	if (forceColor === 0) {
            		return 0;
            	}

            	if (hasFlag('color=16m') ||
            		hasFlag('color=full') ||
            		hasFlag('color=truecolor')) {
            		return 3;
            	}

            	if (hasFlag('color=256')) {
            		return 2;
            	}

            	if (haveStream && !streamIsTTY && forceColor === undefined) {
            		return 0;
            	}

            	const min = forceColor || 0;

            	if (env$1$1.TERM === 'dumb') {
            		return min;
            	}

            	if ('CI' in env$1$1) {
            		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env$1$1) || env$1$1.CI_NAME === 'codeship') {
            			return 1;
            		}

            		return min;
            	}

            	if ('TEAMCITY_VERSION' in env$1$1) {
            		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env$1$1.TEAMCITY_VERSION) ? 1 : 0;
            	}

            	if ('GITHUB_ACTIONS' in env$1$1) {
            		return 1;
            	}

            	if (env$1$1.COLORTERM === 'truecolor') {
            		return 3;
            	}

            	if ('TERM_PROGRAM' in env$1$1) {
            		const version = parseInt((env$1$1.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

            		switch (env$1$1.TERM_PROGRAM) {
            			case 'iTerm.app':
            				return version >= 3 ? 3 : 2;
            			case 'Apple_Terminal':
            				return 2;
            			// No default
            		}
            	}

            	if (/-256(color)?$/i.test(env$1$1.TERM)) {
            		return 2;
            	}

            	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env$1$1.TERM)) {
            		return 1;
            	}

            	if ('COLORTERM' in env$1$1) {
            		return 1;
            	}

            	return min;
            }

            function getSupportLevel(stream) {
            	const level = supportsColor(stream, stream && stream.isTTY);
            	return translateLevel(level);
            }

            var supportsColor_1 = {
            	supportsColor: getSupportLevel,
            	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
            	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
            };

            var node = createCommonjsModule$2(function (module, exports) {

            /**
             * Module dependencies.
             */



            /**
             * This is the Node.js implementation of `debug()`.
             */


            exports.init = init;
            exports.log = log;
            exports.formatArgs = formatArgs;
            exports.save = save;
            exports.load = load;
            exports.useColors = useColors;
            /**
             * Colors.
             */

            exports.colors = [6, 2, 3, 4, 5, 1];

            try {
              // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
              // eslint-disable-next-line import/no-extraneous-dependencies
              var supportsColor = supportsColor_1;

              if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
                exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
              }
            } catch (error) {} // Swallow - we only care if `supports-color` is available; it doesn't have to be.

            /**
             * Build up the default `inspectOpts` object from the environment variables.
             *
             *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
             */


            exports.inspectOpts = Object.keys(process$2.env).filter(function (key) {
              return /^debug_/i.test(key);
            }).reduce(function (obj, key) {
              // Camel-case
              var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
                return k.toUpperCase();
              }); // Coerce string value into JS value

              var val = process$2.env[key];

              if (/^(yes|on|true|enabled)$/i.test(val)) {
                val = true;
              } else if (/^(no|off|false|disabled)$/i.test(val)) {
                val = false;
              } else if (val === 'null') {
                val = null;
              } else {
                val = Number(val);
              }

              obj[prop] = val;
              return obj;
            }, {});
            /**
             * Is stdout a TTY? Colored output is enabled when `true`.
             */

            function useColors() {
              return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process$2.stderr.fd);
            }
            /**
             * Adds ANSI color escape codes if enabled.
             *
             * @api public
             */


            function formatArgs(args) {
              var name = this.namespace,
                  useColors = this.useColors;

              if (useColors) {
                var c = this.color;
                var colorCode = "\x1B[3" + (c < 8 ? c : '8;5;' + c);
                var prefix = "  ".concat(colorCode, ";1m").concat(name, " \x1B[0m");
                args[0] = prefix + args[0].split('\n').join('\n' + prefix);
                args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + "\x1B[0m");
              } else {
                args[0] = getDate() + name + ' ' + args[0];
              }
            }

            function getDate() {
              if (exports.inspectOpts.hideDate) {
                return '';
              }

              return new Date().toISOString() + ' ';
            }
            /**
             * Invokes `util.format()` with the specified arguments and writes to stderr.
             */


            function log() {
              return process$2.stderr.write(util.format.apply(util, arguments) + '\n');
            }
            /**
             * Save `namespaces`.
             *
             * @param {String} namespaces
             * @api private
             */


            function save(namespaces) {
              if (namespaces) {
                process$2.env.DEBUG = namespaces;
              } else {
                // If you set a process.env field to null or undefined, it gets cast to the
                // string 'null' or 'undefined'. Just delete instead.
                delete process$2.env.DEBUG;
              }
            }
            /**
             * Load `namespaces`.
             *
             * @return {String} returns the previously persisted debug modes
             * @api private
             */


            function load() {
              return process$2.env.DEBUG;
            }
            /**
             * Init logic for `debug` instances.
             *
             * Create a new `inspectOpts` object in case `useColors` is set
             * differently for a particular `debug` instance.
             */


            function init(debug) {
              debug.inspectOpts = {};
              var keys = Object.keys(exports.inspectOpts);

              for (var i = 0; i < keys.length; i++) {
                debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
              }
            }

            module.exports = common(exports);
            var formatters = module.exports.formatters;
            /**
             * Map %o to `util.inspect()`, all on a single line.
             */

            formatters.o = function (v) {
              this.inspectOpts.colors = this.useColors;
              return util.inspect(v, this.inspectOpts).replace(/\s*\n\s*/g, ' ');
            };
            /**
             * Map %O to `util.inspect()`, allowing multiple lines if needed.
             */


            formatters.O = function (v) {
              this.inspectOpts.colors = this.useColors;
              return util.inspect(v, this.inspectOpts);
            };
            });
            var node_1 = node.init;
            var node_2 = node.log;
            var node_3 = node.formatArgs;
            var node_4 = node.save;
            var node_5 = node.load;
            var node_6 = node.useColors;
            var node_7 = node.colors;
            var node_8 = node.inspectOpts;

            var src = createCommonjsModule$2(function (module) {

            /**
             * Detect Electron renderer / nwjs process, which is node, but we should
             * treat as a browser.
             */
            if (typeof process$2 === 'undefined' || process$2.type === 'renderer' || browser$1$1 === true || process$2.__nwjs) {
              module.exports = browser$2$1;
            } else {
              module.exports = node;
            }
            });

            var HalfEdge_1 = createCommonjsModule$2(function (module, exports) {

            Object.defineProperty(exports, "__esModule", {
              value: true
            });

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



            var _distance2 = _interopRequireDefault(distance_1);



            var _squaredDistance2 = _interopRequireDefault(squaredDistance_1);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var debug = src('halfedge');

            var HalfEdge = function () {
              function HalfEdge(vertex, face) {
                _classCallCheck(this, HalfEdge);

                this.vertex = vertex;
                this.face = face;
                this.next = null;
                this.prev = null;
                this.opposite = null;
              }

              _createClass(HalfEdge, [{
                key: 'head',
                value: function head() {
                  return this.vertex;
                }
              }, {
                key: 'tail',
                value: function tail() {
                  return this.prev ? this.prev.vertex : null;
                }
              }, {
                key: 'length',
                value: function length() {
                  if (this.tail()) {
                    return (0, _distance2.default)(this.tail().point, this.head().point);
                  }
                  return -1;
                }
              }, {
                key: 'lengthSquared',
                value: function lengthSquared() {
                  if (this.tail()) {
                    return (0, _squaredDistance2.default)(this.tail().point, this.head().point);
                  }
                  return -1;
                }
              }, {
                key: 'setOpposite',
                value: function setOpposite(edge) {
                  var me = this;
                  if (debug.enabled) {
                    debug('opposite ' + me.tail().index + ' <--> ' + me.head().index + ' between ' + me.face.collectIndices() + ', ' + edge.face.collectIndices());
                  }
                  this.opposite = edge;
                  edge.opposite = this;
                }
              }]);

              return HalfEdge;
            }();

            exports.default = HalfEdge;
            module.exports = exports['default'];
            });

            unwrapExports$1(HalfEdge_1);

            var Face_1 = createCommonjsModule$2(function (module, exports) {

            Object.defineProperty(exports, "__esModule", {
              value: true
            });
            exports.DELETED = exports.NON_CONVEX = exports.VISIBLE = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



            var _dot2 = _interopRequireDefault(dot_1);



            var _add2 = _interopRequireDefault(add_1);



            var _subtract2 = _interopRequireDefault(subtract_1);



            var _cross2 = _interopRequireDefault(cross_1);



            var _copy2 = _interopRequireDefault(copy_1);



            var _length2 = _interopRequireDefault(length_1);



            var _scale2 = _interopRequireDefault(scale_1);



            var _scaleAndAdd2 = _interopRequireDefault(scaleAndAdd_1);



            var _normalize2 = _interopRequireDefault(normalize_1);



            var _HalfEdge2 = _interopRequireDefault(HalfEdge_1);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var debug = src('face');

            var VISIBLE = exports.VISIBLE = 0;
            var NON_CONVEX = exports.NON_CONVEX = 1;
            var DELETED = exports.DELETED = 2;

            var Face = function () {
              function Face() {
                _classCallCheck(this, Face);

                this.normal = [];
                this.centroid = [];
                // signed distance from face to the origin
                this.offset = 0;
                // pointer to the a vertex in a double linked list this face can see
                this.outside = null;
                this.mark = VISIBLE;
                this.edge = null;
                this.nVertices = 0;
              }

              _createClass(Face, [{
                key: 'getEdge',
                value: function getEdge(i) {
                  if (typeof i !== 'number') {
                    throw Error('requires a number');
                  }
                  var it = this.edge;
                  while (i > 0) {
                    it = it.next;
                    i -= 1;
                  }
                  while (i < 0) {
                    it = it.prev;
                    i += 1;
                  }
                  return it;
                }
              }, {
                key: 'computeNormal',
                value: function computeNormal() {
                  var e0 = this.edge;
                  var e1 = e0.next;
                  var e2 = e1.next;
                  var v2 = (0, _subtract2.default)([], e1.head().point, e0.head().point);
                  var t = [];
                  var v1 = [];

                  this.nVertices = 2;
                  this.normal = [0, 0, 0];
                  while (e2 !== e0) {
                    (0, _copy2.default)(v1, v2);
                    (0, _subtract2.default)(v2, e2.head().point, e0.head().point);
                    (0, _add2.default)(this.normal, this.normal, (0, _cross2.default)(t, v1, v2));
                    e2 = e2.next;
                    this.nVertices += 1;
                  }
                  this.area = (0, _length2.default)(this.normal);
                  // normalize the vector, since we've already calculated the area
                  // it's cheaper to scale the vector using this quantity instead of
                  // doing the same operation again
                  this.normal = (0, _scale2.default)(this.normal, this.normal, 1 / this.area);
                }
              }, {
                key: 'computeNormalMinArea',
                value: function computeNormalMinArea(minArea) {
                  this.computeNormal();
                  if (this.area < minArea) {
                    // compute the normal without the longest edge
                    var maxEdge = void 0;
                    var maxSquaredLength = 0;
                    var edge = this.edge;

                    // find the longest edge (in length) in the chain of edges
                    do {
                      var lengthSquared = edge.lengthSquared();
                      if (lengthSquared > maxSquaredLength) {
                        maxEdge = edge;
                        maxSquaredLength = lengthSquared;
                      }
                      edge = edge.next;
                    } while (edge !== this.edge);

                    var p1 = maxEdge.tail().point;
                    var p2 = maxEdge.head().point;
                    var maxVector = (0, _subtract2.default)([], p2, p1);
                    var maxLength = Math.sqrt(maxSquaredLength);
                    // maxVector is normalized after this operation
                    (0, _scale2.default)(maxVector, maxVector, 1 / maxLength);
                    // compute the projection of maxVector over this face normal
                    var maxProjection = (0, _dot2.default)(this.normal, maxVector);
                    // subtract the quantity maxEdge adds on the normal
                    (0, _scaleAndAdd2.default)(this.normal, this.normal, maxVector, -maxProjection);
                    // renormalize `this.normal`
                    (0, _normalize2.default)(this.normal, this.normal);
                  }
                }
              }, {
                key: 'computeCentroid',
                value: function computeCentroid() {
                  this.centroid = [0, 0, 0];
                  var edge = this.edge;
                  do {
                    (0, _add2.default)(this.centroid, this.centroid, edge.head().point);
                    edge = edge.next;
                  } while (edge !== this.edge);
                  (0, _scale2.default)(this.centroid, this.centroid, 1 / this.nVertices);
                }
              }, {
                key: 'computeNormalAndCentroid',
                value: function computeNormalAndCentroid(minArea) {
                  if (typeof minArea !== 'undefined') {
                    this.computeNormalMinArea(minArea);
                  } else {
                    this.computeNormal();
                  }
                  this.computeCentroid();
                  this.offset = (0, _dot2.default)(this.normal, this.centroid);
                }
              }, {
                key: 'distanceToPlane',
                value: function distanceToPlane(point) {
                  return (0, _dot2.default)(this.normal, point) - this.offset;
                }

                /**
                 * @private
                 *
                 * Connects two edges assuming that prev.head().point === next.tail().point
                 *
                 * @param {HalfEdge} prev
                 * @param {HalfEdge} next
                 */

              }, {
                key: 'connectHalfEdges',
                value: function connectHalfEdges(prev, next) {
                  var discardedFace = void 0;
                  if (prev.opposite.face === next.opposite.face) {
                    // `prev` is remove a redundant edge
                    var oppositeFace = next.opposite.face;
                    var oppositeEdge = void 0;
                    if (prev === this.edge) {
                      this.edge = next;
                    }
                    if (oppositeFace.nVertices === 3) {
                      // case:
                      // remove the face on the right
                      //
                      //       /|\
                      //      / | \ the face on the right
                      //     /  |  \ --> opposite edge
                      //    / a |   \
                      //   *----*----*
                      //  /     b  |  \
                      //           ▾
                      //      redundant edge
                      //
                      // Note: the opposite edge is actually in the face to the right
                      // of the face to be destroyed
                      oppositeEdge = next.opposite.prev.opposite;
                      oppositeFace.mark = DELETED;
                      discardedFace = oppositeFace;
                    } else {
                      // case:
                      //          t
                      //        *----
                      //       /| <- right face's redundant edge
                      //      / | opposite edge
                      //     /  |  ▴   /
                      //    / a |  |  /
                      //   *----*----*
                      //  /     b  |  \
                      //           ▾
                      //      redundant edge
                      oppositeEdge = next.opposite.next;
                      // make sure that the link `oppositeFace.edge` points correctly even
                      // after the right face redundant edge is removed
                      if (oppositeFace.edge === oppositeEdge.prev) {
                        oppositeFace.edge = oppositeEdge;
                      }

                      //       /|   /
                      //      / | t/opposite edge
                      //     /  | / ▴  /
                      //    / a |/  | /
                      //   *----*----*
                      //  /     b     \
                      oppositeEdge.prev = oppositeEdge.prev.prev;
                      oppositeEdge.prev.next = oppositeEdge;
                    }
                    //       /|
                    //      / |
                    //     /  |
                    //    / a |
                    //   *----*----*
                    //  /     b  ▴  \
                    //           |
                    //     redundant edge
                    next.prev = prev.prev;
                    next.prev.next = next;

                    //       / \  \
                    //      /   \->\
                    //     /     \<-\ opposite edge
                    //    / a     \  \
                    //   *----*----*
                    //  /     b  ^  \
                    next.setOpposite(oppositeEdge);

                    oppositeFace.computeNormalAndCentroid();
                  } else {
                    // trivial case
                    //        *
                    //       /|\
                    //      / | \
                    //     /  |--> next
                    //    / a |   \
                    //   *----*----*
                    //    \ b |   /
                    //     \  |--> prev
                    //      \ | /
                    //       \|/
                    //        *
                    prev.next = next;
                    next.prev = prev;
                  }
                  return discardedFace;
                }
              }, {
                key: 'mergeAdjacentFaces',
                value: function mergeAdjacentFaces(adjacentEdge, discardedFaces) {
                  var oppositeEdge = adjacentEdge.opposite;
                  var oppositeFace = oppositeEdge.face;

                  discardedFaces.push(oppositeFace);
                  oppositeFace.mark = DELETED;

                  // find the chain of edges whose opposite face is `oppositeFace`
                  //
                  //                ===>
                  //      \         face         /
                  //       * ---- * ---- * ---- *
                  //      /     opposite face    \
                  //                <===
                  //
                  var adjacentEdgePrev = adjacentEdge.prev;
                  var adjacentEdgeNext = adjacentEdge.next;
                  var oppositeEdgePrev = oppositeEdge.prev;
                  var oppositeEdgeNext = oppositeEdge.next;

                  // left edge
                  while (adjacentEdgePrev.opposite.face === oppositeFace) {
                    adjacentEdgePrev = adjacentEdgePrev.prev;
                    oppositeEdgeNext = oppositeEdgeNext.next;
                  }
                  // right edge
                  while (adjacentEdgeNext.opposite.face === oppositeFace) {
                    adjacentEdgeNext = adjacentEdgeNext.next;
                    oppositeEdgePrev = oppositeEdgePrev.prev;
                  }
                  // adjacentEdgePrev  \         face         / adjacentEdgeNext
                  //                    * ---- * ---- * ---- *
                  // oppositeEdgeNext  /     opposite face    \ oppositeEdgePrev

                  // fix the face reference of all the opposite edges that are not part of
                  // the edges whose opposite face is not `face` i.e. all the edges that
                  // `face` and `oppositeFace` do not have in common
                  var edge = void 0;
                  for (edge = oppositeEdgeNext; edge !== oppositeEdgePrev.next; edge = edge.next) {
                    edge.face = this;
                  }

                  // make sure that `face.edge` is not one of the edges to be destroyed
                  // Note: it's important for it to be a `next` edge since `prev` edges
                  // might be destroyed on `connectHalfEdges`
                  this.edge = adjacentEdgeNext;

                  // connect the extremes
                  // Note: it might be possible that after connecting the edges a triangular
                  // face might be redundant
                  var discardedFace = void 0;
                  discardedFace = this.connectHalfEdges(oppositeEdgePrev, adjacentEdgeNext);
                  if (discardedFace) {
                    discardedFaces.push(discardedFace);
                  }
                  discardedFace = this.connectHalfEdges(adjacentEdgePrev, oppositeEdgeNext);
                  if (discardedFace) {
                    discardedFaces.push(discardedFace);
                  }

                  this.computeNormalAndCentroid();
                  // TODO: additional consistency checks
                  return discardedFaces;
                }
              }, {
                key: 'collectIndices',
                value: function collectIndices() {
                  var indices = [];
                  var edge = this.edge;
                  do {
                    indices.push(edge.head().index);
                    edge = edge.next;
                  } while (edge !== this.edge);
                  return indices;
                }
              }], [{
                key: 'createTriangle',
                value: function createTriangle(v0, v1, v2) {
                  var minArea = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

                  var face = new Face();
                  var e0 = new _HalfEdge2.default(v0, face);
                  var e1 = new _HalfEdge2.default(v1, face);
                  var e2 = new _HalfEdge2.default(v2, face);

                  // join edges
                  e0.next = e2.prev = e1;
                  e1.next = e0.prev = e2;
                  e2.next = e1.prev = e0;

                  // main half edge reference
                  face.edge = e0;
                  face.computeNormalAndCentroid(minArea);
                  if (debug.enabled) {
                    debug('face created %j', face.collectIndices());
                  }
                  return face;
                }
              }]);

              return Face;
            }();

            exports.default = Face;
            });

            unwrapExports$1(Face_1);
            var Face_2 = Face_1.DELETED;
            var Face_3 = Face_1.NON_CONVEX;
            var Face_4 = Face_1.VISIBLE;

            var QuickHull_1 = createCommonjsModule$2(function (module, exports) {

            Object.defineProperty(exports, "__esModule", {
              value: true
            });

            var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



            var _pointLineDistance2 = _interopRequireDefault(pointLineDistance);



            var _getPlaneNormal2 = _interopRequireDefault(getPlaneNormal);



            var _dot2 = _interopRequireDefault(dot_1);



            var _VertexList2 = _interopRequireDefault(VertexList_1);



            var _Vertex2 = _interopRequireDefault(Vertex_1);



            var _Face2 = _interopRequireDefault(Face_1);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var debug = src('quickhull');

            // merge types
            // non convex with respect to the large face
            var MERGE_NON_CONVEX_WRT_LARGER_FACE = 1;
            var MERGE_NON_CONVEX = 2;

            var QuickHull = function () {
              function QuickHull(points) {
                _classCallCheck(this, QuickHull);

                if (!Array.isArray(points)) {
                  throw TypeError('input is not a valid array');
                }
                if (points.length < 4) {
                  throw Error('cannot build a simplex out of <4 points');
                }

                this.tolerance = -1;

                // buffers
                this.nFaces = 0;
                this.nPoints = points.length;

                this.faces = [];
                this.newFaces = [];
                // helpers
                //
                // let `a`, `b` be `Face` instances
                // let `v` be points wrapped as instance of `Vertex`
                //
                //     [v, v, ..., v, v, v, ...]
                //      ^             ^
                //      |             |
                //  a.outside     b.outside
                //
                this.claimed = new _VertexList2.default();
                this.unclaimed = new _VertexList2.default();

                // vertices of the hull(internal representation of points)
                this.vertices = [];
                for (var i = 0; i < points.length; i += 1) {
                  this.vertices.push(new _Vertex2.default(points[i], i));
                }
                this.discardedFaces = [];
                this.vertexPointIndices = [];
              }

              _createClass(QuickHull, [{
                key: 'addVertexToFace',
                value: function addVertexToFace(vertex, face) {
                  vertex.face = face;
                  if (!face.outside) {
                    this.claimed.add(vertex);
                  } else {
                    this.claimed.insertBefore(face.outside, vertex);
                  }
                  face.outside = vertex;
                }

                /**
                 * Removes `vertex` for the `claimed` list of vertices, it also makes sure
                 * that the link from `face` to the first vertex it sees in `claimed` is
                 * linked correctly after the removal
                 *
                 * @param {Vertex} vertex
                 * @param {Face} face
                 */

              }, {
                key: 'removeVertexFromFace',
                value: function removeVertexFromFace(vertex, face) {
                  if (vertex === face.outside) {
                    // fix face.outside link
                    if (vertex.next && vertex.next.face === face) {
                      // face has at least 2 outside vertices, move the `outside` reference
                      face.outside = vertex.next;
                    } else {
                      // vertex was the only outside vertex that face had
                      face.outside = null;
                    }
                  }
                  this.claimed.remove(vertex);
                }

                /**
                 * Removes all the visible vertices that `face` is able to see which are
                 * stored in the `claimed` vertext list
                 *
                 * @param {Face} face
                 * @return {Vertex|undefined} If face had visible vertices returns
                 * `face.outside`, otherwise undefined
                 */

              }, {
                key: 'removeAllVerticesFromFace',
                value: function removeAllVerticesFromFace(face) {
                  if (face.outside) {
                    // pointer to the last vertex of this face
                    // [..., outside, ..., end, outside, ...]
                    //          |           |      |
                    //          a           a      b
                    var end = face.outside;
                    while (end.next && end.next.face === face) {
                      end = end.next;
                    }
                    this.claimed.removeChain(face.outside, end);
                    //                            b
                    //                       [ outside, ...]
                    //                            |  removes this link
                    //     [ outside, ..., end ] -┘
                    //          |           |
                    //          a           a
                    end.next = null;
                    return face.outside;
                  }
                }

                /**
                 * Removes all the visible vertices that `face` is able to see, additionally
                 * checking the following:
                 *
                 * If `absorbingFace` doesn't exist then all the removed vertices will be
                 * added to the `unclaimed` vertex list
                 *
                 * If `absorbingFace` exists then this method will assign all the vertices of
                 * `face` that can see `absorbingFace`, if a vertex cannot see `absorbingFace`
                 * it's added to the `unclaimed` vertex list
                 *
                 * @param {Face} face
                 * @param {Face} [absorbingFace]
                 */

              }, {
                key: 'deleteFaceVertices',
                value: function deleteFaceVertices(face, absorbingFace) {
                  var faceVertices = this.removeAllVerticesFromFace(face);
                  if (faceVertices) {
                    if (!absorbingFace) {
                      // mark the vertices to be reassigned to some other face
                      this.unclaimed.addAll(faceVertices);
                    } else {
                      // if there's an absorbing face try to assign as many vertices
                      // as possible to it

                      // the reference `vertex.next` might be destroyed on
                      // `this.addVertexToFace` (see VertexList#add), nextVertex is a
                      // reference to it
                      var nextVertex = void 0;
                      for (var vertex = faceVertices; vertex; vertex = nextVertex) {
                        nextVertex = vertex.next;
                        var distance = absorbingFace.distanceToPlane(vertex.point);

                        // check if `vertex` is able to see `absorbingFace`
                        if (distance > this.tolerance) {
                          this.addVertexToFace(vertex, absorbingFace);
                        } else {
                          this.unclaimed.add(vertex);
                        }
                      }
                    }
                  }
                }

                /**
                 * Reassigns as many vertices as possible from the unclaimed list to the new
                 * faces
                 *
                 * @param {Faces[]} newFaces
                 */

              }, {
                key: 'resolveUnclaimedPoints',
                value: function resolveUnclaimedPoints(newFaces) {
                  // cache next vertex so that if `vertex.next` is destroyed it's still
                  // recoverable
                  var vertexNext = this.unclaimed.first();
                  for (var vertex = vertexNext; vertex; vertex = vertexNext) {
                    vertexNext = vertex.next;
                    var maxDistance = this.tolerance;
                    var maxFace = void 0;
                    for (var i = 0; i < newFaces.length; i += 1) {
                      var face = newFaces[i];
                      if (face.mark === Face_1.VISIBLE) {
                        var dist = face.distanceToPlane(vertex.point);
                        if (dist > maxDistance) {
                          maxDistance = dist;
                          maxFace = face;
                        }
                        if (maxDistance > 1000 * this.tolerance) {
                          break;
                        }
                      }
                    }

                    if (maxFace) {
                      this.addVertexToFace(vertex, maxFace);
                    }
                  }
                }

                /**
                 * Computes the extremes of a tetrahedron which will be the initial hull
                 *
                 * @return {number[]} The min/max vertices in the x,y,z directions
                 */

              }, {
                key: 'computeExtremes',
                value: function computeExtremes() {
                  var me = this;
                  var min = [];
                  var max = [];

                  // min vertex on the x,y,z directions
                  var minVertices = [];
                  // max vertex on the x,y,z directions
                  var maxVertices = [];

                  var i = void 0,
                      j = void 0;

                  // initially assume that the first vertex is the min/max
                  for (i = 0; i < 3; i += 1) {
                    minVertices[i] = maxVertices[i] = this.vertices[0];
                  }
                  // copy the coordinates of the first vertex to min/max
                  for (i = 0; i < 3; i += 1) {
                    min[i] = max[i] = this.vertices[0].point[i];
                  }

                  // compute the min/max vertex on all 6 directions
                  for (i = 1; i < this.vertices.length; i += 1) {
                    var vertex = this.vertices[i];
                    var point = vertex.point;
                    // update the min coordinates
                    for (j = 0; j < 3; j += 1) {
                      if (point[j] < min[j]) {
                        min[j] = point[j];
                        minVertices[j] = vertex;
                      }
                    }
                    // update the max coordinates
                    for (j = 0; j < 3; j += 1) {
                      if (point[j] > max[j]) {
                        max[j] = point[j];
                        maxVertices[j] = vertex;
                      }
                    }
                  }

                  // compute epsilon
                  this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min[0]), Math.abs(max[0])) + Math.max(Math.abs(min[1]), Math.abs(max[1])) + Math.max(Math.abs(min[2]), Math.abs(max[2])));
                  if (debug.enabled) {
                    debug('tolerance %d', me.tolerance);
                  }
                  return [minVertices, maxVertices];
                }

                /**
                 * Compues the initial tetrahedron assigning to its faces all the points that
                 * are candidates to form part of the hull
                 */

              }, {
                key: 'createInitialSimplex',
                value: function createInitialSimplex() {
                  var vertices = this.vertices;

                  var _computeExtremes = this.computeExtremes(),
                      _computeExtremes2 = _slicedToArray(_computeExtremes, 2),
                      min = _computeExtremes2[0],
                      max = _computeExtremes2[1];

                  var v0 = void 0,
                      v1 = void 0,
                      v2 = void 0,
                      v3 = void 0;
                  var i = void 0,
                      j = void 0;

                  // Find the two vertices with the greatest 1d separation
                  // (max.x - min.x)
                  // (max.y - min.y)
                  // (max.z - min.z)
                  var maxDistance = 0;
                  var indexMax = 0;
                  for (i = 0; i < 3; i += 1) {
                    var distance = max[i].point[i] - min[i].point[i];
                    if (distance > maxDistance) {
                      maxDistance = distance;
                      indexMax = i;
                    }
                  }
                  v0 = min[indexMax];
                  v1 = max[indexMax];

                  // the next vertex is the one farthest to the line formed by `v0` and `v1`
                  maxDistance = 0;
                  for (i = 0; i < this.vertices.length; i += 1) {
                    var vertex = this.vertices[i];
                    if (vertex !== v0 && vertex !== v1) {
                      var _distance = (0, _pointLineDistance2.default)(vertex.point, v0.point, v1.point);
                      if (_distance > maxDistance) {
                        maxDistance = _distance;
                        v2 = vertex;
                      }
                    }
                  }

                  // the next vertes is the one farthest to the plane `v0`, `v1`, `v2`
                  // normalize((v2 - v1) x (v0 - v1))
                  var normal = (0, _getPlaneNormal2.default)([], v0.point, v1.point, v2.point);
                  // distance from the origin to the plane
                  var distPO = (0, _dot2.default)(v0.point, normal);
                  maxDistance = -1;
                  for (i = 0; i < this.vertices.length; i += 1) {
                    var _vertex = this.vertices[i];
                    if (_vertex !== v0 && _vertex !== v1 && _vertex !== v2) {
                      var _distance2 = Math.abs((0, _dot2.default)(normal, _vertex.point) - distPO);
                      if (_distance2 > maxDistance) {
                        maxDistance = _distance2;
                        v3 = _vertex;
                      }
                    }
                  }

                  // initial simplex
                  // Taken from http://everything2.com/title/How+to+paint+a+tetrahedron
                  //
                  //                              v2
                  //                             ,|,
                  //                           ,7``\'VA,
                  //                         ,7`   |, `'VA,
                  //                       ,7`     `\    `'VA,
                  //                     ,7`        |,      `'VA,
                  //                   ,7`          `\         `'VA,
                  //                 ,7`             |,           `'VA,
                  //               ,7`               `\       ,..ooOOTK` v3
                  //             ,7`                  |,.ooOOT''`    AV
                  //           ,7`            ,..ooOOT`\`           /7
                  //         ,7`      ,..ooOOT''`      |,          AV
                  //        ,T,..ooOOT''`              `\         /7
                  //     v0 `'TTs.,                     |,       AV
                  //            `'TTs.,                 `\      /7
                  //                 `'TTs.,             |,    AV
                  //                      `'TTs.,        `\   /7
                  //                           `'TTs.,    |, AV
                  //                                `'TTs.,\/7
                  //                                     `'T`
                  //                                       v1
                  //
                  var faces = [];
                  if ((0, _dot2.default)(v3.point, normal) - distPO < 0) {
                    // the face is not able to see the point so `planeNormal`
                    // is pointing outside the tetrahedron
                    faces.push(_Face2.default.createTriangle(v0, v1, v2), _Face2.default.createTriangle(v3, v1, v0), _Face2.default.createTriangle(v3, v2, v1), _Face2.default.createTriangle(v3, v0, v2));

                    // set the opposite edge
                    for (i = 0; i < 3; i += 1) {
                      var _j = (i + 1) % 3;
                      // join face[i] i > 0, with the first face
                      faces[i + 1].getEdge(2).setOpposite(faces[0].getEdge(_j));
                      // join face[i] with face[i + 1], 1 <= i <= 3
                      faces[i + 1].getEdge(1).setOpposite(faces[_j + 1].getEdge(0));
                    }
                  } else {
                    // the face is able to see the point so `planeNormal`
                    // is pointing inside the tetrahedron
                    faces.push(_Face2.default.createTriangle(v0, v2, v1), _Face2.default.createTriangle(v3, v0, v1), _Face2.default.createTriangle(v3, v1, v2), _Face2.default.createTriangle(v3, v2, v0));

                    // set the opposite edge
                    for (i = 0; i < 3; i += 1) {
                      var _j2 = (i + 1) % 3;
                      // join face[i] i > 0, with the first face
                      faces[i + 1].getEdge(2).setOpposite(faces[0].getEdge((3 - i) % 3));
                      // join face[i] with face[i + 1]
                      faces[i + 1].getEdge(0).setOpposite(faces[_j2 + 1].getEdge(1));
                    }
                  }

                  // the initial hull is the tetrahedron
                  for (i = 0; i < 4; i += 1) {
                    this.faces.push(faces[i]);
                  }

                  // initial assignment of vertices to the faces of the tetrahedron
                  for (i = 0; i < vertices.length; i += 1) {
                    var _vertex2 = vertices[i];
                    if (_vertex2 !== v0 && _vertex2 !== v1 && _vertex2 !== v2 && _vertex2 !== v3) {
                      maxDistance = this.tolerance;
                      var maxFace = void 0;
                      for (j = 0; j < 4; j += 1) {
                        var _distance3 = faces[j].distanceToPlane(_vertex2.point);
                        if (_distance3 > maxDistance) {
                          maxDistance = _distance3;
                          maxFace = faces[j];
                        }
                      }

                      if (maxFace) {
                        this.addVertexToFace(_vertex2, maxFace);
                      }
                    }
                  }
                }
              }, {
                key: 'reindexFaceAndVertices',
                value: function reindexFaceAndVertices() {
                  // remove inactive faces
                  var activeFaces = [];
                  for (var i = 0; i < this.faces.length; i += 1) {
                    var face = this.faces[i];
                    if (face.mark === Face_1.VISIBLE) {
                      activeFaces.push(face);
                    }
                  }
                  this.faces = activeFaces;
                }
              }, {
                key: 'collectFaces',
                value: function collectFaces(skipTriangulation) {
                  var faceIndices = [];
                  for (var i = 0; i < this.faces.length; i += 1) {
                    if (this.faces[i].mark !== Face_1.VISIBLE) {
                      throw Error('attempt to include a destroyed face in the hull');
                    }
                    var indices = this.faces[i].collectIndices();
                    if (skipTriangulation) {
                      faceIndices.push(indices);
                    } else {
                      for (var j = 0; j < indices.length - 2; j += 1) {
                        faceIndices.push([indices[0], indices[j + 1], indices[j + 2]]);
                      }
                    }
                  }
                  return faceIndices;
                }

                /**
                 * Finds the next vertex to make faces with the current hull
                 *
                 * - let `face` be the first face existing in the `claimed` vertex list
                 *  - if `face` doesn't exist then return since there're no vertices left
                 *  - otherwise for each `vertex` that face sees find the one furthest away
                 *  from `face`
                 *
                 * @return {Vertex|undefined} Returns undefined when there're no more
                 * visible vertices
                 */

              }, {
                key: 'nextVertexToAdd',
                value: function nextVertexToAdd() {
                  if (!this.claimed.isEmpty()) {
                    var eyeVertex = void 0,
                        vertex = void 0;
                    var maxDistance = 0;
                    var eyeFace = this.claimed.first().face;
                    for (vertex = eyeFace.outside; vertex && vertex.face === eyeFace; vertex = vertex.next) {
                      var distance = eyeFace.distanceToPlane(vertex.point);
                      if (distance > maxDistance) {
                        maxDistance = distance;
                        eyeVertex = vertex;
                      }
                    }
                    return eyeVertex;
                  }
                }

                /**
                 * Computes a chain of half edges in ccw order called the `horizon`, for an
                 * edge to be part of the horizon it must join a face that can see
                 * `eyePoint` and a face that cannot see `eyePoint`
                 *
                 * @param {number[]} eyePoint - The coordinates of a point
                 * @param {HalfEdge} crossEdge - The edge used to jump to the current `face`
                 * @param {Face} face - The current face being tested
                 * @param {HalfEdge[]} horizon - The edges that form part of the horizon in
                 * ccw order
                 */

              }, {
                key: 'computeHorizon',
                value: function computeHorizon(eyePoint, crossEdge, face, horizon) {
                  // moves face's vertices to the `unclaimed` vertex list
                  this.deleteFaceVertices(face);

                  face.mark = Face_1.DELETED;

                  var edge = void 0;
                  if (!crossEdge) {
                    edge = crossEdge = face.getEdge(0);
                  } else {
                    // start from the next edge since `crossEdge` was already analyzed
                    // (actually `crossEdge.opposite` was the face who called this method
                    // recursively)
                    edge = crossEdge.next;
                  }

                  // All the faces that are able to see `eyeVertex` are defined as follows
                  //
                  //       v    /
                  //           / <== visible face
                  //          /
                  //         |
                  //         | <== not visible face
                  //
                  //  dot(v, visible face normal) - visible face offset > this.tolerance
                  //
                  do {
                    var oppositeEdge = edge.opposite;
                    var oppositeFace = oppositeEdge.face;
                    if (oppositeFace.mark === Face_1.VISIBLE) {
                      if (oppositeFace.distanceToPlane(eyePoint) > this.tolerance) {
                        this.computeHorizon(eyePoint, oppositeEdge, oppositeFace, horizon);
                      } else {
                        horizon.push(edge);
                      }
                    }
                    edge = edge.next;
                  } while (edge !== crossEdge);
                }

                /**
                 * Creates a face with the points `eyeVertex.point`, `horizonEdge.tail` and
                 * `horizonEdge.tail` in ccw order
                 *
                 * @param {Vertex} eyeVertex
                 * @param {HalfEdge} horizonEdge
                 * @return {HalfEdge} The half edge whose vertex is the eyeVertex
                 */

              }, {
                key: 'addAdjoiningFace',
                value: function addAdjoiningFace(eyeVertex, horizonEdge) {
                  // all the half edges are created in ccw order thus the face is always
                  // pointing outside the hull
                  // edges:
                  //
                  //                  eyeVertex.point
                  //                       / \
                  //                      /   \
                  //                  1  /     \  0
                  //                    /       \
                  //                   /         \
                  //                  /           \
                  //          horizon.tail --- horizon.head
                  //                        2
                  //
                  var face = _Face2.default.createTriangle(eyeVertex, horizonEdge.tail(), horizonEdge.head());
                  this.faces.push(face);
                  // join face.getEdge(-1) with the horizon's opposite edge
                  // face.getEdge(-1) = face.getEdge(2)
                  face.getEdge(-1).setOpposite(horizonEdge.opposite);
                  return face.getEdge(0);
                }

                /**
                 * Adds horizon.length faces to the hull, each face will be 'linked' with the
                 * horizon opposite face and the face on the left/right
                 *
                 * @param {Vertex} eyeVertex
                 * @param {HalfEdge[]} horizon - A chain of half edges in ccw order
                 */

              }, {
                key: 'addNewFaces',
                value: function addNewFaces(eyeVertex, horizon) {
                  this.newFaces = [];
                  var firstSideEdge = void 0,
                      previousSideEdge = void 0;
                  for (var i = 0; i < horizon.length; i += 1) {
                    var horizonEdge = horizon[i];
                    // returns the right side edge
                    var sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);
                    if (!firstSideEdge) {
                      firstSideEdge = sideEdge;
                    } else {
                      // joins face.getEdge(1) with previousFace.getEdge(0)
                      sideEdge.next.setOpposite(previousSideEdge);
                    }
                    this.newFaces.push(sideEdge.face);
                    previousSideEdge = sideEdge;
                  }
                  firstSideEdge.next.setOpposite(previousSideEdge);
                }

                /**
                 * Computes the distance from `edge` opposite face's centroid to
                 * `edge.face`
                 *
                 * @param {HalfEdge} edge
                 * @return {number}
                 * - A positive number when the centroid of the opposite face is above the
                 *   face i.e. when the faces are concave
                 * - A negative number when the centroid of the opposite face is below the
                 *   face i.e. when the faces are convex
                 */

              }, {
                key: 'oppositeFaceDistance',
                value: function oppositeFaceDistance(edge) {
                  return edge.face.distanceToPlane(edge.opposite.face.centroid);
                }

                /**
                 * Merges a face with none/any/all its neighbors according to the strategy
                 * used
                 *
                 * if `mergeType` is MERGE_NON_CONVEX_WRT_LARGER_FACE then the merge will be
                 * decided based on the face with the larger area, the centroid of the face
                 * with the smaller area will be checked against the one with the larger area
                 * to see if it's in the merge range [tolerance, -tolerance] i.e.
                 *
                 *    dot(centroid smaller face, larger face normal) - larger face offset > -tolerance
                 *
                 * Note that the first check (with +tolerance) was done on `computeHorizon`
                 *
                 * If the above is not true then the check is done with respect to the smaller
                 * face i.e.
                 *
                 *    dot(centroid larger face, smaller face normal) - smaller face offset > -tolerance
                 *
                 * If true then it means that two faces are non convex (concave), even if the
                 * dot(...) - offset value is > 0 (that's the point of doing the merge in the
                 * first place)
                 *
                 * If two faces are concave then the check must also be done on the other face
                 * but this is done in another merge pass, for this to happen the face is
                 * marked in a temporal NON_CONVEX state
                 *
                 * if `mergeType` is MERGE_NON_CONVEX then two faces will be merged only if
                 * they pass the following conditions
                 *
                 *    dot(centroid smaller face, larger face normal) - larger face offset > -tolerance
                 *    dot(centroid larger face, smaller face normal) - smaller face offset > -tolerance
                 *
                 * @param {Face} face
                 * @param {number} mergeType - Either MERGE_NON_CONVEX_WRT_LARGER_FACE or
                 * MERGE_NON_CONVEX
                 */

              }, {
                key: 'doAdjacentMerge',
                value: function doAdjacentMerge(face, mergeType) {
                  var edge = face.edge;
                  var convex = true;
                  var it = 0;
                  do {
                    if (it >= face.nVertices) {
                      throw Error('merge recursion limit exceeded');
                    }
                    var oppositeFace = edge.opposite.face;
                    var merge = false;

                    // Important notes about the algorithm to merge faces
                    //
                    // - Given a vertex `eyeVertex` that will be added to the hull
                    //   all the faces that cannot see `eyeVertex` are defined as follows
                    //
                    //      dot(v, not visible face normal) - not visible offset < tolerance
                    //
                    // - Two faces can be merged when the centroid of one of these faces
                    // projected to the normal of the other face minus the other face offset
                    // is in the range [tolerance, -tolerance]
                    // - Since `face` (given in the input for this method) has passed the
                    // check above we only have to check the lower bound e.g.
                    //
                    //      dot(v, not visible face normal) - not visible offset > -tolerance
                    //
                    if (mergeType === MERGE_NON_CONVEX) {
                      if (this.oppositeFaceDistance(edge) > -this.tolerance || this.oppositeFaceDistance(edge.opposite) > -this.tolerance) {
                        merge = true;
                      }
                    } else {
                      if (face.area > oppositeFace.area) {
                        if (this.oppositeFaceDistance(edge) > -this.tolerance) {
                          merge = true;
                        } else if (this.oppositeFaceDistance(edge.opposite) > -this.tolerance) {
                          convex = false;
                        }
                      } else {
                        if (this.oppositeFaceDistance(edge.opposite) > -this.tolerance) {
                          merge = true;
                        } else if (this.oppositeFaceDistance(edge) > -this.tolerance) {
                          convex = false;
                        }
                      }
                    }

                    if (merge) {
                      debug('face merge');
                      // when two faces are merged it might be possible that redundant faces
                      // are destroyed, in that case move all the visible vertices from the
                      // destroyed faces to the `unclaimed` vertex list
                      var discardedFaces = face.mergeAdjacentFaces(edge, []);
                      for (var i = 0; i < discardedFaces.length; i += 1) {
                        this.deleteFaceVertices(discardedFaces[i], face);
                      }
                      return true;
                    }

                    edge = edge.next;
                    it += 1;
                  } while (edge !== face.edge);
                  if (!convex) {
                    face.mark = Face_1.NON_CONVEX;
                  }
                  return false;
                }

                /**
                 * Adds a vertex to the hull with the following algorithm
                 *
                 * - Compute the `horizon` which is a chain of half edges, for an edge to
                 *   belong to this group it must be the edge connecting a face that can
                 *   see `eyeVertex` and a face which cannot see `eyeVertex`
                 * - All the faces that can see `eyeVertex` have its visible vertices removed
                 *   from the claimed VertexList
                 * - A new set of faces is created with each edge of the `horizon` and
                 *   `eyeVertex`, each face is connected with the opposite horizon face and
                 *   the face on the left/right
                 * - The new faces are merged if possible with the opposite horizon face first
                 *   and then the faces on the right/left
                 * - The vertices removed from all the visible faces are assigned to the new
                 *   faces if possible
                 *
                 * @param {Vertex} eyeVertex
                 */

              }, {
                key: 'addVertexToHull',
                value: function addVertexToHull(eyeVertex) {
                  var horizon = [];

                  this.unclaimed.clear();

                  // remove `eyeVertex` from `eyeVertex.face` so that it can't be added to the
                  // `unclaimed` vertex list
                  this.removeVertexFromFace(eyeVertex, eyeVertex.face);
                  this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);
                  if (debug.enabled) {
                    debug('horizon %j', horizon.map(function (edge) {
                      return edge.head().index;
                    }));
                  }
                  this.addNewFaces(eyeVertex, horizon);

                  debug('first merge');

                  // first merge pass
                  // Do the merge with respect to the larger face
                  for (var i = 0; i < this.newFaces.length; i += 1) {
                    var face = this.newFaces[i];
                    if (face.mark === Face_1.VISIBLE) {
                      while (this.doAdjacentMerge(face, MERGE_NON_CONVEX_WRT_LARGER_FACE)) {}
                    }
                  }

                  debug('second merge');

                  // second merge pass
                  // Do the merge on non convex faces (a face is marked as non convex in the
                  // first pass)
                  for (var _i = 0; _i < this.newFaces.length; _i += 1) {
                    var _face = this.newFaces[_i];
                    if (_face.mark === Face_1.NON_CONVEX) {
                      _face.mark = Face_1.VISIBLE;
                      while (this.doAdjacentMerge(_face, MERGE_NON_CONVEX)) {}
                    }
                  }

                  debug('reassigning points to newFaces');
                  // reassign `unclaimed` vertices to the new faces
                  this.resolveUnclaimedPoints(this.newFaces);
                }
              }, {
                key: 'build',
                value: function build() {
                  var iterations = 0;
                  var eyeVertex = void 0;
                  this.createInitialSimplex();
                  while (eyeVertex = this.nextVertexToAdd()) {
                    iterations += 1;
                    debug('== iteration %j ==', iterations);
                    debug('next vertex to add = %d %j', eyeVertex.index, eyeVertex.point);
                    this.addVertexToHull(eyeVertex);
                    debug('end');
                  }
                  this.reindexFaceAndVertices();
                }
              }]);

              return QuickHull;
            }();

            exports.default = QuickHull;
            module.exports = exports['default'];
            });

            unwrapExports$1(QuickHull_1);

            var dist = createCommonjsModule$2(function (module, exports) {

            Object.defineProperty(exports, "__esModule", {
              value: true
            });
            exports.default = runner;



            var _QuickHull2 = _interopRequireDefault(QuickHull_1);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function runner(points) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

              var instance = new _QuickHull2.default(points);
              instance.build();
              return instance.collectFaces(options.skipTriangulation);
            }
            module.exports = exports['default'];
            });

            var QuickHull = unwrapExports$1(dist);

            /** @type function(Points):Solid */
            const buildConvexHullImpl = (points) => {
              const faces = QuickHull(points, { skipTriangulation: false });
              const polygons = faces.map((polygon) =>
                polygon.map((nthPoint) => points[nthPoint])
              );
              polygons.isConvex = true;
              return fromPolygons(polygons);
            };

            /**
             * Constructs a convex hull from the points given.
             * @type function(Points):Solid
             */
            const buildConvexHull = cache(buildConvexHullImpl);

            const buildConvexMinkowskiSumImpl = (aPoints, bPoints) => {
              const summedPoints = [];
              for (const aPoint of aPoints) {
                for (const summedPoint of translate$3(aPoint, bPoints)) {
                  summedPoints.push(summedPoint);
                }
              }
              return buildConvexHull(summedPoints);
            };

            const buildConvexMinkowskiSum = cache(buildConvexMinkowskiSumImpl);

            var twoProduct_1 = twoProduct;

            var SPLITTER = +(Math.pow(2, 27) + 1.0);

            function twoProduct(a, b, result) {
              var x = a * b;

              var c = SPLITTER * a;
              var abig = c - a;
              var ahi = c - abig;
              var alo = a - ahi;

              var d = SPLITTER * b;
              var bbig = d - b;
              var bhi = d - bbig;
              var blo = b - bhi;

              var err1 = x - (ahi * bhi);
              var err2 = err1 - (alo * bhi);
              var err3 = err2 - (ahi * blo);

              var y = alo * blo - err3;

              if(result) {
                result[0] = y;
                result[1] = x;
                return result
              }

              return [ y, x ]
            }

            var robustSum = linearExpansionSum;

            //Easy case: Add two scalars
            function scalarScalar(a, b) {
              var x = a + b;
              var bv = x - a;
              var av = x - bv;
              var br = b - bv;
              var ar = a - av;
              var y = ar + br;
              if(y) {
                return [y, x]
              }
              return [x]
            }

            function linearExpansionSum(e, f) {
              var ne = e.length|0;
              var nf = f.length|0;
              if(ne === 1 && nf === 1) {
                return scalarScalar(e[0], f[0])
              }
              var n = ne + nf;
              var g = new Array(n);
              var count = 0;
              var eptr = 0;
              var fptr = 0;
              var abs = Math.abs;
              var ei = e[eptr];
              var ea = abs(ei);
              var fi = f[fptr];
              var fa = abs(fi);
              var a, b;
              if(ea < fa) {
                b = ei;
                eptr += 1;
                if(eptr < ne) {
                  ei = e[eptr];
                  ea = abs(ei);
                }
              } else {
                b = fi;
                fptr += 1;
                if(fptr < nf) {
                  fi = f[fptr];
                  fa = abs(fi);
                }
              }
              if((eptr < ne && ea < fa) || (fptr >= nf)) {
                a = ei;
                eptr += 1;
                if(eptr < ne) {
                  ei = e[eptr];
                  ea = abs(ei);
                }
              } else {
                a = fi;
                fptr += 1;
                if(fptr < nf) {
                  fi = f[fptr];
                  fa = abs(fi);
                }
              }
              var x = a + b;
              var bv = x - a;
              var y = b - bv;
              var q0 = y;
              var q1 = x;
              var _x, _bv, _av, _br, _ar;
              while(eptr < ne && fptr < nf) {
                if(ea < fa) {
                  a = ei;
                  eptr += 1;
                  if(eptr < ne) {
                    ei = e[eptr];
                    ea = abs(ei);
                  }
                } else {
                  a = fi;
                  fptr += 1;
                  if(fptr < nf) {
                    fi = f[fptr];
                    fa = abs(fi);
                  }
                }
                b = q0;
                x = a + b;
                bv = x - a;
                y = b - bv;
                if(y) {
                  g[count++] = y;
                }
                _x = q1 + x;
                _bv = _x - q1;
                _av = _x - _bv;
                _br = x - _bv;
                _ar = q1 - _av;
                q0 = _ar + _br;
                q1 = _x;
              }
              while(eptr < ne) {
                a = ei;
                b = q0;
                x = a + b;
                bv = x - a;
                y = b - bv;
                if(y) {
                  g[count++] = y;
                }
                _x = q1 + x;
                _bv = _x - q1;
                _av = _x - _bv;
                _br = x - _bv;
                _ar = q1 - _av;
                q0 = _ar + _br;
                q1 = _x;
                eptr += 1;
                if(eptr < ne) {
                  ei = e[eptr];
                }
              }
              while(fptr < nf) {
                a = fi;
                b = q0;
                x = a + b;
                bv = x - a;
                y = b - bv;
                if(y) {
                  g[count++] = y;
                } 
                _x = q1 + x;
                _bv = _x - q1;
                _av = _x - _bv;
                _br = x - _bv;
                _ar = q1 - _av;
                q0 = _ar + _br;
                q1 = _x;
                fptr += 1;
                if(fptr < nf) {
                  fi = f[fptr];
                }
              }
              if(q0) {
                g[count++] = q0;
              }
              if(q1) {
                g[count++] = q1;
              }
              if(!count) {
                g[count++] = 0.0;  
              }
              g.length = count;
              return g
            }

            var twoSum = fastTwoSum;

            function fastTwoSum(a, b, result) {
            	var x = a + b;
            	var bv = x - a;
            	var av = x - bv;
            	var br = b - bv;
            	var ar = a - av;
            	if(result) {
            		result[0] = ar + br;
            		result[1] = x;
            		return result
            	}
            	return [ar+br, x]
            }

            var robustScale = scaleLinearExpansion;

            function scaleLinearExpansion(e, scale) {
              var n = e.length;
              if(n === 1) {
                var ts = twoProduct_1(e[0], scale);
                if(ts[0]) {
                  return ts
                }
                return [ ts[1] ]
              }
              var g = new Array(2 * n);
              var q = [0.1, 0.1];
              var t = [0.1, 0.1];
              var count = 0;
              twoProduct_1(e[0], scale, q);
              if(q[0]) {
                g[count++] = q[0];
              }
              for(var i=1; i<n; ++i) {
                twoProduct_1(e[i], scale, t);
                var pq = q[1];
                twoSum(pq, t[0], q);
                if(q[0]) {
                  g[count++] = q[0];
                }
                var a = t[1];
                var b = q[1];
                var x = a + b;
                var bv = x - a;
                var y = b - bv;
                q[1] = x;
                if(y) {
                  g[count++] = y;
                }
              }
              if(q[1]) {
                g[count++] = q[1];
              }
              if(count === 0) {
                g[count++] = 0.0;
              }
              g.length = count;
              return g
            }

            var robustDiff = robustSubtract;

            //Easy case: Add two scalars
            function scalarScalar$1(a, b) {
              var x = a + b;
              var bv = x - a;
              var av = x - bv;
              var br = b - bv;
              var ar = a - av;
              var y = ar + br;
              if(y) {
                return [y, x]
              }
              return [x]
            }

            function robustSubtract(e, f) {
              var ne = e.length|0;
              var nf = f.length|0;
              if(ne === 1 && nf === 1) {
                return scalarScalar$1(e[0], -f[0])
              }
              var n = ne + nf;
              var g = new Array(n);
              var count = 0;
              var eptr = 0;
              var fptr = 0;
              var abs = Math.abs;
              var ei = e[eptr];
              var ea = abs(ei);
              var fi = -f[fptr];
              var fa = abs(fi);
              var a, b;
              if(ea < fa) {
                b = ei;
                eptr += 1;
                if(eptr < ne) {
                  ei = e[eptr];
                  ea = abs(ei);
                }
              } else {
                b = fi;
                fptr += 1;
                if(fptr < nf) {
                  fi = -f[fptr];
                  fa = abs(fi);
                }
              }
              if((eptr < ne && ea < fa) || (fptr >= nf)) {
                a = ei;
                eptr += 1;
                if(eptr < ne) {
                  ei = e[eptr];
                  ea = abs(ei);
                }
              } else {
                a = fi;
                fptr += 1;
                if(fptr < nf) {
                  fi = -f[fptr];
                  fa = abs(fi);
                }
              }
              var x = a + b;
              var bv = x - a;
              var y = b - bv;
              var q0 = y;
              var q1 = x;
              var _x, _bv, _av, _br, _ar;
              while(eptr < ne && fptr < nf) {
                if(ea < fa) {
                  a = ei;
                  eptr += 1;
                  if(eptr < ne) {
                    ei = e[eptr];
                    ea = abs(ei);
                  }
                } else {
                  a = fi;
                  fptr += 1;
                  if(fptr < nf) {
                    fi = -f[fptr];
                    fa = abs(fi);
                  }
                }
                b = q0;
                x = a + b;
                bv = x - a;
                y = b - bv;
                if(y) {
                  g[count++] = y;
                }
                _x = q1 + x;
                _bv = _x - q1;
                _av = _x - _bv;
                _br = x - _bv;
                _ar = q1 - _av;
                q0 = _ar + _br;
                q1 = _x;
              }
              while(eptr < ne) {
                a = ei;
                b = q0;
                x = a + b;
                bv = x - a;
                y = b - bv;
                if(y) {
                  g[count++] = y;
                }
                _x = q1 + x;
                _bv = _x - q1;
                _av = _x - _bv;
                _br = x - _bv;
                _ar = q1 - _av;
                q0 = _ar + _br;
                q1 = _x;
                eptr += 1;
                if(eptr < ne) {
                  ei = e[eptr];
                }
              }
              while(fptr < nf) {
                a = fi;
                b = q0;
                x = a + b;
                bv = x - a;
                y = b - bv;
                if(y) {
                  g[count++] = y;
                } 
                _x = q1 + x;
                _bv = _x - q1;
                _av = _x - _bv;
                _br = x - _bv;
                _ar = q1 - _av;
                q0 = _ar + _br;
                q1 = _x;
                fptr += 1;
                if(fptr < nf) {
                  fi = -f[fptr];
                }
              }
              if(q0) {
                g[count++] = q0;
              }
              if(q1) {
                g[count++] = q1;
              }
              if(!count) {
                g[count++] = 0.0;  
              }
              g.length = count;
              return g
            }

            var orientation_1 = createCommonjsModule$2(function (module) {






            var NUM_EXPAND = 5;

            var EPSILON     = 1.1102230246251565e-16;
            var ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON;
            var ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON;

            function cofactor(m, c) {
              var result = new Array(m.length-1);
              for(var i=1; i<m.length; ++i) {
                var r = result[i-1] = new Array(m.length-1);
                for(var j=0,k=0; j<m.length; ++j) {
                  if(j === c) {
                    continue
                  }
                  r[k++] = m[i][j];
                }
              }
              return result
            }

            function matrix(n) {
              var result = new Array(n);
              for(var i=0; i<n; ++i) {
                result[i] = new Array(n);
                for(var j=0; j<n; ++j) {
                  result[i][j] = ["m", j, "[", (n-i-1), "]"].join("");
                }
              }
              return result
            }

            function sign(n) {
              if(n & 1) {
                return "-"
              }
              return ""
            }

            function generateSum(expr) {
              if(expr.length === 1) {
                return expr[0]
              } else if(expr.length === 2) {
                return ["sum(", expr[0], ",", expr[1], ")"].join("")
              } else {
                var m = expr.length>>1;
                return ["sum(", generateSum(expr.slice(0, m)), ",", generateSum(expr.slice(m)), ")"].join("")
              }
            }

            function determinant(m) {
              if(m.length === 2) {
                return [["sum(prod(", m[0][0], ",", m[1][1], "),prod(-", m[0][1], ",", m[1][0], "))"].join("")]
              } else {
                var expr = [];
                for(var i=0; i<m.length; ++i) {
                  expr.push(["scale(", generateSum(determinant(cofactor(m, i))), ",", sign(i), m[0][i], ")"].join(""));
                }
                return expr
              }
            }

            function orientation(n) {
              var pos = [];
              var neg = [];
              var m = matrix(n);
              var args = [];
              for(var i=0; i<n; ++i) {
                if((i&1)===0) {
                  pos.push.apply(pos, determinant(cofactor(m, i)));
                } else {
                  neg.push.apply(neg, determinant(cofactor(m, i)));
                }
                args.push("m" + i);
              }
              var posExpr = generateSum(pos);
              var negExpr = generateSum(neg);
              var funcName = "orientation" + n + "Exact";
              var code = ["function ", funcName, "(", args.join(), "){var p=", posExpr, ",n=", negExpr, ",d=sub(p,n);\
return d[d.length-1];};return ", funcName].join("");
              var proc = new Function("sum", "prod", "scale", "sub", code);
              return proc(robustSum, twoProduct_1, robustScale, robustDiff)
            }

            var orientation3Exact = orientation(3);
            var orientation4Exact = orientation(4);

            var CACHED = [
              function orientation0() { return 0 },
              function orientation1() { return 0 },
              function orientation2(a, b) { 
                return b[0] - a[0]
              },
              function orientation3(a, b, c) {
                var l = (a[1] - c[1]) * (b[0] - c[0]);
                var r = (a[0] - c[0]) * (b[1] - c[1]);
                var det = l - r;
                var s;
                if(l > 0) {
                  if(r <= 0) {
                    return det
                  } else {
                    s = l + r;
                  }
                } else if(l < 0) {
                  if(r >= 0) {
                    return det
                  } else {
                    s = -(l + r);
                  }
                } else {
                  return det
                }
                var tol = ERRBOUND3 * s;
                if(det >= tol || det <= -tol) {
                  return det
                }
                return orientation3Exact(a, b, c)
              },
              function orientation4(a,b,c,d) {
                var adx = a[0] - d[0];
                var bdx = b[0] - d[0];
                var cdx = c[0] - d[0];
                var ady = a[1] - d[1];
                var bdy = b[1] - d[1];
                var cdy = c[1] - d[1];
                var adz = a[2] - d[2];
                var bdz = b[2] - d[2];
                var cdz = c[2] - d[2];
                var bdxcdy = bdx * cdy;
                var cdxbdy = cdx * bdy;
                var cdxady = cdx * ady;
                var adxcdy = adx * cdy;
                var adxbdy = adx * bdy;
                var bdxady = bdx * ady;
                var det = adz * (bdxcdy - cdxbdy) 
                        + bdz * (cdxady - adxcdy)
                        + cdz * (adxbdy - bdxady);
                var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)
                              + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)
                              + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz);
                var tol = ERRBOUND4 * permanent;
                if ((det > tol) || (-det > tol)) {
                  return det
                }
                return orientation4Exact(a,b,c,d)
              }
            ];

            function slowOrient(args) {
              var proc = CACHED[args.length];
              if(!proc) {
                proc = CACHED[args.length] = orientation(args.length);
              }
              return proc.apply(undefined, args)
            }

            function generateOrientationProc() {
              while(CACHED.length <= NUM_EXPAND) {
                CACHED.push(orientation(CACHED.length));
              }
              var args = [];
              var procArgs = ["slow"];
              for(var i=0; i<=NUM_EXPAND; ++i) {
                args.push("a" + i);
                procArgs.push("o" + i);
              }
              var code = [
                "function getOrientation(", args.join(), "){switch(arguments.length){case 0:case 1:return 0;"
              ];
              for(var i=2; i<=NUM_EXPAND; ++i) {
                code.push("case ", i, ":return o", i, "(", args.slice(0, i).join(), ");");
              }
              code.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation");
              procArgs.push(code.join(""));

              var proc = Function.apply(undefined, procArgs);
              module.exports = proc.apply(undefined, [slowOrient].concat(CACHED));
              for(var i=0; i<=NUM_EXPAND; ++i) {
                module.exports[i] = CACHED[i];
              }
            }

            generateOrientationProc();
            });

            var monotoneConvexHull2d = monotoneConvexHull2D;

            var orient = orientation_1[3];

            function monotoneConvexHull2D(points) {
              var n = points.length;

              if(n < 3) {
                var result = new Array(n);
                for(var i=0; i<n; ++i) {
                  result[i] = i;
                }

                if(n === 2 &&
                   points[0][0] === points[1][0] &&
                   points[0][1] === points[1][1]) {
                  return [0]
                }

                return result
              }

              //Sort point indices along x-axis
              var sorted = new Array(n);
              for(var i=0; i<n; ++i) {
                sorted[i] = i;
              }
              sorted.sort(function(a,b) {
                var d = points[a][0]-points[b][0];
                if(d) {
                  return d
                }
                return points[a][1] - points[b][1]
              });

              //Construct upper and lower hulls
              var lower = [sorted[0], sorted[1]];
              var upper = [sorted[0], sorted[1]];

              for(var i=2; i<n; ++i) {
                var idx = sorted[i];
                var p   = points[idx];

                //Insert into lower list
                var m = lower.length;
                while(m > 1 && orient(
                    points[lower[m-2]], 
                    points[lower[m-1]], 
                    p) <= 0) {
                  m -= 1;
                  lower.pop();
                }
                lower.push(idx);

                //Insert into upper list
                m = upper.length;
                while(m > 1 && orient(
                    points[upper[m-2]], 
                    points[upper[m-1]], 
                    p) >= 0) {
                  m -= 1;
                  upper.pop();
                }
                upper.push(idx);
              }

              //Merge lists together
              var result = new Array(upper.length + lower.length - 2);
              var ptr    = 0;
              for(var i=0, nl=lower.length; i<nl; ++i) {
                result[ptr++] = lower[i];
              }
              for(var j=upper.length-2; j>0; --j) {
                result[ptr++] = upper[j];
              }

              //Return result
              return result
            }

            const buildConvexSurfaceHullImpl = (points) => {
              const hull = [];
              for (const nth of monotoneConvexHull2d(points)) {
                hull.push(points[nth]);
              }
              return { type: 'z0Surface', z0Surface: makeConvex([hull.reverse()]) };
            };

            const buildConvexSurfaceHull = cache(buildConvexSurfaceHullImpl);

            const EPSILON$2 = 1e-5;

            const buildWalls = (polygons, floor, roof) => {
              for (
                let start = floor.length - 1, end = 0;
                end < floor.length;
                start = end++
              ) {
                // Remember that we are walking CCW.
                const a = deduplicate([floor[start], floor[end], roof[start]]);
                const b = deduplicate([floor[end], roof[end], roof[start]]);

                // Some of these polygons may become degenerate -- skip those.
                if (fromPolygon(a)) {
                  polygons.push(a);
                }

                if (fromPolygon(b)) {
                  polygons.push(b);
                }
              }
            };

            const buildPath = (op, latitude, resolution, context) => {
              const points = [];
              const step = 1 / resolution;
              for (let longitude = 0; longitude <= 1; longitude += step) {
                points.push(op(latitude, longitude, context));
              }
              return points;
            };

            // Build a tube from generated path slices.
            // The paths are assumed to connect in a 1:1 vertical relationship before deduplication.
            const buildFromFunctionImpl = (op, resolution, cap = true, context) => {
              const polygons = [];
              const step = 1 / resolution;
              let lastPath;
              for (let latitude = 0; latitude <= 1 + EPSILON$2; latitude += step) {
                const path = buildPath(op, latitude, resolution, context);
                if (lastPath !== undefined) {
                  buildWalls(polygons, path, lastPath);
                } else {
                  if (cap) {
                    const deduplicatedPath = deduplicate(path);
                    if (deduplicatedPath.length > 0) {
                      polygons.push(...makeConvex$1([deduplicatedPath]));
                    }
                  }
                }
                lastPath = path;
              }
              for (const polygon of polygons) {
                assertGood(polygon);
              }
              if (cap) {
                const deduplicatedPath = deduplicate(flip(lastPath));
                if (deduplicatedPath.length > 0) {
                  polygons.push(...makeConvex$1([deduplicatedPath]));
                }
              }
              const solid = { type: 'solid', solid: fromPolygons(polygons) };
              return solid;
            };

            const buildFromFunction = cache(buildFromFunctionImpl);

            const buildWalls$1 = (polygons, floor, roof) => {
              for (
                let start = floor.length - 1, end = 0;
                end < floor.length;
                start = end++
              ) {
                // Remember that we are walking CCW.
                const a = deduplicate([floor[start], floor[end], roof[start]]);
                const b = deduplicate([floor[end], roof[end], roof[start]]);

                // Some of these polygons may become degenerate -- skip those.
                if (fromPolygon(a)) {
                  polygons.push(a);
                }

                if (fromPolygon(b)) {
                  polygons.push(b);
                }
              }
            };

            // Build a tube from generated path slices.
            // The paths are assumed to connect in a 1:1 vertical relationship before deduplication.
            const buildFromSlices = (buildPath, resolution, cap = true) => {
              const polygons = [];
              const step = 1 / resolution;
              let lastPath;
              for (let t = 0; t <= 1; t += step) {
                const path = buildPath(t);
                if (lastPath !== undefined) {
                  buildWalls$1(polygons, path, lastPath);
                } else {
                  if (cap) {
                    const deduplicatedPath = deduplicate(path);
                    if (deduplicatedPath.length > 0) {
                      polygons.push(...makeConvex$1([deduplicatedPath]));
                    }
                  }
                }
                lastPath = path;
              }
              for (const polygon of polygons) {
                assertGood(polygon);
              }
              if (cap) {
                const deduplicatedPath = deduplicate(lastPath);
                if (deduplicatedPath.length > 0) {
                  polygons.push(...flip$4(makeConvex$1([deduplicatedPath])));
                }
              }

              return {
                type: 'solid',
                solid: fromPolygons(flip$4(polygons)),
              };
            };

            /** @type {function(Point[], Path[]):Triangle[]} */
            const fromPointsAndPaths = (points = [], paths = []) => {
              /** @type {Polygon[]} */
              const polygons = [];
              for (const path of paths) {
                polygons.push(fromPoints$1(path.map((nth) => points[nth])));
              }
              return polygons;
            };

            // Unit icosahedron vertices.
            /** @type {Point[]} */
            const points = [
              [0.850651, 0.0, -0.525731],
              [0.850651, -0.0, 0.525731],
              [-0.850651, -0.0, 0.525731],
              [-0.850651, 0.0, -0.525731],
              [0.0, -0.525731, 0.850651],
              [0.0, 0.525731, 0.850651],
              [0.0, 0.525731, -0.850651],
              [0.0, -0.525731, -0.850651],
              [-0.525731, -0.850651, -0.0],
              [0.525731, -0.850651, -0.0],
              [0.525731, 0.850651, 0.0],
              [-0.525731, 0.850651, 0.0],
            ];

            // Triangular decomposition structure.
            /** @type {Path[]} */
            const paths = [
              [1, 9, 0],
              [0, 10, 1],
              [0, 7, 6],
              [0, 6, 10],
              [0, 9, 7],
              [4, 1, 5],
              [9, 1, 4],
              [1, 10, 5],
              [3, 8, 2],
              [2, 11, 3],
              [4, 5, 2],
              [2, 8, 4],
              [5, 11, 2],
              [6, 7, 3],
              [3, 11, 6],
              [3, 7, 8],
              [4, 8, 9],
              [5, 10, 11],
              [6, 11, 10],
              [7, 9, 8],
            ];

            // FIX: Why aren't we computing the convex hull?

            /**
             * Computes the polygons of a unit icosahedron.
             * @type {function():Triangle[]}
             */
            const buildRegularIcosahedron = () => {
              return fromPointsAndPaths(points, paths);
            };

            const buildPolygonFromPointsImpl = (points) => ({
              type: 'surface',
              surface: [points.map(([x = 0, y = 0, z = 0]) => [x, y, z])],
            });

            const buildPolygonFromPoints = cachePoints(buildPolygonFromPointsImpl);

            /**
             * Construct a regular unit polygon of a given edge count.
             * Note: radius and length must not conflict.
             *
             * @param {Object} [options] - options for construction
             * @param {Integer} [options.sides=32] - how many sides the polygon has.
             * @returns {PointArray} Array of points along the path of the circle in CCW winding.
             *
             * @example
             * const circlePoints = regularPolygon(32)
             *
             * @example
             * const squarePoints = regularPolygon(4)
             * })
             */
            const buildRegularPolygonImpl = (sides = 32) => {
              let points = [];
              for (let i = 0; i < sides; i++) {
                let radians = (2 * Math.PI * i) / sides;
                let [x, y] = fromAngleRadians(radians);
                points.push([x, y, 0]);
              }
              return points;
            };

            const buildRegularPolygon = cache(buildRegularPolygonImpl);

            /** @type {function(surface:Surface, height:number, depth:number, cap:boolean):Solid} */
            const extrudeImpl = (surface, height = 1, depth = 0, cap = true) => {
              const normalize = createNormalize2();
              const surfaceOutline = outlineSurface(surface, normalize);
              /** @type {Polygon[]} */
              const polygons = [];
              const stepHeight = height - depth;

              // Build the walls.
              for (const polygon of surfaceOutline) {
                const wall = flip(polygon);
                const floor = translate([0, 0, depth + stepHeight * 0], wall);
                const roof = translate([0, 0, depth + stepHeight * 1], wall);
                // Walk around the floor to build the walls.
                for (let i = 0; i < floor.length; i++) {
                  const floorStart = floor[i];
                  const floorEnd = floor[(i + 1) % floor.length];
                  const roofStart = roof[i];
                  const roofEnd = roof[(i + 1) % roof.length];
                  polygons.push([floorStart, roofStart, roofEnd, floorEnd]);
                }
              }

              if (cap) {
                // FIX: This is already Z0.
                // FIX: This is bringing the vertices out of alignment?
                const surface = makeConvex$1(surfaceOutline, normalize);

                // Roof goes up.
                const roof = translate$1([0, 0, height], surface);
                polygons.push(...roof);

                // floor faces down.
                const floor = translate$1([0, 0, depth], flip$4(surface));
                polygons.push(...floor);
              }

              const solid = fromPolygons(polygons);
              return solid;
            };

            /**
             * Extrudes a surface vertically.
             * @type {function(Surface, height:number, depth:number, cap:boolean):Solid}
             */
            const extrude = cache(extrudeImpl);

            /** @type {function(edges:number):Solid} */
            const buildRegularPrismImpl = (edges = 32) => {
              const path = buildRegularPolygon(edges);
              /** @type {Surface} */
              const surface = [translate([0, 0, -0.5], path)];
              return extrude(surface, 1);
            };

            /**
             * Builds a regular prism of height 1 with the specified number of edges.
             * @type {function(edges:number):Solid}
             */
            const buildRegularPrism = cache(buildRegularPrismImpl);

            // Unit tetrahedron vertices.
            const points$1 = [
              [1, 1, 1],
              [-1, 1, -1],
              [1, -1, -1],
              [-1, 1, -1],
              [-1, -1, 1],
              [1, -1, -1],
              [1, 1, 1],
              [1, -1, -1],
              [-1, -1, 1],
              [1, 1, 1],
              [-1, -1, 1],
              [-1, 1, -1],
            ];

            const buildRegularTetrahedron = (options = {}) =>
              buildConvexHull(points$1);

            const buildWalls$2 = (polygons, floor, roof) => {
              for (
                let start = floor.length - 1, end = 0;
                end < floor.length;
                start = end++
              ) {
                // Remember that we are walking CCW.
                polygons.push(
                  deduplicate([floor[start], floor[end], roof[end], roof[start]])
                );
              }
            };

            // Approximates a UV sphere.
            const buildRingSphereImpl = (resolution = 20) => {
              /** @type {Polygon[]} */
              const polygons = [];
              let lastPath;

              const latitudinalResolution = 2 + resolution;
              const longitudinalResolution = 2 * latitudinalResolution;

              // Trace out latitudinal rings.
              const ring = buildRegularPolygon(longitudinalResolution);
              let path;
              const getEffectiveSlice = (slice) => {
                if (slice === 0) {
                  return 0.5;
                } else if (slice === latitudinalResolution) {
                  return latitudinalResolution - 0.5;
                } else {
                  return slice;
                }
              };
              for (let slice = 0; slice <= latitudinalResolution; slice++) {
                const angle =
                  (Math.PI * 1.0 * getEffectiveSlice(slice)) / latitudinalResolution;
                const height = Math.cos(angle);
                const radius = Math.sin(angle);
                const points = ring;
                const scaledPath = scale$2([radius, radius, radius], points);
                const translatedPath = translate([0, 0, height], scaledPath);
                path = translatedPath;
                if (lastPath !== undefined) {
                  buildWalls$2(polygons, path, lastPath);
                } else {
                  polygons.push(path);
                }
                lastPath = path;
              }
              if (path) {
                polygons.push(flip(path));
              }
              for (const polygon of polygons) {
                assertGood(polygon);
              }
              return fromPolygons(polygons);
            };

            const buildRingSphere = cache(buildRingSphereImpl);

            var cache$1 = {
                '1': bezier1
              , '2': bezier2
              , '3': bezier3
              , '4': bezier4
            };

            var bezier = neat;
            var prepare_1 = prepare;

            function neat(arr, t) {
              return prepare(arr.length)(arr, t)
            }

            function prepare(pieces) {
              pieces = +pieces|0;
              if (!pieces) throw new Error('Cannot create a interpolator with no elements')
              if (cache$1[pieces]) return cache$1[pieces]

              var fn = ['var ut = 1 - t', ''];

              var n = pieces;
              while (n--) {
                for (var j = 0; j < n; j += 1) {
                  if (n+1 === pieces) {
                    fn.push('var p'+j+' = arr['+j+'] * ut + arr['+(j+1)+'] * t');
                  } else
                  if (n > 1) {
                    fn.push('p'+j+' = p'+j+' * ut + p'+(j+1)+' * t');
                  } else {
                    fn.push('return p'+j+' * ut + p'+(j+1)+' * t');
                  }
                }
                if (n > 1) fn.push('');
              }

              fn = [
                'return function bezier'+pieces+'(arr, t) {'
                , fn.map(function(s) { return '  ' + s }).join('\n')
                , '}'
              ].join('\n');

              return Function(fn)()
            }

            //
            // Including the first four degrees
            // manually - there's a slight performance penalty
            // to generated code. It's outweighed by
            // the gains of the optimisations, but always
            // helps to cover the most common cases :)
            //

            function bezier1(arr) {
              return arr[0]
            }

            function bezier2(arr, t) {
              return arr[0] + (arr[1] - arr[0]) * t
            }

            function bezier3(arr, t) {
              var ut = 1 - t;
              return (arr[0] * ut + arr[1] * t) * ut + (arr[1] * ut + arr[2] * t) * t
            }

            function bezier4(arr, t) {
              var ut = 1 - t;
              var a1 = arr[1] * ut + arr[2] * t;
              return ((arr[0] * ut + arr[1] * t) * ut + a1 * t) * ut + (a1 * ut + (arr[2] * ut + arr[3] * t) * t) * t
            }
            bezier.prepare = prepare_1;

            const interpolateCubicBezier = bezier.prepare(4);

            const buildWalls$3 = (polygons, floor, roof) => {
              for (
                let start = floor.length - 1, end = 0;
                end < floor.length;
                start = end++
              ) {
                if (floor[start] === null || floor[end] === null) {
                  continue;
                }
                // Remember that we are walking CCW.
                polygons.push([roof[start], roof[end], floor[start]]);
                polygons.push([roof[end], floor[end], floor[start]]);
              }
            };

            // Rotate a path around the X axis to produce the polygons of a solid.
            const loopImpl = (
              path,
              endRadians = Math.PI * 2,
              resolution = 16,
              pitch = 0
            ) => {
              const stepRadians = (Math.PI * 2) / resolution;
              const pitchPerRadian = pitch / (Math.PI * 2);
              let lastPath;
              /** @type {Polygon[]} */
              const polygons = [];
              if (endRadians !== Math.PI * 2 || pitch !== 0) {
                // Cap the loop.
                polygons.push(
                  flip(path),
                  translate([pitchPerRadian * endRadians, 0, 0], rotateX$1(endRadians, path))
                );
              }
              for (let radians = 0; radians < endRadians; radians += stepRadians) {
                const rotatedPath = translate(
                  [pitchPerRadian * radians, 0, 0],
                  rotateX$1(radians, path)
                );
                if (lastPath !== undefined) {
                  buildWalls$3(polygons, rotatedPath, lastPath);
                }
                lastPath = rotatedPath;
              }
              if (lastPath !== undefined) {
                buildWalls$3(
                  polygons,
                  translate([pitchPerRadian * endRadians, 0, 0], rotateX$1(endRadians, path)),
                  lastPath
                );
              }
              return { type: 'solid', solid: fromPolygons(polygons) };
            };

            const loop = cache(loopImpl);

            const sin = (a) => Math.sin((a / 360) * Math.PI * 2);

            const regularPolygonEdgeLengthToRadius = (length, edges) =>
              length / (2 * sin(180 / edges));

            const toRadiusFromApothem = (apothem, sides) =>
              apothem / Math.cos(Math.PI / sides);

            const EPSILON$3 = 1e-5;
            // const EPSILON2 = 1e-10;

            const COPLANAR$1 = 1; // Neither front nor back.
            const FRONT$1 = 2;
            const BACK$1 = 4;

            const dot$3 = (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2];

            // const toType = (plane, point) => {
            //   // const t = planeDistance(plane, point);
            //   const t = plane[0] * point[0] + plane[1] * point[1] + plane[2] * point[2] - plane[3];
            //   if (t < -EPSILON) {
            //     return BACK;
            //   } else if (t > EPSILON) {
            //     return FRONT;
            //   } else {
            //     return COPLANAR;
            //   }
            // };

            const pointType$1 = [];

            const splitPolygon$2 = (
              normalize,
              plane,
              polygon,
              back,
              abutting,
              overlapping,
              front
            ) => {
              /*
                // This slows things down on average, probably due to not having the bounding sphere computed.
                // Check for non-intersection due to distance from the plane.
                const [center, radius] = measureBoundingSphere(polygon);
                let distance = planeDistance(plane, center) + EPSILON;
                if (distance > radius) {
                  front.push(polygon);
                  return;
                } else if (distance < -radius) {
                  back.push(polygon);
                  return;
                }
              */
              let polygonType = COPLANAR$1;
              const polygonPlane = toPlane(polygon);
              if (polygonPlane === undefined) {
                // Degenerate polygon
                return;
              }
              if (!equals$1(polygonPlane, plane)) {
                for (let nth = 0; nth < polygon.length; nth++) {
                  // const type = toType(plane, polygon[nth]);
                  // const t = planeDistance(plane, point);
                  const point = polygon[nth];
                  const t =
                    plane[0] * point[0] +
                    plane[1] * point[1] +
                    plane[2] * point[2] -
                    plane[3];
                  if (t < -EPSILON$3) {
                    polygonType |= BACK$1;
                    pointType$1[nth] = BACK$1;
                  } else if (t > EPSILON$3) {
                    polygonType |= FRONT$1;
                    pointType$1[nth] = FRONT$1;
                  } else {
                    polygonType |= COPLANAR$1;
                    pointType$1[nth] = COPLANAR$1;
                  }
                }
              }

              // Put the polygon in the correct list, splitting it when necessary.
              switch (polygonType) {
                case COPLANAR$1:
                  if (dot$3(plane, polygonPlane) > 0) {
                    // The plane and the polygon face the same way, so the spaces overlap.
                    overlapping.push(polygon);
                  } else {
                    // The plane and the polygon face the opposite directions, so the spaces abut.
                    abutting.push(polygon);
                  }
                  return;
                case FRONT$1:
                  front.push(polygon);
                  return;
                case BACK$1:
                  back.push(polygon);
                  return;
                default: {
                  // SPANNING
                  const frontPoints = [];
                  const backPoints = [];

                  const last = polygon.length - 1;
                  let startPoint = polygon[last];
                  let startType = pointType$1[last];
                  for (let nth = 0; nth < polygon.length; nth++) {
                    const endPoint = polygon[nth];
                    const endType = pointType$1[nth];
                    if (startType !== BACK$1) {
                      // The inequality is important as it includes COPLANAR points.
                      frontPoints.push(startPoint);
                    }
                    if (startType !== FRONT$1) {
                      // The inequality is important as it includes COPLANAR points.
                      backPoints.push(startPoint);
                    }
                    if (
                      (startType === FRONT$1 && endType !== FRONT$1) ||
                      (startType === BACK$1 && endType !== BACK$1)
                    ) {
                      // This should include COPLANAR points.
                      // Compute the point that touches the splitting plane.
                      const spanPoint = normalize(
                        splitLineByPlane(plane, startPoint, endPoint)
                      );
                      frontPoints.push(spanPoint);
                      backPoints.push(spanPoint);
                    }
                    startPoint = endPoint;
                    startType = endType;
                  }
                  pushWhenValid(front, frontPoints, polygonPlane);
                  pushWhenValid(back, backPoints, polygonPlane);
                  break;
                }
              }
            };

            const BRANCH = 0;
            const IN_LEAF = 1;
            const OUT_LEAF = 2;

            /**
             * @typedef {object} Bsp
             * @property {Plane} plane
             * @property {Polygon[]} same
             * @property {BRANCH|IN_LEAF|OUT_LEAF} kind
             * @property {Bsp} back
             * @property {Bsp} front
             */

            const X$7 = 0;
            const Y$7 = 1;
            const Z$6 = 2;

            /** @type {Bsp} */
            const inLeaf = {
              plane: null,
              same: [],
              kind: IN_LEAF,
              back: null,
              front: null,
            };

            /** @type {Bsp} */
            const outLeaf = {
              plane: null,
              same: [],
              kind: OUT_LEAF,
              back: null,
              front: null,
            };

            const fromBoundingBoxes = (
              [aMin, aMax],
              [bMin, bMax],
              front = outLeaf,
              back = inLeaf
            ) => {
              const cMin = max(aMin, bMin);
              const cMax = min(aMax, bMax);
              const bsp = {
                // Bottom
                kind: BRANCH,
                plane: [0, 0, -1, -cMin[Z$6] + EPSILON$3 * 1000],
                front,
                back: {
                  // Top
                  kind: BRANCH,
                  plane: [0, 0, 1, cMax[Z$6] + EPSILON$3 * 1000],
                  front,
                  back: {
                    // Left
                    kind: BRANCH,
                    plane: [-1, 0, 0, -cMin[X$7] + EPSILON$3 * 1000],
                    front,
                    back: {
                      // Right
                      kind: BRANCH,
                      plane: [1, 0, 0, cMax[X$7] + EPSILON$3 * 1000],
                      front,
                      back: {
                        // Back
                        kind: BRANCH,
                        plane: [0, -1, 0, -cMin[Y$7] + EPSILON$3 * 1000],
                        front,
                        back: {
                          // Front
                          kind: BRANCH,
                          plane: [0, 1, 0, cMax[Y$7] + EPSILON$3 * 1000],
                          front: outLeaf,
                          back,
                        },
                      },
                    },
                  },
                },
              };
              return bsp;
            };

            /**
             * Builds a BspTree from polygon soup.
             * The bsp tree is constructed from the planes of the polygons.
             * The polygons allow us to determine when a half-plane is uninhabited.
             */
            const fromPolygonsToBspTree = (polygons, normalize) => {
              if (polygons.length === 0) {
                // Everything is outside of an empty geometry.
                return outLeaf;
              }
              let same = [];
              let front = [];
              let back = [];
              let plane = toPlane(polygons[polygons.length >> 1]);

              if (plane === undefined) {
                throw Error('die');
              }

              for (const polygon of polygons) {
                splitPolygon$2(
                  normalize,
                  plane,
                  polygon,
                  /* back= */ back,
                  /* abutting= */ back,
                  /* overlapping= */ same,
                  /* front= */ front
                );
              }

              const bsp = {
                back: back.length === 0 ? inLeaf : fromPolygonsToBspTree(back, normalize),
                front:
                  front.length === 0 ? outLeaf : fromPolygonsToBspTree(front, normalize),
                kind: BRANCH,
                plane,
                same,
              };

              return bsp;
            };

            const fromPolygons$1 = (polygons, normalize) =>
              fromPolygonsToBspTree(polygons, normalize);

            const fromSolid$1 = (solid, normalize) => {
              const polygons = [];
              for (const surface of solid) {
                polygons.push(...surface);
              }
              return fromPolygons$1(polygons, normalize);
            };

            const keepIn = (polygons) => {
              for (const polygon of polygons) {
                polygon.leaf = inLeaf;
              }
              return polygons;
            };

            const keepOut = (polygons) => {
              for (const polygon of polygons) {
                polygon.leaf = outLeaf;
              }
              return polygons;
            };

            // Merge the result of a split.
            const merge$1 = (front, back) => {
              const merged = [];
              const scan = (polygons) => {
                for (const polygon of polygons) {
                  if (polygon.leaf) {
                    if (polygon.sibling && polygon.sibling.leaf === polygon.leaf) {
                      polygon.parent.leaf = polygon.leaf;
                      polygon.leaf = null;
                      polygon.sibling.leaf = undefined;
                      merged.push(polygon.parent);
                    } else {
                      merged.push(polygon);
                    }
                  }
                }
              };
              scan(front);
              scan(back);
              return merged;
            };

            const clean$1 = (polygons) => {
              for (const polygon of polygons) {
                delete polygon.parent;
                delete polygon.sibling;
              }
              return polygons;
            };

            const removeInteriorPolygonsForUnionKeepingOverlap = (
              bsp,
              polygons,
              normalize
            ) => {
              if (bsp === inLeaf) {
                return [];
              } else if (bsp === outLeaf) {
                return keepOut(polygons);
              } else {
                const front = [];
                const back = [];
                for (let i = 0; i < polygons.length; i++) {
                  splitPolygon$2(
                    normalize,
                    bsp.plane,
                    polygons[i],
                    /* back= */ back,
                    /* abutting= */ back,
                    /* overlapping= */ front,
                    /* front= */ front
                  );
                }
                const trimmedFront = removeInteriorPolygonsForUnionKeepingOverlap(
                  bsp.front,
                  front,
                  normalize
                );
                const trimmedBack = removeInteriorPolygonsForUnionKeepingOverlap(
                  bsp.back,
                  back,
                  normalize
                );

                if (trimmedFront.length === 0) {
                  return trimmedBack;
                } else if (trimmedBack.length === 0) {
                  return trimmedFront;
                } else {
                  return merge$1(trimmedFront, trimmedBack);
                }
              }
            };

            const removeInteriorPolygonsForUnionDroppingOverlap = (
              bsp,
              polygons,
              normalize
            ) => {
              if (bsp === inLeaf) {
                return [];
              } else if (bsp === outLeaf) {
                return keepOut(polygons);
              } else {
                const front = [];
                const back = [];
                for (let i = 0; i < polygons.length; i++) {
                  splitPolygon$2(
                    normalize,
                    bsp.plane,
                    polygons[i],
                    /* back= */ back,
                    /* abutting= */ back,
                    /* overlapping= */ back,
                    /* front= */ front
                  );
                }
                const trimmedFront = removeInteriorPolygonsForUnionDroppingOverlap(
                  bsp.front,
                  front,
                  normalize
                );
                const trimmedBack = removeInteriorPolygonsForUnionDroppingOverlap(
                  bsp.back,
                  back,
                  normalize
                );

                if (trimmedFront.length === 0) {
                  return trimmedBack;
                } else if (trimmedBack.length === 0) {
                  return trimmedFront;
                } else {
                  return merge$1(trimmedFront, trimmedBack);
                }
              }
            };

            const removeExteriorPolygonsForSection = (bsp, polygons, normalize) => {
              if (bsp === inLeaf) {
                return keepIn(polygons);
              } else if (bsp === outLeaf) {
                return [];
              } else {
                const front = [];
                const back = [];
                for (let i = 0; i < polygons.length; i++) {
                  splitPolygon$2(
                    normalize,
                    bsp.plane,
                    polygons[i],
                    /* back= */ back,
                    /* abutting= */ front,
                    /* overlapping= */ back,
                    /* front= */ front
                  );
                }
                const trimmedFront = removeExteriorPolygonsForSection(
                  bsp.front,
                  front,
                  normalize
                );
                const trimmedBack = removeExteriorPolygonsForSection(
                  bsp.back,
                  back,
                  normalize
                );

                if (trimmedFront.length === 0) {
                  return trimmedBack;
                } else if (trimmedBack.length === 0) {
                  return trimmedFront;
                } else {
                  return merge$1(trimmedFront, trimmedBack);
                }
              }
            };

            const removeExteriorPolygonsForCutDroppingOverlap = (
              bsp,
              polygons,
              normalize
            ) => {
              if (bsp === inLeaf) {
                return keepIn(polygons);
              } else if (bsp === outLeaf) {
                return [];
              } else {
                const front = [];
                const back = [];
                for (let i = 0; i < polygons.length; i++) {
                  splitPolygon$2(
                    normalize,
                    bsp.plane,
                    polygons[i],
                    /* back= */ back, // keepward
                    /* abutting= */ back, // keepward
                    /* overlapping= */ front, // dropward
                    /* front= */ front
                  ); // dropward
                }
                const trimmedFront = removeExteriorPolygonsForCutDroppingOverlap(
                  bsp.front,
                  front,
                  normalize
                );
                const trimmedBack = removeExteriorPolygonsForCutDroppingOverlap(
                  bsp.back,
                  back,
                  normalize
                );

                if (trimmedFront.length === 0) {
                  return trimmedBack;
                } else if (trimmedBack.length === 0) {
                  return trimmedFront;
                } else {
                  return merge$1(trimmedFront, trimmedBack);
                }
              }
            };

            const removeExteriorPolygonsForCutKeepingOverlap = (
              bsp,
              polygons,
              normalize
            ) => {
              if (bsp === inLeaf) {
                return keepIn(polygons);
              } else if (bsp === outLeaf) {
                return [];
              } else {
                const front = [];
                const back = [];
                for (let i = 0; i < polygons.length; i++) {
                  splitPolygon$2(
                    normalize,
                    bsp.plane,
                    polygons[i],
                    /* back= */ back, // keepward
                    /* abutting= */ front, // dropward
                    /* overlapping= */ back, // keepward
                    /* front= */ front
                  ); // dropward
                }
                const trimmedFront = removeExteriorPolygonsForCutKeepingOverlap(
                  bsp.front,
                  front,
                  normalize
                );
                const trimmedBack = removeExteriorPolygonsForCutKeepingOverlap(
                  bsp.back,
                  back,
                  normalize
                );

                if (trimmedFront.length === 0) {
                  return trimmedBack;
                } else if (trimmedBack.length === 0) {
                  return trimmedFront;
                } else {
                  return merge$1(trimmedFront, trimmedBack);
                }
              }
            };

            const removeInteriorPolygonsForDifference = (bsp, polygons, normalize) => {
              if (bsp === inLeaf) {
                return [];
              } else if (bsp === outLeaf) {
                return keepOut(polygons);
              } else {
                const outward = [];
                const inward = [];
                for (let i = 0; i < polygons.length; i++) {
                  splitPolygon$2(
                    normalize,
                    bsp.plane,
                    polygons[i],
                    /* back= */ inward,
                    /* abutting= */ outward, // dropward
                    /* overlapping= */ inward, // dropward
                    /* front= */ outward
                  );
                }
                const trimmedFront = removeInteriorPolygonsForDifference(
                  bsp.front,
                  outward,
                  normalize
                );
                const trimmedBack = removeInteriorPolygonsForDifference(
                  bsp.back,
                  inward,
                  normalize
                );

                if (trimmedFront.length === 0) {
                  return trimmedBack;
                } else if (trimmedBack.length === 0) {
                  return trimmedFront;
                } else {
                  return merge$1(trimmedFront, trimmedBack);
                }
              }
            };

            const removeExteriorPolygonsForDifference = (bsp, polygons, normalize) => {
              if (bsp === inLeaf) {
                return keepIn(polygons);
              } else if (bsp === outLeaf) {
                return [];
              } else {
                const outward = [];
                const inward = [];
                for (let i = 0; i < polygons.length; i++) {
                  splitPolygon$2(
                    normalize,
                    bsp.plane,
                    polygons[i],
                    /* back= */ inward,
                    /* abutting= */ outward, // dropward
                    /* overlapping= */ outward, // dropward
                    /* front= */ outward
                  );
                }
                const trimmedFront = removeExteriorPolygonsForDifference(
                  bsp.front,
                  outward,
                  normalize
                );
                const trimmedBack = removeExteriorPolygonsForDifference(
                  bsp.back,
                  inward,
                  normalize
                );

                if (trimmedFront.length === 0) {
                  return trimmedBack;
                } else if (trimmedBack.length === 0) {
                  return trimmedFront;
                } else {
                  return merge$1(trimmedFront, trimmedBack);
                }
              }
            };

            const removeExteriorPolygonsForIntersectionKeepingOverlap = (
              bsp,
              polygons,
              normalize
            ) => {
              if (bsp === inLeaf) {
                return keepIn(polygons);
              } else if (bsp === outLeaf) {
                return [];
              } else {
                const front = [];
                const back = [];
                for (let i = 0; i < polygons.length; i++) {
                  splitPolygon$2(
                    normalize,
                    bsp.plane,
                    polygons[i],
                    /* back= */ back,
                    /* abutting= */ front,
                    /* overlapping= */ back,
                    /* front= */ front
                  );
                }
                const trimmedFront = removeExteriorPolygonsForIntersectionKeepingOverlap(
                  bsp.front,
                  front,
                  normalize
                );
                const trimmedBack = removeExteriorPolygonsForIntersectionKeepingOverlap(
                  bsp.back,
                  back,
                  normalize
                );

                if (trimmedFront.length === 0) {
                  return trimmedBack;
                } else if (trimmedBack.length === 0) {
                  return trimmedFront;
                } else {
                  return merge$1(trimmedFront, trimmedBack);
                }
              }
            };

            const removeExteriorPolygonsForIntersectionDroppingOverlap = (
              bsp,
              polygons,
              normalize
            ) => {
              if (bsp === inLeaf) {
                return keepIn(polygons);
              } else if (bsp === outLeaf) {
                return [];
              } else {
                const front = [];
                const back = [];
                for (let i = 0; i < polygons.length; i++) {
                  splitPolygon$2(
                    normalize,
                    bsp.plane,
                    polygons[i],
                    /* back= */ back,
                    /* abutting= */ front,
                    /* overlapping= */ front,
                    /* front= */ front
                  );
                }
                const trimmedFront = removeExteriorPolygonsForIntersectionDroppingOverlap(
                  bsp.front,
                  front,
                  normalize
                );
                const trimmedBack = removeExteriorPolygonsForIntersectionDroppingOverlap(
                  bsp.back,
                  back,
                  normalize
                );

                if (trimmedFront.length === 0) {
                  return trimmedBack;
                } else if (trimmedBack.length === 0) {
                  return trimmedFront;
                } else {
                  return merge$1(trimmedFront, trimmedBack);
                }
              }
            };

            // Don't merge the fragments for this one.
            const dividePolygons = (bsp, polygons, normalize) => {
              if (bsp === inLeaf) {
                return polygons;
              } else if (bsp === outLeaf) {
                return polygons;
              } else {
                const front = [];
                const back = [];
                for (let i = 0; i < polygons.length; i++) {
                  splitPolygon$2(
                    normalize,
                    bsp.plane,
                    polygons[i],
                    /* back= */ back,
                    /* abutting= */ front,
                    /* overlapping= */ back,
                    /* front= */ front
                  );
                }
                const trimmedFront = dividePolygons(bsp.front, front, normalize);
                const trimmedBack = dividePolygons(bsp.back, back, normalize);

                if (trimmedFront.length === 0) {
                  return trimmedBack;
                } else if (trimmedBack.length === 0) {
                  return trimmedFront;
                } else {
                  return [].concat(trimmedFront, trimmedBack);
                }
              }
            };

            const replaceLeafs = (bsp, inBsp = inLeaf, outBsp = outLeaf) => {
              switch (bsp.kind) {
                case IN_LEAF:
                  return inBsp;
                case OUT_LEAF:
                  return outBsp;
                case BRANCH:
                  return {
                    ...bsp,
                    front: replaceLeafs(bsp.front, inBsp, outBsp),
                    back: replaceLeafs(bsp.back, inBsp, outBsp),
                  };
                default:
                  throw Error(`Unexpected bsp kind: ${bsp.kind}`);
              }
            };

            // Anything in either bsp is in.
            const unifyBspTrees = (a, b) => replaceLeafs(a, inLeaf, b);

            const cut$1 = (solid, surface, normalize = createNormalize3()) => {
              // Build a classifier from the planar polygon.
              const cutBsp = fromPolygons$1(surface, normalize);
              const solidPolygons = toPolygons$1(alignVertices(solid, normalize));

              // Classify the solid with it.
              const trimmedSolid = removeExteriorPolygonsForCutDroppingOverlap(
                cutBsp,
                solidPolygons,
                normalize
              );

              // The solid will have holes that need to be patched with the parts of the
              // planar polygon that are on the solid boundary.
              const solidBsp = fromPolygons$1(solidPolygons, normalize);
              const trimmedPolygons = removeExteriorPolygonsForCutKeepingOverlap(
                solidBsp,
                surface,
                normalize
              );

              return fromPolygons([...trimmedSolid, ...trimmedPolygons], normalize);
            };

            const cutOpen = (solid, surface, normalize = createNormalize3()) => {
              // Build a classifier from the planar polygon.
              const cutBsp = fromPolygons$1(surface, normalize);
              const solidPolygons = toPolygons$1(alignVertices(solid, normalize));

              // Classify the solid with it.
              const trimmedSolid = removeExteriorPolygonsForCutDroppingOverlap(
                cutBsp,
                solidPolygons,
                normalize
              );

              return fromPolygons(trimmedSolid, normalize);
            };

            const containsPoint = (bsp, point, history = []) => {
              while (true) {
                history.push(bsp);
                if (bsp === inLeaf) {
                  return true;
                } else if (bsp === outLeaf) {
                  return false;
                } else {
                  const plane = bsp.plane;
                  // const t = planeDistance(plane, point);
                  const t =
                    plane[0] * point[0] +
                    plane[1] * point[1] +
                    plane[2] * point[2] -
                    plane[3];
                  if (t <= 0) {
                    // Consider points on the surface to be contained.
                    bsp = bsp.back;
                  } else {
                    bsp = bsp.front;
                  }
                }
              }
            };

            const X$1$4 = 0;
            const Y$1$4 = 1;
            const Z$1$3 = 2;

            const walkX = (min, max, resolution) => {
              const midX = Math.floor((min[X$1$4] + max[X$1$4]) / 2);
              if (midX === min[X$1$4]) {
                return walkY(min, max, resolution);
              }
              return {
                back: walkX(min, [midX, max[Y$1$4], max[Z$1$3]], resolution),
                front: walkX([midX, min[Y$1$4], min[Z$1$3]], max, resolution),
                kind: BRANCH,
                plane: [1, 0, 0, midX * resolution],
                same: [],
              };
            };

            const walkY = (min, max, resolution) => {
              const midY = Math.floor((min[Y$1$4] + max[Y$1$4]) / 2);
              if (midY === min[Y$1$4]) {
                return walkZ(min, max, resolution);
              }
              return {
                back: walkY(min, [max[X$1$4], midY, max[Z$1$3]], resolution),
                front: walkY([min[X$1$4], midY, min[Z$1$3]], max, resolution),
                kind: BRANCH,
                plane: [0, 1, 0, midY * resolution],
                same: [],
              };
            };

            const walkZ = (min, max, resolution) => {
              const midZ = Math.floor((min[Z$1$3] + max[Z$1$3]) / 2);
              if (midZ === min[Z$1$3]) {
                return inLeaf;
              }
              return {
                back: walkZ(min, [max[X$1$4], max[Y$1$4], midZ], resolution),
                front: walkZ([min[X$1$4], min[Y$1$4], midZ], max, resolution),
                kind: BRANCH,
                plane: [0, 0, 1, midZ * resolution],
                same: [],
              };
            };

            const deform = (solid, transform, min, max, resolution) => {
              const normalize = createNormalize3();

              const solidPolygons = toPolygons$1(alignVertices(solid));

              const floor = ([x, y, z]) => [
                Math.floor(x / resolution),
                Math.floor(y / resolution),
                Math.floor(z / resolution),
              ];
              const ceil = ([x, y, z]) => [
                Math.ceil(x / resolution),
                Math.ceil(y / resolution),
                Math.ceil(z / resolution),
              ];

              const bsp = walkX(floor(min), ceil(max), resolution);

              // Classify the solid with it.
              const dividedPolygons = [];

              for (const polygon of dividePolygons(bsp, solidPolygons, normalize)) {
                if (polygon.length > 3) {
                  for (let nth = 2; nth < polygon.length; nth++) {
                    dividedPolygons.push([polygon[0], polygon[nth - 1], polygon[nth]]);
                  }
                } else if (polygon.length === 3) {
                  dividedPolygons.push(polygon);
                }
              }

              const realignedPolygons = alignVertices([dividedPolygons])[0];

              const vertices = new Map();

              // We only need this for non-deterministic transforms.
              // Let's require transforms be deterministic functions.
              for (const path of realignedPolygons) {
                for (const point of path) {
                  const tag = JSON.stringify(point);
                  if (!vertices.has(tag)) {
                    vertices.set(tag, transform(point));
                  }
                }
              }

              // Now the solid should have vertexes at the given heights, and we can apply the transform.
              const transformedPolygons = realignedPolygons.map((path) =>
                path.map((point) => vertices.get(JSON.stringify(point)))
              );

              return fromPolygons(transformedPolygons);
            };

            const differenceSurface = (bsp, surface, normalize, emit) => {
              if (bsp === outLeaf) {
                emit(surface);
              } else if (bsp !== inLeaf) {
                const front = [];
                const back = [];
                for (let i = 0; i < surface.length; i++) {
                  splitPolygon$2(
                    normalize,
                    bsp.plane,
                    surface[i],
                    /* back= */ back,
                    /* abutting= */ back,
                    /* overlapping= */ back,
                    /* front= */ front
                  );
                }
                differenceSurface(bsp.front, front, normalize, emit);
                differenceSurface(bsp.back, back, normalize, emit);
              }
            };

            const nullPartition = (
              bbBsp,
              aBB,
              bBB,
              bbOutLeaf,
              aPolygons,
              normalize
            ) => {
              const aIn = aPolygons;
              const aBsp = fromPolygons$1(aIn, normalize);
              return [aIn, [], aBsp];
            };

            const MIN = 0;

            const difference$1 = (aSolid, ...bSolids) => {
              if (bSolids.length === 0) {
                return aSolid;
              }

              const normalize = createNormalize3();
              let a = toPolygons$1(alignVertices(aSolid, normalize));
              if (a.length === 0) {
                return [];
              }
              let bs = bSolids
                .map((b) => toPolygons$1(alignVertices(b, normalize)))
                .filter((b) => b.length > 0 && !doesNotOverlap(a, b));

              while (bs.length > 0) {
                const b = bs.shift();

                const aBB = measureBoundingBox(a);
                const bBB = measureBoundingBox(b);
                const bbBsp = fromBoundingBoxes(aBB, bBB, outLeaf, inLeaf);

                const [aIn, aOut, aBsp] = nullPartition(bbBsp, aBB, bBB, inLeaf, a, normalize);
                const [bIn, , bBsp] = nullPartition(bbBsp, aBB, bBB, outLeaf, b, normalize);

                if (aIn.length === 0) {
                  const bbMin = max(aBB[MIN], bBB[MIN]);
                  // There are two ways for aIn to be empty: the space is fully enclosed or fully vacated.
                  const aBsp = fromPolygons$1(a, normalize);
                  if (containsPoint(aBsp, bbMin)) {
                    // The space is fully enclosed; invert b.
                    a = [...aOut, ...flip$3(bIn)];
                  } else {
                    // The space is fully vacated; nothing to be cut.
                    continue;
                  }
                } else if (bIn.length === 0) {
                  const bbMin = max(aBB[MIN], bBB[MIN]);
                  // There are two ways for bIn to be empty: the space is fully enclosed or fully vacated.
                  const bBsp = fromPolygons$1(b, normalize);
                  if (containsPoint(bBsp, bbMin)) {
                    // The space is fully enclosed; only the out region remains.
                    a = aOut;
                  } else {
                    // The space is fully vacated; nothing to cut with.
                    continue;
                  }
                } else {
                  // Remove the parts of a that are inside b.
                  const aTrimmed = removeInteriorPolygonsForDifference(
                    bBsp,
                    aIn,
                    normalize
                  );
                  // Remove the parts of b that are outside a.
                  const bTrimmed = removeExteriorPolygonsForDifference(
                    aBsp,
                    bIn,
                    normalize
                  );

                  a = clean$1([...aOut, ...aTrimmed, ...flip$3(bTrimmed)]);
                }
              }
              return fromPolygons(a, normalize);
            };

            const LARGE$1 = 1e10;

            const fromSurface$2 = (surface, normalize) => {
              const polygons = [];
              const normal = toPlane$2(surface);
              if (normal !== undefined) {
                const top = scale(LARGE$1, normal);
                const bottom = scale(0, normal);
                for (const path of outlineSurface(surface, normalize)) {
                  for (const [start, end] of getEdges(path)) {
                    // Build a large wall.
                    polygons.push([
                      add(start, top),
                      add(start, bottom),
                      add(end, bottom),
                      add(end, top),
                    ]);
                  }
                }
                // Build a tall prism.
                polygons.push(...translate$1(bottom, flip$4(surface)));
                polygons.push(...translate$1(top, surface));
              }
              return fromPolygons$1(polygons, normalize);
            };

            const intersectSurface = (bsp, surface, normalize, emit) => {
              if (bsp === inLeaf) {
                emit(surface);
              } else if (bsp !== outLeaf) {
                const front = [];
                const back = [];
                for (let i = 0; i < surface.length; i++) {
                  splitPolygon$2(
                    normalize,
                    bsp.plane,
                    surface[i],
                    /* back= */ back,
                    /* abutting= */ back,
                    /* overlapping= */ back,
                    /* front= */ front
                  );
                }
                intersectSurface(bsp.front, front, normalize, emit);
                intersectSurface(bsp.back, back, normalize, emit);
              }
            };

            const MIN$1 = 0;

            // An asymmetric binary merge.
            const intersection = (...solids) => {
              if (solids.length === 0) {
                return [];
              }
              if (solids.length === 1) {
                return solids[0];
              }
              const normalize = createNormalize3();
              const s = solids.map((solid) =>
                toPolygons$1(alignVertices(solid, normalize))
              );
              while (s.length > 1) {
                const a = s.shift();
                const b = s.shift();

                if (doesNotOverlap(a, b)) {
                  return [];
                }

                const aBB = measureBoundingBox(a);
                const bBB = measureBoundingBox(b);
                const bbBsp = fromBoundingBoxes(aBB, bBB, outLeaf, inLeaf);

                const [aIn, , aBsp] = nullPartition(bbBsp, aBB, bBB, outLeaf, a, normalize);
                const [bIn, , bBsp] = nullPartition(bbBsp, aBB, bBB, outLeaf, b, normalize);

                if (aIn.length === 0) {
                  const bbMin = max(aBB[MIN$1], bBB[MIN$1]);
                  // There are two ways for aIn to be empty: the space is fully exclosed or fully vacated.
                  const aBsp = fromPolygons$1(a, normalize);
                  if (containsPoint(aBsp, bbMin)) {
                    // The space is fully enclosed.
                    s.push(bIn);
                  } else {
                    // The space is fully vacated.
                    return [];
                  }
                } else if (bIn.length === 0) {
                  const bbMin = max(aBB[MIN$1], bBB[MIN$1]);
                  // There are two ways for bIn to be empty: the space is fully exclosed or fully vacated.
                  const bBsp = fromPolygons$1(b, normalize);
                  if (containsPoint(bBsp, bbMin)) {
                    // The space is fully enclosed.
                    s.push(aIn);
                  } else {
                    // The space is fully vacated.
                    return [];
                  }
                } else {
                  const aTrimmed = removeExteriorPolygonsForIntersectionKeepingOverlap(
                    bBsp,
                    aIn,
                    normalize
                  );
                  const bTrimmed = removeExteriorPolygonsForIntersectionDroppingOverlap(
                    aBsp,
                    bIn,
                    normalize
                  );

                  s.push(clean$1([...aTrimmed, ...bTrimmed]));
                }
              }
              return fromPolygons(s[0], normalize);
            };

            const planeDistance = (plane, point) =>
              plane[0] * point[0] + plane[1] * point[1] + plane[2] * point[2] - plane[3];

            const splitPaths = (normalize, plan, paths, back, front) => {
              for (const path of paths) {
                splitPath$1(normalize, plan, path, back, front);
              }
            };

            // FIX: This chops up the path into discrete segments.
            const splitPath$1 = (normalize, plane, path, back, front) => {
              for (const [start, end] of getEdges(path)) {
                const t = planeDistance(plane, start);
                const direction = subtract(end, start);
                let lambda = (plane[3] - dot(plane, start)) / dot(plane, direction);
                if (!Number.isNaN(lambda) && lambda > 0 && lambda < 1) {
                  const span = normalize(add(start, scale(lambda, direction)));
                  if (t > 0) {
                    // Front to back
                    front.push(createOpenPath(start, span));
                    back.push(createOpenPath(span, end));
                  } else {
                    back.push(createOpenPath(start, span));
                    front.push(createOpenPath(span, end));
                  }
                } else {
                  if (t > 0) {
                    front.push(createOpenPath(start, end));
                  } else {
                    back.push(createOpenPath(start, end));
                  }
                }
              }
            };

            const removeExteriorPaths = (bsp, paths, normalize, emit) => {
              if (bsp === inLeaf) {
                return emit(paths);
              } else if (bsp === outLeaf) {
                return [];
              } else {
                const front = [];
                const back = [];
                splitPaths(
                  normalize,
                  bsp.plane,
                  paths,
                  /* back= */ back,
                  /* abutting= */ front);
                removeExteriorPaths(bsp.front, front, normalize, emit);
                removeExteriorPaths(bsp.back, back, normalize, emit);
              }
            };

            const section = (solid, surfaces, normalize) => {
              const bsp = fromSolid$1(alignVertices(solid, normalize), normalize);
              return surfaces.map((surface) =>
                removeExteriorPolygonsForSection(bsp, surface, normalize)
              );
            };

            const toConvexClouds = (bsp, normalize) => {
              const clouds = [];
              const walk = (bsp, polygons) => {
                if (bsp === outLeaf) {
                  return null;
                } else if (bsp === inLeaf) {
                  const cloud = [];
                  for (const polygon of polygons) {
                    cloud.push(...polygon.map(normalize));
                  }
                  clouds.push(cloud);
                } else {
                  const back = [...bsp.same];
                  const front = [...bsp.same];
                  for (const polygon of polygons) {
                    splitPolygon$2(normalize, bsp.plane, polygon, back, front, back, front);
                  }
                  walk(bsp.front, front);
                  walk(bsp.back, back);
                }
              };
              walk(bsp, []);
              return clouds;
            };

            const toConvexSolids = (bsp, normalize) => {
              const solids = [];
              for (const cloud of toConvexClouds(bsp, normalize)) {
                solids.push(buildConvexHull(cloud));
              }
              return solids;
            };

            const MIN$2 = 0;

            // An asymmetric binary merge.
            const union$2 = (...solids) => {
              if (solids.length === 0) {
                return [];
              }
              if (solids.length === 1) {
                return solids[0];
              }
              const normalize = createNormalize3();
              const s = solids
                .map((solid) => toPolygons$1(alignVertices(solid, normalize)))
                .filter((s) => s.length > 0);
              while (s.length >= 2) {
                const a = s.shift();
                const b = s.shift();

                if (doesNotOverlap(a, b)) {
                  s.push([...a, ...b]);
                  continue;
                }

                const aBB = measureBoundingBox(a);
                const bBB = measureBoundingBox(b);
                const bbBsp = fromBoundingBoxes(aBB, bBB, outLeaf, inLeaf);

                const [aIn, aOut, aBsp] = nullPartition(bbBsp, aBB, bBB, inLeaf, a, normalize);
                const [bIn, bOut, bBsp] = nullPartition(bbBsp, aBB, bBB, inLeaf, b, normalize);

                if (aIn.length === 0) {
                  const bbMin = max(aBB[MIN$2], bBB[MIN$2]);
                  // There are two ways for aIn to be empty: the space is fully enclosed or fully vacated.
                  const aBsp = fromPolygons$1(a, normalize);
                  if (containsPoint(aBsp, bbMin)) {
                    // The space is fully enclosed; bIn is redundant.
                    s.push([...aOut, ...aIn, ...bOut]);
                  } else {
                    s.push([...aOut, ...aIn, ...bOut]);
                    // The space is fully vacated; nothing overlaps b.
                    s.push([...a, ...b]);
                  }
                } else if (bIn.length === 0) {
                  const bbMin = max(aBB[MIN$2], bBB[MIN$2]);
                  // There are two ways for bIn to be empty: the space is fully enclosed or fully vacated.
                  const bBsp = fromPolygons$1(b, normalize);
                  if (containsPoint(bBsp, bbMin)) {
                    // The space is fully enclosed; aIn is redundant.
                    s.push([...aOut, ...bIn, ...bOut]);
                  } else {
                    // The space is fully vacated; nothing overlaps a.
                    s.push([...a, ...b]);
                  }
                } else {
                  const aTrimmed = removeInteriorPolygonsForUnionKeepingOverlap(
                    bBsp,
                    aIn,
                    normalize
                  );
                  const bTrimmed = removeInteriorPolygonsForUnionDroppingOverlap(
                    aBsp,
                    bIn,
                    normalize
                  );

                  s.push(clean$1([...aOut, ...bTrimmed, ...bOut, ...aTrimmed]));
                }
              }
              return fromPolygons(s[0], normalize);
            };

            const transformImpl$1 = (matrix, untransformed) => {
              if (untransformed.length) throw Error('die');
              if (matrix.some((value) => typeof value !== 'number' || isNaN(value))) {
                throw Error('die');
              }
              return {
                type: 'transform',
                matrix,
                content: [untransformed],
                tags: untransformed.tags,
              };
            };

            const transform$8 = cacheTransform(transformImpl$1);

            const update = (geometry, updates, changes) => {
              if (updates === undefined) {
                return geometry;
              }
              if (geometry === updates) {
                return geometry;
              }
              const updated = {};
              for (const key of Object.keys(geometry)) {
                if (typeof key !== 'symbol') {
                  updated[key] = geometry[key];
                }
              }
              let changed = false;
              for (const key of Object.keys(updates)) {
                if (updates[key] !== updated[key]) {
                  updated[key] = updates[key];
                  changed = true;
                }
              }
              if (changes !== undefined) {
                for (const key of Object.keys(changes)) {
                  if (changes[key] !== updated[key]) {
                    updated[key] = changes[key];
                    changed = true;
                  }
                }
              }
              if (changed) {
                return updated;
              } else {
                return geometry;
              }
            };

            const validateContent = (geometry, content) => {
              if (content && content.some((value) => !value)) {
                for (const v of content) {
                  console.log(`QQ/content: ${v}`);
                }
                throw Error(
                  `Invalid content: ${JSON.stringify(geometry, (k, v) =>
        !v ? `<# ${v} #>` : v
      )} ${JSON.stringify(content, (k, v) => (!v ? `<# ${v} #>` : v))}`
                );
              }
              return content;
            };

            const rewrite = (geometry, op, state) => {
              const walk = (geometry, state) => {
                if (geometry.content) {
                  return op(
                    geometry,
                    (changes, state) =>
                      update(
                        geometry,
                        {
                          content: validateContent(
                            geometry,
                            geometry.content?.map?.((entry) => walk(entry, state))
                          ),
                        },
                        changes
                      ),
                    walk,
                    state
                  );
                } else {
                  return op(geometry, (changes) => update(geometry, changes), walk, state);
                }
              };
              return walk(geometry, state);
            };

            const visit = (geometry, op, state) => {
              const walk = (geometry, state) => {
                if (geometry.content) {
                  if (geometry.content.some((x) => x === undefined)) {
                    throw Error(`Bad geometry: ${JSON.stringify(geometry)}`);
                  }
                  return op(geometry, (_) => geometry.content?.forEach(walk), state);
                } else {
                  return op(geometry, (_) => undefined, state);
                }
              };
              return walk(geometry, state);
            };

            const reconcile$1 = (geometry, normalize = createNormalize3()) =>
              rewrite(geometry, (geometry, descend) => {
                if (geometry.type === 'solid') {
                  return {
                    type: 'solid',
                    solid: reconcile(geometry.solid, normalize),
                    tags: geometry.tags,
                  };
                } else {
                  return descend();
                }
              });

            const makeWatertight$2 = (
              geometry,
              normalize = createNormalize3(),
              onFixed
            ) =>
              rewrite(geometry, (geometry, descend) => {
                if (geometry.type === 'solid') {
                  return {
                    type: 'solid',
                    solid: makeWatertight$1(geometry.solid, normalize, onFixed),
                    tags: geometry.tags,
                  };
                } else {
                  return descend();
                }
              });

            const isWatertight$2 = (geometry) => {
              let watertight = true;
              visit(geometry, (geometry, descend) => {
                if (geometry.type === 'solid' && !isWatertight$1(geometry.solid)) {
                  watertight = false;
                }
                return descend();
              });
              return watertight;
            };

            const isNotVoid = ({ tags }) => {
              return tags === undefined || tags.includes('compose/non-positive') === false;
            };

            const isVoid = (geometry) => !isNotVoid(geometry);

            const allTags = (geometry) => {
              const collectedTags = new Set();
              const op = ({ tags }, descend) => {
                if (tags !== undefined) {
                  for (const tag of tags) {
                    collectedTags.add(tag);
                  }
                }
                descend();
              };
              visit(geometry, op);
              return collectedTags;
            };

            const taggedAssembly = ({ tags }, ...content) => {
              if (content.some((value) => !value)) {
                throw Error(`Undefined Assembly content`);
              }
              if (content.some((value) => value.length)) {
                throw Error(`Assembly content is an array`);
              }
              if (content.some((value) => value.geometry)) {
                throw Error(`Likely Shape instance in Assembly content`);
              }
              if (tags !== undefined && tags.length === undefined) {
                throw Error(`Bad tags`);
              }
              if (typeof tags === 'function') {
                throw Error(`Tags is a function`);
              }
              return { type: 'assembly', tags, content };
            };

            const assembleImpl = (...taggedGeometries) =>
              taggedAssembly({}, ...taggedGeometries);

            const assemble = cache(assembleImpl);

            const taggedSurface = ({ tags }, surface) => {
              return { type: 'surface', tags, surface };
            };

            const taggedZ0Surface = ({ tags }, z0Surface) => {
              return { type: 'z0Surface', tags, z0Surface };
            };

            const transformedGeometry = Symbol('transformedGeometry');

            const toTransformedGeometry = (geometry) => {
              if (geometry[transformedGeometry] === undefined) {
                const op = (geometry, descend, walk, matrix) => {
                  switch (geometry.type) {
                    case 'transform':
                      // Preserve any tags applied to the untransformed geometry.
                      // FIX: Ensure tags are merged between transformed and untransformed upon resolution.
                      return walk(geometry.content[0], multiply$1(matrix, geometry.matrix));
                    case 'assembly':
                    case 'layout':
                    case 'layers':
                    case 'item':
                    case 'sketch':
                      return descend(undefined, matrix);
                    case 'disjointAssembly':
                      if (matrix === identityMatrix) {
                        // A disjointAssembly does not contain any untransformed geometry.
                        // There is no transform, so we can stop here.
                        return geometry;
                      } else {
                        return descend(undefined, matrix);
                      }
                    case 'plan':
                      return descend(
                        {
                          marks: transform$7(matrix, geometry.marks),
                          planes: geometry.planes.map((plane) =>
                            transform$2(matrix, plane)
                          ),
                        },
                        matrix
                      );
                    case 'paths':
                      return descend({ paths: transform$6(matrix, geometry.paths) });
                    case 'points':
                      return descend({ points: transform$7(matrix, geometry.points) });
                    case 'solid':
                      return descend({ solid: transform$5(matrix, geometry.solid) });
                    case 'surface':
                    case 'z0Surface': {
                      const surface = geometry.z0Surface || geometry.surface;
                      if (surface.length === 0) {
                        // Empty geometries don't need transforming, but we'll return a
                        // fresh one to avoid any caching.
                        return taggedSurface({}, []);
                      }
                      const transformedSurface = transform$4(matrix, surface);
                      if (
                        equals$1(toPlane$2(transformedSurface), [0, 0, 1, 0])
                      ) {
                        return taggedZ0Surface({ tags: geometry.tags }, transformedSurface);
                      } else {
                        return taggedSurface({ tags: geometry.tags }, transformedSurface);
                      }
                    }
                    default:
                      throw Error(
                        `Unexpected geometry ${geometry.type} see ${JSON.stringify(
              geometry
            )}`
                      );
                  }
                };
                geometry[transformedGeometry] = rewrite(geometry, op, identityMatrix);
              }
              return geometry[transformedGeometry];
            };

            const canonicalize$9 = (geometry) => {
              const op = (geometry, descend) => {
                switch (geometry.type) {
                  case 'points':
                    return descend({ points: canonicalize$8(geometry.points) });
                  case 'paths':
                    return descend({ paths: canonicalize$7(geometry.paths) });
                  case 'plan':
                    return descend({
                      marks: canonicalize$8(geometry.marks),
                      planes: geometry.planes.map(canonicalize$2),
                    });
                  case 'surface':
                    return descend({ surface: canonicalize$5(geometry.surface) });
                  case 'z0Surface':
                    return descend({ z0Surface: canonicalize$5(geometry.z0Surface) });
                  case 'solid':
                    return descend({ solid: canonicalize$6(geometry.solid) });
                  case 'item':
                  case 'assembly':
                  case 'disjointAssembly':
                  case 'layers':
                  case 'layout':
                  case 'sketch':
                    return descend();
                  default:
                    throw Error(`Unexpected geometry type ${geometry.type}`);
                }
              };
              return rewrite(toTransformedGeometry(geometry), op);
            };

            const eachItem = (geometry, op) => {
              const walk = (geometry, descend) => {
                switch (geometry.type) {
                  case 'sketch': {
                    // Sketches aren't real.
                    return;
                  }
                  default: {
                    op(geometry);
                    return descend();
                  }
                }
              };
              visit(geometry, walk);
            };

            const getAnySurfaces = (geometry) => {
              const surfaces = [];
              eachItem(geometry, (item) => {
                switch (item.type) {
                  case 'surface':
                  case 'z0Surface':
                    surfaces.push(item);
                }
              });
              return surfaces;
            };

            const getPaths = (geometry) => {
              const pathsets = [];
              eachItem(geometry, (item) => {
                if (item.type === 'paths') {
                  pathsets.push(item);
                }
              });
              return pathsets;
            };

            const getSolids = (geometry) => {
              const solids = [];
              eachItem(geometry, (item) => {
                if (item.type === 'solid') {
                  solids.push(item);
                }
              });
              return solids;
            };

            const taggedPaths = ({ tags }, paths) => {
              return { type: 'paths', tags, paths };
            };

            const taggedSolid = ({ tags }, solid) => {
              return { type: 'solid', tags, solid };
            };

            const differenceImpl = (geometry, ...geometries) => {
              const op = (geometry, descend) => {
                const { tags } = geometry;
                switch (geometry.type) {
                  case 'solid': {
                    const normalize = createNormalize3();
                    const todo = [];
                    for (const geometry of geometries) {
                      for (const { solid } of getSolids(geometry)) {
                        todo.push(solid);
                      }
                      for (const { surface, z0Surface } of getAnySurfaces(geometry)) {
                        todo.push(fromSurface$1(surface || z0Surface, normalize));
                      }
                    }
                    return taggedSolid({ tags }, difference$1(geometry.solid, ...todo));
                  }
                  case 'z0Surface':
                  case 'surface': {
                    const normalize = createNormalize3();
                    let thisSurface = geometry.surface || geometry.z0Surface;
                    for (const geometry of geometries) {
                      for (const { solid } of getSolids(geometry)) {
                        const differencedSurface = [];
                        differenceSurface(
                          fromSolid$1(solid),
                          thisSurface,
                          normalize,
                          (surface) => differencedSurface.push(...surface)
                        );
                        thisSurface = differencedSurface;
                      }
                      for (const { surface, z0Surface } of getAnySurfaces(geometry)) {
                        const differencedSurface = [];
                        differenceSurface(
                          fromSurface$2(surface || z0Surface, normalize),
                          thisSurface,
                          normalize,
                          (surface) => differencedSurface.push(...surface)
                        );
                        thisSurface = differencedSurface;
                      }
                    }
                    return taggedSurface({ tags }, makeWatertight(thisSurface));
                  }
                  case 'paths': {
                    const todo = [];
                    for (const geometry of geometries) {
                      for (const { paths } of getPaths(geometry)) {
                        todo.push(paths);
                      }
                    }
                    return taggedPaths({ tags }, difference(geometry.paths, ...todo));
                  }
                  case 'points': {
                    // Not implemented yet.
                    return geometry;
                  }
                  case 'plan':
                  case 'assembly':
                  case 'item':
                  case 'disjointAssembly':
                  case 'layers': {
                    return descend();
                  }
                  case 'sketch': {
                    // Sketches aren't real for intersection.
                    return geometry;
                  }
                  default:
                    throw Error(`Unexpected geometry: ${JSON.stringify(geometry)}`);
                }
              };

              return rewrite(geometry, op);
            };

            /*
            const differenceImpl = (geometry, ...geometries) => {
              const op = (geometry, descend) => {
                const { tags } = geometry;
                switch (geometry.type) {
                  case 'solid': {
                    const todo = [];
                    for (const geometry of geometries) {
                      for (const { solid } of getSolids(geometry)) {
                        todo.push(solid);
                      }
                    }
                    return taggedSolid({ tags }, solidDifference(geometry.solid, ...todo));
                  }
                  case 'surface': {
                    // FIX: Solids should cut surfaces
                    const todo = [];
                    for (const geometry of geometries) {
                      for (const { surface } of getSurfaces(geometry)) {
                        todo.push(surface);
                      }
                      for (const { z0Surface } of getZ0Surfaces(geometry)) {
                        todo.push(z0Surface);
                      }
                    }
                    return taggedSurface(
                      { tags },
                      surfaceDifference(geometry.surface, ...todo)
                    );
                  }
                  case 'z0Surface': {
                    // FIX: Solids should cut surfaces
                    const todoSurfaces = [];
                    const todoZ0Surfaces = [];
                    for (const geometry of geometries) {
                      for (const { surface } of getSurfaces(geometry)) {
                        todoSurfaces.push(surface);
                      }
                      for (const { z0Surface } of getZ0Surfaces(geometry)) {
                        todoZ0Surfaces.push(z0Surface);
                      }
                    }
                    if (todoSurfaces.length > 0) {
                      return taggedSurface(
                        { tags },
                        surfaceDifference(
                          geometry.z0Surface,
                          ...todoSurfaces,
                          ...todoZ0Surfaces
                        )
                      );
                    } else {
                      return taggedZ0Surface(
                        { tags },
                        z0SurfaceDifference(geometry.z0Surface, ...todoZ0Surfaces)
                      );
                    }
                  }
                  case 'paths': {
                    const todo = [];
                    for (const geometry of geometries) {
                      for (const { paths } of getPaths(geometry)) {
                        todo.push(paths);
                      }
                    }
                    return taggedPaths({ tags }, pathsDifference(geometry.paths, ...todo));
                  }
                  case 'assembly':
                  case 'disjointAssembly':
                  case 'layers':
                  case 'plan':
                  case 'item':
                  case 'layout':
                  case 'points': {
                    return descend();
                  }
                  case 'sketch': {
                    // Sketches aren't real for difference.
                    return geometry;
                  }
                  default: {
                    throw Error(`Unknown geometry type ${JSON.stringify(geometry)}`);
                  }
                }
              };

              return rewrite(geometry, op);
            };
            */

            const difference$2 = cache(differenceImpl);

            const hasMatchingTag = (set, tags, whenSetUndefined = false) => {
              if (set === undefined) {
                return whenSetUndefined;
              } else if (tags !== undefined && tags.some((tag) => set.includes(tag))) {
                return true;
              } else {
                return false;
              }
            };

            const buildCondition = (conditionTags, conditionSpec) => {
              switch (conditionSpec) {
                case 'has':
                  return (geometryTags) => hasMatchingTag(geometryTags, conditionTags);
                case 'has not':
                  return (geometryTags) => !hasMatchingTag(geometryTags, conditionTags);
                default:
                  return undefined;
              }
            };

            const rewriteTagsImpl = (
              add,
              remove,
              geometry,
              conditionTags,
              conditionSpec
            ) => {
              const condition = buildCondition(conditionTags, conditionSpec);
              const composeTags = (geometryTags) => {
                if (condition === undefined || condition(geometryTags)) {
                  if (geometryTags === undefined) {
                    return add.filter((tag) => !remove.includes(tag));
                  } else {
                    return [...add, ...geometryTags].filter((tag) => !remove.includes(tag));
                  }
                } else {
                  return geometryTags;
                }
              };
              const op = (geometry, descend) => {
                switch (geometry.type) {
                  case 'assembly':
                  case 'disjointAssembly':
                  case 'layers':
                    return descend();
                  default:
                    const composedTags = composeTags(geometry.tags);
                    if (composedTags === undefined) {
                      const copy = { ...geometry };
                      delete copy.tags;
                      return copy;
                    }
                    if (composedTags === geometry.tags) {
                      return geometry;
                    } else {
                      return descend({ tags: composedTags });
                    }
                }
              };
              return rewrite(geometry, op);
            };

            const rewriteTags = cacheRewriteTags(rewriteTagsImpl);

            // Dropped elements displace as usual, but are not included in positive output.

            const drop = (tags, geometry) =>
              rewriteTags(['compose/non-positive'], [], geometry, tags, 'has');

            const eachPoint$4 = (emit, geometry) => {
              const op = (geometry, descend) => {
                switch (geometry.type) {
                  case 'assembly':
                  case 'disjointAssembly':
                  case 'layers':
                  case 'item':
                  case 'layout':
                    return descend();
                  case 'points':
                    return eachPoint$3(emit, geometry.points);
                  case 'paths':
                    return eachPoint$2(emit, geometry.paths);
                  case 'solid':
                    return eachPoint$1(emit, geometry.solid);
                  case 'surface':
                    return eachPoint(emit, geometry.surface);
                  case 'z0Surface':
                    return eachPoint(emit, geometry.z0Surface);
                  default:
                    throw Error(
                      `Unexpected geometry ${geometry.type} ${JSON.stringify(geometry)}`
                    );
                }
              };
              visit(geometry, op);
            };

            const flip$8 = (geometry) => {
              const op = (geometry, descend) => {
                switch (geometry.type) {
                  case 'points':
                    return { ...geometry, points: flip$7(geometry.points) };
                  case 'paths':
                    return { ...geometry, paths: flip$6(geometry.paths) };
                  case 'surface':
                    return { ...geometry, surface: flip$4(geometry.surface) };
                  case 'z0Surface':
                    return { ...geometry, surface: flip$4(geometry.z0Surface) };
                  case 'solid':
                    return { ...geometry, solid: flip$5(geometry.solid) };
                  case 'assembly':
                  case 'disjointAssembly':
                  case 'layers':
                  case 'layout':
                  case 'plan':
                  case 'item':
                    return descend();
                  default:
                    throw Error(`die: ${JSON.stringify(geometry)}`);
                }
              };
              return rewrite(geometry, op);
            };

            const taggedDisjointAssembly = ({ tags }, ...content) => {
              if (content.some((value) => !value)) {
                throw Error(`Undefined DisjointAssembly content`);
              }
              if (content.some((value) => value.length)) {
                throw Error(`DisjointAssembly content is an array`);
              }
              if (content.some((value) => value.geometry)) {
                throw Error(`Likely Shape instance in DisjointAssembly content`);
              }
              if (tags !== undefined && tags.length === undefined) {
                throw Error(`Bad tags`);
              }
              if (typeof tags === 'function') {
                throw Error(`Tags is a function`);
              }
              const disjointAssembly = { type: 'disjointAssembly', tags, content };
              visit(disjointAssembly, (geometry, descend) => {
                if (geometry.type === 'transform') {
                  throw Error('DisjointAssembly contains transform.');
                }
                return descend();
              });
              return disjointAssembly;
            };

            const linkDisjointAssembly = Symbol('linkDisjointAssembly');

            const toDisjointGeometry = (geometry) => {
              const op = (geometry, descend, walk) => {
                if (geometry[linkDisjointAssembly]) {
                  return geometry[linkDisjointAssembly];
                } else if (geometry.type === 'disjointAssembly') {
                  // Everything below this point is disjoint.
                  return geometry;
                } else if (geometry.type === 'transform') {
                  return walk(toTransformedGeometry(geometry), op);
                } else if (geometry.type === 'assembly') {
                  const assembly = geometry.content.map((entry) => rewrite(entry, op));
                  const disjointAssembly = [];
                  for (let i = assembly.length - 1; i >= 0; i--) {
                    disjointAssembly.unshift(difference$2(assembly[i], ...disjointAssembly));
                  }
                  const disjointed = taggedDisjointAssembly({}, ...disjointAssembly);
                  geometry[linkDisjointAssembly] = disjointed;
                  return disjointed;
                } else {
                  return descend();
                }
              };
              // FIX: Interleave toTransformedGeometry into this rewrite.
              if (geometry.type === 'disjointAssembly') {
                return geometry;
              } else {
                const disjointed = rewrite(geometry, op);
                if (disjointed.type === 'disjointAssembly') {
                  geometry[linkDisjointAssembly] = disjointed;
                  return disjointed;
                } else {
                  const wrapper = taggedDisjointAssembly({}, disjointed);
                  geometry[linkDisjointAssembly] = wrapper;
                  return wrapper;
                }
              }
            };

            const fix = (geometry) => {
              const op = (geometry, descend) => {
                const { tags } = geometry;
                switch (geometry.type) {
                  case 'solid': {
                    const normalize = createNormalize3();
                    const bsp = fromSolid$1(geometry.solid, normalize);
                    const convexSolids = toConvexSolids(bsp, normalize);
                    if (convexSolids.length === 1) {
                      convexSolids[0].tags = tags;
                      return convexSolids[0];
                    } else {
                      return taggedDisjointAssembly({ tags }, ...convexSolids);
                    }
                  }
                  case 'surface':
                  case 'z0Surface':
                  case 'paths':
                  case 'points':
                  case 'plan':
                  case 'assembly':
                  case 'item':
                  case 'disjointAssembly':
                  case 'layers':
                  case 'sketch':
                    // Sketches aren't real for union.
                    return descend();
                  default:
                    throw Error(`Unexpected geometry: ${JSON.stringify(geometry)}`);
                }
              };

              return rewrite(toDisjointGeometry(geometry), op);
            };

            const fromPathsToSurfaceImpl = (paths) => {
              return taggedSurface({}, makeConvex$1(paths, createNormalize3()));
            };

            const fromPathsToSurface = cache(fromPathsToSurfaceImpl);

            const fromPathToSurfaceImpl = (path) => fromPathsToSurface([path]);

            const fromPathToSurface = cache(fromPathToSurfaceImpl);

            const fromSurfaceToPathsImpl = (surface) => {
              return { type: 'paths', paths: surface };
            };

            const fromSurfaceToPaths = cache(fromSurfaceToPathsImpl);

            const eachNonVoidItem = (geometry, op) => {
              const walk = (geometry, descend) => {
                // FIX: Sketches aren't real either -- but this is a bit unclear.
                if (geometry.type !== 'sketch' && isNotVoid(geometry)) {
                  op(geometry);
                  descend();
                }
              };
              visit(geometry, walk);
            };

            const getAnyNonVoidSurfaces = (geometry) => {
              const surfaces = [];
              eachNonVoidItem(geometry, (item) => {
                switch (item.type) {
                  case 'surface':
                  case 'z0Surface':
                    surfaces.push(item);
                }
              });
              return surfaces;
            };

            const getItems = (geometry) => {
              const items = [];
              const op = (geometry, descend) => {
                switch (geometry.type) {
                  case 'item':
                    return items.push(geometry);
                  case 'sketch':
                    // We don't look inside sketches.
                    return;
                  default:
                    return descend();
                }
              };
              visit(geometry, op);
              return items;
            };

            const getLayouts = (geometry) => {
              const layouts = [];
              eachItem(geometry, (item) => {
                if (item.type === 'layout') {
                  layouts.push(item);
                }
              });
              return layouts;
            };

            // Retrieve leaf geometry.

            const getLeafs = (geometry) => {
              const leafs = [];
              const op = (geometry, descend) => {
                switch (geometry.type) {
                  case 'assembly':
                  case 'disjointAssembly':
                  case 'layers':
                  case 'layout':
                    return descend();
                  default:
                    return leafs.push(geometry);
                }
              };
              visit(geometry, op);
              return leafs;
            };

            const getNonVoidPaths = (geometry) => {
              const pathsets = [];
              eachNonVoidItem(geometry, (item) => {
                if (item.type === 'paths') {
                  pathsets.push(item);
                }
              });
              return pathsets;
            };

            const getNonVoidPoints = (geometry) => {
              const pointsets = [];
              eachNonVoidItem(geometry, (item) => {
                if (item.type === 'points') {
                  pointsets.push(item);
                }
              });
              return pointsets;
            };

            const getNonVoidSolids = (geometry) => {
              const solids = [];
              eachNonVoidItem(geometry, (item) => {
                if (item.type === 'solid') {
                  solids.push(item);
                }
              });
              return solids;
            };

            const getNonVoidSurfaces = (geometry) => {
              const surfaces = [];
              eachNonVoidItem(geometry, (item) => {
                if (item.type === 'surface') {
                  surfaces.push(item);
                }
              });
              return surfaces;
            };

            const getNonVoidZ0Surfaces = (geometry) => {
              const z0Surfaces = [];
              eachNonVoidItem(geometry, (item) => {
                if (item.type === 'z0Surface') {
                  z0Surfaces.push(item);
                }
              });
              return z0Surfaces;
            };

            const getPlans = (geometry) => {
              const plans = [];
              eachItem(geometry, (item) => {
                if (item.type === 'plan') {
                  plans.push(item);
                }
              });
              return plans;
            };

            const getSurfaces = (geometry) => {
              const surfaces = [];
              eachItem(geometry, (item) => {
                if (item.type === 'surface') {
                  surfaces.push(item);
                }
              });
              return surfaces;
            };

            const getZ0Surfaces = (geometry) => {
              const z0Surfaces = [];
              eachItem(geometry, (item) => {
                if (item.type === 'z0Surface') {
                  z0Surfaces.push(item);
                }
              });
              return z0Surfaces;
            };

            const taggedLayers = ({ tags }, ...content) => {
              if (content.some((value) => !value)) {
                throw Error(`Undefined Layers content`);
              }
              if (content.some((value) => value.length)) {
                throw Error(`Layers content is an array`);
              }
              return { type: 'layers', tags, content };
            };

            const toBspTree = (geometry, normalize) => {
              // Start with an empty tree.
              let bspTree = fromSolid$1([], normalize);
              const op = (geometry, descend) => {
                switch (geometry.type) {
                  case 'solid': {
                    bspTree = unifyBspTrees(
                      bspTree,
                      fromSolid$1(geometry.solid, normalize)
                    );
                    return descend();
                  }
                  // FIX: We want some distinction between volumes for membership and volumes for composition.
                  case 'surface':
                  case 'z0Surface': {
                    bspTree = unifyBspTrees(
                      bspTree,
                      fromSurface$2(geometry.surface || geometry.z0Surface, normalize)
                    );
                    return descend();
                  }
                  case 'paths':
                  case 'points':
                  case 'plan':
                  case 'assembly':
                  case 'item':
                  case 'disjointAssembly':
                  case 'layers':
                  case 'sketch': {
                    return descend();
                  }
                  default:
                    throw Error(`Unexpected geometry: ${JSON.stringify(geometry)}`);
                }
              };

              visit(geometry, op);

              return bspTree;
            };

            const intersectionImpl = (geometry, ...geometries) => {
              const op = (geometry, descend) => {
                const { tags } = geometry;
                switch (geometry.type) {
                  case 'solid': {
                    const normalize = createNormalize3();
                    const otherGeometry = geometries[0];
                    const solids = [
                      ...getNonVoidSolids(otherGeometry).map(({ solid }) => solid),
                      ...getAnyNonVoidSurfaces(
                        otherGeometry
                      ).map(({ surface, z0Surface }) =>
                        fromSurface$1(surface || z0Surface, normalize)
                      ),
                    ];
                    const intersections = solids
                      .map((solid) => intersection(geometry.solid, solid))
                      .filter((solid) => solid.length > 0)
                      .map((solid) => taggedSolid({ tags }, solid));
                    if (intersections.length === 1) {
                      return intersections[0];
                    } else if (geometries.length === 1) {
                      return taggedLayers({}, ...intersections);
                    } else {
                      return intersection$1(
                        taggedLayers({}, ...intersections),
                        ...geometries.slice(1)
                      );
                    }
                  }
                  case 'z0Surface':
                  case 'surface': {
                    const normalize = createNormalize3();
                    const thisSurface = geometry.surface || geometry.z0Surface;
                    const otherGeometry = geometries[0];
                    const solids = [
                      ...getNonVoidSolids(otherGeometry).map(({ solid }) => solid),
                      ...getAnyNonVoidSurfaces(
                        otherGeometry
                      ).map(({ surface, z0Surface }) =>
                        fromSurface$1(surface || z0Surface, normalize)
                      ),
                    ];
                    const intersections = solids
                      .map((solid) => {
                        const intersectedSurface = [];
                        intersectSurface(
                          fromSolid$1(solid, normalize),
                          thisSurface,
                          normalize,
                          (surface) => intersectedSurface.push(...surface)
                        );
                        return intersectedSurface;
                      })
                      .filter((surface) => surface.length > 0)
                      .map((surface) =>
                        taggedSurface({ tags }, makeWatertight(surface))
                      );
                    if (intersections.length === 1) {
                      return intersections[0];
                    } else if (geometries.length === 1) {
                      return taggedLayers({}, ...intersections);
                    } else {
                      return intersection$1(
                        taggedLayers({}, ...intersections),
                        ...geometries.slice(1)
                      );
                    }
                  }
                  case 'paths': {
                    const normalize = createNormalize3();
                    let thisPaths = geometry.paths;
                    for (const geometry of geometries) {
                      const bsp = toBspTree(geometry, normalize);
                      const clippedPaths = [];
                      removeExteriorPaths(bsp, thisPaths, normalize, (paths) =>
                        clippedPaths.push(...paths)
                      );
                      thisPaths = clippedPaths;
                    }
                    return taggedPaths({ tags }, thisPaths);
                  }
                  case 'points': {
                    // Not implemented yet.
                    return geometry;
                  }
                  case 'plan':
                  case 'assembly':
                  case 'item':
                  case 'disjointAssembly':
                  case 'layers': {
                    return descend();
                  }
                  case 'sketch': {
                    // Sketches aren't real for intersection.
                    return geometry;
                  }
                  default:
                    throw Error(`Unexpected geometry: ${JSON.stringify(geometry)}`);
                }
              };

              return rewrite(geometry, op);
            };

            const intersection$1 = cache(intersectionImpl);

            // DEPRECATED
            const toKeptGeometry = (geometry) => toDisjointGeometry(geometry);

            const measureArea$3 = (rawGeometry) => {
              const geometry = toKeptGeometry(rawGeometry);
              let area = 0;
              const op = (geometry, descend) => {
                if (isVoid(geometry)) {
                  return;
                }
                switch (geometry.type) {
                  case 'surface':
                    area += measureArea$2(geometry.surface);
                    break;
                  case 'z0Surface':
                    area += measureArea$2(geometry.z0Surface);
                    break;
                  case 'solid':
                    for (const surface of geometry.solid) {
                      area += measureArea$2(surface);
                    }
                    break;
                }
                descend();
              };
              visit(geometry, op);
              return area;
            };

            const measureBoundingBoxGeneric = (geometry) => {
              let minPoint = [Infinity, Infinity, Infinity];
              let maxPoint = [-Infinity, -Infinity, -Infinity];
              eachPoint$4((point) => {
                minPoint = min(minPoint, point);
                maxPoint = max(maxPoint, point);
              }, geometry);
              return [minPoint, maxPoint];
            };

            const measureBoundingBox$4 = (geometry) => {
              let minPoint = [Infinity, Infinity, Infinity];
              let maxPoint = [-Infinity, -Infinity, -Infinity];

              const update = ([itemMinPoint, itemMaxPoint]) => {
                minPoint = min(minPoint, itemMinPoint);
                maxPoint = max(maxPoint, itemMaxPoint);
              };

              const op = (geometry, descend) => {
                if (isVoid(geometry)) {
                  return;
                }
                switch (geometry.type) {
                  case 'assembly':
                  case 'layers':
                  case 'disjointAssembly':
                  case 'item':
                  case 'plan':
                  case 'sketch':
                    return descend();
                  case 'layout':
                    return update(geometry.marks);
                  case 'solid':
                    return update(measureBoundingBox$3(geometry.solid));
                  case 'surface':
                    return update(measureBoundingBox$2(geometry.surface));
                  case 'z0Surface':
                    return update(measureBoundingBox$1(geometry.z0Surface));
                  case 'points':
                  case 'paths':
                    return update(measureBoundingBoxGeneric(geometry));
                  default:
                    throw Error(`Unknown geometry: ${geometry.type}`);
                }
              };

              visit(toKeptGeometry(geometry), op);

              return [minPoint, maxPoint];
            };

            const X$8 = 0;
            const Y$8 = 1;
            const Z$7 = 2;

            const measureHeights = (geometry, resolution = 1) => {
              const normalize = createNormalize3();
              const [min, max] = measureBoundingBox$4(geometry);
              const bspTree = toBspTree(geometry, normalize);
              const paths = [];
              const minX = Math.floor(min[X$8]);
              const maxX = Math.ceil(max[X$8]);
              const minY = Math.floor(min[Y$8]);
              const maxY = Math.ceil(max[Y$8]);
              for (let x = minX; x <= maxX; x += resolution) {
                for (let y = minY; y <= maxY; y += resolution) {
                  paths.push(
                    createOpenPath(normalize([x, y, min[Z$7]]), normalize([x, y, max[Z$7]]))
                  );
                }
              }
              const clippedPaths = [];
              removeExteriorPaths(bspTree, paths, normalize, (paths) =>
                clippedPaths.push(...paths)
              );
              const heights = new Map();
              const op = (point) => {
                const key = `${point[X$8]}/${point[Y$8]}`;
                if (!heights.has(key) || heights.get(key)[Z$7] < point[Z$7]) {
                  heights.set(key, point);
                }
              };
              eachPoint$2(op, clippedPaths);
              return [...heights.values()];
            };

            const outlineImpl = (geometry, includeFaces = true, includeHoles = true) => {
              const normalize = createNormalize3();

              // FIX: This assumes general coplanarity.
              const keptGeometry = toKeptGeometry(geometry);
              const outlines = [];
              for (const { solid } of getNonVoidSolids(keptGeometry)) {
                outlines.push(outlineSolid(solid, normalize));
              }
              // This is a bit tricky -- let's consider an assembly that produces an effective surface.
              // For now, let's consolidate, and see what goes terribly wrong.
              for (const surface of getAnyNonVoidSurfaces(keptGeometry).map(
                ({ surface, z0Surface }) => surface || z0Surface
              )) {
                outlines.push(
                  outlineSurface(surface, normalize, includeFaces, includeHoles)
                );
              }
              return outlines.map((outline) => taggedPaths({}, outline));
            };

            const outline = cache(outlineImpl);

            const taggedItem = ({ tags }, ...content) => {
              if (tags !== undefined && tags.length === undefined) {
                throw Error(`Bad tags: ${tags}`);
              }
              if (content.some((value) => value === undefined)) {
                throw Error(`Undefined Item content`);
              }
              if (content.length !== 1) {
                throw Error(`Item expects a single content geometry`);
              }
              return { type: 'item', tags, content };
            };

            const taggedLayout = (
              { tags, size, margin, title, marks = [] },
              ...content
            ) => {
              if (content.some((value) => value === undefined)) {
                throw Error(`Undefined Layout content`);
              }
              if (content.some((value) => value.length)) {
                throw Error(`Layout content is an array`);
              }
              if (content.some((value) => value.geometry)) {
                throw Error(`Likely Shape in Layout`);
              }
              return {
                type: 'layout',
                layout: { size, margin, title },
                marks,
                tags,
                content,
              };
            };

            const taggedPoints = ({ tags }, points) => {
              return { type: 'points', tags, points };
            };

            const taggedSketch = ({ tags }, ...content) => {
              if (content.some((value) => value === undefined)) {
                throw Error(`Undefined Sketch content`);
              }
              if (content.length !== 1) {
                throw Error(`Sketch expects a single content geometry`);
              }
              return { type: 'sketch', tags, content };
            };

            // The resolution is 1 / multiplier.
            const multiplier = 1e5;

            const X$1$5 = 0;
            const Y$1$5 = 1;
            const Z$1$4 = 2;

            // FIX: Use createNormalize3
            const createPointNormalizer = () => {
              const map = new Map();
              const normalize = (coordinate) => {
                // Apply a spatial quantization to the 3 dimensional coordinate.
                const nx = Math.floor(coordinate[X$1$5] * multiplier - 0.5);
                const ny = Math.floor(coordinate[Y$1$5] * multiplier - 0.5);
                const nz = Math.floor(coordinate[Z$1$4] * multiplier - 0.5);
                // Look for an existing inhabitant.
                const value = map.get(`${nx}/${ny}/${nz}`);
                if (value !== undefined) {
                  return value;
                }
                // One of the ~0 or ~1 values will match the rounded values above.
                // The other will match the adjacent cell.
                const nx0 = nx;
                const ny0 = ny;
                const nz0 = nz;
                const nx1 = nx0 + 1;
                const ny1 = ny0 + 1;
                const nz1 = nz0 + 1;
                // Populate the space of the quantized coordinate and its adjacencies.
                // const normalized = [nx1 / multiplier, ny1 / multiplier, nz1 / multiplier];
                const normalized = coordinate;
                map.set(`${nx0}/${ny0}/${nz0}`, normalized);
                map.set(`${nx0}/${ny0}/${nz1}`, normalized);
                map.set(`${nx0}/${ny1}/${nz0}`, normalized);
                map.set(`${nx0}/${ny1}/${nz1}`, normalized);
                map.set(`${nx1}/${ny0}/${nz0}`, normalized);
                map.set(`${nx1}/${ny0}/${nz1}`, normalized);
                map.set(`${nx1}/${ny1}/${nz0}`, normalized);
                map.set(`${nx1}/${ny1}/${nz1}`, normalized);
                // This is now the normalized coordinate for this region.
                return normalized;
              };
              return normalize;
            };

            const toPoints = (geometry) => {
              const normalize = createPointNormalizer();
              const points = new Set();
              eachPoint$4((point) => points.add(normalize(point)), geometry);
              return { type: 'points', points: [...points] };
            };

            // Union is a little more complex, since it can violate disjointAssembly invariants.
            const unionImpl = (geometry, ...geometries) => {
              const op = (geometry, descend) => {
                const { tags } = geometry;
                switch (geometry.type) {
                  case 'solid': {
                    const solids = [];
                    for (const geometry of geometries) {
                      for (const { solid } of getNonVoidSolids(geometry)) {
                        solids.push(solid);
                      }
                    }
                    // No meaningful way to unify with a surface.
                    return taggedSolid({ tags }, union$2(geometry.solid, ...solids));
                  }
                  case 'surface':
                  case 'z0Surface': {
                    const normalize = createNormalize3();
                    const thisSurface = geometry.surface || geometry.z0Surface;
                    let planarPolygon = toPolygon(toPlane$2(thisSurface));
                    const solids = [];
                    for (const input of [geometry, ...geometries]) {
                      for (const { solid } of getNonVoidSolids(input)) {
                        solids.push(solid);
                      }
                      for (const { surface, z0Surface } of getAnyNonVoidSurfaces(input)) {
                        solids.push(fromSurface$1(surface || z0Surface, normalize));
                      }
                    }
                    const unionedSolid = union$2(...solids);
                    const clippedPolygons = [];
                    intersectSurface(
                      fromSolid$1(unionedSolid, normalize),
                      [planarPolygon],
                      normalize,
                      (polygons) => clippedPolygons.push(...polygons)
                    );
                    return taggedSurface(
                      { tags },
                      makeWatertight(clippedPolygons, normalize)
                    );
                  }
                  case 'paths': {
                    const { paths, tags } = geometry;
                    const pathsets = [];
                    for (const { paths } of getNonVoidPaths(geometry)) {
                      pathsets.push(paths);
                    }
                    return taggedPaths({ tags }, union(paths, ...pathsets));
                  }
                  case 'points': {
                    const { points, tags } = geometry;
                    const pointsets = [];
                    for (const { points } of getNonVoidPoints(geometry)) {
                      pointsets.push(points);
                    }
                    return taggedPoints({ tags }, union$1(points, ...pointsets));
                  }
                  case 'plan':
                  case 'assembly':
                  case 'item':
                  case 'disjointAssembly':
                  case 'layers': {
                    return descend();
                  }
                  case 'sketch': {
                    // Sketches aren't real for union.
                    return geometry;
                  }
                  default:
                    throw Error(`Unexpected geometry: ${JSON.stringify(geometry)}`);
                }
              };

              return rewrite(geometry, op);
            };

            const union$3 = cache(unionImpl);
            const translate$4 = (vector, geometry) =>
              transform$8(fromTranslation(vector), geometry);

            // Derived from npm color-namer due to issue with rollup and weak maps.

            var colors = [
              { name: 'black', rgb: 0x000000, origin: 'basic' },
              { name: 'blue', rgb: 0x0000ff, origin: 'basic' },
              { name: 'cyan', rgb: 0x00ffff, origin: 'basic' },
              { name: 'green', rgb: 0x008000, origin: 'basic' },
              { name: 'teal', rgb: 0x008080, origin: 'basic' },
              { name: 'turquoise', rgb: 0x40e0d0, origin: 'basic' },
              { name: 'indigo', rgb: 0x4b0082, origin: 'basic' },
              { name: 'gray', rgb: 0x808080, origin: 'basic' },
              { name: 'purple', rgb: 0x800080, origin: 'basic' },
              { name: 'brown', rgb: 0xa52a2a, origin: 'basic' },
              { name: 'tan', rgb: 0xd2b48c, origin: 'basic' },
              { name: 'violet', rgb: 0xee82ee, origin: 'basic' },
              { name: 'beige', rgb: 0xf5f5dc, origin: 'basic' },
              { name: 'fuchsia', rgb: 0xff00ff, origin: 'basic' },
              { name: 'gold', rgb: 0xffd700, origin: 'basic' },
              { name: 'magenta', rgb: 0xff00ff, origin: 'basic' },
              { name: 'orange', rgb: 0xffa500, origin: 'basic' },
              { name: 'pink', rgb: 0xffc0cb, origin: 'basic' },
              { name: 'red', rgb: 0xff0000, origin: 'basic' },
              { name: 'white', rgb: 0xffffff, origin: 'basic' },
              { name: 'yellow', rgb: 0xffff00, origin: 'basic' },
              { name: 'aqua', rgb: 0x00ffff, origin: 'html' },
              { name: 'aliceblue', rgb: 0xf0f8ff, origin: 'html' },
              { name: 'antiquewhite', rgb: 0xfaebd7, origin: 'html' },
              { name: 'black', rgb: 0x000000, origin: 'html' },
              { name: 'blue', rgb: 0x0000ff, origin: 'html' },
              { name: 'cyan', rgb: 0x00ffff, origin: 'html' },
              { name: 'darkblue', rgb: 0x00008b, origin: 'html' },
              { name: 'darkcyan', rgb: 0x008b8b, origin: 'html' },
              { name: 'darkgreen', rgb: 0x006400, origin: 'html' },
              { name: 'darkturquoise', rgb: 0x00ced1, origin: 'html' },
              { name: 'deepskyblue', rgb: 0x00bfff, origin: 'html' },
              { name: 'green', rgb: 0x008000, origin: 'html' },
              { name: 'lime', rgb: 0x00ff00, origin: 'html' },
              { name: 'mediumblue', rgb: 0x0000cd, origin: 'html' },
              { name: 'mediumspringgreen', rgb: 0x00fa9a, origin: 'html' },
              { name: 'navy', rgb: 0x000080, origin: 'html' },
              { name: 'springgreen', rgb: 0x00ff7f, origin: 'html' },
              { name: 'teal', rgb: 0x008080, origin: 'html' },
              { name: 'midnightblue', rgb: 0x191970, origin: 'html' },
              { name: 'dodgerblue', rgb: 0x1e90ff, origin: 'html' },
              { name: 'lightseagreen', rgb: 0x20b2aa, origin: 'html' },
              { name: 'forestgreen', rgb: 0x228b22, origin: 'html' },
              { name: 'seagreen', rgb: 0x2e8b57, origin: 'html' },
              { name: 'darkslategray', rgb: 0x2f4f4f, origin: 'html' },
              { name: 'darkslategrey', rgb: 0x2f4f4f, origin: 'html' },
              { name: 'limegreen', rgb: 0x32cd32, origin: 'html' },
              { name: 'mediumseagreen', rgb: 0x3cb371, origin: 'html' },
              { name: 'turquoise', rgb: 0x40e0d0, origin: 'html' },
              { name: 'royalblue', rgb: 0x4169e1, origin: 'html' },
              { name: 'steelblue', rgb: 0x4682b4, origin: 'html' },
              { name: 'darkslateblue', rgb: 0x483d8b, origin: 'html' },
              { name: 'mediumturquoise', rgb: 0x48d1cc, origin: 'html' },
              { name: 'indigo', rgb: 0x4b0082, origin: 'html' },
              { name: 'darkolivegreen', rgb: 0x556b2f, origin: 'html' },
              { name: 'cadetblue', rgb: 0x5f9ea0, origin: 'html' },
              { name: 'cornflowerblue', rgb: 0x6495ed, origin: 'html' },
              { name: 'mediumaquamarine', rgb: 0x66cdaa, origin: 'html' },
              { name: 'dimgray', rgb: 0x696969, origin: 'html' },
              { name: 'dimgrey', rgb: 0x696969, origin: 'html' },
              { name: 'slateblue', rgb: 0x6a5acd, origin: 'html' },
              { name: 'olivedrab', rgb: 0x6b8e23, origin: 'html' },
              { name: 'slategray', rgb: 0x708090, origin: 'html' },
              { name: 'slategrey', rgb: 0x708090, origin: 'html' },
              { name: 'lightslategray', rgb: 0x778899, origin: 'html' },
              { name: 'lightslategrey', rgb: 0x778899, origin: 'html' },
              { name: 'mediumslateblue', rgb: 0x7b68ee, origin: 'html' },
              { name: 'lawngreen', rgb: 0x7cfc00, origin: 'html' },
              { name: 'aquamarine', rgb: 0x7fffd4, origin: 'html' },
              { name: 'chartreuse', rgb: 0x7fff00, origin: 'html' },
              { name: 'gray', rgb: 0x808080, origin: 'html' },
              { name: 'grey', rgb: 0x808080, origin: 'html' },
              { name: 'maroon', rgb: 0x800000, origin: 'html' },
              { name: 'olive', rgb: 0x808000, origin: 'html' },
              { name: 'purple', rgb: 0x800080, origin: 'html' },
              { name: 'lightskyblue', rgb: 0x87cefa, origin: 'html' },
              { name: 'skyblue', rgb: 0x87ceeb, origin: 'html' },
              { name: 'blueviolet', rgb: 0x8a2be2, origin: 'html' },
              { name: 'darkmagenta', rgb: 0x8b008b, origin: 'html' },
              { name: 'darkred', rgb: 0x8b0000, origin: 'html' },
              { name: 'saddlebrown', rgb: 0x8b4513, origin: 'html' },
              { name: 'darkseagreen', rgb: 0x8fbc8f, origin: 'html' },
              { name: 'lightgreen', rgb: 0x90ee90, origin: 'html' },
              { name: 'mediumpurple', rgb: 0x9370db, origin: 'html' },
              { name: 'darkviolet', rgb: 0x9400d3, origin: 'html' },
              { name: 'palegreen', rgb: 0x98fb98, origin: 'html' },
              { name: 'darkorchid', rgb: 0x9932cc, origin: 'html' },
              { name: 'yellowgreen', rgb: 0x9acd32, origin: 'html' },
              { name: 'sienna', rgb: 0xa0522d, origin: 'html' },
              { name: 'brown', rgb: 0xa52a2a, origin: 'html' },
              { name: 'darkgray', rgb: 0xa9a9a9, origin: 'html' },
              { name: 'darkgrey', rgb: 0xa9a9a9, origin: 'html' },
              { name: 'greenyellow', rgb: 0xadff2f, origin: 'html' },
              { name: 'lightblue', rgb: 0xadd8e6, origin: 'html' },
              { name: 'paleturquoise', rgb: 0xafeeee, origin: 'html' },
              { name: 'lightsteelblue', rgb: 0xb0c4de, origin: 'html' },
              { name: 'powderblue', rgb: 0xb0e0e6, origin: 'html' },
              { name: 'firebrick', rgb: 0xb22222, origin: 'html' },
              { name: 'darkgoldenrod', rgb: 0xb8860b, origin: 'html' },
              { name: 'mediumorchid', rgb: 0xba55d3, origin: 'html' },
              { name: 'rosybrown', rgb: 0xbc8f8f, origin: 'html' },
              { name: 'darkkhaki', rgb: 0xbdb76b, origin: 'html' },
              { name: 'silver', rgb: 0xc0c0c0, origin: 'html' },
              { name: 'mediumvioletred', rgb: 0xc71585, origin: 'html' },
              { name: 'indianred', rgb: 0xcd5c5c, origin: 'html' },
              { name: 'peru', rgb: 0xcd853f, origin: 'html' },
              { name: 'chocolate', rgb: 0xd2691e, origin: 'html' },
              { name: 'tan', rgb: 0xd2b48c, origin: 'html' },
              { name: 'lightgray', rgb: 0xd3d3d3, origin: 'html' },
              { name: 'lightgrey', rgb: 0xd3d3d3, origin: 'html' },
              { name: 'thistle', rgb: 0xd8bfd8, origin: 'html' },
              { name: 'goldenrod', rgb: 0xdaa520, origin: 'html' },
              { name: 'orchid', rgb: 0xda70d6, origin: 'html' },
              { name: 'palevioletred', rgb: 0xdb7093, origin: 'html' },
              { name: 'crimson', rgb: 0xdc143c, origin: 'html' },
              { name: 'gainsboro', rgb: 0xdcdcdc, origin: 'html' },
              { name: 'plum', rgb: 0xdda0dd, origin: 'html' },
              { name: 'burlywood', rgb: 0xdeb887, origin: 'html' },
              { name: 'lightcyan', rgb: 0xe0ffff, origin: 'html' },
              { name: 'lavender', rgb: 0xe6e6fa, origin: 'html' },
              { name: 'darksalmon', rgb: 0xe9967a, origin: 'html' },
              { name: 'palegoldenrod', rgb: 0xeee8aa, origin: 'html' },
              { name: 'violet', rgb: 0xee82ee, origin: 'html' },
              { name: 'azure', rgb: 0xf0ffff, origin: 'html' },
              { name: 'honeydew', rgb: 0xf0fff0, origin: 'html' },
              { name: 'khaki', rgb: 0xf0e68c, origin: 'html' },
              { name: 'lightcoral', rgb: 0xf08080, origin: 'html' },
              { name: 'sandybrown', rgb: 0xf4a460, origin: 'html' },
              { name: 'beige', rgb: 0xf5f5dc, origin: 'html' },
              { name: 'mintcream', rgb: 0xf5fffa, origin: 'html' },
              { name: 'wheat', rgb: 0xf5deb3, origin: 'html' },
              { name: 'whitesmoke', rgb: 0xf5f5f5, origin: 'html' },
              { name: 'ghostwhite', rgb: 0xf8f8ff, origin: 'html' },
              { name: 'lightgoldenrodyellow', rgb: 0xfafad2, origin: 'html' },
              { name: 'linen', rgb: 0xfaf0e6, origin: 'html' },
              { name: 'salmon', rgb: 0xfa8072, origin: 'html' },
              { name: 'oldlace', rgb: 0xfdf5e6, origin: 'html' },
              { name: 'bisque', rgb: 0xffe4c4, origin: 'html' },
              { name: 'blanchedalmond', rgb: 0xffebcd, origin: 'html' },
              { name: 'coral', rgb: 0xff7f50, origin: 'html' },
              { name: 'cornsilk', rgb: 0xfff8dc, origin: 'html' },
              { name: 'darkorange', rgb: 0xff8c00, origin: 'html' },
              { name: 'deeppink', rgb: 0xff1493, origin: 'html' },
              { name: 'floralwhite', rgb: 0xfffaf0, origin: 'html' },
              { name: 'fuchsia', rgb: 0xff00ff, origin: 'html' },
              { name: 'gold', rgb: 0xffd700, origin: 'html' },
              { name: 'hotpink', rgb: 0xff69b4, origin: 'html' },
              { name: 'ivory', rgb: 0xfffff0, origin: 'html' },
              { name: 'lavenderblush', rgb: 0xfff0f5, origin: 'html' },
              { name: 'lemonchiffon', rgb: 0xfffacd, origin: 'html' },
              { name: 'lightpink', rgb: 0xffb6c1, origin: 'html' },
              { name: 'lightsalmon', rgb: 0xffa07a, origin: 'html' },
              { name: 'lightyellow', rgb: 0xffffe0, origin: 'html' },
              { name: 'magenta', rgb: 0xff00ff, origin: 'html' },
              { name: 'mistyrose', rgb: 0xffe4e1, origin: 'html' },
              { name: 'moccasin', rgb: 0xffe4b5, origin: 'html' },
              { name: 'navajowhite', rgb: 0xffdead, origin: 'html' },
              { name: 'orange', rgb: 0xffa500, origin: 'html' },
              { name: 'orangered', rgb: 0xff4500, origin: 'html' },
              { name: 'papayawhip', rgb: 0xffefd5, origin: 'html' },
              { name: 'peachpuff', rgb: 0xffdab9, origin: 'html' },
              { name: 'pink', rgb: 0xffc0cb, origin: 'html' },
              { name: 'red', rgb: 0xff0000, origin: 'html' },
              { name: 'seashell', rgb: 0xfff5ee, origin: 'html' },
              { name: 'snow', rgb: 0xfffafa, origin: 'html' },
              { name: 'tomato', rgb: 0xff6347, origin: 'html' },
              { name: 'white', rgb: 0xffffff, origin: 'html' },
              { name: 'yellow', rgb: 0xffff00, origin: 'html' },
              { name: 'black', rgb: 0x000000, origin: './ntc' },
              { name: 'navy blue', rgb: 0x000080, origin: './ntc' },
              { name: 'dark blue', rgb: 0x0000c8, origin: './ntc' },
              { name: 'blue', rgb: 0x0000ff, origin: './ntc' },
              { name: 'stratos', rgb: 0x000741, origin: './ntc' },
              { name: 'swamp', rgb: 0x001b1c, origin: './ntc' },
              { name: 'resolution blue', rgb: 0x002387, origin: './ntc' },
              { name: 'deep fir', rgb: 0x002900, origin: './ntc' },
              { name: 'burnham', rgb: 0x002e20, origin: './ntc' },
              { name: 'international klein blue', rgb: 0x002fa7, origin: './ntc' },
              { name: 'prussian blue', rgb: 0x003153, origin: './ntc' },
              { name: 'midnight blue', rgb: 0x003366, origin: './ntc' },
              { name: 'smalt', rgb: 0x003399, origin: './ntc' },
              { name: 'deep teal', rgb: 0x003532, origin: './ntc' },
              { name: 'cyprus', rgb: 0x003e40, origin: './ntc' },
              { name: 'kaitoke green', rgb: 0x004620, origin: './ntc' },
              { name: 'cobalt', rgb: 0x0047ab, origin: './ntc' },
              { name: 'crusoe', rgb: 0x004816, origin: './ntc' },
              { name: 'sherpa blue', rgb: 0x004950, origin: './ntc' },
              { name: 'endeavour', rgb: 0x0056a7, origin: './ntc' },
              { name: 'camarone', rgb: 0x00581a, origin: './ntc' },
              { name: 'science blue', rgb: 0x0066cc, origin: './ntc' },
              { name: 'blue ribbon', rgb: 0x0066ff, origin: './ntc' },
              { name: 'tropical rain forest', rgb: 0x00755e, origin: './ntc' },
              { name: 'allports', rgb: 0x0076a3, origin: './ntc' },
              { name: 'deep cerulean', rgb: 0x007ba7, origin: './ntc' },
              { name: 'lochmara', rgb: 0x007ec7, origin: './ntc' },
              { name: 'azure radiance', rgb: 0x007fff, origin: './ntc' },
              { name: 'teal', rgb: 0x008080, origin: './ntc' },
              { name: 'bondi blue', rgb: 0x0095b6, origin: './ntc' },
              { name: 'pacific blue', rgb: 0x009dc4, origin: './ntc' },
              { name: 'persian green', rgb: 0x00a693, origin: './ntc' },
              { name: 'jade', rgb: 0x00a86b, origin: './ntc' },
              { name: 'caribbean green', rgb: 0x00cc99, origin: './ntc' },
              { name: "robin's egg blue", rgb: 0x00cccc, origin: './ntc' },
              { name: 'green', rgb: 0x00ff00, origin: './ntc' },
              { name: 'spring green', rgb: 0x00ff7f, origin: './ntc' },
              { name: 'cyan / aqua', rgb: 0x00ffff, origin: './ntc' },
              { name: 'blue charcoal', rgb: 0x010d1a, origin: './ntc' },
              { name: 'midnight', rgb: 0x011635, origin: './ntc' },
              { name: 'holly', rgb: 0x011d13, origin: './ntc' },
              { name: 'daintree', rgb: 0x012731, origin: './ntc' },
              { name: 'cardin green', rgb: 0x01361c, origin: './ntc' },
              { name: 'county green', rgb: 0x01371a, origin: './ntc' },
              { name: 'astronaut blue', rgb: 0x013e62, origin: './ntc' },
              { name: 'regal blue', rgb: 0x013f6a, origin: './ntc' },
              { name: 'aqua deep', rgb: 0x014b43, origin: './ntc' },
              { name: 'orient', rgb: 0x015e85, origin: './ntc' },
              { name: 'blue stone', rgb: 0x016162, origin: './ntc' },
              { name: 'fun green', rgb: 0x016d39, origin: './ntc' },
              { name: 'pine green', rgb: 0x01796f, origin: './ntc' },
              { name: 'blue lagoon', rgb: 0x017987, origin: './ntc' },
              { name: 'deep sea', rgb: 0x01826b, origin: './ntc' },
              { name: 'green haze', rgb: 0x01a368, origin: './ntc' },
              { name: 'english holly', rgb: 0x022d15, origin: './ntc' },
              { name: 'sherwood green', rgb: 0x02402c, origin: './ntc' },
              { name: 'congress blue', rgb: 0x02478e, origin: './ntc' },
              { name: 'evening sea', rgb: 0x024e46, origin: './ntc' },
              { name: 'bahama blue', rgb: 0x026395, origin: './ntc' },
              { name: 'observatory', rgb: 0x02866f, origin: './ntc' },
              { name: 'cerulean', rgb: 0x02a4d3, origin: './ntc' },
              { name: 'tangaroa', rgb: 0x03163c, origin: './ntc' },
              { name: 'green vogue', rgb: 0x032b52, origin: './ntc' },
              { name: 'mosque', rgb: 0x036a6e, origin: './ntc' },
              { name: 'midnight moss', rgb: 0x041004, origin: './ntc' },
              { name: 'black pearl', rgb: 0x041322, origin: './ntc' },
              { name: 'blue whale', rgb: 0x042e4c, origin: './ntc' },
              { name: 'zuccini', rgb: 0x044022, origin: './ntc' },
              { name: 'teal blue', rgb: 0x044259, origin: './ntc' },
              { name: 'deep cove', rgb: 0x051040, origin: './ntc' },
              { name: 'gulf blue', rgb: 0x051657, origin: './ntc' },
              { name: 'venice blue', rgb: 0x055989, origin: './ntc' },
              { name: 'watercourse', rgb: 0x056f57, origin: './ntc' },
              { name: 'catalina blue', rgb: 0x062a78, origin: './ntc' },
              { name: 'tiber', rgb: 0x063537, origin: './ntc' },
              { name: 'gossamer', rgb: 0x069b81, origin: './ntc' },
              { name: 'niagara', rgb: 0x06a189, origin: './ntc' },
              { name: 'tarawera', rgb: 0x073a50, origin: './ntc' },
              { name: 'jaguar', rgb: 0x080110, origin: './ntc' },
              { name: 'black bean', rgb: 0x081910, origin: './ntc' },
              { name: 'deep sapphire', rgb: 0x082567, origin: './ntc' },
              { name: 'elf green', rgb: 0x088370, origin: './ntc' },
              { name: 'bright turquoise', rgb: 0x08e8de, origin: './ntc' },
              { name: 'downriver', rgb: 0x092256, origin: './ntc' },
              { name: 'palm green', rgb: 0x09230f, origin: './ntc' },
              { name: 'madison', rgb: 0x09255d, origin: './ntc' },
              { name: 'bottle green', rgb: 0x093624, origin: './ntc' },
              { name: 'deep sea green', rgb: 0x095859, origin: './ntc' },
              { name: 'salem', rgb: 0x097f4b, origin: './ntc' },
              { name: 'black russian', rgb: 0x0a001c, origin: './ntc' },
              { name: 'dark fern', rgb: 0x0a480d, origin: './ntc' },
              { name: 'japanese laurel', rgb: 0x0a6906, origin: './ntc' },
              { name: 'atoll', rgb: 0x0a6f75, origin: './ntc' },
              { name: 'cod gray', rgb: 0x0b0b0b, origin: './ntc' },
              { name: 'marshland', rgb: 0x0b0f08, origin: './ntc' },
              { name: 'gordons green', rgb: 0x0b1107, origin: './ntc' },
              { name: 'black forest', rgb: 0x0b1304, origin: './ntc' },
              { name: 'san felix', rgb: 0x0b6207, origin: './ntc' },
              { name: 'malachite', rgb: 0x0bda51, origin: './ntc' },
              { name: 'ebony', rgb: 0x0c0b1d, origin: './ntc' },
              { name: 'woodsmoke', rgb: 0x0c0d0f, origin: './ntc' },
              { name: 'racing green', rgb: 0x0c1911, origin: './ntc' },
              { name: 'surfie green', rgb: 0x0c7a79, origin: './ntc' },
              { name: 'blue chill', rgb: 0x0c8990, origin: './ntc' },
              { name: 'black rock', rgb: 0x0d0332, origin: './ntc' },
              { name: 'bunker', rgb: 0x0d1117, origin: './ntc' },
              { name: 'aztec', rgb: 0x0d1c19, origin: './ntc' },
              { name: 'bush', rgb: 0x0d2e1c, origin: './ntc' },
              { name: 'cinder', rgb: 0x0e0e18, origin: './ntc' },
              { name: 'firefly', rgb: 0x0e2a30, origin: './ntc' },
              { name: 'torea bay', rgb: 0x0f2d9e, origin: './ntc' },
              { name: 'vulcan', rgb: 0x10121d, origin: './ntc' },
              { name: 'green waterloo', rgb: 0x101405, origin: './ntc' },
              { name: 'eden', rgb: 0x105852, origin: './ntc' },
              { name: 'arapawa', rgb: 0x110c6c, origin: './ntc' },
              { name: 'ultramarine', rgb: 0x120a8f, origin: './ntc' },
              { name: 'elephant', rgb: 0x123447, origin: './ntc' },
              { name: 'jewel', rgb: 0x126b40, origin: './ntc' },
              { name: 'diesel', rgb: 0x130000, origin: './ntc' },
              { name: 'asphalt', rgb: 0x130a06, origin: './ntc' },
              { name: 'blue zodiac', rgb: 0x13264d, origin: './ntc' },
              { name: 'parsley', rgb: 0x134f19, origin: './ntc' },
              { name: 'nero', rgb: 0x140600, origin: './ntc' },
              { name: 'tory blue', rgb: 0x1450aa, origin: './ntc' },
              { name: 'bunting', rgb: 0x151f4c, origin: './ntc' },
              { name: 'denim', rgb: 0x1560bd, origin: './ntc' },
              { name: 'genoa', rgb: 0x15736b, origin: './ntc' },
              { name: 'mirage', rgb: 0x161928, origin: './ntc' },
              { name: 'hunter green', rgb: 0x161d10, origin: './ntc' },
              { name: 'big stone', rgb: 0x162a40, origin: './ntc' },
              { name: 'celtic', rgb: 0x163222, origin: './ntc' },
              { name: 'timber green', rgb: 0x16322c, origin: './ntc' },
              { name: 'gable green', rgb: 0x163531, origin: './ntc' },
              { name: 'pine tree', rgb: 0x171f04, origin: './ntc' },
              { name: 'chathams blue', rgb: 0x175579, origin: './ntc' },
              { name: 'deep forest green', rgb: 0x182d09, origin: './ntc' },
              { name: 'blumine', rgb: 0x18587a, origin: './ntc' },
              { name: 'palm leaf', rgb: 0x19330e, origin: './ntc' },
              { name: 'nile blue', rgb: 0x193751, origin: './ntc' },
              { name: 'fun blue', rgb: 0x1959a8, origin: './ntc' },
              { name: 'lucky point', rgb: 0x1a1a68, origin: './ntc' },
              { name: 'mountain meadow', rgb: 0x1ab385, origin: './ntc' },
              { name: 'tolopea', rgb: 0x1b0245, origin: './ntc' },
              { name: 'haiti', rgb: 0x1b1035, origin: './ntc' },
              { name: 'deep koamaru', rgb: 0x1b127b, origin: './ntc' },
              { name: 'acadia', rgb: 0x1b1404, origin: './ntc' },
              { name: 'seaweed', rgb: 0x1b2f11, origin: './ntc' },
              { name: 'biscay', rgb: 0x1b3162, origin: './ntc' },
              { name: 'matisse', rgb: 0x1b659d, origin: './ntc' },
              { name: 'crowshead', rgb: 0x1c1208, origin: './ntc' },
              { name: 'rangoon green', rgb: 0x1c1e13, origin: './ntc' },
              { name: 'persian blue', rgb: 0x1c39bb, origin: './ntc' },
              { name: 'everglade', rgb: 0x1c402e, origin: './ntc' },
              { name: 'elm', rgb: 0x1c7c7d, origin: './ntc' },
              { name: 'green pea', rgb: 0x1d6142, origin: './ntc' },
              { name: 'creole', rgb: 0x1e0f04, origin: './ntc' },
              { name: 'karaka', rgb: 0x1e1609, origin: './ntc' },
              { name: 'el paso', rgb: 0x1e1708, origin: './ntc' },
              { name: 'cello', rgb: 0x1e385b, origin: './ntc' },
              { name: 'te papa green', rgb: 0x1e433c, origin: './ntc' },
              { name: 'dodger blue', rgb: 0x1e90ff, origin: './ntc' },
              { name: 'eastern blue', rgb: 0x1e9ab0, origin: './ntc' },
              { name: 'night rider', rgb: 0x1f120f, origin: './ntc' },
              { name: 'java', rgb: 0x1fc2c2, origin: './ntc' },
              { name: 'jacksons purple', rgb: 0x20208d, origin: './ntc' },
              { name: 'cloud burst', rgb: 0x202e54, origin: './ntc' },
              { name: 'blue dianne', rgb: 0x204852, origin: './ntc' },
              { name: 'eternity', rgb: 0x211a0e, origin: './ntc' },
              { name: 'deep blue', rgb: 0x220878, origin: './ntc' },
              { name: 'forest green', rgb: 0x228b22, origin: './ntc' },
              { name: 'mallard', rgb: 0x233418, origin: './ntc' },
              { name: 'violet', rgb: 0x240a40, origin: './ntc' },
              { name: 'kilamanjaro', rgb: 0x240c02, origin: './ntc' },
              { name: 'log cabin', rgb: 0x242a1d, origin: './ntc' },
              { name: 'black olive', rgb: 0x242e16, origin: './ntc' },
              { name: 'green house', rgb: 0x24500f, origin: './ntc' },
              { name: 'graphite', rgb: 0x251607, origin: './ntc' },
              { name: 'cannon black', rgb: 0x251706, origin: './ntc' },
              { name: 'port gore', rgb: 0x251f4f, origin: './ntc' },
              { name: 'shark', rgb: 0x25272c, origin: './ntc' },
              { name: 'green kelp', rgb: 0x25311c, origin: './ntc' },
              { name: 'curious blue', rgb: 0x2596d1, origin: './ntc' },
              { name: 'paua', rgb: 0x260368, origin: './ntc' },
              { name: 'paris m', rgb: 0x26056a, origin: './ntc' },
              { name: 'wood bark', rgb: 0x261105, origin: './ntc' },
              { name: 'gondola', rgb: 0x261414, origin: './ntc' },
              { name: 'steel gray', rgb: 0x262335, origin: './ntc' },
              { name: 'ebony clay', rgb: 0x26283b, origin: './ntc' },
              { name: 'bay of many', rgb: 0x273a81, origin: './ntc' },
              { name: 'plantation', rgb: 0x27504b, origin: './ntc' },
              { name: 'eucalyptus', rgb: 0x278a5b, origin: './ntc' },
              { name: 'oil', rgb: 0x281e15, origin: './ntc' },
              { name: 'astronaut', rgb: 0x283a77, origin: './ntc' },
              { name: 'mariner', rgb: 0x286acd, origin: './ntc' },
              { name: 'violent violet', rgb: 0x290c5e, origin: './ntc' },
              { name: 'bastille', rgb: 0x292130, origin: './ntc' },
              { name: 'zeus', rgb: 0x292319, origin: './ntc' },
              { name: 'charade', rgb: 0x292937, origin: './ntc' },
              { name: 'jelly bean', rgb: 0x297b9a, origin: './ntc' },
              { name: 'jungle green', rgb: 0x29ab87, origin: './ntc' },
              { name: 'cherry pie', rgb: 0x2a0359, origin: './ntc' },
              { name: 'coffee bean', rgb: 0x2a140e, origin: './ntc' },
              { name: 'baltic sea', rgb: 0x2a2630, origin: './ntc' },
              { name: 'turtle green', rgb: 0x2a380b, origin: './ntc' },
              { name: 'cerulean blue', rgb: 0x2a52be, origin: './ntc' },
              { name: 'sepia black', rgb: 0x2b0202, origin: './ntc' },
              { name: 'valhalla', rgb: 0x2b194f, origin: './ntc' },
              { name: 'heavy metal', rgb: 0x2b3228, origin: './ntc' },
              { name: 'blue gem', rgb: 0x2c0e8c, origin: './ntc' },
              { name: 'revolver', rgb: 0x2c1632, origin: './ntc' },
              { name: 'bleached cedar', rgb: 0x2c2133, origin: './ntc' },
              { name: 'lochinvar', rgb: 0x2c8c84, origin: './ntc' },
              { name: 'mikado', rgb: 0x2d2510, origin: './ntc' },
              { name: 'outer space', rgb: 0x2d383a, origin: './ntc' },
              { name: 'st tropaz', rgb: 0x2d569b, origin: './ntc' },
              { name: 'jacaranda', rgb: 0x2e0329, origin: './ntc' },
              { name: 'jacko bean', rgb: 0x2e1905, origin: './ntc' },
              { name: 'rangitoto', rgb: 0x2e3222, origin: './ntc' },
              { name: 'rhino', rgb: 0x2e3f62, origin: './ntc' },
              { name: 'sea green', rgb: 0x2e8b57, origin: './ntc' },
              { name: 'scooter', rgb: 0x2ebfd4, origin: './ntc' },
              { name: 'onion', rgb: 0x2f270e, origin: './ntc' },
              { name: 'governor bay', rgb: 0x2f3cb3, origin: './ntc' },
              { name: 'sapphire', rgb: 0x2f519e, origin: './ntc' },
              { name: 'spectra', rgb: 0x2f5a57, origin: './ntc' },
              { name: 'casal', rgb: 0x2f6168, origin: './ntc' },
              { name: 'melanzane', rgb: 0x300529, origin: './ntc' },
              { name: 'cocoa brown', rgb: 0x301f1e, origin: './ntc' },
              { name: 'woodrush', rgb: 0x302a0f, origin: './ntc' },
              { name: 'san juan', rgb: 0x304b6a, origin: './ntc' },
              { name: 'turquoise', rgb: 0x30d5c8, origin: './ntc' },
              { name: 'eclipse', rgb: 0x311c17, origin: './ntc' },
              { name: 'pickled bluewood', rgb: 0x314459, origin: './ntc' },
              { name: 'azure', rgb: 0x315ba1, origin: './ntc' },
              { name: 'calypso', rgb: 0x31728d, origin: './ntc' },
              { name: 'paradiso', rgb: 0x317d82, origin: './ntc' },
              { name: 'persian indigo', rgb: 0x32127a, origin: './ntc' },
              { name: 'blackcurrant', rgb: 0x32293a, origin: './ntc' },
              { name: 'mine shaft', rgb: 0x323232, origin: './ntc' },
              { name: 'stromboli', rgb: 0x325d52, origin: './ntc' },
              { name: 'bilbao', rgb: 0x327c14, origin: './ntc' },
              { name: 'astral', rgb: 0x327da0, origin: './ntc' },
              { name: 'christalle', rgb: 0x33036b, origin: './ntc' },
              { name: 'thunder', rgb: 0x33292f, origin: './ntc' },
              { name: 'shamrock', rgb: 0x33cc99, origin: './ntc' },
              { name: 'tamarind', rgb: 0x341515, origin: './ntc' },
              { name: 'mardi gras', rgb: 0x350036, origin: './ntc' },
              { name: 'valentino', rgb: 0x350e42, origin: './ntc' },
              { name: 'jagger', rgb: 0x350e57, origin: './ntc' },
              { name: 'tuna', rgb: 0x353542, origin: './ntc' },
              { name: 'chambray', rgb: 0x354e8c, origin: './ntc' },
              { name: 'martinique', rgb: 0x363050, origin: './ntc' },
              { name: 'tuatara', rgb: 0x363534, origin: './ntc' },
              { name: 'waiouru', rgb: 0x363c0d, origin: './ntc' },
              { name: 'ming', rgb: 0x36747d, origin: './ntc' },
              { name: 'la palma', rgb: 0x368716, origin: './ntc' },
              { name: 'chocolate', rgb: 0x370202, origin: './ntc' },
              { name: 'clinker', rgb: 0x371d09, origin: './ntc' },
              { name: 'brown tumbleweed', rgb: 0x37290e, origin: './ntc' },
              { name: 'birch', rgb: 0x373021, origin: './ntc' },
              { name: 'oracle', rgb: 0x377475, origin: './ntc' },
              { name: 'blue diamond', rgb: 0x380474, origin: './ntc' },
              { name: 'grape', rgb: 0x381a51, origin: './ntc' },
              { name: 'dune', rgb: 0x383533, origin: './ntc' },
              { name: 'oxford blue', rgb: 0x384555, origin: './ntc' },
              { name: 'clover', rgb: 0x384910, origin: './ntc' },
              { name: 'limed spruce', rgb: 0x394851, origin: './ntc' },
              { name: 'dell', rgb: 0x396413, origin: './ntc' },
              { name: 'toledo', rgb: 0x3a0020, origin: './ntc' },
              { name: 'sambuca', rgb: 0x3a2010, origin: './ntc' },
              { name: 'jacarta', rgb: 0x3a2a6a, origin: './ntc' },
              { name: 'william', rgb: 0x3a686c, origin: './ntc' },
              { name: 'killarney', rgb: 0x3a6a47, origin: './ntc' },
              { name: 'keppel', rgb: 0x3ab09e, origin: './ntc' },
              { name: 'temptress', rgb: 0x3b000b, origin: './ntc' },
              { name: 'aubergine', rgb: 0x3b0910, origin: './ntc' },
              { name: 'jon', rgb: 0x3b1f1f, origin: './ntc' },
              { name: 'treehouse', rgb: 0x3b2820, origin: './ntc' },
              { name: 'amazon', rgb: 0x3b7a57, origin: './ntc' },
              { name: 'boston blue', rgb: 0x3b91b4, origin: './ntc' },
              { name: 'windsor', rgb: 0x3c0878, origin: './ntc' },
              { name: 'rebel', rgb: 0x3c1206, origin: './ntc' },
              { name: 'meteorite', rgb: 0x3c1f76, origin: './ntc' },
              { name: 'dark ebony', rgb: 0x3c2005, origin: './ntc' },
              { name: 'camouflage', rgb: 0x3c3910, origin: './ntc' },
              { name: 'bright gray', rgb: 0x3c4151, origin: './ntc' },
              { name: 'cape cod', rgb: 0x3c4443, origin: './ntc' },
              { name: 'lunar green', rgb: 0x3c493a, origin: './ntc' },
              { name: 'bean  ', rgb: 0x3d0c02, origin: './ntc' },
              { name: 'bistre', rgb: 0x3d2b1f, origin: './ntc' },
              { name: 'goblin', rgb: 0x3d7d52, origin: './ntc' },
              { name: 'kingfisher daisy', rgb: 0x3e0480, origin: './ntc' },
              { name: 'cedar', rgb: 0x3e1c14, origin: './ntc' },
              { name: 'english walnut', rgb: 0x3e2b23, origin: './ntc' },
              { name: 'black marlin', rgb: 0x3e2c1c, origin: './ntc' },
              { name: 'ship gray', rgb: 0x3e3a44, origin: './ntc' },
              { name: 'pelorous', rgb: 0x3eabbf, origin: './ntc' },
              { name: 'bronze', rgb: 0x3f2109, origin: './ntc' },
              { name: 'cola', rgb: 0x3f2500, origin: './ntc' },
              { name: 'madras', rgb: 0x3f3002, origin: './ntc' },
              { name: 'minsk', rgb: 0x3f307f, origin: './ntc' },
              { name: 'cabbage pont', rgb: 0x3f4c3a, origin: './ntc' },
              { name: 'tom thumb', rgb: 0x3f583b, origin: './ntc' },
              { name: 'mineral green', rgb: 0x3f5d53, origin: './ntc' },
              { name: 'puerto rico', rgb: 0x3fc1aa, origin: './ntc' },
              { name: 'harlequin', rgb: 0x3fff00, origin: './ntc' },
              { name: 'brown pod', rgb: 0x401801, origin: './ntc' },
              { name: 'cork', rgb: 0x40291d, origin: './ntc' },
              { name: 'masala', rgb: 0x403b38, origin: './ntc' },
              { name: 'thatch green', rgb: 0x403d19, origin: './ntc' },
              { name: 'fiord', rgb: 0x405169, origin: './ntc' },
              { name: 'viridian', rgb: 0x40826d, origin: './ntc' },
              { name: 'chateau green', rgb: 0x40a860, origin: './ntc' },
              { name: 'ripe plum', rgb: 0x410056, origin: './ntc' },
              { name: 'paco', rgb: 0x411f10, origin: './ntc' },
              { name: 'deep oak', rgb: 0x412010, origin: './ntc' },
              { name: 'merlin', rgb: 0x413c37, origin: './ntc' },
              { name: 'gun powder', rgb: 0x414257, origin: './ntc' },
              { name: 'east bay', rgb: 0x414c7d, origin: './ntc' },
              { name: 'royal blue', rgb: 0x4169e1, origin: './ntc' },
              { name: 'ocean green', rgb: 0x41aa78, origin: './ntc' },
              { name: 'burnt maroon', rgb: 0x420303, origin: './ntc' },
              { name: 'lisbon brown', rgb: 0x423921, origin: './ntc' },
              { name: 'faded jade', rgb: 0x427977, origin: './ntc' },
              { name: 'scarlet gum', rgb: 0x431560, origin: './ntc' },
              { name: 'iroko', rgb: 0x433120, origin: './ntc' },
              { name: 'armadillo', rgb: 0x433e37, origin: './ntc' },
              { name: 'river bed', rgb: 0x434c59, origin: './ntc' },
              { name: 'green leaf', rgb: 0x436a0d, origin: './ntc' },
              { name: 'barossa', rgb: 0x44012d, origin: './ntc' },
              { name: 'morocco brown', rgb: 0x441d00, origin: './ntc' },
              { name: 'mako', rgb: 0x444954, origin: './ntc' },
              { name: 'kelp', rgb: 0x454936, origin: './ntc' },
              { name: 'san marino', rgb: 0x456cac, origin: './ntc' },
              { name: 'picton blue', rgb: 0x45b1e8, origin: './ntc' },
              { name: 'loulou', rgb: 0x460b41, origin: './ntc' },
              { name: 'crater brown', rgb: 0x462425, origin: './ntc' },
              { name: 'gray asparagus', rgb: 0x465945, origin: './ntc' },
              { name: 'steel blue', rgb: 0x4682b4, origin: './ntc' },
              { name: 'rustic red', rgb: 0x480404, origin: './ntc' },
              { name: 'bulgarian rose', rgb: 0x480607, origin: './ntc' },
              { name: 'clairvoyant', rgb: 0x480656, origin: './ntc' },
              { name: 'cocoa bean', rgb: 0x481c1c, origin: './ntc' },
              { name: 'woody brown', rgb: 0x483131, origin: './ntc' },
              { name: 'taupe', rgb: 0x483c32, origin: './ntc' },
              { name: 'van cleef', rgb: 0x49170c, origin: './ntc' },
              { name: 'brown derby', rgb: 0x492615, origin: './ntc' },
              { name: 'metallic bronze', rgb: 0x49371b, origin: './ntc' },
              { name: 'verdun green', rgb: 0x495400, origin: './ntc' },
              { name: 'blue bayoux', rgb: 0x496679, origin: './ntc' },
              { name: 'bismark', rgb: 0x497183, origin: './ntc' },
              { name: 'bracken', rgb: 0x4a2a04, origin: './ntc' },
              { name: 'deep bronze', rgb: 0x4a3004, origin: './ntc' },
              { name: 'mondo', rgb: 0x4a3c30, origin: './ntc' },
              { name: 'tundora', rgb: 0x4a4244, origin: './ntc' },
              { name: 'gravel', rgb: 0x4a444b, origin: './ntc' },
              { name: 'trout', rgb: 0x4a4e5a, origin: './ntc' },
              { name: 'pigment indigo', rgb: 0x4b0082, origin: './ntc' },
              { name: 'nandor', rgb: 0x4b5d52, origin: './ntc' },
              { name: 'saddle', rgb: 0x4c3024, origin: './ntc' },
              { name: 'abbey', rgb: 0x4c4f56, origin: './ntc' },
              { name: 'blackberry', rgb: 0x4d0135, origin: './ntc' },
              { name: 'cab sav', rgb: 0x4d0a18, origin: './ntc' },
              { name: 'indian tan', rgb: 0x4d1e01, origin: './ntc' },
              { name: 'cowboy', rgb: 0x4d282d, origin: './ntc' },
              { name: 'livid brown', rgb: 0x4d282e, origin: './ntc' },
              { name: 'rock', rgb: 0x4d3833, origin: './ntc' },
              { name: 'punga', rgb: 0x4d3d14, origin: './ntc' },
              { name: 'bronzetone', rgb: 0x4d400f, origin: './ntc' },
              { name: 'woodland', rgb: 0x4d5328, origin: './ntc' },
              { name: 'mahogany', rgb: 0x4e0606, origin: './ntc' },
              { name: 'bossanova', rgb: 0x4e2a5a, origin: './ntc' },
              { name: 'matterhorn', rgb: 0x4e3b41, origin: './ntc' },
              { name: 'bronze olive', rgb: 0x4e420c, origin: './ntc' },
              { name: 'mulled wine', rgb: 0x4e4562, origin: './ntc' },
              { name: 'axolotl', rgb: 0x4e6649, origin: './ntc' },
              { name: 'wedgewood', rgb: 0x4e7f9e, origin: './ntc' },
              { name: 'shakespeare', rgb: 0x4eabd1, origin: './ntc' },
              { name: 'honey flower', rgb: 0x4f1c70, origin: './ntc' },
              { name: 'daisy bush', rgb: 0x4f2398, origin: './ntc' },
              { name: 'indigo', rgb: 0x4f69c6, origin: './ntc' },
              { name: 'fern green', rgb: 0x4f7942, origin: './ntc' },
              { name: 'fruit salad', rgb: 0x4f9d5d, origin: './ntc' },
              { name: 'apple', rgb: 0x4fa83d, origin: './ntc' },
              { name: 'mortar', rgb: 0x504351, origin: './ntc' },
              { name: 'kashmir blue', rgb: 0x507096, origin: './ntc' },
              { name: 'cutty sark', rgb: 0x507672, origin: './ntc' },
              { name: 'emerald', rgb: 0x50c878, origin: './ntc' },
              { name: 'emperor', rgb: 0x514649, origin: './ntc' },
              { name: 'chalet green', rgb: 0x516e3d, origin: './ntc' },
              { name: 'como', rgb: 0x517c66, origin: './ntc' },
              { name: 'smalt blue', rgb: 0x51808f, origin: './ntc' },
              { name: 'castro', rgb: 0x52001f, origin: './ntc' },
              { name: 'maroon oak', rgb: 0x520c17, origin: './ntc' },
              { name: 'gigas', rgb: 0x523c94, origin: './ntc' },
              { name: 'voodoo', rgb: 0x533455, origin: './ntc' },
              { name: 'victoria', rgb: 0x534491, origin: './ntc' },
              { name: 'hippie green', rgb: 0x53824b, origin: './ntc' },
              { name: 'heath', rgb: 0x541012, origin: './ntc' },
              { name: 'judge gray', rgb: 0x544333, origin: './ntc' },
              { name: 'fuscous gray', rgb: 0x54534d, origin: './ntc' },
              { name: 'vida loca', rgb: 0x549019, origin: './ntc' },
              { name: 'cioccolato', rgb: 0x55280c, origin: './ntc' },
              { name: 'saratoga', rgb: 0x555b10, origin: './ntc' },
              { name: 'finlandia', rgb: 0x556d56, origin: './ntc' },
              { name: 'havelock blue', rgb: 0x5590d9, origin: './ntc' },
              { name: 'fountain blue', rgb: 0x56b4be, origin: './ntc' },
              { name: 'spring leaves', rgb: 0x578363, origin: './ntc' },
              { name: 'saddle brown', rgb: 0x583401, origin: './ntc' },
              { name: 'scarpa flow', rgb: 0x585562, origin: './ntc' },
              { name: 'cactus', rgb: 0x587156, origin: './ntc' },
              { name: 'hippie blue', rgb: 0x589aaf, origin: './ntc' },
              { name: 'wine berry', rgb: 0x591d35, origin: './ntc' },
              { name: 'brown bramble', rgb: 0x592804, origin: './ntc' },
              { name: 'congo brown', rgb: 0x593737, origin: './ntc' },
              { name: 'millbrook', rgb: 0x594433, origin: './ntc' },
              { name: 'waikawa gray', rgb: 0x5a6e9c, origin: './ntc' },
              { name: 'horizon', rgb: 0x5a87a0, origin: './ntc' },
              { name: 'jambalaya', rgb: 0x5b3013, origin: './ntc' },
              { name: 'bordeaux', rgb: 0x5c0120, origin: './ntc' },
              { name: 'mulberry wood', rgb: 0x5c0536, origin: './ntc' },
              { name: 'carnaby tan', rgb: 0x5c2e01, origin: './ntc' },
              { name: 'comet', rgb: 0x5c5d75, origin: './ntc' },
              { name: 'redwood', rgb: 0x5d1e0f, origin: './ntc' },
              { name: 'don juan', rgb: 0x5d4c51, origin: './ntc' },
              { name: 'chicago', rgb: 0x5d5c58, origin: './ntc' },
              { name: 'verdigris', rgb: 0x5d5e37, origin: './ntc' },
              { name: 'dingley', rgb: 0x5d7747, origin: './ntc' },
              { name: 'breaker bay', rgb: 0x5da19f, origin: './ntc' },
              { name: 'kabul', rgb: 0x5e483e, origin: './ntc' },
              { name: 'hemlock', rgb: 0x5e5d3b, origin: './ntc' },
              { name: 'irish coffee', rgb: 0x5f3d26, origin: './ntc' },
              { name: 'mid gray', rgb: 0x5f5f6e, origin: './ntc' },
              { name: 'shuttle gray', rgb: 0x5f6672, origin: './ntc' },
              { name: 'aqua forest', rgb: 0x5fa777, origin: './ntc' },
              { name: 'tradewind', rgb: 0x5fb3ac, origin: './ntc' },
              { name: 'horses neck', rgb: 0x604913, origin: './ntc' },
              { name: 'smoky', rgb: 0x605b73, origin: './ntc' },
              { name: 'corduroy', rgb: 0x606e68, origin: './ntc' },
              { name: 'danube', rgb: 0x6093d1, origin: './ntc' },
              { name: 'espresso', rgb: 0x612718, origin: './ntc' },
              { name: 'eggplant', rgb: 0x614051, origin: './ntc' },
              { name: 'costa del sol', rgb: 0x615d30, origin: './ntc' },
              { name: 'glade green', rgb: 0x61845f, origin: './ntc' },
              { name: 'buccaneer', rgb: 0x622f30, origin: './ntc' },
              { name: 'quincy', rgb: 0x623f2d, origin: './ntc' },
              { name: 'butterfly bush', rgb: 0x624e9a, origin: './ntc' },
              { name: 'west coast', rgb: 0x625119, origin: './ntc' },
              { name: 'finch', rgb: 0x626649, origin: './ntc' },
              { name: 'patina', rgb: 0x639a8f, origin: './ntc' },
              { name: 'fern', rgb: 0x63b76c, origin: './ntc' },
              { name: 'blue violet', rgb: 0x6456b7, origin: './ntc' },
              { name: 'dolphin', rgb: 0x646077, origin: './ntc' },
              { name: 'storm dust', rgb: 0x646463, origin: './ntc' },
              { name: 'siam', rgb: 0x646a54, origin: './ntc' },
              { name: 'nevada', rgb: 0x646e75, origin: './ntc' },
              { name: 'cornflower blue', rgb: 0x6495ed, origin: './ntc' },
              { name: 'viking', rgb: 0x64ccdb, origin: './ntc' },
              { name: 'rosewood', rgb: 0x65000b, origin: './ntc' },
              { name: 'cherrywood', rgb: 0x651a14, origin: './ntc' },
              { name: 'purple heart', rgb: 0x652dc1, origin: './ntc' },
              { name: 'fern frond', rgb: 0x657220, origin: './ntc' },
              { name: 'willow grove', rgb: 0x65745d, origin: './ntc' },
              { name: 'hoki', rgb: 0x65869f, origin: './ntc' },
              { name: 'pompadour', rgb: 0x660045, origin: './ntc' },
              { name: 'purple', rgb: 0x660099, origin: './ntc' },
              { name: 'tyrian purple', rgb: 0x66023c, origin: './ntc' },
              { name: 'dark tan', rgb: 0x661010, origin: './ntc' },
              { name: 'silver tree', rgb: 0x66b58f, origin: './ntc' },
              { name: 'bright green', rgb: 0x66ff00, origin: './ntc' },
              { name: "screamin' green", rgb: 0x66ff66, origin: './ntc' },
              { name: 'black rose', rgb: 0x67032d, origin: './ntc' },
              { name: 'scampi', rgb: 0x675fa6, origin: './ntc' },
              { name: 'ironside gray', rgb: 0x676662, origin: './ntc' },
              { name: 'viridian green', rgb: 0x678975, origin: './ntc' },
              { name: 'christi', rgb: 0x67a712, origin: './ntc' },
              { name: 'nutmeg wood finish', rgb: 0x683600, origin: './ntc' },
              { name: 'zambezi', rgb: 0x685558, origin: './ntc' },
              { name: 'salt box', rgb: 0x685e6e, origin: './ntc' },
              { name: 'tawny port', rgb: 0x692545, origin: './ntc' },
              { name: 'finn', rgb: 0x692d54, origin: './ntc' },
              { name: 'scorpion', rgb: 0x695f62, origin: './ntc' },
              { name: 'lynch', rgb: 0x697e9a, origin: './ntc' },
              { name: 'spice', rgb: 0x6a442e, origin: './ntc' },
              { name: 'himalaya', rgb: 0x6a5d1b, origin: './ntc' },
              { name: 'soya bean', rgb: 0x6a6051, origin: './ntc' },
              { name: 'hairy heath', rgb: 0x6b2a14, origin: './ntc' },
              { name: 'royal purple', rgb: 0x6b3fa0, origin: './ntc' },
              { name: 'shingle fawn', rgb: 0x6b4e31, origin: './ntc' },
              { name: 'dorado', rgb: 0x6b5755, origin: './ntc' },
              { name: 'bermuda gray', rgb: 0x6b8ba2, origin: './ntc' },
              { name: 'olive drab', rgb: 0x6b8e23, origin: './ntc' },
              { name: 'eminence', rgb: 0x6c3082, origin: './ntc' },
              { name: 'turquoise blue', rgb: 0x6cdae7, origin: './ntc' },
              { name: 'lonestar', rgb: 0x6d0101, origin: './ntc' },
              { name: 'pine cone', rgb: 0x6d5e54, origin: './ntc' },
              { name: 'dove gray', rgb: 0x6d6c6c, origin: './ntc' },
              { name: 'juniper', rgb: 0x6d9292, origin: './ntc' },
              { name: 'gothic', rgb: 0x6d92a1, origin: './ntc' },
              { name: 'red oxide', rgb: 0x6e0902, origin: './ntc' },
              { name: 'moccaccino', rgb: 0x6e1d14, origin: './ntc' },
              { name: 'pickled bean', rgb: 0x6e4826, origin: './ntc' },
              { name: 'dallas', rgb: 0x6e4b26, origin: './ntc' },
              { name: 'kokoda', rgb: 0x6e6d57, origin: './ntc' },
              { name: 'pale sky', rgb: 0x6e7783, origin: './ntc' },
              { name: 'cafe royale', rgb: 0x6f440c, origin: './ntc' },
              { name: 'flint', rgb: 0x6f6a61, origin: './ntc' },
              { name: 'highland', rgb: 0x6f8e63, origin: './ntc' },
              { name: 'limeade', rgb: 0x6f9d02, origin: './ntc' },
              { name: 'downy', rgb: 0x6fd0c5, origin: './ntc' },
              { name: 'persian plum', rgb: 0x701c1c, origin: './ntc' },
              { name: 'sepia', rgb: 0x704214, origin: './ntc' },
              { name: 'antique bronze', rgb: 0x704a07, origin: './ntc' },
              { name: 'ferra', rgb: 0x704f50, origin: './ntc' },
              { name: 'coffee', rgb: 0x706555, origin: './ntc' },
              { name: 'slate gray', rgb: 0x708090, origin: './ntc' },
              { name: 'cedar wood finish', rgb: 0x711a00, origin: './ntc' },
              { name: 'metallic copper', rgb: 0x71291d, origin: './ntc' },
              { name: 'affair', rgb: 0x714693, origin: './ntc' },
              { name: 'studio', rgb: 0x714ab2, origin: './ntc' },
              { name: 'tobacco brown', rgb: 0x715d47, origin: './ntc' },
              { name: 'yellow metal', rgb: 0x716338, origin: './ntc' },
              { name: 'peat', rgb: 0x716b56, origin: './ntc' },
              { name: 'olivetone', rgb: 0x716e10, origin: './ntc' },
              { name: 'storm gray', rgb: 0x717486, origin: './ntc' },
              { name: 'sirocco', rgb: 0x718080, origin: './ntc' },
              { name: 'aquamarine blue', rgb: 0x71d9e2, origin: './ntc' },
              { name: 'venetian red', rgb: 0x72010f, origin: './ntc' },
              { name: 'old copper', rgb: 0x724a2f, origin: './ntc' },
              { name: 'go ben', rgb: 0x726d4e, origin: './ntc' },
              { name: 'raven', rgb: 0x727b89, origin: './ntc' },
              { name: 'seance', rgb: 0x731e8f, origin: './ntc' },
              { name: 'raw umber', rgb: 0x734a12, origin: './ntc' },
              { name: 'kimberly', rgb: 0x736c9f, origin: './ntc' },
              { name: 'crocodile', rgb: 0x736d58, origin: './ntc' },
              { name: 'crete', rgb: 0x737829, origin: './ntc' },
              { name: 'xanadu', rgb: 0x738678, origin: './ntc' },
              { name: 'spicy mustard', rgb: 0x74640d, origin: './ntc' },
              { name: 'limed ash', rgb: 0x747d63, origin: './ntc' },
              { name: 'rolling stone', rgb: 0x747d83, origin: './ntc' },
              { name: 'blue smoke', rgb: 0x748881, origin: './ntc' },
              { name: 'laurel', rgb: 0x749378, origin: './ntc' },
              { name: 'mantis', rgb: 0x74c365, origin: './ntc' },
              { name: 'russett', rgb: 0x755a57, origin: './ntc' },
              { name: 'deluge', rgb: 0x7563a8, origin: './ntc' },
              { name: 'cosmic', rgb: 0x76395d, origin: './ntc' },
              { name: 'blue marguerite', rgb: 0x7666c6, origin: './ntc' },
              { name: 'lima', rgb: 0x76bd17, origin: './ntc' },
              { name: 'sky blue', rgb: 0x76d7ea, origin: './ntc' },
              { name: 'dark burgundy', rgb: 0x770f05, origin: './ntc' },
              { name: 'crown of thorns', rgb: 0x771f1f, origin: './ntc' },
              { name: 'walnut', rgb: 0x773f1a, origin: './ntc' },
              { name: 'pablo', rgb: 0x776f61, origin: './ntc' },
              { name: 'pacifika', rgb: 0x778120, origin: './ntc' },
              { name: 'oxley', rgb: 0x779e86, origin: './ntc' },
              { name: 'pastel green', rgb: 0x77dd77, origin: './ntc' },
              { name: 'japanese maple', rgb: 0x780109, origin: './ntc' },
              { name: 'mocha', rgb: 0x782d19, origin: './ntc' },
              { name: 'peanut', rgb: 0x782f16, origin: './ntc' },
              { name: 'camouflage green', rgb: 0x78866b, origin: './ntc' },
              { name: 'wasabi', rgb: 0x788a25, origin: './ntc' },
              { name: 'ship cove', rgb: 0x788bba, origin: './ntc' },
              { name: 'sea nymph', rgb: 0x78a39c, origin: './ntc' },
              { name: 'roman coffee', rgb: 0x795d4c, origin: './ntc' },
              { name: 'old lavender', rgb: 0x796878, origin: './ntc' },
              { name: 'rum', rgb: 0x796989, origin: './ntc' },
              { name: 'fedora', rgb: 0x796a78, origin: './ntc' },
              { name: 'sandstone', rgb: 0x796d62, origin: './ntc' },
              { name: 'spray', rgb: 0x79deec, origin: './ntc' },
              { name: 'siren', rgb: 0x7a013a, origin: './ntc' },
              { name: 'fuchsia blue', rgb: 0x7a58c1, origin: './ntc' },
              { name: 'boulder', rgb: 0x7a7a7a, origin: './ntc' },
              { name: 'wild blue yonder', rgb: 0x7a89b8, origin: './ntc' },
              { name: 'de york', rgb: 0x7ac488, origin: './ntc' },
              { name: 'red beech', rgb: 0x7b3801, origin: './ntc' },
              { name: 'cinnamon', rgb: 0x7b3f00, origin: './ntc' },
              { name: 'yukon gold', rgb: 0x7b6608, origin: './ntc' },
              { name: 'tapa', rgb: 0x7b7874, origin: './ntc' },
              { name: 'waterloo ', rgb: 0x7b7c94, origin: './ntc' },
              { name: 'flax smoke', rgb: 0x7b8265, origin: './ntc' },
              { name: 'amulet', rgb: 0x7b9f80, origin: './ntc' },
              { name: 'asparagus', rgb: 0x7ba05b, origin: './ntc' },
              { name: 'kenyan copper', rgb: 0x7c1c05, origin: './ntc' },
              { name: 'pesto', rgb: 0x7c7631, origin: './ntc' },
              { name: 'topaz', rgb: 0x7c778a, origin: './ntc' },
              { name: 'concord', rgb: 0x7c7b7a, origin: './ntc' },
              { name: 'jumbo', rgb: 0x7c7b82, origin: './ntc' },
              { name: 'trendy green', rgb: 0x7c881a, origin: './ntc' },
              { name: 'gumbo', rgb: 0x7ca1a6, origin: './ntc' },
              { name: 'acapulco', rgb: 0x7cb0a1, origin: './ntc' },
              { name: 'neptune', rgb: 0x7cb7bb, origin: './ntc' },
              { name: 'pueblo', rgb: 0x7d2c14, origin: './ntc' },
              { name: 'bay leaf', rgb: 0x7da98d, origin: './ntc' },
              { name: 'malibu', rgb: 0x7dc8f7, origin: './ntc' },
              { name: 'bermuda', rgb: 0x7dd8c6, origin: './ntc' },
              { name: 'copper canyon', rgb: 0x7e3a15, origin: './ntc' },
              { name: 'claret', rgb: 0x7f1734, origin: './ntc' },
              { name: 'peru tan', rgb: 0x7f3a02, origin: './ntc' },
              { name: 'falcon', rgb: 0x7f626d, origin: './ntc' },
              { name: 'mobster', rgb: 0x7f7589, origin: './ntc' },
              { name: 'moody blue', rgb: 0x7f76d3, origin: './ntc' },
              { name: 'chartreuse', rgb: 0x7fff00, origin: './ntc' },
              { name: 'aquamarine', rgb: 0x7fffd4, origin: './ntc' },
              { name: 'maroon', rgb: 0x800000, origin: './ntc' },
              { name: 'rose bud cherry', rgb: 0x800b47, origin: './ntc' },
              { name: 'falu red', rgb: 0x801818, origin: './ntc' },
              { name: 'red robin', rgb: 0x80341f, origin: './ntc' },
              { name: 'vivid violet', rgb: 0x803790, origin: './ntc' },
              { name: 'russet', rgb: 0x80461b, origin: './ntc' },
              { name: 'friar gray', rgb: 0x807e79, origin: './ntc' },
              { name: 'olive', rgb: 0x808000, origin: './ntc' },
              { name: 'gray', rgb: 0x808080, origin: './ntc' },
              { name: 'gulf stream', rgb: 0x80b3ae, origin: './ntc' },
              { name: 'glacier', rgb: 0x80b3c4, origin: './ntc' },
              { name: 'seagull', rgb: 0x80ccea, origin: './ntc' },
              { name: 'nutmeg', rgb: 0x81422c, origin: './ntc' },
              { name: 'spicy pink', rgb: 0x816e71, origin: './ntc' },
              { name: 'empress', rgb: 0x817377, origin: './ntc' },
              { name: 'spanish green', rgb: 0x819885, origin: './ntc' },
              { name: 'sand dune', rgb: 0x826f65, origin: './ntc' },
              { name: 'gunsmoke', rgb: 0x828685, origin: './ntc' },
              { name: 'battleship gray', rgb: 0x828f72, origin: './ntc' },
              { name: 'merlot', rgb: 0x831923, origin: './ntc' },
              { name: 'shadow', rgb: 0x837050, origin: './ntc' },
              { name: 'chelsea cucumber', rgb: 0x83aa5d, origin: './ntc' },
              { name: 'monte carlo', rgb: 0x83d0c6, origin: './ntc' },
              { name: 'plum', rgb: 0x843179, origin: './ntc' },
              { name: 'granny smith', rgb: 0x84a0a0, origin: './ntc' },
              { name: 'chetwode blue', rgb: 0x8581d9, origin: './ntc' },
              { name: 'bandicoot', rgb: 0x858470, origin: './ntc' },
              { name: 'bali hai', rgb: 0x859faf, origin: './ntc' },
              { name: 'half baked', rgb: 0x85c4cc, origin: './ntc' },
              { name: 'red devil', rgb: 0x860111, origin: './ntc' },
              { name: 'lotus', rgb: 0x863c3c, origin: './ntc' },
              { name: 'ironstone', rgb: 0x86483c, origin: './ntc' },
              { name: 'bull shot', rgb: 0x864d1e, origin: './ntc' },
              { name: 'rusty nail', rgb: 0x86560a, origin: './ntc' },
              { name: 'bitter', rgb: 0x868974, origin: './ntc' },
              { name: 'regent gray', rgb: 0x86949f, origin: './ntc' },
              { name: 'disco', rgb: 0x871550, origin: './ntc' },
              { name: 'americano', rgb: 0x87756e, origin: './ntc' },
              { name: 'hurricane', rgb: 0x877c7b, origin: './ntc' },
              { name: 'oslo gray', rgb: 0x878d91, origin: './ntc' },
              { name: 'sushi', rgb: 0x87ab39, origin: './ntc' },
              { name: 'spicy mix', rgb: 0x885342, origin: './ntc' },
              { name: 'kumera', rgb: 0x886221, origin: './ntc' },
              { name: 'suva gray', rgb: 0x888387, origin: './ntc' },
              { name: 'avocado', rgb: 0x888d65, origin: './ntc' },
              { name: 'camelot', rgb: 0x893456, origin: './ntc' },
              { name: 'solid pink', rgb: 0x893843, origin: './ntc' },
              { name: 'cannon pink', rgb: 0x894367, origin: './ntc' },
              { name: 'makara', rgb: 0x897d6d, origin: './ntc' },
              { name: 'burnt umber', rgb: 0x8a3324, origin: './ntc' },
              { name: 'true v', rgb: 0x8a73d6, origin: './ntc' },
              { name: 'clay creek', rgb: 0x8a8360, origin: './ntc' },
              { name: 'monsoon', rgb: 0x8a8389, origin: './ntc' },
              { name: 'stack', rgb: 0x8a8f8a, origin: './ntc' },
              { name: 'jordy blue', rgb: 0x8ab9f1, origin: './ntc' },
              { name: 'electric violet', rgb: 0x8b00ff, origin: './ntc' },
              { name: 'monarch', rgb: 0x8b0723, origin: './ntc' },
              { name: 'corn harvest', rgb: 0x8b6b0b, origin: './ntc' },
              { name: 'olive haze', rgb: 0x8b8470, origin: './ntc' },
              { name: 'schooner', rgb: 0x8b847e, origin: './ntc' },
              { name: 'natural gray', rgb: 0x8b8680, origin: './ntc' },
              { name: 'mantle', rgb: 0x8b9c90, origin: './ntc' },
              { name: 'portage', rgb: 0x8b9fee, origin: './ntc' },
              { name: 'envy', rgb: 0x8ba690, origin: './ntc' },
              { name: 'cascade', rgb: 0x8ba9a5, origin: './ntc' },
              { name: 'riptide', rgb: 0x8be6d8, origin: './ntc' },
              { name: 'cardinal pink', rgb: 0x8c055e, origin: './ntc' },
              { name: 'mule fawn', rgb: 0x8c472f, origin: './ntc' },
              { name: 'potters clay', rgb: 0x8c5738, origin: './ntc' },
              { name: 'trendy pink', rgb: 0x8c6495, origin: './ntc' },
              { name: 'paprika', rgb: 0x8d0226, origin: './ntc' },
              { name: 'sanguine brown', rgb: 0x8d3d38, origin: './ntc' },
              { name: 'tosca', rgb: 0x8d3f3f, origin: './ntc' },
              { name: 'cement', rgb: 0x8d7662, origin: './ntc' },
              { name: 'granite green', rgb: 0x8d8974, origin: './ntc' },
              { name: 'manatee', rgb: 0x8d90a1, origin: './ntc' },
              { name: 'polo blue', rgb: 0x8da8cc, origin: './ntc' },
              { name: 'red berry', rgb: 0x8e0000, origin: './ntc' },
              { name: 'rope', rgb: 0x8e4d1e, origin: './ntc' },
              { name: 'opium', rgb: 0x8e6f70, origin: './ntc' },
              { name: 'domino', rgb: 0x8e775e, origin: './ntc' },
              { name: 'mamba', rgb: 0x8e8190, origin: './ntc' },
              { name: 'nepal', rgb: 0x8eabc1, origin: './ntc' },
              { name: 'pohutukawa', rgb: 0x8f021c, origin: './ntc' },
              { name: 'el salva', rgb: 0x8f3e33, origin: './ntc' },
              { name: 'korma', rgb: 0x8f4b0e, origin: './ntc' },
              { name: 'squirrel', rgb: 0x8f8176, origin: './ntc' },
              { name: 'vista blue', rgb: 0x8fd6b4, origin: './ntc' },
              { name: 'burgundy', rgb: 0x900020, origin: './ntc' },
              { name: 'old brick', rgb: 0x901e1e, origin: './ntc' },
              { name: 'hemp', rgb: 0x907874, origin: './ntc' },
              { name: 'almond frost', rgb: 0x907b71, origin: './ntc' },
              { name: 'sycamore', rgb: 0x908d39, origin: './ntc' },
              { name: 'sangria', rgb: 0x92000a, origin: './ntc' },
              { name: 'cumin', rgb: 0x924321, origin: './ntc' },
              { name: 'beaver', rgb: 0x926f5b, origin: './ntc' },
              { name: 'stonewall', rgb: 0x928573, origin: './ntc' },
              { name: 'venus', rgb: 0x928590, origin: './ntc' },
              { name: 'medium purple', rgb: 0x9370db, origin: './ntc' },
              { name: 'cornflower', rgb: 0x93ccea, origin: './ntc' },
              { name: 'algae green', rgb: 0x93dfb8, origin: './ntc' },
              { name: 'copper rust', rgb: 0x944747, origin: './ntc' },
              { name: 'arrowtown', rgb: 0x948771, origin: './ntc' },
              { name: 'scarlett', rgb: 0x950015, origin: './ntc' },
              { name: 'strikemaster', rgb: 0x956387, origin: './ntc' },
              { name: 'mountain mist', rgb: 0x959396, origin: './ntc' },
              { name: 'carmine', rgb: 0x960018, origin: './ntc' },
              { name: 'brown', rgb: 0x964b00, origin: './ntc' },
              { name: 'leather', rgb: 0x967059, origin: './ntc' },
              { name: "purple mountain's majesty", rgb: 0x9678b6, origin: './ntc' },
              { name: 'lavender purple', rgb: 0x967bb6, origin: './ntc' },
              { name: 'pewter', rgb: 0x96a8a1, origin: './ntc' },
              { name: 'summer green', rgb: 0x96bbab, origin: './ntc' },
              { name: 'au chico', rgb: 0x97605d, origin: './ntc' },
              { name: 'wisteria', rgb: 0x9771b5, origin: './ntc' },
              { name: 'atlantis', rgb: 0x97cd2d, origin: './ntc' },
              { name: 'vin rouge', rgb: 0x983d61, origin: './ntc' },
              { name: 'lilac bush', rgb: 0x9874d3, origin: './ntc' },
              { name: 'bazaar', rgb: 0x98777b, origin: './ntc' },
              { name: 'hacienda', rgb: 0x98811b, origin: './ntc' },
              { name: 'pale oyster', rgb: 0x988d77, origin: './ntc' },
              { name: 'mint green', rgb: 0x98ff98, origin: './ntc' },
              { name: 'fresh eggplant', rgb: 0x990066, origin: './ntc' },
              { name: 'violet eggplant', rgb: 0x991199, origin: './ntc' },
              { name: 'tamarillo', rgb: 0x991613, origin: './ntc' },
              { name: 'totem pole', rgb: 0x991b07, origin: './ntc' },
              { name: 'copper rose', rgb: 0x996666, origin: './ntc' },
              { name: 'amethyst', rgb: 0x9966cc, origin: './ntc' },
              { name: 'mountbatten pink', rgb: 0x997a8d, origin: './ntc' },
              { name: 'blue bell', rgb: 0x9999cc, origin: './ntc' },
              { name: 'prairie sand', rgb: 0x9a3820, origin: './ntc' },
              { name: 'toast', rgb: 0x9a6e61, origin: './ntc' },
              { name: 'gurkha', rgb: 0x9a9577, origin: './ntc' },
              { name: 'olivine', rgb: 0x9ab973, origin: './ntc' },
              { name: 'shadow green', rgb: 0x9ac2b8, origin: './ntc' },
              { name: 'oregon', rgb: 0x9b4703, origin: './ntc' },
              { name: 'lemon grass', rgb: 0x9b9e8f, origin: './ntc' },
              { name: 'stiletto', rgb: 0x9c3336, origin: './ntc' },
              { name: 'hawaiian tan', rgb: 0x9d5616, origin: './ntc' },
              { name: 'gull gray', rgb: 0x9dacb7, origin: './ntc' },
              { name: 'pistachio', rgb: 0x9dc209, origin: './ntc' },
              { name: 'granny smith apple', rgb: 0x9de093, origin: './ntc' },
              { name: 'anakiwa', rgb: 0x9de5ff, origin: './ntc' },
              { name: 'chelsea gem', rgb: 0x9e5302, origin: './ntc' },
              { name: 'sepia skin', rgb: 0x9e5b40, origin: './ntc' },
              { name: 'sage', rgb: 0x9ea587, origin: './ntc' },
              { name: 'citron', rgb: 0x9ea91f, origin: './ntc' },
              { name: 'rock blue', rgb: 0x9eb1cd, origin: './ntc' },
              { name: 'morning glory', rgb: 0x9edee0, origin: './ntc' },
              { name: 'cognac', rgb: 0x9f381d, origin: './ntc' },
              { name: 'reef gold', rgb: 0x9f821c, origin: './ntc' },
              { name: 'star dust', rgb: 0x9f9f9c, origin: './ntc' },
              { name: 'santas gray', rgb: 0x9fa0b1, origin: './ntc' },
              { name: 'sinbad', rgb: 0x9fd7d3, origin: './ntc' },
              { name: 'feijoa', rgb: 0x9fdd8c, origin: './ntc' },
              { name: 'tabasco', rgb: 0xa02712, origin: './ntc' },
              { name: 'buttered rum', rgb: 0xa1750d, origin: './ntc' },
              { name: 'hit gray', rgb: 0xa1adb5, origin: './ntc' },
              { name: 'citrus', rgb: 0xa1c50a, origin: './ntc' },
              { name: 'aqua island', rgb: 0xa1dad7, origin: './ntc' },
              { name: 'water leaf', rgb: 0xa1e9de, origin: './ntc' },
              { name: 'flirt', rgb: 0xa2006d, origin: './ntc' },
              { name: 'rouge', rgb: 0xa23b6c, origin: './ntc' },
              { name: 'cape palliser', rgb: 0xa26645, origin: './ntc' },
              { name: 'gray chateau', rgb: 0xa2aab3, origin: './ntc' },
              { name: 'edward', rgb: 0xa2aeab, origin: './ntc' },
              { name: 'pharlap', rgb: 0xa3807b, origin: './ntc' },
              { name: 'amethyst smoke', rgb: 0xa397b4, origin: './ntc' },
              { name: 'blizzard blue', rgb: 0xa3e3ed, origin: './ntc' },
              { name: 'delta', rgb: 0xa4a49d, origin: './ntc' },
              { name: 'wistful', rgb: 0xa4a6d3, origin: './ntc' },
              { name: 'green smoke', rgb: 0xa4af6e, origin: './ntc' },
              { name: 'jazzberry jam', rgb: 0xa50b5e, origin: './ntc' },
              { name: 'zorba', rgb: 0xa59b91, origin: './ntc' },
              { name: 'bahia', rgb: 0xa5cb0c, origin: './ntc' },
              { name: 'roof terracotta', rgb: 0xa62f20, origin: './ntc' },
              { name: 'paarl', rgb: 0xa65529, origin: './ntc' },
              { name: 'barley corn', rgb: 0xa68b5b, origin: './ntc' },
              { name: 'donkey brown', rgb: 0xa69279, origin: './ntc' },
              { name: 'dawn', rgb: 0xa6a29a, origin: './ntc' },
              { name: 'mexican red', rgb: 0xa72525, origin: './ntc' },
              { name: 'luxor gold', rgb: 0xa7882c, origin: './ntc' },
              { name: 'rich gold', rgb: 0xa85307, origin: './ntc' },
              { name: 'reno sand', rgb: 0xa86515, origin: './ntc' },
              { name: 'coral tree', rgb: 0xa86b6b, origin: './ntc' },
              { name: 'dusty gray', rgb: 0xa8989b, origin: './ntc' },
              { name: 'dull lavender', rgb: 0xa899e6, origin: './ntc' },
              { name: 'tallow', rgb: 0xa8a589, origin: './ntc' },
              { name: 'bud', rgb: 0xa8ae9c, origin: './ntc' },
              { name: 'locust', rgb: 0xa8af8e, origin: './ntc' },
              { name: 'norway', rgb: 0xa8bd9f, origin: './ntc' },
              { name: 'chinook', rgb: 0xa8e3bd, origin: './ntc' },
              { name: 'gray olive', rgb: 0xa9a491, origin: './ntc' },
              { name: 'aluminium', rgb: 0xa9acb6, origin: './ntc' },
              { name: 'cadet blue', rgb: 0xa9b2c3, origin: './ntc' },
              { name: 'schist', rgb: 0xa9b497, origin: './ntc' },
              { name: 'tower gray', rgb: 0xa9bdbf, origin: './ntc' },
              { name: 'perano', rgb: 0xa9bef2, origin: './ntc' },
              { name: 'opal', rgb: 0xa9c6c2, origin: './ntc' },
              { name: 'night shadz', rgb: 0xaa375a, origin: './ntc' },
              { name: 'fire', rgb: 0xaa4203, origin: './ntc' },
              { name: 'muesli', rgb: 0xaa8b5b, origin: './ntc' },
              { name: 'sandal', rgb: 0xaa8d6f, origin: './ntc' },
              { name: 'shady lady', rgb: 0xaaa5a9, origin: './ntc' },
              { name: 'logan', rgb: 0xaaa9cd, origin: './ntc' },
              { name: 'spun pearl', rgb: 0xaaabb7, origin: './ntc' },
              { name: 'regent st blue', rgb: 0xaad6e6, origin: './ntc' },
              { name: 'magic mint', rgb: 0xaaf0d1, origin: './ntc' },
              { name: 'lipstick', rgb: 0xab0563, origin: './ntc' },
              { name: 'royal heath', rgb: 0xab3472, origin: './ntc' },
              { name: 'sandrift', rgb: 0xab917a, origin: './ntc' },
              { name: 'cold purple', rgb: 0xaba0d9, origin: './ntc' },
              { name: 'bronco', rgb: 0xaba196, origin: './ntc' },
              { name: 'limed oak', rgb: 0xac8a56, origin: './ntc' },
              { name: 'east side', rgb: 0xac91ce, origin: './ntc' },
              { name: 'lemon ginger', rgb: 0xac9e22, origin: './ntc' },
              { name: 'napa', rgb: 0xaca494, origin: './ntc' },
              { name: 'hillary', rgb: 0xaca586, origin: './ntc' },
              { name: 'cloudy', rgb: 0xaca59f, origin: './ntc' },
              { name: 'silver chalice', rgb: 0xacacac, origin: './ntc' },
              { name: 'swamp green', rgb: 0xacb78e, origin: './ntc' },
              { name: 'spring rain', rgb: 0xaccbb1, origin: './ntc' },
              { name: 'conifer', rgb: 0xacdd4d, origin: './ntc' },
              { name: 'celadon', rgb: 0xace1af, origin: './ntc' },
              { name: 'mandalay', rgb: 0xad781b, origin: './ntc' },
              { name: 'casper', rgb: 0xadbed1, origin: './ntc' },
              { name: 'moss green', rgb: 0xaddfad, origin: './ntc' },
              { name: 'padua', rgb: 0xade6c4, origin: './ntc' },
              { name: 'green yellow', rgb: 0xadff2f, origin: './ntc' },
              { name: 'hippie pink', rgb: 0xae4560, origin: './ntc' },
              { name: 'desert', rgb: 0xae6020, origin: './ntc' },
              { name: 'bouquet', rgb: 0xae809e, origin: './ntc' },
              { name: 'medium carmine', rgb: 0xaf4035, origin: './ntc' },
              { name: 'apple blossom', rgb: 0xaf4d43, origin: './ntc' },
              { name: 'brown rust', rgb: 0xaf593e, origin: './ntc' },
              { name: 'driftwood', rgb: 0xaf8751, origin: './ntc' },
              { name: 'alpine', rgb: 0xaf8f2c, origin: './ntc' },
              { name: 'lucky', rgb: 0xaf9f1c, origin: './ntc' },
              { name: 'martini', rgb: 0xafa09e, origin: './ntc' },
              { name: 'bombay', rgb: 0xafb1b8, origin: './ntc' },
              { name: 'pigeon post', rgb: 0xafbdd9, origin: './ntc' },
              { name: 'cadillac', rgb: 0xb04c6a, origin: './ntc' },
              { name: 'matrix', rgb: 0xb05d54, origin: './ntc' },
              { name: 'tapestry', rgb: 0xb05e81, origin: './ntc' },
              { name: 'mai tai', rgb: 0xb06608, origin: './ntc' },
              { name: 'del rio', rgb: 0xb09a95, origin: './ntc' },
              { name: 'powder blue', rgb: 0xb0e0e6, origin: './ntc' },
              { name: 'inch worm', rgb: 0xb0e313, origin: './ntc' },
              { name: 'bright red', rgb: 0xb10000, origin: './ntc' },
              { name: 'vesuvius', rgb: 0xb14a0b, origin: './ntc' },
              { name: 'pumpkin skin', rgb: 0xb1610b, origin: './ntc' },
              { name: 'santa fe', rgb: 0xb16d52, origin: './ntc' },
              { name: 'teak', rgb: 0xb19461, origin: './ntc' },
              { name: 'fringy flower', rgb: 0xb1e2c1, origin: './ntc' },
              { name: 'ice cold', rgb: 0xb1f4e7, origin: './ntc' },
              { name: 'shiraz', rgb: 0xb20931, origin: './ntc' },
              { name: 'biloba flower', rgb: 0xb2a1ea, origin: './ntc' },
              { name: 'tall poppy', rgb: 0xb32d29, origin: './ntc' },
              { name: 'fiery orange', rgb: 0xb35213, origin: './ntc' },
              { name: 'hot toddy', rgb: 0xb38007, origin: './ntc' },
              { name: 'taupe gray', rgb: 0xb3af95, origin: './ntc' },
              { name: 'la rioja', rgb: 0xb3c110, origin: './ntc' },
              { name: 'well read', rgb: 0xb43332, origin: './ntc' },
              { name: 'blush', rgb: 0xb44668, origin: './ntc' },
              { name: 'jungle mist', rgb: 0xb4cfd3, origin: './ntc' },
              { name: 'turkish rose', rgb: 0xb57281, origin: './ntc' },
              { name: 'lavender', rgb: 0xb57edc, origin: './ntc' },
              { name: 'mongoose', rgb: 0xb5a27f, origin: './ntc' },
              { name: 'olive green', rgb: 0xb5b35c, origin: './ntc' },
              { name: 'jet stream', rgb: 0xb5d2ce, origin: './ntc' },
              { name: 'cruise', rgb: 0xb5ecdf, origin: './ntc' },
              { name: 'hibiscus', rgb: 0xb6316c, origin: './ntc' },
              { name: 'thatch', rgb: 0xb69d98, origin: './ntc' },
              { name: 'heathered gray', rgb: 0xb6b095, origin: './ntc' },
              { name: 'eagle', rgb: 0xb6baa4, origin: './ntc' },
              { name: 'spindle', rgb: 0xb6d1ea, origin: './ntc' },
              { name: 'gum leaf', rgb: 0xb6d3bf, origin: './ntc' },
              { name: 'rust', rgb: 0xb7410e, origin: './ntc' },
              { name: 'muddy waters', rgb: 0xb78e5c, origin: './ntc' },
              { name: 'sahara', rgb: 0xb7a214, origin: './ntc' },
              { name: 'husk', rgb: 0xb7a458, origin: './ntc' },
              { name: 'nobel', rgb: 0xb7b1b1, origin: './ntc' },
              { name: 'heather', rgb: 0xb7c3d0, origin: './ntc' },
              { name: 'madang', rgb: 0xb7f0be, origin: './ntc' },
              { name: 'milano red', rgb: 0xb81104, origin: './ntc' },
              { name: 'copper', rgb: 0xb87333, origin: './ntc' },
              { name: 'gimblet', rgb: 0xb8b56a, origin: './ntc' },
              { name: 'green spring', rgb: 0xb8c1b1, origin: './ntc' },
              { name: 'celery', rgb: 0xb8c25d, origin: './ntc' },
              { name: 'sail', rgb: 0xb8e0f9, origin: './ntc' },
              { name: 'chestnut', rgb: 0xb94e48, origin: './ntc' },
              { name: 'crail', rgb: 0xb95140, origin: './ntc' },
              { name: 'marigold', rgb: 0xb98d28, origin: './ntc' },
              { name: 'wild willow', rgb: 0xb9c46a, origin: './ntc' },
              { name: 'rainee', rgb: 0xb9c8ac, origin: './ntc' },
              { name: 'guardsman red', rgb: 0xba0101, origin: './ntc' },
              { name: 'rock spray', rgb: 0xba450c, origin: './ntc' },
              { name: 'bourbon', rgb: 0xba6f1e, origin: './ntc' },
              { name: 'pirate gold', rgb: 0xba7f03, origin: './ntc' },
              { name: 'nomad', rgb: 0xbab1a2, origin: './ntc' },
              { name: 'submarine', rgb: 0xbac7c9, origin: './ntc' },
              { name: 'charlotte', rgb: 0xbaeef9, origin: './ntc' },
              { name: 'medium red violet', rgb: 0xbb3385, origin: './ntc' },
              { name: 'brandy rose', rgb: 0xbb8983, origin: './ntc' },
              { name: 'rio grande', rgb: 0xbbd009, origin: './ntc' },
              { name: 'surf', rgb: 0xbbd7c1, origin: './ntc' },
              { name: 'powder ash', rgb: 0xbcc9c2, origin: './ntc' },
              { name: 'tuscany', rgb: 0xbd5e2e, origin: './ntc' },
              { name: 'quicksand', rgb: 0xbd978e, origin: './ntc' },
              { name: 'silk', rgb: 0xbdb1a8, origin: './ntc' },
              { name: 'malta', rgb: 0xbdb2a1, origin: './ntc' },
              { name: 'chatelle', rgb: 0xbdb3c7, origin: './ntc' },
              { name: 'lavender gray', rgb: 0xbdbbd7, origin: './ntc' },
              { name: 'french gray', rgb: 0xbdbdc6, origin: './ntc' },
              { name: 'clay ash', rgb: 0xbdc8b3, origin: './ntc' },
              { name: 'loblolly', rgb: 0xbdc9ce, origin: './ntc' },
              { name: 'french pass', rgb: 0xbdedfd, origin: './ntc' },
              { name: 'london hue', rgb: 0xbea6c3, origin: './ntc' },
              { name: 'pink swan', rgb: 0xbeb5b7, origin: './ntc' },
              { name: 'fuego', rgb: 0xbede0d, origin: './ntc' },
              { name: 'rose of sharon', rgb: 0xbf5500, origin: './ntc' },
              { name: 'tide', rgb: 0xbfb8b0, origin: './ntc' },
              { name: 'blue haze', rgb: 0xbfbed8, origin: './ntc' },
              { name: 'silver sand', rgb: 0xbfc1c2, origin: './ntc' },
              { name: 'key lime pie', rgb: 0xbfc921, origin: './ntc' },
              { name: 'ziggurat', rgb: 0xbfdbe2, origin: './ntc' },
              { name: 'lime', rgb: 0xbfff00, origin: './ntc' },
              { name: 'thunderbird', rgb: 0xc02b18, origin: './ntc' },
              { name: 'mojo', rgb: 0xc04737, origin: './ntc' },
              { name: 'old rose', rgb: 0xc08081, origin: './ntc' },
              { name: 'silver', rgb: 0xc0c0c0, origin: './ntc' },
              { name: 'pale leaf', rgb: 0xc0d3b9, origin: './ntc' },
              { name: 'pixie green', rgb: 0xc0d8b6, origin: './ntc' },
              { name: 'tia maria', rgb: 0xc1440e, origin: './ntc' },
              { name: 'fuchsia pink', rgb: 0xc154c1, origin: './ntc' },
              { name: 'buddha gold', rgb: 0xc1a004, origin: './ntc' },
              { name: 'bison hide', rgb: 0xc1b7a4, origin: './ntc' },
              { name: 'tea', rgb: 0xc1bab0, origin: './ntc' },
              { name: 'gray suit', rgb: 0xc1becd, origin: './ntc' },
              { name: 'sprout', rgb: 0xc1d7b0, origin: './ntc' },
              { name: 'sulu', rgb: 0xc1f07c, origin: './ntc' },
              { name: 'indochine', rgb: 0xc26b03, origin: './ntc' },
              { name: 'twine', rgb: 0xc2955d, origin: './ntc' },
              { name: 'cotton seed', rgb: 0xc2bdb6, origin: './ntc' },
              { name: 'pumice', rgb: 0xc2cac4, origin: './ntc' },
              { name: 'jagged ice', rgb: 0xc2e8e5, origin: './ntc' },
              { name: 'maroon flush', rgb: 0xc32148, origin: './ntc' },
              { name: 'indian khaki', rgb: 0xc3b091, origin: './ntc' },
              { name: 'pale slate', rgb: 0xc3bfc1, origin: './ntc' },
              { name: 'gray nickel', rgb: 0xc3c3bd, origin: './ntc' },
              { name: 'periwinkle gray', rgb: 0xc3cde6, origin: './ntc' },
              { name: 'tiara', rgb: 0xc3d1d1, origin: './ntc' },
              { name: 'tropical blue', rgb: 0xc3ddf9, origin: './ntc' },
              { name: 'cardinal', rgb: 0xc41e3a, origin: './ntc' },
              { name: 'fuzzy wuzzy brown', rgb: 0xc45655, origin: './ntc' },
              { name: 'orange roughy', rgb: 0xc45719, origin: './ntc' },
              { name: 'mist gray', rgb: 0xc4c4bc, origin: './ntc' },
              { name: 'coriander', rgb: 0xc4d0b0, origin: './ntc' },
              { name: 'mint tulip', rgb: 0xc4f4eb, origin: './ntc' },
              { name: 'mulberry', rgb: 0xc54b8c, origin: './ntc' },
              { name: 'nugget', rgb: 0xc59922, origin: './ntc' },
              { name: 'tussock', rgb: 0xc5994b, origin: './ntc' },
              { name: 'sea mist', rgb: 0xc5dbca, origin: './ntc' },
              { name: 'yellow green', rgb: 0xc5e17a, origin: './ntc' },
              { name: 'brick red', rgb: 0xc62d42, origin: './ntc' },
              { name: 'contessa', rgb: 0xc6726b, origin: './ntc' },
              { name: 'oriental pink', rgb: 0xc69191, origin: './ntc' },
              { name: 'roti', rgb: 0xc6a84b, origin: './ntc' },
              { name: 'ash', rgb: 0xc6c3b5, origin: './ntc' },
              { name: 'kangaroo', rgb: 0xc6c8bd, origin: './ntc' },
              { name: 'las palmas', rgb: 0xc6e610, origin: './ntc' },
              { name: 'monza', rgb: 0xc7031e, origin: './ntc' },
              { name: 'red violet', rgb: 0xc71585, origin: './ntc' },
              { name: 'coral reef', rgb: 0xc7bca2, origin: './ntc' },
              { name: 'melrose', rgb: 0xc7c1ff, origin: './ntc' },
              { name: 'cloud', rgb: 0xc7c4bf, origin: './ntc' },
              { name: 'ghost', rgb: 0xc7c9d5, origin: './ntc' },
              { name: 'pine glade', rgb: 0xc7cd90, origin: './ntc' },
              { name: 'botticelli', rgb: 0xc7dde5, origin: './ntc' },
              { name: 'antique brass', rgb: 0xc88a65, origin: './ntc' },
              { name: 'lilac', rgb: 0xc8a2c8, origin: './ntc' },
              { name: 'hokey pokey', rgb: 0xc8a528, origin: './ntc' },
              { name: 'lily', rgb: 0xc8aabf, origin: './ntc' },
              { name: 'laser', rgb: 0xc8b568, origin: './ntc' },
              { name: 'edgewater', rgb: 0xc8e3d7, origin: './ntc' },
              { name: 'piper', rgb: 0xc96323, origin: './ntc' },
              { name: 'pizza', rgb: 0xc99415, origin: './ntc' },
              { name: 'light wisteria', rgb: 0xc9a0dc, origin: './ntc' },
              { name: 'rodeo dust', rgb: 0xc9b29b, origin: './ntc' },
              { name: 'sundance', rgb: 0xc9b35b, origin: './ntc' },
              { name: 'earls green', rgb: 0xc9b93b, origin: './ntc' },
              { name: 'silver rust', rgb: 0xc9c0bb, origin: './ntc' },
              { name: 'conch', rgb: 0xc9d9d2, origin: './ntc' },
              { name: 'reef', rgb: 0xc9ffa2, origin: './ntc' },
              { name: 'aero blue', rgb: 0xc9ffe5, origin: './ntc' },
              { name: 'flush mahogany', rgb: 0xca3435, origin: './ntc' },
              { name: 'turmeric', rgb: 0xcabb48, origin: './ntc' },
              { name: 'paris white', rgb: 0xcadcd4, origin: './ntc' },
              { name: 'bitter lemon', rgb: 0xcae00d, origin: './ntc' },
              { name: 'skeptic', rgb: 0xcae6da, origin: './ntc' },
              { name: 'viola', rgb: 0xcb8fa9, origin: './ntc' },
              { name: 'foggy gray', rgb: 0xcbcab6, origin: './ntc' },
              { name: 'green mist', rgb: 0xcbd3b0, origin: './ntc' },
              { name: 'nebula', rgb: 0xcbdbd6, origin: './ntc' },
              { name: 'persian red', rgb: 0xcc3333, origin: './ntc' },
              { name: 'burnt orange', rgb: 0xcc5500, origin: './ntc' },
              { name: 'ochre', rgb: 0xcc7722, origin: './ntc' },
              { name: 'puce', rgb: 0xcc8899, origin: './ntc' },
              { name: 'thistle green', rgb: 0xcccaa8, origin: './ntc' },
              { name: 'periwinkle', rgb: 0xccccff, origin: './ntc' },
              { name: 'electric lime', rgb: 0xccff00, origin: './ntc' },
              { name: 'tenn', rgb: 0xcd5700, origin: './ntc' },
              { name: 'chestnut rose', rgb: 0xcd5c5c, origin: './ntc' },
              { name: 'brandy punch', rgb: 0xcd8429, origin: './ntc' },
              { name: 'onahau', rgb: 0xcdf4ff, origin: './ntc' },
              { name: 'sorrell brown', rgb: 0xceb98f, origin: './ntc' },
              { name: 'cold turkey', rgb: 0xcebaba, origin: './ntc' },
              { name: 'yuma', rgb: 0xcec291, origin: './ntc' },
              { name: 'chino', rgb: 0xcec7a7, origin: './ntc' },
              { name: 'eunry', rgb: 0xcfa39d, origin: './ntc' },
              { name: 'old gold', rgb: 0xcfb53b, origin: './ntc' },
              { name: 'tasman', rgb: 0xcfdccf, origin: './ntc' },
              { name: 'surf crest', rgb: 0xcfe5d2, origin: './ntc' },
              { name: 'humming bird', rgb: 0xcff9f3, origin: './ntc' },
              { name: 'scandal', rgb: 0xcffaf4, origin: './ntc' },
              { name: 'red stage', rgb: 0xd05f04, origin: './ntc' },
              { name: 'hopbush', rgb: 0xd06da1, origin: './ntc' },
              { name: 'meteor', rgb: 0xd07d12, origin: './ntc' },
              { name: 'perfume', rgb: 0xd0bef8, origin: './ntc' },
              { name: 'prelude', rgb: 0xd0c0e5, origin: './ntc' },
              { name: 'tea green', rgb: 0xd0f0c0, origin: './ntc' },
              { name: 'geebung', rgb: 0xd18f1b, origin: './ntc' },
              { name: 'vanilla', rgb: 0xd1bea8, origin: './ntc' },
              { name: 'soft amber', rgb: 0xd1c6b4, origin: './ntc' },
              { name: 'celeste', rgb: 0xd1d2ca, origin: './ntc' },
              { name: 'mischka', rgb: 0xd1d2dd, origin: './ntc' },
              { name: 'pear', rgb: 0xd1e231, origin: './ntc' },
              { name: 'hot cinnamon', rgb: 0xd2691e, origin: './ntc' },
              { name: 'raw sienna', rgb: 0xd27d46, origin: './ntc' },
              { name: 'careys pink', rgb: 0xd29eaa, origin: './ntc' },
              { name: 'tan', rgb: 0xd2b48c, origin: './ntc' },
              { name: 'deco', rgb: 0xd2da97, origin: './ntc' },
              { name: 'blue romance', rgb: 0xd2f6de, origin: './ntc' },
              { name: 'gossip', rgb: 0xd2f8b0, origin: './ntc' },
              { name: 'sisal', rgb: 0xd3cbba, origin: './ntc' },
              { name: 'swirl', rgb: 0xd3cdc5, origin: './ntc' },
              { name: 'charm', rgb: 0xd47494, origin: './ntc' },
              { name: 'clam shell', rgb: 0xd4b6af, origin: './ntc' },
              { name: 'straw', rgb: 0xd4bf8d, origin: './ntc' },
              { name: 'akaroa', rgb: 0xd4c4a8, origin: './ntc' },
              { name: 'bird flower', rgb: 0xd4cd16, origin: './ntc' },
              { name: 'iron', rgb: 0xd4d7d9, origin: './ntc' },
              { name: 'geyser', rgb: 0xd4dfe2, origin: './ntc' },
              { name: 'hawkes blue', rgb: 0xd4e2fc, origin: './ntc' },
              { name: 'grenadier', rgb: 0xd54600, origin: './ntc' },
              { name: 'can can', rgb: 0xd591a4, origin: './ntc' },
              { name: 'whiskey', rgb: 0xd59a6f, origin: './ntc' },
              { name: 'winter hazel', rgb: 0xd5d195, origin: './ntc' },
              { name: 'granny apple', rgb: 0xd5f6e3, origin: './ntc' },
              { name: 'my pink', rgb: 0xd69188, origin: './ntc' },
              { name: 'tacha', rgb: 0xd6c562, origin: './ntc' },
              { name: 'moon raker', rgb: 0xd6cef6, origin: './ntc' },
              { name: 'quill gray', rgb: 0xd6d6d1, origin: './ntc' },
              { name: 'snowy mint', rgb: 0xd6ffdb, origin: './ntc' },
              { name: 'new york pink', rgb: 0xd7837f, origin: './ntc' },
              { name: 'pavlova', rgb: 0xd7c498, origin: './ntc' },
              { name: 'fog', rgb: 0xd7d0ff, origin: './ntc' },
              { name: 'valencia', rgb: 0xd84437, origin: './ntc' },
              { name: 'japonica', rgb: 0xd87c63, origin: './ntc' },
              { name: 'thistle', rgb: 0xd8bfd8, origin: './ntc' },
              { name: 'maverick', rgb: 0xd8c2d5, origin: './ntc' },
              { name: 'foam', rgb: 0xd8fcfa, origin: './ntc' },
              { name: 'cabaret', rgb: 0xd94972, origin: './ntc' },
              { name: 'burning sand', rgb: 0xd99376, origin: './ntc' },
              { name: 'cameo', rgb: 0xd9b99b, origin: './ntc' },
              { name: 'timberwolf', rgb: 0xd9d6cf, origin: './ntc' },
              { name: 'tana', rgb: 0xd9dcc1, origin: './ntc' },
              { name: 'link water', rgb: 0xd9e4f5, origin: './ntc' },
              { name: 'mabel', rgb: 0xd9f7ff, origin: './ntc' },
              { name: 'cerise', rgb: 0xda3287, origin: './ntc' },
              { name: 'flame pea', rgb: 0xda5b38, origin: './ntc' },
              { name: 'bamboo', rgb: 0xda6304, origin: './ntc' },
              { name: 'red damask', rgb: 0xda6a41, origin: './ntc' },
              { name: 'orchid', rgb: 0xda70d6, origin: './ntc' },
              { name: 'copperfield', rgb: 0xda8a67, origin: './ntc' },
              { name: 'golden grass', rgb: 0xdaa520, origin: './ntc' },
              { name: 'zanah', rgb: 0xdaecd6, origin: './ntc' },
              { name: 'iceberg', rgb: 0xdaf4f0, origin: './ntc' },
              { name: 'oyster bay', rgb: 0xdafaff, origin: './ntc' },
              { name: 'cranberry', rgb: 0xdb5079, origin: './ntc' },
              { name: 'petite orchid', rgb: 0xdb9690, origin: './ntc' },
              { name: 'di serria', rgb: 0xdb995e, origin: './ntc' },
              { name: 'alto', rgb: 0xdbdbdb, origin: './ntc' },
              { name: 'frosted mint', rgb: 0xdbfff8, origin: './ntc' },
              { name: 'crimson', rgb: 0xdc143c, origin: './ntc' },
              { name: 'punch', rgb: 0xdc4333, origin: './ntc' },
              { name: 'galliano', rgb: 0xdcb20c, origin: './ntc' },
              { name: 'blossom', rgb: 0xdcb4bc, origin: './ntc' },
              { name: 'wattle', rgb: 0xdcd747, origin: './ntc' },
              { name: 'westar', rgb: 0xdcd9d2, origin: './ntc' },
              { name: 'moon mist', rgb: 0xdcddcc, origin: './ntc' },
              { name: 'caper', rgb: 0xdcedb4, origin: './ntc' },
              { name: 'swans down', rgb: 0xdcf0ea, origin: './ntc' },
              { name: 'swiss coffee', rgb: 0xddd6d5, origin: './ntc' },
              { name: 'white ice', rgb: 0xddf9f1, origin: './ntc' },
              { name: 'cerise red', rgb: 0xde3163, origin: './ntc' },
              { name: 'roman', rgb: 0xde6360, origin: './ntc' },
              { name: 'tumbleweed', rgb: 0xdea681, origin: './ntc' },
              { name: 'gold tips', rgb: 0xdeba13, origin: './ntc' },
              { name: 'brandy', rgb: 0xdec196, origin: './ntc' },
              { name: 'wafer', rgb: 0xdecbc6, origin: './ntc' },
              { name: 'sapling', rgb: 0xded4a4, origin: './ntc' },
              { name: 'barberry', rgb: 0xded717, origin: './ntc' },
              { name: 'beryl green', rgb: 0xdee5c0, origin: './ntc' },
              { name: 'pattens blue', rgb: 0xdef5ff, origin: './ntc' },
              { name: 'heliotrope', rgb: 0xdf73ff, origin: './ntc' },
              { name: 'apache', rgb: 0xdfbe6f, origin: './ntc' },
              { name: 'chenin', rgb: 0xdfcd6f, origin: './ntc' },
              { name: 'lola', rgb: 0xdfcfdb, origin: './ntc' },
              { name: 'willow brook', rgb: 0xdfecda, origin: './ntc' },
              { name: 'chartreuse yellow', rgb: 0xdfff00, origin: './ntc' },
              { name: 'mauve', rgb: 0xe0b0ff, origin: './ntc' },
              { name: 'anzac', rgb: 0xe0b646, origin: './ntc' },
              { name: 'harvest gold', rgb: 0xe0b974, origin: './ntc' },
              { name: 'calico', rgb: 0xe0c095, origin: './ntc' },
              { name: 'baby blue', rgb: 0xe0ffff, origin: './ntc' },
              { name: 'sunglo', rgb: 0xe16865, origin: './ntc' },
              { name: 'equator', rgb: 0xe1bc64, origin: './ntc' },
              { name: 'pink flare', rgb: 0xe1c0c8, origin: './ntc' },
              { name: 'periglacial blue', rgb: 0xe1e6d6, origin: './ntc' },
              { name: 'kidnapper', rgb: 0xe1ead4, origin: './ntc' },
              { name: 'tara', rgb: 0xe1f6e8, origin: './ntc' },
              { name: 'mandy', rgb: 0xe25465, origin: './ntc' },
              { name: 'terracotta', rgb: 0xe2725b, origin: './ntc' },
              { name: 'golden bell', rgb: 0xe28913, origin: './ntc' },
              { name: 'shocking', rgb: 0xe292c0, origin: './ntc' },
              { name: 'dixie', rgb: 0xe29418, origin: './ntc' },
              { name: 'light orchid', rgb: 0xe29cd2, origin: './ntc' },
              { name: 'snuff', rgb: 0xe2d8ed, origin: './ntc' },
              { name: 'mystic', rgb: 0xe2ebed, origin: './ntc' },
              { name: 'apple green', rgb: 0xe2f3ec, origin: './ntc' },
              { name: 'razzmatazz', rgb: 0xe30b5c, origin: './ntc' },
              { name: 'alizarin crimson', rgb: 0xe32636, origin: './ntc' },
              { name: 'cinnabar', rgb: 0xe34234, origin: './ntc' },
              { name: 'cavern pink', rgb: 0xe3bebe, origin: './ntc' },
              { name: 'peppermint', rgb: 0xe3f5e1, origin: './ntc' },
              { name: 'mindaro', rgb: 0xe3f988, origin: './ntc' },
              { name: 'deep blush', rgb: 0xe47698, origin: './ntc' },
              { name: 'gamboge', rgb: 0xe49b0f, origin: './ntc' },
              { name: 'melanie', rgb: 0xe4c2d5, origin: './ntc' },
              { name: 'twilight', rgb: 0xe4cfde, origin: './ntc' },
              { name: 'bone', rgb: 0xe4d1c0, origin: './ntc' },
              { name: 'sunflower', rgb: 0xe4d422, origin: './ntc' },
              { name: 'grain brown', rgb: 0xe4d5b7, origin: './ntc' },
              { name: 'zombie', rgb: 0xe4d69b, origin: './ntc' },
              { name: 'frostee', rgb: 0xe4f6e7, origin: './ntc' },
              { name: 'snow flurry', rgb: 0xe4ffd1, origin: './ntc' },
              { name: 'amaranth', rgb: 0xe52b50, origin: './ntc' },
              { name: 'zest', rgb: 0xe5841b, origin: './ntc' },
              { name: 'dust storm', rgb: 0xe5ccc9, origin: './ntc' },
              { name: 'stark white', rgb: 0xe5d7bd, origin: './ntc' },
              { name: 'hampton', rgb: 0xe5d8af, origin: './ntc' },
              { name: 'bon jour', rgb: 0xe5e0e1, origin: './ntc' },
              { name: 'mercury', rgb: 0xe5e5e5, origin: './ntc' },
              { name: 'polar', rgb: 0xe5f9f6, origin: './ntc' },
              { name: 'trinidad', rgb: 0xe64e03, origin: './ntc' },
              { name: 'gold sand', rgb: 0xe6be8a, origin: './ntc' },
              { name: 'cashmere', rgb: 0xe6bea5, origin: './ntc' },
              { name: 'double spanish white', rgb: 0xe6d7b9, origin: './ntc' },
              { name: 'satin linen', rgb: 0xe6e4d4, origin: './ntc' },
              { name: 'harp', rgb: 0xe6f2ea, origin: './ntc' },
              { name: 'off green', rgb: 0xe6f8f3, origin: './ntc' },
              { name: 'hint of green', rgb: 0xe6ffe9, origin: './ntc' },
              { name: 'tranquil', rgb: 0xe6ffff, origin: './ntc' },
              { name: 'mango tango', rgb: 0xe77200, origin: './ntc' },
              { name: 'christine', rgb: 0xe7730a, origin: './ntc' },
              { name: 'tonys pink', rgb: 0xe79f8c, origin: './ntc' },
              { name: 'kobi', rgb: 0xe79fc4, origin: './ntc' },
              { name: 'rose fog', rgb: 0xe7bcb4, origin: './ntc' },
              { name: 'corn', rgb: 0xe7bf05, origin: './ntc' },
              { name: 'putty', rgb: 0xe7cd8c, origin: './ntc' },
              { name: 'gray nurse', rgb: 0xe7ece6, origin: './ntc' },
              { name: 'lily white', rgb: 0xe7f8ff, origin: './ntc' },
              { name: 'bubbles', rgb: 0xe7feff, origin: './ntc' },
              { name: 'fire bush', rgb: 0xe89928, origin: './ntc' },
              { name: 'shilo', rgb: 0xe8b9b3, origin: './ntc' },
              { name: 'pearl bush', rgb: 0xe8e0d5, origin: './ntc' },
              { name: 'green white', rgb: 0xe8ebe0, origin: './ntc' },
              { name: 'chrome white', rgb: 0xe8f1d4, origin: './ntc' },
              { name: 'gin', rgb: 0xe8f2eb, origin: './ntc' },
              { name: 'aqua squeeze', rgb: 0xe8f5f2, origin: './ntc' },
              { name: 'clementine', rgb: 0xe96e00, origin: './ntc' },
              { name: 'burnt sienna', rgb: 0xe97451, origin: './ntc' },
              { name: 'tahiti gold', rgb: 0xe97c07, origin: './ntc' },
              { name: 'oyster pink', rgb: 0xe9cecd, origin: './ntc' },
              { name: 'confetti', rgb: 0xe9d75a, origin: './ntc' },
              { name: 'ebb', rgb: 0xe9e3e3, origin: './ntc' },
              { name: 'ottoman', rgb: 0xe9f8ed, origin: './ntc' },
              { name: 'clear day', rgb: 0xe9fffd, origin: './ntc' },
              { name: 'carissma', rgb: 0xea88a8, origin: './ntc' },
              { name: 'porsche', rgb: 0xeaae69, origin: './ntc' },
              { name: 'tulip tree', rgb: 0xeab33b, origin: './ntc' },
              { name: 'rob roy', rgb: 0xeac674, origin: './ntc' },
              { name: 'raffia', rgb: 0xeadab8, origin: './ntc' },
              { name: 'white rock', rgb: 0xeae8d4, origin: './ntc' },
              { name: 'panache', rgb: 0xeaf6ee, origin: './ntc' },
              { name: 'solitude', rgb: 0xeaf6ff, origin: './ntc' },
              { name: 'aqua spring', rgb: 0xeaf9f5, origin: './ntc' },
              { name: 'dew', rgb: 0xeafffe, origin: './ntc' },
              { name: 'apricot', rgb: 0xeb9373, origin: './ntc' },
              { name: 'zinnwaldite', rgb: 0xebc2af, origin: './ntc' },
              { name: 'fuel yellow', rgb: 0xeca927, origin: './ntc' },
              { name: 'ronchi', rgb: 0xecc54e, origin: './ntc' },
              { name: 'french lilac', rgb: 0xecc7ee, origin: './ntc' },
              { name: 'just right', rgb: 0xeccdb9, origin: './ntc' },
              { name: 'wild rice', rgb: 0xece090, origin: './ntc' },
              { name: 'fall green', rgb: 0xecebbd, origin: './ntc' },
              { name: 'aths special', rgb: 0xecebce, origin: './ntc' },
              { name: 'starship', rgb: 0xecf245, origin: './ntc' },
              { name: 'red ribbon', rgb: 0xed0a3f, origin: './ntc' },
              { name: 'tango', rgb: 0xed7a1c, origin: './ntc' },
              { name: 'carrot orange', rgb: 0xed9121, origin: './ntc' },
              { name: 'sea pink', rgb: 0xed989e, origin: './ntc' },
              { name: 'tacao', rgb: 0xedb381, origin: './ntc' },
              { name: 'desert sand', rgb: 0xedc9af, origin: './ntc' },
              { name: 'pancho', rgb: 0xedcdab, origin: './ntc' },
              { name: 'chamois', rgb: 0xeddcb1, origin: './ntc' },
              { name: 'primrose', rgb: 0xedea99, origin: './ntc' },
              { name: 'frost', rgb: 0xedf5dd, origin: './ntc' },
              { name: 'aqua haze', rgb: 0xedf5f5, origin: './ntc' },
              { name: 'zumthor', rgb: 0xedf6ff, origin: './ntc' },
              { name: 'narvik', rgb: 0xedf9f1, origin: './ntc' },
              { name: 'honeysuckle', rgb: 0xedfc84, origin: './ntc' },
              { name: 'lavender magenta', rgb: 0xee82ee, origin: './ntc' },
              { name: 'beauty bush', rgb: 0xeec1be, origin: './ntc' },
              { name: 'chalky', rgb: 0xeed794, origin: './ntc' },
              { name: 'almond', rgb: 0xeed9c4, origin: './ntc' },
              { name: 'flax', rgb: 0xeedc82, origin: './ntc' },
              { name: 'bizarre', rgb: 0xeededa, origin: './ntc' },
              { name: 'double colonial white', rgb: 0xeee3ad, origin: './ntc' },
              { name: 'cararra', rgb: 0xeeeee8, origin: './ntc' },
              { name: 'manz', rgb: 0xeeef78, origin: './ntc' },
              { name: 'tahuna sands', rgb: 0xeef0c8, origin: './ntc' },
              { name: 'athens gray', rgb: 0xeef0f3, origin: './ntc' },
              { name: 'tusk', rgb: 0xeef3c3, origin: './ntc' },
              { name: 'loafer', rgb: 0xeef4de, origin: './ntc' },
              { name: 'catskill white', rgb: 0xeef6f7, origin: './ntc' },
              { name: 'twilight blue', rgb: 0xeefdff, origin: './ntc' },
              { name: 'jonquil', rgb: 0xeeff9a, origin: './ntc' },
              { name: 'rice flower', rgb: 0xeeffe2, origin: './ntc' },
              { name: 'jaffa', rgb: 0xef863f, origin: './ntc' },
              { name: 'gallery', rgb: 0xefefef, origin: './ntc' },
              { name: 'porcelain', rgb: 0xeff2f3, origin: './ntc' },
              { name: 'mauvelous', rgb: 0xf091a9, origin: './ntc' },
              { name: 'golden dream', rgb: 0xf0d52d, origin: './ntc' },
              { name: 'golden sand', rgb: 0xf0db7d, origin: './ntc' },
              { name: 'buff', rgb: 0xf0dc82, origin: './ntc' },
              { name: 'prim', rgb: 0xf0e2ec, origin: './ntc' },
              { name: 'khaki', rgb: 0xf0e68c, origin: './ntc' },
              { name: 'selago', rgb: 0xf0eefd, origin: './ntc' },
              { name: 'titan white', rgb: 0xf0eeff, origin: './ntc' },
              { name: 'alice blue', rgb: 0xf0f8ff, origin: './ntc' },
              { name: 'feta', rgb: 0xf0fcea, origin: './ntc' },
              { name: 'gold drop', rgb: 0xf18200, origin: './ntc' },
              { name: 'wewak', rgb: 0xf19bab, origin: './ntc' },
              { name: 'sahara sand', rgb: 0xf1e788, origin: './ntc' },
              { name: 'parchment', rgb: 0xf1e9d2, origin: './ntc' },
              { name: 'blue chalk', rgb: 0xf1e9ff, origin: './ntc' },
              { name: 'mint julep', rgb: 0xf1eec1, origin: './ntc' },
              { name: 'seashell', rgb: 0xf1f1f1, origin: './ntc' },
              { name: 'saltpan', rgb: 0xf1f7f2, origin: './ntc' },
              { name: 'tidal', rgb: 0xf1ffad, origin: './ntc' },
              { name: 'chiffon', rgb: 0xf1ffc8, origin: './ntc' },
              { name: 'flamingo', rgb: 0xf2552a, origin: './ntc' },
              { name: 'tangerine', rgb: 0xf28500, origin: './ntc' },
              { name: 'mandys pink', rgb: 0xf2c3b2, origin: './ntc' },
              { name: 'concrete', rgb: 0xf2f2f2, origin: './ntc' },
              { name: 'black squeeze', rgb: 0xf2fafa, origin: './ntc' },
              { name: 'pomegranate', rgb: 0xf34723, origin: './ntc' },
              { name: 'buttercup', rgb: 0xf3ad16, origin: './ntc' },
              { name: 'new orleans', rgb: 0xf3d69d, origin: './ntc' },
              { name: 'vanilla ice', rgb: 0xf3d9df, origin: './ntc' },
              { name: 'sidecar', rgb: 0xf3e7bb, origin: './ntc' },
              { name: 'dawn pink', rgb: 0xf3e9e5, origin: './ntc' },
              { name: 'wheatfield', rgb: 0xf3edcf, origin: './ntc' },
              { name: 'canary', rgb: 0xf3fb62, origin: './ntc' },
              { name: 'orinoco', rgb: 0xf3fbd4, origin: './ntc' },
              { name: 'carla', rgb: 0xf3ffd8, origin: './ntc' },
              { name: 'hollywood cerise', rgb: 0xf400a1, origin: './ntc' },
              { name: 'sandy brown', rgb: 0xf4a460, origin: './ntc' },
              { name: 'saffron', rgb: 0xf4c430, origin: './ntc' },
              { name: 'ripe lemon', rgb: 0xf4d81c, origin: './ntc' },
              { name: 'janna', rgb: 0xf4ebd3, origin: './ntc' },
              { name: 'pampas', rgb: 0xf4f2ee, origin: './ntc' },
              { name: 'wild sand', rgb: 0xf4f4f4, origin: './ntc' },
              { name: 'zircon', rgb: 0xf4f8ff, origin: './ntc' },
              { name: 'froly', rgb: 0xf57584, origin: './ntc' },
              { name: 'cream can', rgb: 0xf5c85c, origin: './ntc' },
              { name: 'manhattan', rgb: 0xf5c999, origin: './ntc' },
              { name: 'maize', rgb: 0xf5d5a0, origin: './ntc' },
              { name: 'wheat', rgb: 0xf5deb3, origin: './ntc' },
              { name: 'sandwisp', rgb: 0xf5e7a2, origin: './ntc' },
              { name: 'pot pourri', rgb: 0xf5e7e2, origin: './ntc' },
              { name: 'albescent white', rgb: 0xf5e9d3, origin: './ntc' },
              { name: 'soft peach', rgb: 0xf5edef, origin: './ntc' },
              { name: 'ecru white', rgb: 0xf5f3e5, origin: './ntc' },
              { name: 'beige', rgb: 0xf5f5dc, origin: './ntc' },
              { name: 'golden fizz', rgb: 0xf5fb3d, origin: './ntc' },
              { name: 'australian mint', rgb: 0xf5ffbe, origin: './ntc' },
              { name: 'french rose', rgb: 0xf64a8a, origin: './ntc' },
              { name: 'brilliant rose', rgb: 0xf653a6, origin: './ntc' },
              { name: 'illusion', rgb: 0xf6a4c9, origin: './ntc' },
              { name: 'merino', rgb: 0xf6f0e6, origin: './ntc' },
              { name: 'black haze', rgb: 0xf6f7f7, origin: './ntc' },
              { name: 'spring sun', rgb: 0xf6ffdc, origin: './ntc' },
              { name: 'violet red', rgb: 0xf7468a, origin: './ntc' },
              { name: 'chilean fire', rgb: 0xf77703, origin: './ntc' },
              { name: 'persian pink', rgb: 0xf77fbe, origin: './ntc' },
              { name: 'rajah', rgb: 0xf7b668, origin: './ntc' },
              { name: 'azalea', rgb: 0xf7c8da, origin: './ntc' },
              { name: 'we peep', rgb: 0xf7dbe6, origin: './ntc' },
              { name: 'quarter spanish white', rgb: 0xf7f2e1, origin: './ntc' },
              { name: 'whisper', rgb: 0xf7f5fa, origin: './ntc' },
              { name: 'snow drift', rgb: 0xf7faf7, origin: './ntc' },
              { name: 'casablanca', rgb: 0xf8b853, origin: './ntc' },
              { name: 'chantilly', rgb: 0xf8c3df, origin: './ntc' },
              { name: 'cherub', rgb: 0xf8d9e9, origin: './ntc' },
              { name: 'marzipan', rgb: 0xf8db9d, origin: './ntc' },
              { name: 'energy yellow', rgb: 0xf8dd5c, origin: './ntc' },
              { name: 'givry', rgb: 0xf8e4bf, origin: './ntc' },
              { name: 'white linen', rgb: 0xf8f0e8, origin: './ntc' },
              { name: 'magnolia', rgb: 0xf8f4ff, origin: './ntc' },
              { name: 'spring wood', rgb: 0xf8f6f1, origin: './ntc' },
              { name: 'coconut cream', rgb: 0xf8f7dc, origin: './ntc' },
              { name: 'white lilac', rgb: 0xf8f7fc, origin: './ntc' },
              { name: 'desert storm', rgb: 0xf8f8f7, origin: './ntc' },
              { name: 'texas', rgb: 0xf8f99c, origin: './ntc' },
              { name: 'corn field', rgb: 0xf8facd, origin: './ntc' },
              { name: 'mimosa', rgb: 0xf8fdd3, origin: './ntc' },
              { name: 'carnation', rgb: 0xf95a61, origin: './ntc' },
              { name: 'saffron mango', rgb: 0xf9bf58, origin: './ntc' },
              { name: 'carousel pink', rgb: 0xf9e0ed, origin: './ntc' },
              { name: 'dairy cream', rgb: 0xf9e4bc, origin: './ntc' },
              { name: 'portica', rgb: 0xf9e663, origin: './ntc' },
              { name: 'amour', rgb: 0xf9eaf3, origin: './ntc' },
              { name: 'rum swizzle', rgb: 0xf9f8e4, origin: './ntc' },
              { name: 'dolly', rgb: 0xf9ff8b, origin: './ntc' },
              { name: 'sugar cane', rgb: 0xf9fff6, origin: './ntc' },
              { name: 'ecstasy', rgb: 0xfa7814, origin: './ntc' },
              { name: 'tan hide', rgb: 0xfa9d5a, origin: './ntc' },
              { name: 'corvette', rgb: 0xfad3a2, origin: './ntc' },
              { name: 'peach yellow', rgb: 0xfadfad, origin: './ntc' },
              { name: 'turbo', rgb: 0xfae600, origin: './ntc' },
              { name: 'astra', rgb: 0xfaeab9, origin: './ntc' },
              { name: 'champagne', rgb: 0xfaeccc, origin: './ntc' },
              { name: 'linen', rgb: 0xfaf0e6, origin: './ntc' },
              { name: 'fantasy', rgb: 0xfaf3f0, origin: './ntc' },
              { name: 'citrine white', rgb: 0xfaf7d6, origin: './ntc' },
              { name: 'alabaster', rgb: 0xfafafa, origin: './ntc' },
              { name: 'hint of yellow', rgb: 0xfafde4, origin: './ntc' },
              { name: 'milan', rgb: 0xfaffa4, origin: './ntc' },
              { name: 'brink pink', rgb: 0xfb607f, origin: './ntc' },
              { name: 'geraldine', rgb: 0xfb8989, origin: './ntc' },
              { name: 'lavender rose', rgb: 0xfba0e3, origin: './ntc' },
              { name: 'sea buckthorn', rgb: 0xfba129, origin: './ntc' },
              { name: 'sun', rgb: 0xfbac13, origin: './ntc' },
              { name: 'lavender pink', rgb: 0xfbaed2, origin: './ntc' },
              { name: 'rose bud', rgb: 0xfbb2a3, origin: './ntc' },
              { name: 'cupid', rgb: 0xfbbeda, origin: './ntc' },
              { name: 'classic rose', rgb: 0xfbcce7, origin: './ntc' },
              { name: 'apricot peach', rgb: 0xfbceb1, origin: './ntc' },
              { name: 'banana mania', rgb: 0xfbe7b2, origin: './ntc' },
              { name: 'marigold yellow', rgb: 0xfbe870, origin: './ntc' },
              { name: 'festival', rgb: 0xfbe96c, origin: './ntc' },
              { name: 'sweet corn', rgb: 0xfbea8c, origin: './ntc' },
              { name: 'candy corn', rgb: 0xfbec5d, origin: './ntc' },
              { name: 'hint of red', rgb: 0xfbf9f9, origin: './ntc' },
              { name: 'shalimar', rgb: 0xfbffba, origin: './ntc' },
              { name: 'shocking pink', rgb: 0xfc0fc0, origin: './ntc' },
              { name: 'tickle me pink', rgb: 0xfc80a5, origin: './ntc' },
              { name: 'tree poppy', rgb: 0xfc9c1d, origin: './ntc' },
              { name: 'lightning yellow', rgb: 0xfcc01e, origin: './ntc' },
              { name: 'goldenrod', rgb: 0xfcd667, origin: './ntc' },
              { name: 'candlelight', rgb: 0xfcd917, origin: './ntc' },
              { name: 'cherokee', rgb: 0xfcda98, origin: './ntc' },
              { name: 'double pearl lusta', rgb: 0xfcf4d0, origin: './ntc' },
              { name: 'pearl lusta', rgb: 0xfcf4dc, origin: './ntc' },
              { name: 'vista white', rgb: 0xfcf8f7, origin: './ntc' },
              { name: 'bianca', rgb: 0xfcfbf3, origin: './ntc' },
              { name: 'moon glow', rgb: 0xfcfeda, origin: './ntc' },
              { name: 'china ivory', rgb: 0xfcffe7, origin: './ntc' },
              { name: 'ceramic', rgb: 0xfcfff9, origin: './ntc' },
              { name: 'torch red', rgb: 0xfd0e35, origin: './ntc' },
              { name: 'wild watermelon', rgb: 0xfd5b78, origin: './ntc' },
              { name: 'crusta', rgb: 0xfd7b33, origin: './ntc' },
              { name: 'sorbus', rgb: 0xfd7c07, origin: './ntc' },
              { name: 'sweet pink', rgb: 0xfd9fa2, origin: './ntc' },
              { name: 'light apricot', rgb: 0xfdd5b1, origin: './ntc' },
              { name: 'pig pink', rgb: 0xfdd7e4, origin: './ntc' },
              { name: 'cinderella', rgb: 0xfde1dc, origin: './ntc' },
              { name: 'golden glow', rgb: 0xfde295, origin: './ntc' },
              { name: 'lemon', rgb: 0xfde910, origin: './ntc' },
              { name: 'old lace', rgb: 0xfdf5e6, origin: './ntc' },
              { name: 'half colonial white', rgb: 0xfdf6d3, origin: './ntc' },
              { name: 'drover', rgb: 0xfdf7ad, origin: './ntc' },
              { name: 'pale prim', rgb: 0xfdfeb8, origin: './ntc' },
              { name: 'cumulus', rgb: 0xfdffd5, origin: './ntc' },
              { name: 'persian rose', rgb: 0xfe28a2, origin: './ntc' },
              { name: 'sunset orange', rgb: 0xfe4c40, origin: './ntc' },
              { name: 'bittersweet', rgb: 0xfe6f5e, origin: './ntc' },
              { name: 'california', rgb: 0xfe9d04, origin: './ntc' },
              { name: 'yellow sea', rgb: 0xfea904, origin: './ntc' },
              { name: 'melon', rgb: 0xfebaad, origin: './ntc' },
              { name: 'bright sun', rgb: 0xfed33c, origin: './ntc' },
              { name: 'dandelion', rgb: 0xfed85d, origin: './ntc' },
              { name: 'salomie', rgb: 0xfedb8d, origin: './ntc' },
              { name: 'cape honey', rgb: 0xfee5ac, origin: './ntc' },
              { name: 'remy', rgb: 0xfeebf3, origin: './ntc' },
              { name: 'oasis', rgb: 0xfeefce, origin: './ntc' },
              { name: 'bridesmaid', rgb: 0xfef0ec, origin: './ntc' },
              { name: 'beeswax', rgb: 0xfef2c7, origin: './ntc' },
              { name: 'bleach white', rgb: 0xfef3d8, origin: './ntc' },
              { name: 'pipi', rgb: 0xfef4cc, origin: './ntc' },
              { name: 'half spanish white', rgb: 0xfef4db, origin: './ntc' },
              { name: 'wisp pink', rgb: 0xfef4f8, origin: './ntc' },
              { name: 'provincial pink', rgb: 0xfef5f1, origin: './ntc' },
              { name: 'half dutch white', rgb: 0xfef7de, origin: './ntc' },
              { name: 'solitaire', rgb: 0xfef8e2, origin: './ntc' },
              { name: 'white pointer', rgb: 0xfef8ff, origin: './ntc' },
              { name: 'off yellow', rgb: 0xfef9e3, origin: './ntc' },
              { name: 'orange white', rgb: 0xfefced, origin: './ntc' },
              { name: 'red', rgb: 0xff0000, origin: './ntc' },
              { name: 'rose', rgb: 0xff007f, origin: './ntc' },
              { name: 'purple pizzazz', rgb: 0xff00cc, origin: './ntc' },
              { name: 'magenta / fuchsia', rgb: 0xff00ff, origin: './ntc' },
              { name: 'scarlet', rgb: 0xff2400, origin: './ntc' },
              { name: 'wild strawberry', rgb: 0xff3399, origin: './ntc' },
              { name: 'razzle dazzle rose', rgb: 0xff33cc, origin: './ntc' },
              { name: 'radical red', rgb: 0xff355e, origin: './ntc' },
              { name: 'red orange', rgb: 0xff3f34, origin: './ntc' },
              { name: 'coral red', rgb: 0xff4040, origin: './ntc' },
              { name: 'vermilion', rgb: 0xff4d00, origin: './ntc' },
              { name: 'international orange', rgb: 0xff4f00, origin: './ntc' },
              { name: 'outrageous orange', rgb: 0xff6037, origin: './ntc' },
              { name: 'blaze orange', rgb: 0xff6600, origin: './ntc' },
              { name: 'pink flamingo', rgb: 0xff66ff, origin: './ntc' },
              { name: 'orange', rgb: 0xff681f, origin: './ntc' },
              { name: 'hot pink', rgb: 0xff69b4, origin: './ntc' },
              { name: 'persimmon', rgb: 0xff6b53, origin: './ntc' },
              { name: 'blush pink', rgb: 0xff6fff, origin: './ntc' },
              { name: 'burning orange', rgb: 0xff7034, origin: './ntc' },
              { name: 'pumpkin', rgb: 0xff7518, origin: './ntc' },
              { name: 'flamenco', rgb: 0xff7d07, origin: './ntc' },
              { name: 'flush orange', rgb: 0xff7f00, origin: './ntc' },
              { name: 'coral', rgb: 0xff7f50, origin: './ntc' },
              { name: 'salmon', rgb: 0xff8c69, origin: './ntc' },
              { name: 'pizazz', rgb: 0xff9000, origin: './ntc' },
              { name: 'west side', rgb: 0xff910f, origin: './ntc' },
              { name: 'pink salmon', rgb: 0xff91a4, origin: './ntc' },
              { name: 'neon carrot', rgb: 0xff9933, origin: './ntc' },
              { name: 'atomic tangerine', rgb: 0xff9966, origin: './ntc' },
              { name: 'vivid tangerine', rgb: 0xff9980, origin: './ntc' },
              { name: 'sunshade', rgb: 0xff9e2c, origin: './ntc' },
              { name: 'orange peel', rgb: 0xffa000, origin: './ntc' },
              { name: 'mona lisa', rgb: 0xffa194, origin: './ntc' },
              { name: 'web orange', rgb: 0xffa500, origin: './ntc' },
              { name: 'carnation pink', rgb: 0xffa6c9, origin: './ntc' },
              { name: 'hit pink', rgb: 0xffab81, origin: './ntc' },
              { name: 'yellow orange', rgb: 0xffae42, origin: './ntc' },
              { name: 'cornflower lilac', rgb: 0xffb0ac, origin: './ntc' },
              { name: 'sundown', rgb: 0xffb1b3, origin: './ntc' },
              { name: 'my sin', rgb: 0xffb31f, origin: './ntc' },
              { name: 'texas rose', rgb: 0xffb555, origin: './ntc' },
              { name: 'cotton candy', rgb: 0xffb7d5, origin: './ntc' },
              { name: 'macaroni and cheese', rgb: 0xffb97b, origin: './ntc' },
              { name: 'selective yellow', rgb: 0xffba00, origin: './ntc' },
              { name: 'koromiko', rgb: 0xffbd5f, origin: './ntc' },
              { name: 'amber', rgb: 0xffbf00, origin: './ntc' },
              { name: 'wax flower', rgb: 0xffc0a8, origin: './ntc' },
              { name: 'pink', rgb: 0xffc0cb, origin: './ntc' },
              { name: 'your pink', rgb: 0xffc3c0, origin: './ntc' },
              { name: 'supernova', rgb: 0xffc901, origin: './ntc' },
              { name: 'flesh', rgb: 0xffcba4, origin: './ntc' },
              { name: 'sunglow', rgb: 0xffcc33, origin: './ntc' },
              { name: 'golden tainoi', rgb: 0xffcc5c, origin: './ntc' },
              { name: 'peach orange', rgb: 0xffcc99, origin: './ntc' },
              { name: 'chardonnay', rgb: 0xffcd8c, origin: './ntc' },
              { name: 'pastel pink', rgb: 0xffd1dc, origin: './ntc' },
              { name: 'romantic', rgb: 0xffd2b7, origin: './ntc' },
              { name: 'grandis', rgb: 0xffd38c, origin: './ntc' },
              { name: 'gold', rgb: 0xffd700, origin: './ntc' },
              { name: 'school bus yellow', rgb: 0xffd800, origin: './ntc' },
              { name: 'cosmos', rgb: 0xffd8d9, origin: './ntc' },
              { name: 'mustard', rgb: 0xffdb58, origin: './ntc' },
              { name: 'peach schnapps', rgb: 0xffdcd6, origin: './ntc' },
              { name: 'caramel', rgb: 0xffddaf, origin: './ntc' },
              { name: 'tuft bush', rgb: 0xffddcd, origin: './ntc' },
              { name: 'watusi', rgb: 0xffddcf, origin: './ntc' },
              { name: 'pink lace', rgb: 0xffddf4, origin: './ntc' },
              { name: 'navajo white', rgb: 0xffdead, origin: './ntc' },
              { name: 'frangipani', rgb: 0xffdeb3, origin: './ntc' },
              { name: 'pippin', rgb: 0xffe1df, origin: './ntc' },
              { name: 'pale rose', rgb: 0xffe1f2, origin: './ntc' },
              { name: 'negroni', rgb: 0xffe2c5, origin: './ntc' },
              { name: 'cream brulee', rgb: 0xffe5a0, origin: './ntc' },
              { name: 'peach', rgb: 0xffe5b4, origin: './ntc' },
              { name: 'tequila', rgb: 0xffe6c7, origin: './ntc' },
              { name: 'kournikova', rgb: 0xffe772, origin: './ntc' },
              { name: 'sandy beach', rgb: 0xffeac8, origin: './ntc' },
              { name: 'karry', rgb: 0xffead4, origin: './ntc' },
              { name: 'broom', rgb: 0xffec13, origin: './ntc' },
              { name: 'colonial white', rgb: 0xffedbc, origin: './ntc' },
              { name: 'derby', rgb: 0xffeed8, origin: './ntc' },
              { name: 'vis vis', rgb: 0xffefa1, origin: './ntc' },
              { name: 'egg white', rgb: 0xffefc1, origin: './ntc' },
              { name: 'papaya whip', rgb: 0xffefd5, origin: './ntc' },
              { name: 'fair pink', rgb: 0xffefec, origin: './ntc' },
              { name: 'peach cream', rgb: 0xfff0db, origin: './ntc' },
              { name: 'lavender blush', rgb: 0xfff0f5, origin: './ntc' },
              { name: 'gorse', rgb: 0xfff14f, origin: './ntc' },
              { name: 'buttermilk', rgb: 0xfff1b5, origin: './ntc' },
              { name: 'pink lady', rgb: 0xfff1d8, origin: './ntc' },
              { name: 'forget me not', rgb: 0xfff1ee, origin: './ntc' },
              { name: 'tutu', rgb: 0xfff1f9, origin: './ntc' },
              { name: 'picasso', rgb: 0xfff39d, origin: './ntc' },
              { name: 'chardon', rgb: 0xfff3f1, origin: './ntc' },
              { name: 'paris daisy', rgb: 0xfff46e, origin: './ntc' },
              { name: 'barley white', rgb: 0xfff4ce, origin: './ntc' },
              { name: 'egg sour', rgb: 0xfff4dd, origin: './ntc' },
              { name: 'sazerac', rgb: 0xfff4e0, origin: './ntc' },
              { name: 'serenade', rgb: 0xfff4e8, origin: './ntc' },
              { name: 'chablis', rgb: 0xfff4f3, origin: './ntc' },
              { name: 'seashell peach', rgb: 0xfff5ee, origin: './ntc' },
              { name: 'sauvignon', rgb: 0xfff5f3, origin: './ntc' },
              { name: 'milk punch', rgb: 0xfff6d4, origin: './ntc' },
              { name: 'varden', rgb: 0xfff6df, origin: './ntc' },
              { name: 'rose white', rgb: 0xfff6f5, origin: './ntc' },
              { name: 'baja white', rgb: 0xfff8d1, origin: './ntc' },
              { name: 'gin fizz', rgb: 0xfff9e2, origin: './ntc' },
              { name: 'early dawn', rgb: 0xfff9e6, origin: './ntc' },
              { name: 'lemon chiffon', rgb: 0xfffacd, origin: './ntc' },
              { name: 'bridal heath', rgb: 0xfffaf4, origin: './ntc' },
              { name: 'scotch mist', rgb: 0xfffbdc, origin: './ntc' },
              { name: 'soapstone', rgb: 0xfffbf9, origin: './ntc' },
              { name: 'witch haze', rgb: 0xfffc99, origin: './ntc' },
              { name: 'buttery white', rgb: 0xfffcea, origin: './ntc' },
              { name: 'island spice', rgb: 0xfffcee, origin: './ntc' },
              { name: 'cream', rgb: 0xfffdd0, origin: './ntc' },
              { name: 'chilean heath', rgb: 0xfffde6, origin: './ntc' },
              { name: 'travertine', rgb: 0xfffde8, origin: './ntc' },
              { name: 'orchid white', rgb: 0xfffdf3, origin: './ntc' },
              { name: 'quarter pearl lusta', rgb: 0xfffdf4, origin: './ntc' },
              { name: 'half and half', rgb: 0xfffee1, origin: './ntc' },
              { name: 'apricot white', rgb: 0xfffeec, origin: './ntc' },
              { name: 'rice cake', rgb: 0xfffef0, origin: './ntc' },
              { name: 'black white', rgb: 0xfffef6, origin: './ntc' },
              { name: 'romance', rgb: 0xfffefd, origin: './ntc' },
              { name: 'yellow', rgb: 0xffff00, origin: './ntc' },
              { name: 'laser lemon', rgb: 0xffff66, origin: './ntc' },
              { name: 'pale canary', rgb: 0xffff99, origin: './ntc' },
              { name: 'portafino', rgb: 0xffffb4, origin: './ntc' },
              { name: 'ivory', rgb: 0xfffff0, origin: './ntc' },
              { name: 'white', rgb: 0xffffff, origin: './ntc' },
              { name: 'mahogany', rgb: 0xcd4a4a, origin: './pantone' },
              { name: 'fuzzy wuzzy brown', rgb: 0xcc6666, origin: './pantone' },
              { name: 'chestnut', rgb: 0xbc5d58, origin: './pantone' },
              { name: 'red orange', rgb: 0xff5349, origin: './pantone' },
              { name: 'sunset orange', rgb: 0xfd5e53, origin: './pantone' },
              { name: 'bittersweet', rgb: 0xfd7c6e, origin: './pantone' },
              { name: 'melon', rgb: 0xfdbcb4, origin: './pantone' },
              { name: 'outrageous orange', rgb: 0xff6e4a, origin: './pantone' },
              { name: 'vivid tangerine', rgb: 0xffa089, origin: './pantone' },
              { name: 'burnt sienna', rgb: 0xea7e5d, origin: './pantone' },
              { name: 'brown', rgb: 0xb4674d, origin: './pantone' },
              { name: 'sepia', rgb: 0xa5694f, origin: './pantone' },
              { name: 'orange', rgb: 0xff7538, origin: './pantone' },
              { name: 'burnt orange', rgb: 0xff7f49, origin: './pantone' },
              { name: 'copper', rgb: 0xdd9475, origin: './pantone' },
              { name: 'mango tango', rgb: 0xff8243, origin: './pantone' },
              { name: 'atomic tangerine', rgb: 0xffa474, origin: './pantone' },
              { name: 'beaver', rgb: 0x9f8170, origin: './pantone' },
              { name: 'antique brass', rgb: 0xcd9575, origin: './pantone' },
              { name: 'desert sand', rgb: 0xefcdb8, origin: './pantone' },
              { name: 'raw sienna', rgb: 0xd68a59, origin: './pantone' },
              { name: 'tumbleweed', rgb: 0xdeaa88, origin: './pantone' },
              { name: 'tan', rgb: 0xfaa76c, origin: './pantone' },
              { name: 'peach', rgb: 0xffcfab, origin: './pantone' },
              { name: 'macaroni and cheese', rgb: 0xffbd88, origin: './pantone' },
              { name: 'apricot', rgb: 0xfdd9b5, origin: './pantone' },
              { name: 'neon carrot', rgb: 0xffa343, origin: './pantone' },
              { name: 'almond', rgb: 0xefdbc5, origin: './pantone' },
              { name: 'yellow orange', rgb: 0xffb653, origin: './pantone' },
              { name: 'gold', rgb: 0xe7c697, origin: './pantone' },
              { name: 'shadow', rgb: 0x8a795d, origin: './pantone' },
              { name: 'banana mania', rgb: 0xfae7b5, origin: './pantone' },
              { name: 'sunglow', rgb: 0xffcf48, origin: './pantone' },
              { name: 'goldenrod', rgb: 0xfcd975, origin: './pantone' },
              { name: 'dandelion', rgb: 0xfddb6d, origin: './pantone' },
              { name: 'yellow', rgb: 0xfce883, origin: './pantone' },
              { name: 'green yellow', rgb: 0xf0e891, origin: './pantone' },
              { name: 'spring green', rgb: 0xeceabe, origin: './pantone' },
              { name: 'olive green', rgb: 0xbab86c, origin: './pantone' },
              { name: 'laser lemon', rgb: 0xfdfc74, origin: './pantone' },
              { name: 'unmellow yellow', rgb: 0xfdfc74, origin: './pantone' },
              { name: 'canary', rgb: 0xffff99, origin: './pantone' },
              { name: 'yellow green', rgb: 0xc5e384, origin: './pantone' },
              { name: 'inch worm', rgb: 0xb2ec5d, origin: './pantone' },
              { name: 'asparagus', rgb: 0x87a96b, origin: './pantone' },
              { name: 'granny smith apple', rgb: 0xa8e4a0, origin: './pantone' },
              { name: 'electric lime', rgb: 0x1df914, origin: './pantone' },
              { name: 'screamin green', rgb: 0x76ff7a, origin: './pantone' },
              { name: 'fern', rgb: 0x71bc78, origin: './pantone' },
              { name: 'forest green', rgb: 0x6dae81, origin: './pantone' },
              { name: 'sea green', rgb: 0x9fe2bf, origin: './pantone' },
              { name: 'green', rgb: 0x1cac78, origin: './pantone' },
              { name: 'mountain meadow', rgb: 0x30ba8f, origin: './pantone' },
              { name: 'shamrock', rgb: 0x45cea2, origin: './pantone' },
              { name: 'jungle green', rgb: 0x3bb08f, origin: './pantone' },
              { name: 'caribbean green', rgb: 0x1cd3a2, origin: './pantone' },
              { name: 'tropical rain forest', rgb: 0x17806d, origin: './pantone' },
              { name: 'pine green', rgb: 0x158078, origin: './pantone' },
              { name: 'robin egg blue', rgb: 0x1fcecb, origin: './pantone' },
              { name: 'aquamarine', rgb: 0x78dbe2, origin: './pantone' },
              { name: 'turquoise blue', rgb: 0x77dde7, origin: './pantone' },
              { name: 'sky blue', rgb: 0x80daeb, origin: './pantone' },
              { name: 'outer space', rgb: 0x414a4c, origin: './pantone' },
              { name: 'blue green', rgb: 0x199ebd, origin: './pantone' },
              { name: 'pacific blue', rgb: 0x1ca9c9, origin: './pantone' },
              { name: 'cerulean', rgb: 0x1dacd6, origin: './pantone' },
              { name: 'cornflower', rgb: 0x9aceeb, origin: './pantone' },
              { name: 'midnight blue', rgb: 0x1a4876, origin: './pantone' },
              { name: 'navy blue', rgb: 0x1974d2, origin: './pantone' },
              { name: 'denim', rgb: 0x2b6cc4, origin: './pantone' },
              { name: 'blue', rgb: 0x1f75fe, origin: './pantone' },
              { name: 'periwinkle', rgb: 0xc5d0e6, origin: './pantone' },
              { name: 'cadet blue', rgb: 0xb0b7c6, origin: './pantone' },
              { name: 'indigo', rgb: 0x5d76cb, origin: './pantone' },
              { name: 'wild blue yonder', rgb: 0xa2add0, origin: './pantone' },
              { name: 'manatee', rgb: 0x979aaa, origin: './pantone' },
              { name: 'blue bell', rgb: 0xadadd6, origin: './pantone' },
              { name: 'blue violet', rgb: 0x7366bd, origin: './pantone' },
              { name: 'purple heart', rgb: 0x7442c8, origin: './pantone' },
              { name: 'royal purple', rgb: 0x7851a9, origin: './pantone' },
              { name: 'purple mountains’ majesty', rgb: 0x9d81ba, origin: './pantone' },
              { name: 'violet (purple)', rgb: 0x926eae, origin: './pantone' },
              { name: 'wisteria', rgb: 0xcda4de, origin: './pantone' },
              { name: 'vivid violet', rgb: 0x8f509d, origin: './pantone' },
              { name: 'fuchsia', rgb: 0xc364c5, origin: './pantone' },
              { name: 'shocking pink', rgb: 0xfb7efd, origin: './pantone' },
              { name: 'pink flamingo', rgb: 0xfc74fd, origin: './pantone' },
              { name: 'plum', rgb: 0x8e4585, origin: './pantone' },
              { name: 'hot magenta', rgb: 0xff1dce, origin: './pantone' },
              { name: 'purple pizzazz', rgb: 0xff1dce, origin: './pantone' },
              { name: 'razzle dazzle rose', rgb: 0xff48d0, origin: './pantone' },
              { name: 'orchid', rgb: 0xe6a8d7, origin: './pantone' },
              { name: 'red violet', rgb: 0xc0448f, origin: './pantone' },
              { name: 'eggplant', rgb: 0x6e5160, origin: './pantone' },
              { name: 'cerise', rgb: 0xdd4492, origin: './pantone' },
              { name: 'wild strawberry', rgb: 0xff43a4, origin: './pantone' },
              { name: 'magenta', rgb: 0xf664af, origin: './pantone' },
              { name: 'lavender', rgb: 0xfcb4d5, origin: './pantone' },
              { name: 'cotton candy', rgb: 0xffbcd9, origin: './pantone' },
              { name: 'violet red', rgb: 0xf75394, origin: './pantone' },
              { name: 'carnation pink', rgb: 0xffaacc, origin: './pantone' },
              { name: 'razzmatazz', rgb: 0xe3256b, origin: './pantone' },
              { name: 'piggy pink', rgb: 0xfdd7e4, origin: './pantone' },
              { name: 'jazzberry jam', rgb: 0xca3767, origin: './pantone' },
              { name: 'blush', rgb: 0xde5d83, origin: './pantone' },
              { name: 'tickle me pink', rgb: 0xfc89ac, origin: './pantone' },
              { name: 'pink sherbet', rgb: 0xf780a1, origin: './pantone' },
              { name: 'maroon', rgb: 0xc8385a, origin: './pantone' },
              { name: 'red', rgb: 0xee204d, origin: './pantone' },
              { name: 'radical red', rgb: 0xff496c, origin: './pantone' },
              { name: 'mauvelous', rgb: 0xef98aa, origin: './pantone' },
              { name: 'wild watermelon', rgb: 0xfc6c85, origin: './pantone' },
              { name: 'scarlet', rgb: 0xfc2847, origin: './pantone' },
              { name: 'salmon', rgb: 0xff9baa, origin: './pantone' },
              { name: 'brick red', rgb: 0xcb4154, origin: './pantone' },
              { name: 'white', rgb: 0xededed, origin: './pantone' },
              { name: 'timberwolf', rgb: 0xdbd7d2, origin: './pantone' },
              { name: 'silver', rgb: 0xcdc5c2, origin: './pantone' },
              { name: 'gray', rgb: 0x95918c, origin: './pantone' },
              { name: 'black', rgb: 0x232323, origin: './pantone' },
              { name: 'red', rgb: 0xff0000, origin: './roygbiv' },
              { name: 'orange', rgb: 0xffa500, origin: './roygbiv' },
              { name: 'yellow', rgb: 0xffff00, origin: './roygbiv' },
              { name: 'green', rgb: 0x008000, origin: './roygbiv' },
              { name: 'blue', rgb: 0x0000ff, origin: './roygbiv' },
              { name: 'indigo', rgb: 0x4b0082, origin: './roygbiv' },
              { name: 'violet', rgb: 0xee82ee, origin: './roygbiv' },
              { name: 'indigo', rgb: 0x4b0082, origin: './x11' },
              { name: 'gold', rgb: 0xffd700, origin: './x11' },
              { name: 'hotpink', rgb: 0xff69b4, origin: './x11' },
              { name: 'firebrick', rgb: 0xb22222, origin: './x11' },
              { name: 'indianred', rgb: 0xcd5c5c, origin: './x11' },
              { name: 'yellow', rgb: 0xffff00, origin: './x11' },
              { name: 'mistyrose', rgb: 0xffe4e1, origin: './x11' },
              { name: 'darkolivegreen', rgb: 0x556b2f, origin: './x11' },
              { name: 'olive', rgb: 0x808000, origin: './x11' },
              { name: 'darkseagreen', rgb: 0x8fbc8f, origin: './x11' },
              { name: 'pink', rgb: 0xffc0cb, origin: './x11' },
              { name: 'tomato', rgb: 0xff6347, origin: './x11' },
              { name: 'lightcoral', rgb: 0xf08080, origin: './x11' },
              { name: 'orangered', rgb: 0xff4500, origin: './x11' },
              { name: 'navajowhite', rgb: 0xffdead, origin: './x11' },
              { name: 'lime', rgb: 0x00ff00, origin: './x11' },
              { name: 'palegreen', rgb: 0x98fb98, origin: './x11' },
              { name: 'darkslategrey', rgb: 0x2f4f4f, origin: './x11' },
              { name: 'greenyellow', rgb: 0xadff2f, origin: './x11' },
              { name: 'burlywood', rgb: 0xdeb887, origin: './x11' },
              { name: 'seashell', rgb: 0xfff5ee, origin: './x11' },
              { name: 'mediumspringgreen', rgb: 0x00fa9a, origin: './x11' },
              { name: 'fuchsia', rgb: 0xff00ff, origin: './x11' },
              { name: 'papayawhip', rgb: 0xffefd5, origin: './x11' },
              { name: 'blanchedalmond', rgb: 0xffebcd, origin: './x11' },
              { name: 'chartreuse', rgb: 0x7fff00, origin: './x11' },
              { name: 'dimgray', rgb: 0x696969, origin: './x11' },
              { name: 'black', rgb: 0x000000, origin: './x11' },
              { name: 'peachpuff', rgb: 0xffdab9, origin: './x11' },
              { name: 'springgreen', rgb: 0x00ff7f, origin: './x11' },
              { name: 'aquamarine', rgb: 0x7fffd4, origin: './x11' },
              { name: 'white', rgb: 0xffffff, origin: './x11' },
              { name: 'orange', rgb: 0xffa500, origin: './x11' },
              { name: 'lightsalmon', rgb: 0xffa07a, origin: './x11' },
              { name: 'darkslategray', rgb: 0x2f4f4f, origin: './x11' },
              { name: 'brown', rgb: 0xa52a2a, origin: './x11' },
              { name: 'ivory', rgb: 0xfffff0, origin: './x11' },
              { name: 'dodgerblue', rgb: 0x1e90ff, origin: './x11' },
              { name: 'peru', rgb: 0xcd853f, origin: './x11' },
              { name: 'lawngreen', rgb: 0x7cfc00, origin: './x11' },
              { name: 'chocolate', rgb: 0xd2691e, origin: './x11' },
              { name: 'crimson', rgb: 0xdc143c, origin: './x11' },
              { name: 'forestgreen', rgb: 0x228b22, origin: './x11' },
              { name: 'darkgrey', rgb: 0xa9a9a9, origin: './x11' },
              { name: 'lightseagreen', rgb: 0x20b2aa, origin: './x11' },
              { name: 'cyan', rgb: 0x00ffff, origin: './x11' },
              { name: 'mintcream', rgb: 0xf5fffa, origin: './x11' },
              { name: 'silver', rgb: 0xc0c0c0, origin: './x11' },
              { name: 'antiquewhite', rgb: 0xfaebd7, origin: './x11' },
              { name: 'mediumorchid', rgb: 0xba55d3, origin: './x11' },
              { name: 'skyblue', rgb: 0x87ceeb, origin: './x11' },
              { name: 'gray', rgb: 0x808080, origin: './x11' },
              { name: 'darkturquoise', rgb: 0x00ced1, origin: './x11' },
              { name: 'goldenrod', rgb: 0xdaa520, origin: './x11' },
              { name: 'darkgreen', rgb: 0x006400, origin: './x11' },
              { name: 'floralwhite', rgb: 0xfffaf0, origin: './x11' },
              { name: 'darkviolet', rgb: 0x9400d3, origin: './x11' },
              { name: 'darkgray', rgb: 0xa9a9a9, origin: './x11' },
              { name: 'moccasin', rgb: 0xffe4b5, origin: './x11' },
              { name: 'saddlebrown', rgb: 0x8b4513, origin: './x11' },
              { name: 'grey', rgb: 0x808080, origin: './x11' },
              { name: 'darkslateblue', rgb: 0x483d8b, origin: './x11' },
              { name: 'lightskyblue', rgb: 0x87cefa, origin: './x11' },
              { name: 'lightpink', rgb: 0xffb6c1, origin: './x11' },
              { name: 'mediumvioletred', rgb: 0xc71585, origin: './x11' },
              { name: 'slategrey', rgb: 0x708090, origin: './x11' },
              { name: 'red', rgb: 0xff0000, origin: './x11' },
              { name: 'deeppink', rgb: 0xff1493, origin: './x11' },
              { name: 'limegreen', rgb: 0x32cd32, origin: './x11' },
              { name: 'darkmagenta', rgb: 0x8b008b, origin: './x11' },
              { name: 'palegoldenrod', rgb: 0xeee8aa, origin: './x11' },
              { name: 'plum', rgb: 0xdda0dd, origin: './x11' },
              { name: 'turquoise', rgb: 0x40e0d0, origin: './x11' },
              { name: 'lightgrey', rgb: 0xd3d3d3, origin: './x11' },
              { name: 'lightgoldenrodyellow', rgb: 0xfafad2, origin: './x11' },
              { name: 'darkgoldenrod', rgb: 0xb8860b, origin: './x11' },
              { name: 'lavender', rgb: 0xe6e6fa, origin: './x11' },
              { name: 'maroon', rgb: 0x800000, origin: './x11' },
              { name: 'yellowgreen', rgb: 0x9acd32, origin: './x11' },
              { name: 'sandybrown', rgb: 0xf4a460, origin: './x11' },
              { name: 'thistle', rgb: 0xd8bfd8, origin: './x11' },
              { name: 'violet', rgb: 0xee82ee, origin: './x11' },
              { name: 'navy', rgb: 0x000080, origin: './x11' },
              { name: 'magenta', rgb: 0xff00ff, origin: './x11' },
              { name: 'dimgrey', rgb: 0x696969, origin: './x11' },
              { name: 'tan', rgb: 0xd2b48c, origin: './x11' },
              { name: 'rosybrown', rgb: 0xbc8f8f, origin: './x11' },
              { name: 'olivedrab', rgb: 0x6b8e23, origin: './x11' },
              { name: 'blue', rgb: 0x0000ff, origin: './x11' },
              { name: 'lightblue', rgb: 0xadd8e6, origin: './x11' },
              { name: 'ghostwhite', rgb: 0xf8f8ff, origin: './x11' },
              { name: 'honeydew', rgb: 0xf0fff0, origin: './x11' },
              { name: 'cornflowerblue', rgb: 0x6495ed, origin: './x11' },
              { name: 'slateblue', rgb: 0x6a5acd, origin: './x11' },
              { name: 'linen', rgb: 0xfaf0e6, origin: './x11' },
              { name: 'darkblue', rgb: 0x00008b, origin: './x11' },
              { name: 'powderblue', rgb: 0xb0e0e6, origin: './x11' },
              { name: 'seagreen', rgb: 0x2e8b57, origin: './x11' },
              { name: 'darkkhaki', rgb: 0xbdb76b, origin: './x11' },
              { name: 'snow', rgb: 0xfffafa, origin: './x11' },
              { name: 'sienna', rgb: 0xa0522d, origin: './x11' },
              { name: 'mediumblue', rgb: 0x0000cd, origin: './x11' },
              { name: 'royalblue', rgb: 0x4169e1, origin: './x11' },
              { name: 'lightcyan', rgb: 0xe0ffff, origin: './x11' },
              { name: 'green', rgb: 0x008000, origin: './x11' },
              { name: 'mediumpurple', rgb: 0x9370db, origin: './x11' },
              { name: 'midnightblue', rgb: 0x191970, origin: './x11' },
              { name: 'cornsilk', rgb: 0xfff8dc, origin: './x11' },
              { name: 'paleturquoise', rgb: 0xafeeee, origin: './x11' },
              { name: 'bisque', rgb: 0xffe4c4, origin: './x11' },
              { name: 'slategray', rgb: 0x708090, origin: './x11' },
              { name: 'darkcyan', rgb: 0x008b8b, origin: './x11' },
              { name: 'khaki', rgb: 0xf0e68c, origin: './x11' },
              { name: 'wheat', rgb: 0xf5deb3, origin: './x11' },
              { name: 'teal', rgb: 0x008080, origin: './x11' },
              { name: 'darkorchid', rgb: 0x9932cc, origin: './x11' },
              { name: 'deepskyblue', rgb: 0x00bfff, origin: './x11' },
              { name: 'salmon', rgb: 0xfa8072, origin: './x11' },
              { name: 'darkred', rgb: 0x8b0000, origin: './x11' },
              { name: 'steelblue', rgb: 0x4682b4, origin: './x11' },
              { name: 'palevioletred', rgb: 0xdb7093, origin: './x11' },
              { name: 'lightslategray', rgb: 0x778899, origin: './x11' },
              { name: 'aliceblue', rgb: 0xf0f8ff, origin: './x11' },
              { name: 'lightslategrey', rgb: 0x778899, origin: './x11' },
              { name: 'lightgreen', rgb: 0x90ee90, origin: './x11' },
              { name: 'orchid', rgb: 0xda70d6, origin: './x11' },
              { name: 'gainsboro', rgb: 0xdcdcdc, origin: './x11' },
              { name: 'mediumseagreen', rgb: 0x3cb371, origin: './x11' },
              { name: 'lightgray', rgb: 0xd3d3d3, origin: './x11' },
              { name: 'mediumturquoise', rgb: 0x48d1cc, origin: './x11' },
              { name: 'lemonchiffon', rgb: 0xfffacd, origin: './x11' },
              { name: 'cadetblue', rgb: 0x5f9ea0, origin: './x11' },
              { name: 'lightyellow', rgb: 0xffffe0, origin: './x11' },
              { name: 'lavenderblush', rgb: 0xfff0f5, origin: './x11' },
              { name: 'coral', rgb: 0xff7f50, origin: './x11' },
              { name: 'purple', rgb: 0x800080, origin: './x11' },
              { name: 'aqua', rgb: 0x00ffff, origin: './x11' },
              { name: 'whitesmoke', rgb: 0xf5f5f5, origin: './x11' },
              { name: 'mediumslateblue', rgb: 0x7b68ee, origin: './x11' },
              { name: 'darkorange', rgb: 0xff8c00, origin: './x11' },
              { name: 'mediumaquamarine', rgb: 0x66cdaa, origin: './x11' },
              { name: 'darksalmon', rgb: 0xe9967a, origin: './x11' },
              { name: 'beige', rgb: 0xf5f5dc, origin: './x11' },
              { name: 'blueviolet', rgb: 0x8a2be2, origin: './x11' },
              { name: 'azure', rgb: 0xf0ffff, origin: './x11' },
              { name: 'lightsteelblue', rgb: 0xb0c4de, origin: './x11' },
              { name: 'oldlace', rgb: 0xfdf5e6, origin: './x11' },
            ];

            // From 'colour-proximity' and 'chroma-js' npm.

            const proximity = (s1, s2) => {
              const c1 = rgb2lab(...s1);
              const c2 = rgb2lab(...s2);
              return Math.sqrt(
                Math.pow(c1[0] - c2[0], 2) +
                  Math.pow(c1[1] - c2[1], 2) +
                  Math.pow(c1[2] - c2[2], 2)
              );
            };

            const labConstants = {
              // Corresponds roughly to RGB brighter/darker
              Kn: 18,

              // D65 standard referent
              Xn: 0.95047,
              Yn: 1,
              Zn: 1.08883,

              t0: 0.137931034, // 4 / 29
              t1: 0.206896552, // 6 / 29
              t2: 0.12841855, // 3 * t1 * t1
              t3: 0.008856452, // t1 * t1 * t1
            };

            const rgbXyz = (r) => {
              if ((r /= 255) <= 0.04045) {
                return r / 12.92;
              }
              return Math.pow((r + 0.055) / 1.055, 2.4);
            };

            const xyzLab = function (t) {
              if (t > labConstants.t3) {
                return Math.pow(t, 1 / 3);
              }
              return t / labConstants.t2 + labConstants.t0;
            };

            const rgb2xyz = (r, g, b) => {
              r = rgbXyz(r);
              g = rgbXyz(g);
              b = rgbXyz(b);
              var x = xyzLab(
                (0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / labConstants.Xn
              );
              var y = xyzLab(
                (0.2126729 * r + 0.7151522 * g + 0.072175 * b) / labConstants.Yn
              );
              var z = xyzLab(
                (0.0193339 * r + 0.119192 * g + 0.9503041 * b) / labConstants.Zn
              );
              return [x, y, z];
            };

            const rgb2lab = (r, g, b) => {
              const [x, y, z] = rgb2xyz(r, g, b);
              const l = 116 * y - 16;
              return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];
            };

            const toEntryFromRgbInt = (rgbInt) => {
              const rgb = toArrayFromRgbInt(rgbInt);
              let bestDistance = Infinity;
              let best;
              for (const entry of colors) {
                const distance = proximity(rgb, toArrayFromRgbInt(entry.rgb));
                if (distance < bestDistance) {
                  best = entry;
                  bestDistance = distance;
                }
              }
              return best;
            };

            const toRgbIntFromName = (name, defaultRgbInt = 0) => {
              let rgbInt;
              // Handle '#00ffbb'.
              if (rgbInt === undefined) {
                if (name.startsWith('#')) {
                  rgbInt = parseInt(name.substring(1), 16);
                }
              }
              // Handle 'blue'.
              if (rgbInt === undefined) {
                const normalizedName = name.toLowerCase();
                for (const { name, rgb } of colors) {
                  if (normalizedName === name) {
                    rgbInt = rgb;
                  }
                }
              }
              // Handle defaulting.
              if (rgbInt === undefined) {
                rgbInt = defaultRgbInt;
              }
              return rgbInt;
            };

            const toArrayFromRgbInt = (rgbInt) => [
              (rgbInt >> 16) & 0xff,
              (rgbInt >> 8) & 0xff,
              (rgbInt >> 0) & 0xff,
            ];

            const toRgbIntFromTags = (tags = [], defaultRgb = [0, 0, 0]) => {
              let rgb = defaultRgb;
              for (const tag of tags) {
                if (tag.startsWith('color/')) {
                  let entry = toRgbIntFromName(tag.substring(6));
                  if (entry !== undefined) {
                    return entry;
                  }
                }
              }
              return rgb;
            };

            const toTagFromName = (name) => {
              const entry = toEntryFromRgbInt(toRgbIntFromName(name));
              if (entry !== undefined) {
                return `color/${entry.name.toLowerCase()}`;
              }
              return `color/unknown`;
            };

            const toRgbFromTags = (tags, defaultRgb) => {
              const rgbInt = toRgbIntFromTags(tags, null);
              if (rgbInt === null) {
                return defaultRgb;
              }
              return toArrayFromRgbInt(rgbInt);
            };

            class Shape {
              close() {
                const geometry = this.toDisjointGeometry();
                if (!isSingleOpenPath(geometry.content[0])) {
                  throw Error('Close requires a single open path.');
                }
                return Shape.fromClosedPath(close(geometry.content[0].paths[0]));
              }

              concat(...shapes) {
                const paths = [];
                for (const shape of [this, ...shapes]) {
                  const geometry = shape.toDisjointGeometry();
                  if (!isSingleOpenPath(geometry.content[0])) {
                    throw Error(
                      `Concatenation requires single open paths: ${JSON.stringify(
            geometry
          )}`
                    );
                  }
                  paths.push(geometry.content[0].paths[0]);
                }
                return Shape.fromOpenPath(concatenate(...paths));
              }

              constructor(geometry = taggedAssembly({}), context) {
                if (geometry.geometry) {
                  throw Error('die: { geometry: ... } is not valid geometry.');
                }
                this.geometry = geometry;
                this.context = context;
              }

              eachPoint(operation) {
                eachPoint$4(operation, this.toDisjointGeometry());
              }

              flip() {
                return fromGeometry(flip$8(toDisjointGeometry$1(this)), this.context);
              }

              setTags(tags) {
                return fromGeometry({ ...toGeometry(this), tags }, this.context);
              }

              toKeptGeometry(options = {}) {
                return this.toDisjointGeometry();
              }

              toDisjointGeometry(options = {}) {
                return toDisjointGeometry(toGeometry(this));
              }

              toTransformedGeometry(options = {}) {
                return toTransformedGeometry(toGeometry(this));
              }

              getContext(symbol) {
                return this.context[symbol];
              }

              toGeometry() {
                return this.geometry;
              }

              toPoints() {
                return toPoints(this.toDisjointGeometry()).points;
              }

              transform(matrix) {
                if (matrix.some((item) => typeof item !== 'number' || isNaN(item))) {
                  throw Error('die: matrix is malformed');
                }
                return fromGeometry(transform$8(matrix, this.toGeometry()), this.context);
              }

              reconcile() {
                return fromGeometry(reconcile$1(this.toDisjointGeometry()));
              }

              assertWatertight() {
                if (!this.isWatertight()) {
                  throw Error('not watertight');
                }
                return this;
              }

              isWatertight() {
                return isWatertight$2(this.toDisjointGeometry());
              }

              makeWatertight(threshold) {
                return fromGeometry(
                  makeWatertight$2(this.toDisjointGeometry(), undefined, undefined)
                );
              }
            }

            const isSingleOpenPath = ({ paths }) =>
              paths !== undefined && paths.length === 1 && paths[0][0] === null;

            Shape.fromClosedPath = (path, context) =>
              fromGeometry(taggedPaths({}, [close(path)]), context);
            Shape.fromGeometry = (geometry, context) => new Shape(geometry, context);
            Shape.fromOpenPath = (path, context) =>
              fromGeometry(taggedPaths({}, [open(path)]), context);
            Shape.fromPath = (path, context) =>
              fromGeometry(taggedPaths({}, [path]), context);
            Shape.fromPaths = (paths, context) =>
              fromGeometry(taggedPaths({}, paths), context);
            Shape.fromPathToSurface = (path, context) =>
              fromGeometry(fromPathToSurface(path), context);
            Shape.fromPathsToSurface = (paths, context) =>
              fromGeometry(fromPathsToSurface(paths), context);
            Shape.fromPoint = (point, context) =>
              fromGeometry(taggedPoints({}, [point]), context);
            Shape.fromPoints = (points, context) =>
              fromGeometry(taggedPoints({}, points), context);
            Shape.fromPolygonsToSolid = (polygons, context) =>
              fromGeometry(taggedSolid({}, fromPolygons(polygons)), context);
            Shape.fromPolygonsToSurface = (polygons, context) =>
              fromGeometry(taggedSurface({}, polygons), context);
            Shape.fromSurfaces = (surfaces, context) =>
              fromGeometry(taggedSolid({}, surfaces), context);
            Shape.fromSolid = (solid, context) =>
              fromGeometry(taggedSolid({}, solid), context);

            const fromGeometry = Shape.fromGeometry;
            const toGeometry = (shape) => shape.toGeometry();
            const toDisjointGeometry$1 = (shape) => shape.toDisjointGeometry();
            const toKeptGeometry$1 = (shape) => shape.toDisjointGeometry();

            /**
             *
             * # Union
             *
             * Union produces a version of the first shape extended to cover the remaining shapes, as applicable.
             * Different kinds of shapes do not interact. e.g., you cannot union a surface and a solid.
             *
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * union(Sphere(5).left(),
             *       Sphere(5),
             *       Sphere(5).right())
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * union(Sphere(5).left(),
             *       Sphere(5),
             *       Sphere(5).right())
             *   .section()
             *   .outline()
             * ```
             * :::
             * ::: illustration { "view": { "position": [0, 0, 5] } }
             * ```
             * union(Triangle(),
             *       Triangle().rotateZ(180))
             * ```
             * :::
             * ::: illustration { "view": { "position": [0, 0, 5] } }
             * ```
             * union(Triangle(),
             *       Triangle().rotateZ(180))
             *   .outline()
             * ```
             * :::
             * ::: illustration { "view": { "position": [5, 5, 5] } }
             * ```
             * union(assemble(Cube().left(),
             *                Cube().right()),
             *       Cube().front())
             *   .section()
             *   .outline()
             * ```
             * :::
             *
             **/

            // NOTE: Perhaps we should make union(a, b, c) equivalent to emptyGeometry.union(a, b, c);
            // This would restore commutation.

            const union$4 = (...shapes) => {
              switch (shapes.length) {
                case 0: {
                  return fromGeometry(taggedAssembly({}));
                }
                case 1: {
                  return shapes[0];
                }
                default: {
                  return fromGeometry(union$3(...shapes.map(toKeptGeometry$1)));
                }
              }
            };

            const unionMethod = function (...shapes) {
              return union$4(this, ...shapes);
            };
            Shape.prototype.union = unionMethod;

            union$4.signature = 'union(shape:Shape, ...shapes:Shape) -> Shape';
            unionMethod.signature = 'Shape -> union(...shapes:Shape) -> Shape';

            /**
             *
             * # shape.add(...shapes)
             *
             * Produces a version of shape with the regions overlapped by shapes added.
             *
             * shape.add(...shapes) is equivalent to union(shape, ...shapes).
             *
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Cube(10).below().add(Cube(5).moveX(5).below())
             * ```
             * :::
             *
             **/

            const addMethod = function (...shapes) {
              return union$4(this, ...shapes);
            };
            Shape.prototype.add = addMethod;

            addMethod.signature = 'Shape -> (...Shapes) -> Shape';

            // x.addTo(y) === y.add(x)

            const addToMethod = function (shape) {
              return union$4(shape, this);
            };
            Shape.prototype.addTo = addToMethod;

            addToMethod.signature = 'Shape -> (...Shapes) -> Shape';

            /**
             *
             * # As
             *
             * Produces a version of a shape with user defined tags.
             *
             * ::: illustration
             * ```
             * Circle(10).as('A')
             * ```
             * :::
             *
             **/

            const as = (shape, tags) =>
              Shape.fromGeometry(
                rewriteTags(
                  tags.map((tag) => `user/${tag}`),
                  [],
                  shape.toGeometry()
                )
              );

            const notAs = (shape, tags) =>
              Shape.fromGeometry(
                rewriteTags(
                  [],
                  tags.map((tag) => `user/${tag}`),
                  shape.toGeometry()
                )
              );

            const asMethod = function (...tags) {
              return as(this, tags);
            };
            const notAsMethod = function (...tags) {
              return notAs(this, tags);
            };

            Shape.prototype.as = asMethod;
            Shape.prototype.notAs = notAsMethod;

            asMethod.signature = 'Shape -> as(...tags:string) -> Shape';
            notAsMethod.signature = 'Shape -> as(...tags:string) -> Shape';

            /**
             *
             * # Assemble
             *
             * Produces an assembly of shapes that can be manipulated as a single shape.
             * assemble(a, b) is equivalent to a.with(b).
             *
             * ::: illustration { "view": { "position": [80, 80, 80] } }
             * ```
             * assemble(Circle(20).moveZ(-12),
             *          Square(40).moveZ(16).outline(),
             *          Cylinder(10, 20));
             * ```
             * :::
             *
             * Components of the assembly can be extracted by tag filtering.
             *
             * Components later in the assembly project holes into components earlier in the
             * assembly so that the geometries are disjoint.
             *
             * ::: illustration { "view": { "position": [100, 100, 100] } }
             * ```
             * assemble(Cube(30).above().as('cube'),
             *          Cylinder(10, 40).above().as('cylinder'))
             * ```
             * :::
             * ::: illustration { "view": { "position": [100, 100, 100] } }
             * ```
             * assemble(Cube(30).above().as('cube'),
             *          Cylinder(10, 40).above().as('cylinder'))
             *   .keep('cube')
             * ```
             * :::
             * ::: illustration { "view": { "position": [100, 100, 100] } }
             * ```
             * assemble(Cube(30).above().as('cube'),
             *          assemble(Circle(40),
             *                   Circle(50).outline()).as('circles'))
             *   .keep('circles')
             * ```
             * :::
             * ::: illustration { "view": { "position": [100, 100, 100] } }
             * ```
             * assemble(Cube(30).above().as('cube'),
             *          assemble(Circle(40).as('circle'),
             *                   Circle(50).outline().as('outline')))
             *   .drop('outline')
             * ```
             * :::
             *
             **/

            const assemble$1 = (...shapes) => {
              shapes = shapes.filter((shape) => shape !== undefined);
              switch (shapes.length) {
                case 0: {
                  return Shape.fromGeometry(taggedAssembly({}));
                }
                case 1: {
                  return shapes[0];
                }
                default: {
                  return fromGeometry(assemble(...shapes.map(toGeometry)));
                }
              }
            };

            const X$9 = 0;
            const Y$9 = 1;
            const Z$8 = 2;

            /**
             * Moves the left front corner to the left front corner of the bench
             * and places the top level with the bench top at Z = 0.
             *
             * Operations are downward and relative to the top of the shape.
             */

            const bench = (shape, x = 0, y = 0, z = 0) => {
              const { max, min } = shape.size();
              return shape.move(0 - x - min[X$9], 0 - y - min[Y$9], 0 - z - max[Z$8]);
            };

            const benchMethod = function (x, y, z) {
              return bench(this, x, y, z);
            };
            Shape.prototype.bench = benchMethod;

            /**
             * Moves the left front corner to the left front corner of the bench
             * and places the bottom level with the bench top at Z = 0.
             *
             * Operations are upward and relative to the bottom of the shape.
             */

            const benchTop = (shape, x = 0, y = 0, z = 0) => {
              const { min } = shape.size();
              return shape.move(0 - x - min[X$9], 0 - y - min[Y$9], 0 - z - min[Z$8]);
            };

            const benchTopMethod = function (x, y, z) {
              return benchTop(this, x, y, z);
            };
            Shape.prototype.benchTop = benchTopMethod;

            const canonicalize$a = (shape) =>
              Shape.fromGeometry(canonicalize$9(shape.toGeometry()));

            const canonicalizeMethod = function () {
              return canonicalize$a(this);
            };
            Shape.prototype.canonicalize = canonicalizeMethod;

            /**
             *
             * # Measure Bounding Box
             *
             * Provides the corners of the smallest orthogonal box containing the shape.
             *
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Sphere(7)
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * const [corner1, corner2] = Sphere(7).measureBoundingBox();
             * Cube.fromCorners(corner1, corner2)
             * ```
             * :::
             **/

            const measureBoundingBox$5 = (shape) =>
              measureBoundingBox$4(shape.toGeometry());

            const measureBoundingBoxMethod = function () {
              return measureBoundingBox$5(this);
            };
            Shape.prototype.measureBoundingBox = measureBoundingBoxMethod;

            measureBoundingBox$5.signature = 'measureBoundingBox(shape:Shape) -> BoundingBox';
            measureBoundingBoxMethod.signature =
              'Shape -> measureBoundingBox() -> BoundingBox';

            /**
             *
             * # Center
             *
             * Moves the shape so that its bounding box is centered on the origin.
             *
             * ::: illustration { "view": { "position": [60, -60, 60], "target": [0, 0, 0] } }
             * ```
             * Circle(20).with(Cube(10).center())
             * ```
             * :::
             **/

            const X$1$6 = 0;
            const Y$1$6 = 1;
            const Z$1$5 = 2;

            const center = (
              shape,
              { centerX = true, centerY = true, centerZ = true } = {}
            ) => {
              const [minPoint, maxPoint] = measureBoundingBox$5(shape);
              const center = scale(0.5, add(minPoint, maxPoint));
              if (!centerX) {
                center[X$1$6] = 0;
              }
              if (!centerY) {
                center[Y$1$6] = 0;
              }
              if (!centerZ) {
                center[Z$1$5] = 0;
              }
              // FIX: Find a more principled way to handle centering empty shapes.
              if (isNaN(center[X$1$6]) || isNaN(center[Y$1$6]) || isNaN(center[Z$1$5])) {
                return shape;
              }
              const moved = shape.move(...negate(center));
              return moved;
            };

            const centerMethod = function (...params) {
              return center(this, ...params);
            };
            Shape.prototype.center = centerMethod;

            /**
             *
             * # Intersection
             *
             * Intersection produces a version of the first shape retaining only the parts included in the remaining shapes.
             *
             * Different kinds of shapes do not interact. e.g., you cannot intersect a surface and a solid.
             *
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * intersection(Cube(12),
             *              Sphere(8))
             * ```
             * :::
             * ::: illustration
             * ```
             * intersection(Circle(10).move(-5),
             *              Circle(10).move(5))
             * ```
             * :::
             * ::: illustration { "view": { "position": [5, 5, 5] } }
             * ```
             * intersection(assemble(Cube().below(),
             *                       Cube().above()),
             *              Sphere(1))
             * ```
             * :::
             * ::: illustration
             * ```
             * assemble(difference(Square(10),
             *                     Square(7))
             *            .translate(-2, -2),
             *          difference(Square(10),
             *                     Square(7))
             *            .move(2, 2));
             * ```
             * :::
             * ::: illustration
             * ```
             * intersection(difference(Square(10),
             *                         Square(7))
             *                .translate(-2, -2),
             *              difference(Square(10),
             *                         Square(7))
             *                .move(2, 2));
             * ```
             * :::
             **/

            const intersection$2 = (...shapes) => {
              switch (shapes.length) {
                case 0: {
                  return fromGeometry(taggedAssembly({}));
                }
                case 1: {
                  // We still want to produce a simple shape.
                  return fromGeometry(toKeptGeometry$1(shapes[0]));
                }
                default: {
                  return fromGeometry(intersection$1(...shapes.map(toKeptGeometry$1)));
                }
              }
            };

            const clipMethod = function (...shapes) {
              return intersection$2(this, ...shapes);
            };
            Shape.prototype.clip = clipMethod;

            clipMethod.signature = 'Shape -> clip(...to:Shape) -> Shape';

            const clipFromMethod = function (shape) {
              return intersection$2(shape, this);
            };
            Shape.prototype.clipFrom = clipFromMethod;

            clipFromMethod.signature = 'Shape -> clipFrom(...to:Shape) -> Shape';

            /**
             *
             * # Color
             *
             * Produces a version of a shape the given color.
             * FIX: Support color in convert/threejs/toSvg.
             *
             * ::: illustration
             * ```
             * Circle(10).color('blue')
             * ```
             * :::
             * ::: illustration
             * ```
             * Triangle(10).color('chartreuse')
             * ```
             * :::
             *
             **/

            const fromName = (shape, name) =>
              Shape.fromGeometry(
                rewriteTags([toTagFromName(name)], [], shape.toGeometry())
              );

            const color = (...args) => fromName(...args);

            const colorMethod = function (...args) {
              return color(this, ...args);
            };
            Shape.prototype.color = colorMethod;

            color.signature = 'color(shape:Shape, color:string) -> Shape';
            colorMethod.signature = 'Shape -> color(color:string) -> Shape';

            const colors$1 = (shape) =>
              [...allTags(shape.toGeometry())]
                .filter((tag) => tag.startsWith('color/'))
                .map((tag) => tag.substring(6));

            const colorsMethod = function () {
              return colors$1(this);
            };
            Shape.prototype.colors = colorsMethod;

            colors$1.signature = 'colors(shape:Shape) -> strings';
            colorsMethod.signature = 'Shape -> colors() -> strings';

            /**
             *
             * # Difference
             *
             * Difference produces a version of the first shape with the remaining shapes removed, where applicable.
             * Different kinds of shapes do not interact. e.g., you cannot subtract a surface from a solid.
             *
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * difference(Cube(10).below(),
             *            Cube(5).below())
             * ```
             * :::
             * ::: illustration
             * ```
             * difference(Circle(10),
             *            Circle(2.5))
             * ```
             * :::
             * ::: illustration { "view": { "position": [5, 5, 5] } }
             * ```
             * difference(assemble(Cube().below(),
             *                     Cube().above()),
             *            Cube().right())
             * ```
             * :::
             *
             **/

            const difference$3 = (...shapes) => {
              switch (shapes.length) {
                case 0: {
                  return fromGeometry(taggedAssembly({}));
                }
                case 1: {
                  // We still want to produce a simple shape.
                  return fromGeometry(toKeptGeometry$1(shapes[0]));
                }
                default: {
                  return fromGeometry(difference$2(...shapes.map(toKeptGeometry$1)));
                }
              }
            };

            /**
             *
             * # shape.cut(...shapes)
             *
             * Produces a version of shape with the regions overlapped by shapes removed.
             *
             * shape.cut(...shapes) is equivalent to difference(shape, ...shapes).
             *
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Cube(10).below().cut(Cube(5).below())
             * ```
             * :::
             *
             **/

            const cutMethod = function (...shapes) {
              return difference$3(this, ...shapes);
            };
            Shape.prototype.cut = cutMethod;

            cutMethod.signature = 'Shape -> cut(...shapes:Shape) -> Shape';

            // a.cut(b) === b.cutFrom(a)

            const cutFromMethod = function (shape) {
              return difference$3(shape, this);
            };
            Shape.prototype.cutFrom = cutFromMethod;

            cutFromMethod.signature = 'Shape -> cutFrom(...shapes:Shape) -> Shape';

            const faces = (shape, op = (x) => x) => {
              const faces = [];
              for (const { solid } of getSolids(shape.toKeptGeometry())) {
                for (const surface of solid) {
                  faces.push(
                    op(
                      Shape.fromGeometry(
                        taggedDisjointAssembly({}, ...outline(taggedSurface({}, surface)))
                      ),
                      faces.length
                    )
                  );
                }
              }
              return assemble$1(...faces);
            };

            const facesMethod = function (...args) {
              return faces(this, ...args);
            };
            Shape.prototype.faces = facesMethod;

            const fix$1 = (shape) => Shape.fromGeometry(fix(shape.toGeometry()));

            const fixMethod = function () {
              return fix$1(this);
            };
            Shape.prototype.fix = fixMethod;

            const inSolids = (shape, op = (_) => _) => {
              let nth = 0;
              const rewritten = rewrite(shape.toKeptGeometry(), (geometry, descend) => {
                if (geometry.solid) {
                  // Operate on the solid.
                  const solid = op(Shape.fromGeometry(geometry), nth++);
                  // Replace the solid with the result (which might not be a solid).
                  return solid.toGeometry();
                } else {
                  return descend();
                }
              });
              return Shape.fromGeometry(rewritten);
            };

            const inSolidsMethod = function (...args) {
              return inSolids(this, ...args);
            };
            Shape.prototype.inSolids = inSolidsMethod;

            inSolids.signature = 'inSolids(shape:Shape, op:function) -> Shapes';
            inSolidsMethod.signature = 'Shape -> inSolids(op:function) -> Shapes';

            const junctions = (shape, mode = (n) => n) => {
              const junctions = [];
              const points = [];
              for (const { solid } of getSolids(shape.toKeptGeometry())) {
                const normalize = createNormalize3();
                const select = junctionSelector(solid);
                for (const surface of solid) {
                  for (const path of surface) {
                    for (const point of path) {
                      points.push(normalize(point));
                    }
                  }
                }
                for (const point of points) {
                  if (mode(select(point))) {
                    junctions.push(point);
                  }
                }
              }
              return Shape.fromGeometry(taggedPoints({}, junctions));
            };

            const nonJunctions = (shape) => junctions(shape, (n) => !n);

            const junctionsMethod = function () {
              return junctions(this);
            };
            Shape.prototype.junctions = junctionsMethod;

            const nonJunctionsMethod = function () {
              return nonJunctions(this);
            };
            Shape.prototype.nonJunctions = nonJunctionsMethod;

            /**
             *
             * # Keep in assembly
             *
             * Generates an assembly from components in an assembly with a tag.
             *
             * ::: illustration
             * ```
             * assemble(Circle(10).as('A'),
             *          Square(10).as('B'))
             * ```
             * :::
             * ::: illustration
             * ```
             * assemble(Circle(10).as('A'),
             *          Square(10).as('B'))
             *   .keep('A')
             * ```
             * :::
             * ::: illustration
             * ```
             * assemble(Circle(10).as('A'),
             *          Square(10).as('B'))
             *   .keep('B')
             * ```
             * :::
             * ::: illustration
             * ```
             * assemble(Circle(10).as('A'),
             *          Square(10).as('B'))
             *   .keep('A', 'B')
             * ```
             * :::
             *
             **/

            const selectToKeep = (matchTags, geometryTags) => {
              if (geometryTags === undefined) {
                return false;
              }
              for (const geometryTag of geometryTags) {
                if (matchTags.includes(geometryTag)) {
                  return true;
                }
              }
              return false;
            };

            const selectToDrop = (matchTags, geometryTags) =>
              !selectToKeep(matchTags, geometryTags);

            const keepOrDrop = (shape, tags, select) => {
              const matchTags = tags.map((tag) => `user/${tag}`);

              const op = (geometry, descend) => {
                // FIX: Need a more reliable way to detect leaf structure.
                if (
                  geometry.solid ||
                  geometry.surface ||
                  geometry.z0Surface ||
                  geometry.points ||
                  geometry.paths ||
                  geometry.item
                ) {
                  if (select(matchTags, geometry.tags)) {
                    return descend();
                  } else {
                    // Operate on the shape.
                    const shape = Shape.fromGeometry(geometry);
                    // Note that this transform does not violate geometry disjunction.
                    // const dropped = shape.Void().layer(shape.sketch()).toGeometry();
                    const dropped = shape.Void().toGeometry();
                    return dropped;
                  }
                } else {
                  return descend();
                }
              };

              const rewritten = rewrite(shape.toKeptGeometry(), op);
              return Shape.fromGeometry(rewritten);
            };

            const keep = (shape, tags) => {
              if (tags === undefined) {
                // Dropping no tags is an unconditional keep.
                return keepOrDrop(shape, [], selectToDrop);
              } else {
                return keepOrDrop(shape, tags, selectToKeep);
              }
            };

            const drop$1 = (shape, tags) => {
              if (tags === undefined) {
                // Keeping no tags is an unconditional drop.
                return keepOrDrop(shape, [], selectToKeep);
              } else {
                return keepOrDrop(shape, tags, selectToDrop);
              }
            };

            const keepMethod = function (...tags) {
              return keep(this, tags);
            };
            Shape.prototype.keep = keepMethod;

            const dropMethod = function (...tags) {
              return drop$1(this, tags);
            };
            Shape.prototype.drop = dropMethod;

            /**
             *
             * # Kept
             *
             * Kept produces a geometry without dropped elements.
             *
             **/

            const kept = (shape) => Shape.fromGeometry(toKeptGeometry$1(shape));

            const keptMethod = function () {
              return kept(this);
            };
            Shape.prototype.kept = keptMethod;

            kept.signature = 'kept(shape:Shape) -> Shape';
            keptMethod.signature = 'Shape -> kept() -> Shape';

            const layer = (...shapes) =>
              Shape.fromGeometry(
                taggedLayers({}, ...shapes.map((shape) => shape.toGeometry()))
              );

            const layerMethod = function (...shapes) {
              return layer(this, ...shapes);
            };
            Shape.prototype.layer = layerMethod;
            Shape.prototype.and = layerMethod;

            /**
             *
             * # Material
             *
             * Produces a version of a shape with a given material.
             *
             * Materials supported include 'paper', 'metal', 'glass', etc.
             *
             * ::: illustration
             * ```
             * Cylinder(5, 10).material('copper')
             * ```
             * :::
             *
             **/

            const material = (shape, ...tags) =>
              Shape.fromGeometry(
                rewriteTags(
                  tags.map((tag) => `material/${tag}`),
                  [],
                  shape.toGeometry()
                )
              );

            const materialMethod = function (...tags) {
              return material(this, ...tags);
            };
            Shape.prototype.material = materialMethod;

            material.signature = 'material(shape:Shape) -> Shape';
            materialMethod.signature = 'Shape -> material() -> Shape';

            /**
             *
             * # Measure Center
             *
             * Provides the center of the smallest orthogonal box containing the shape.
             *
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Sphere(7)
             * ```
             * :::
             **/

            const measureCenter = (shape) => {
              // FIX: Produce a clearer definition of center.
              const geometry = shape.toKeptGeometry();
              if (geometry.plan && geometry.plan.connector) {
                // Return the center of the connector.
                return geometry.marks[0];
              }
              const [high, low] = measureBoundingBox$5(shape);
              return scale(0.5, add(high, low));
            };

            const measureCenterMethod = function () {
              return measureCenter(this);
            };
            Shape.prototype.measureCenter = measureCenterMethod;

            measureCenter.signature = 'measureCenter(shape:Shape) -> vector';
            measureCenterMethod.signature = 'Shape -> measureCenter() -> vector';

            /**
             *
             * # Translate
             *
             * Translation moves a shape.
             *
             * ::: illustration { "view": { "position": [10, 0, 10] } }
             * ```
             * assemble(Circle(),
             *          Sphere().above())
             * ```
             * :::
             * ::: illustration { "view": { "position": [10, 0, 10] } }
             * ```
             * assemble(Circle(),
             *          Sphere().above()
             *                  .translate(0, 0, 1))
             * ```
             * :::
             * ::: illustration { "view": { "position": [10, 0, 10] } }
             * ```
             * assemble(Circle(),
             *          Sphere().above()
             *                  .translate(0, 1, 0))
             * ```
             * :::
             * ::: illustration { "view": { "position": [10, 0, 10] } }
             * ```
             * assemble(Circle(),
             *          Sphere().above()
             *                  .translate([-1, -1, 1]))
             * ```
             * :::
             *
             **/

            const translate$5 = (shape, x = 0, y = 0, z = 0) =>
              shape.transform(fromTranslation([x, y, z]));

            const method = function (...args) {
              return translate$5(this, ...args);
            };
            Shape.prototype.translate = method;

            /**
             *
             * # Move
             *
             * A shorter way to write translate.
             *
             */

            const move = (...args) => translate$5(...args);

            const moveMethod = function (...params) {
              return translate$5(this, ...params);
            };
            Shape.prototype.move = moveMethod;

            /**
             *
             * # MoveX
             *
             * Move along the X axis.
             *
             */

            const moveX = (shape, x = 0) => move(shape, x);

            const moveXMethod = function (x) {
              return moveX(this, x);
            };
            Shape.prototype.moveX = moveXMethod;

            moveX.signature = 'moveX(shape:Shape, x:number = 0) -> Shape';
            moveXMethod.signature = 'Shape -> moveX(x:number = 0) -> Shape';

            /**
             *
             * # MoveY
             *
             * Move along the Y axis.
             *
             */

            const moveY = (shape, y = 0) => move(shape, 0, y);

            const moveYMethod = function (y) {
              return moveY(this, y);
            };
            Shape.prototype.moveY = moveYMethod;

            moveY.signature = 'moveY(shape:Shape, y:number = 0) -> Shape';
            moveYMethod.signature = 'Shape -> moveY(y:number = 0) -> Shape';

            /**
             *
             * # MoveZ
             *
             * Move along the Z axis.
             *
             */

            const moveZ = (shape, z = 0) => move(shape, 0, 0, z);

            const moveZMethod = function (z) {
              return moveZ(this, z);
            };
            Shape.prototype.moveZ = moveZMethod;

            moveZ.signature = 'moveZ(shape:Shape, z:number = 0) -> Shape';
            moveZMethod.signature = 'Shape -> moveZ(z:number = 0) -> Shape';

            const noPlan = (shape, tags, select) => {
              const op = (geometry, descend) => {
                if (geometry.plan) {
                  return taggedLayers({});
                } else {
                  return descend();
                }
              };

              const rewritten = rewrite(shape.toKeptGeometry(), op);
              return Shape.fromGeometry(rewritten);
            };

            const noPlanMethod = function (...tags) {
              return noPlan(this);
            };
            Shape.prototype.noPlan = noPlanMethod;

            const noVoid = (shape, tags, select) => {
              const op = (geometry, descend) => {
                if (isVoid(geometry)) {
                  return taggedLayers({});
                } else {
                  return descend();
                }
              };

              const rewritten = rewrite(shape.toKeptGeometry(), op);
              return Shape.fromGeometry(rewritten);
            };

            const noVoidMethod = function (...tags) {
              return noVoid(this);
            };
            Shape.prototype.noVoid = noVoidMethod;

            const opMethod = function (op, ...args) {
              return op(this, ...args);
            };
            const withOpMethod = function (op, ...args) {
              return assemble$1(this, op(this, ...args));
            };

            Shape.prototype.op = opMethod;
            Shape.prototype.withOp = withOpMethod;

            const openEdges = (shape, { isOpen = true } = {}) => {
              const r = (v) => v;
              const paths = [];
              for (const { solid } of getSolids(shape.toKeptGeometry())) {
                paths.push(...findOpenEdges(solid, isOpen));
              }
              return Shape.fromGeometry(
                taggedPaths(
                  {},
                  paths.map((path) => path.map(([x, y, z]) => [r(x), r(y), r(z)]))
                )
              );
            };

            const openEdgesMethod = function (...args) {
              return openEdges(this, ...args);
            };
            Shape.prototype.openEdges = openEdgesMethod;

            const withOpenEdgesMethod = function (...args) {
              return assemble$1(this, openEdges(this, ...args));
            };
            Shape.prototype.withOpenEdges = withOpenEdgesMethod;

            /**
             *
             * # Orient
             *
             * Orients a shape so that it moves from 'center' to 'from' and faces toward 'at', rather than 'facing'.
             *
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Square(10)
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Square(10).orient({ from: [3, 3, 3], at: [1, 1, 1] });
             * ```
             * :::
             **/

            const orient$1 = (
              shape,
              { center = [0, 0, 0], facing = [0, 0, 1], at = [0, 0, 0], from = [0, 0, 0] }
            ) => {
              const normalizedFacing = normalize(facing);
              const normalizedAt = normalize(subtract(at, from));

              const angle =
                (Math.acos(dot(normalizedFacing, normalizedAt)) * 180) / Math.PI;
              const axis = normalize(cross(normalizedFacing, normalizedAt));

              return shape.move(negate(center)).rotate(angle, axis).move(from);
            };

            const orientMethod = function (...args) {
              return orient$1(this, ...args);
            };
            Shape.prototype.orient = orientMethod;

            orient$1.signature =
              'orient(Shape:shape, { center:Point, facing:Vector, at:Point, from:Point }) -> Shape';
            orientMethod.signature =
              'Shape -> orient({ center:Point, facing:Vector, at:Point, from:Point }) -> Shape';

            const planes = (shape) => {
              const pieces = [];
              for (const { solid, tags } of getNonVoidSolids(shape.toDisjointGeometry())) {
                for (const surface of solid) {
                  pieces.push(
                    Shape.fromGeometry(
                      taggedSurface(
                        { tags },
                        fromPlane(toPlane$2(surface))
                      )
                    )
                  );
                }
              }
              for (const { surface, z0Surface, tags } of getAnyNonVoidSurfaces(
                shape.toDisjointGeometry()
              )) {
                const thisSurface = surface || z0Surface;
                pieces.push(
                  Shape.fromGeometry(
                    taggedSurface(
                      { tags },
                      fromPlane(toPlane$2(thisSurface))
                    )
                  )
                );
              }

              return pieces;
            };

            const planesMethod = function () {
              return planes(this);
            };
            Shape.prototype.planes = planesMethod;

            /**
             *
             * # Rotate
             *
             * ```
             * rotate(shape, axis, angle)
             * shape.rotate(axis, angle)
             * ```
             *
             * Rotates the shape around the provided axis.
             *
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Square(10)
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Square(10).rotate([1, 1, 1], 90)
             * ```
             * :::
             **/

            const rotate$1 = (shape, angle = 0, axis = [0, 0, 1]) =>
              shape.transform(fromRotation(angle * 0.017453292519943295, axis));

            const rotateMethod = function (...args) {
              return rotate$1(this, ...args);
            };
            Shape.prototype.rotate = rotateMethod;

            /**
             *
             * # Rotate X
             *
             * Rotates the shape around the X axis.
             *
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Square(10)
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Square(10).rotateX(90)
             * ```
             * :::
             **/

            const rotateX$2 = (shape, angle) =>
              shape.transform(fromXRotation(angle * 0.017453292519943295));

            const rotateXMethod = function (angle) {
              return rotateX$2(this, angle);
            };
            Shape.prototype.rotateX = rotateXMethod;

            /**
             *
             * # Rotate Y
             *
             * Rotates the shape around the Y axis.
             *
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Square(10)
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Square(10).rotateY(90)
             * ```
             * :::
             **/

            const rotateY$1 = (shape, angle) =>
              shape.transform(fromYRotation(angle * 0.017453292519943295));

            const rotateYMethod = function (angle) {
              return rotateY$1(this, angle);
            };
            Shape.prototype.rotateY = rotateYMethod;

            /**
             *
             * # Rotate Z
             *
             * Rotates the shape around the Z axis.
             *
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Square(10)
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Square(10).rotateZ(45)
             * ```
             * :::
             **/

            const rotateZ$2 = (shape, angle) =>
              shape.transform(fromZRotation(angle * 0.017453292519943295));

            const rotateZMethod = function (angle) {
              return rotateZ$2(this, angle);
            };
            Shape.prototype.rotateZ = rotateZMethod;

            /**
             *
             * # Scale
             *
             * Scales an object uniformly or per axis.
             *
             * ::: illustration { "view": { "position": [10, 10, 10] } }
             * ```
             * Cube()
             * ```
             * :::
             * ::: illustration { "view": { "position": [10, 10, 10] } }
             * ```
             * Cube().scale(2)
             * ```
             * :::
             * ::: illustration { "view": { "position": [10, 10, 10] } }
             * ```
             * Cube().scale([1, 2, 3])
             * ```
             * :::
             **/

            const scale$4 = (factor, shape) => {
              if (factor.length) {
                const [x = 1, y = 1, z = 1] = factor;
                return shape.transform(fromScaling([x, y, z]));
              } else {
                return shape.transform(fromScaling([factor, factor, factor]));
              }
            };

            const scaleMethod = function (factor) {
              return scale$4(factor, this);
            };
            Shape.prototype.scale = scaleMethod;

            const X$2$1 = 0;
            const Y$2$1 = 1;
            const Z$2$1 = 2;

            const size = (shape) => {
              const geometry = shape.toKeptGeometry();
              const [min, max] = measureBoundingBox$4(geometry);
              const area = measureArea$3(geometry);
              const length = max[X$2$1] - min[X$2$1];
              const width = max[Y$2$1] - min[Y$2$1];
              const height = max[Z$2$1] - min[Z$2$1];
              const center = scale(0.5, add(min, max));
              const radius = distance(center, max);
              return { area, length, width, height, max, min, center, radius };
            };

            const sizeMethod = function () {
              return size(this);
            };
            Shape.prototype.size = sizeMethod;

            size.signature = 'size(shape:Shape) -> Size';
            sizeMethod.signature = 'Shape -> size() -> Size';

            const sketch = (shape) =>
              Shape.fromGeometry(taggedSketch({}, shape.toGeometry()));

            Shape.prototype.sketch = function () {
              return sketch(this);
            };

            Shape.prototype.withSketch = function () {
              return assemble$1(this, sketch(this));
            };

            const solids = (shape, xform = (_) => _) => {
              const solids = [];
              for (const solid of getNonVoidSolids(shape.toDisjointGeometry())) {
                solids.push(xform(Shape.fromGeometry(solid)));
              }
              return solids;
            };

            const solidsMethod = function (...args) {
              return solids(this, ...args);
            };
            Shape.prototype.solids = solidsMethod;

            const surfaces = (shape, op = (_) => _) => {
              const surfaces = [];
              for (const surface of getAnyNonVoidSurfaces(shape.toDisjointGeometry())) {
                surfaces.push(op(Shape.fromGeometry(surface)));
              }
              return surfaces;
            };

            const surfacesMethod = function (op) {
              return surfaces(this, op);
            };
            Shape.prototype.surfaces = surfacesMethod;

            const tags = (shape) =>
              [...allTags(shape.toGeometry())]
                .filter((tag) => tag.startsWith('user/'))
                .map((tag) => tag.substring(5));

            const method$1 = function () {
              return tags(this);
            };

            Shape.prototype.tags = method$1;

            const toolpaths = (shape, xform = (_) => _) => {
              const toolpaths = [];
              for (const geometry of getNonVoidPaths(shape.toDisjointGeometry())) {
                const { tags = [] } = geometry;
                if (tags.includes('path/Toolpath')) {
                  toolpaths.push(xform(Shape.fromGeometry(geometry)));
                }
              }
              return toolpaths;
            };

            const toolpathsMethod = function (xform) {
              return toolpaths(this, xform);
            };
            Shape.prototype.toolpaths = toolpathsMethod;

            const keepToolpathsMethod = function (xform) {
              return assemble$1(...toolpaths(this, xform));
            };
            Shape.prototype.keepToolpaths = keepToolpathsMethod;

            const trace = (shape, length = 1) => {
              const tracePaths = [];
              for (const { paths } of getPaths(shape.toKeptGeometry())) {
                for (let start = 0; ; start += length) {
                  const segments = segment(paths, start, start + length);
                  if (segments.length === 0) {
                    break;
                  }
                  tracePaths.push(...segments);
                }
              }
              return Shape.fromGeometry(
                taggedPaths({ tags: ['display/trace'] }, tracePaths)
              );
            };

            const traceMethod = function (length = 1) {
              return trace(this, length);
            };
            Shape.prototype.trace = traceMethod;

            /**
             *
             * # Turn
             *
             * ```
             * turn(shape, axis, angle)
             * shape.turn(axis, angle)
             * ```
             *
             * Rotates the shape around its own axis.
             *
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Square(10)
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Square(10).turn([1, 1, 1], 90)
             * ```
             * :::
             **/

            const turn = (shape, axis, angle) => {
              const center = shape.measureCenter();
              return shape
                .move(...negate(center))
                .rotate(axis, angle)
                .move(...center);
            };

            const turnMethod = function (angle, axis) {
              return turn(this, axis, angle);
            };
            Shape.prototype.turn = turnMethod;

            const turnX$1 = (shape, angle) => {
              const center = shape.measureCenter();
              return shape
                .move(...negate(center))
                .rotateX(angle)
                .move(...center);
            };

            const turnXMethod = function (angle) {
              return turnX$1(this, angle);
            };
            Shape.prototype.turnX = turnXMethod;

            const turnY$1 = (shape, angle) => {
              const center = shape.measureCenter();
              return shape
                .move(...negate(center))
                .rotateY(angle)
                .move(...center);
            };

            const turnYMethod = function (angle) {
              return turnY$1(this, angle);
            };
            Shape.prototype.turnY = turnYMethod;

            const turnZ$1 = (shape, angle) => {
              const center = shape.measureCenter();
              return shape
                .move(...negate(center))
                .rotateZ(angle)
                .move(...center);
            };

            const turnZMethod = function (angle) {
              return turnZ$1(this, angle);
            };
            Shape.prototype.turnZ = turnZMethod;

            // FIX: Debugging only -- remove this method.
            const wall = (shape) => {
              const normalize = createNormalize3();
              const solids = [];
              for (const { surface, z0Surface, tags } of getAnyNonVoidSurfaces(
                shape.toDisjointGeometry()
              )) {
                solids.push(
                  taggedSolid({ tags }, fromSurface$1(surface || z0Surface, normalize))
                );
              }
              return Shape.fromGeometry(taggedAssembly({}, ...solids));
            };

            const wallMethod = function () {
              return wall(this);
            };
            Shape.prototype.wall = wallMethod;

            const toWireframeFromSolid = (solid) => {
              const paths = [];
              for (const surface of solid) {
                paths.push(...surface);
              }
              return Shape.fromPaths(paths);
            };

            const toWireframeFromSurface = (surface) => {
              return Shape.fromPaths(surface);
            };

            const wireframe = (options = {}, shape) => {
              const pieces = [];
              for (const { solid } of getNonVoidSolids(shape.toKeptGeometry())) {
                pieces.push(toWireframeFromSolid(solid));
              }
              for (const { surface } of getNonVoidSurfaces(shape.toKeptGeometry())) {
                pieces.push(toWireframeFromSurface(surface));
              }
              for (const { z0Surface } of getNonVoidZ0Surfaces(shape.toKeptGeometry())) {
                pieces.push(toWireframeFromSurface(z0Surface));
              }
              return assemble$1(...pieces);
            };

            const method$2 = function (options) {
              return wireframe(options, this);
            };

            Shape.prototype.wireframe = method$2;
            Shape.prototype.withWireframe = function (options) {
              return assemble$1(this, wireframe(options, this));
            };

            const wireframeFaces = (shape, op = (x) => x) => {
              const faces = [];
              for (const { solid } of getSolids(shape.toKeptGeometry())) {
                for (const surface of solid) {
                  for (const path of surface) {
                    faces.push(
                      op(Shape.fromGeometry(taggedPaths({}, [path])), faces.length)
                    );
                  }
                }
              }
              return assemble$1(...faces);
            };

            const wireframeFacesMethod = function (...args) {
              return wireframeFaces(this, ...args);
            };
            Shape.prototype.wireframeFaces = wireframeFacesMethod;

            /**
             *
             * # With
             *
             * Assembles the current shape with those provided.
             *
             * The below example is equivalent to
             * ```
             * assemble(Circle(20), Square(40).moveX(10))
             * ```
             *
             * ::: illustration { "view": { "position": [80, 80, 80] } }
             * ```
             * Circle(20).with(Square(40).moveX(10))
             * ```
             * :::
             *
             **/

            const withMethod = function (...shapes) {
              return assemble$1(this, ...shapes);
            };
            Shape.prototype.with = withMethod;

            const prepareShape = (shape, name, options = {}) => {
              let index = 0;
              const entries = [];
              entries.push({
                data: new TextEncoder('utf8').encode(JSON.stringify(shape)),
                filename: `${name}_${index++}.jsxcad`,
                type: 'application/x-jsxcad',
              });
              return entries;
            };

            const downloadShapeMethod = function (...args) {
              const entries = prepareShape(this, ...args);
              emit$1({ download: { entries } });
              return this;
            };
            Shape.prototype.downloadShape = downloadShapeMethod;

            const writeShape = (shape, name, options = {}) => {
              for (const { data, filename } of prepareShape(shape, name, {})) {
                addPending(writeFile({ doSerialize: false }, `output/${filename}`, data));
              }
              return shape;
            };

            const writeShapeMethod = function (...args) {
              return writeShape(this, ...args);
            };
            Shape.prototype.writeShape = writeShapeMethod;

            const loadGeometry = async (path) =>
              Shape.fromGeometry(await read(path));

            const saveGeometry = async (path, shape) =>
              write(path, shape.toGeometry());

            /**
             *
             * # Log
             *
             * Writes a string to the console.
             *
             * ```
             * log("Hello, World")
             * ```
             *
             **/

            const toText = (value) => {
              if (typeof value === 'object') {
                return JSON.stringify(value);
              } else {
                return String(value);
              }
            };

            const log$2 = (value, level) => {
              const text = toText(value);
              emit$1({ log: { text, level } });
              return log({ op: 'text', text, level });
            };

            const logOp = (shape, op) => {
              const text = String(op(shape));
              emit$1({ log: { text } });
              return log({ op: 'text', text });
            };

            const logMethod = function (
              op = (shape) => JSON.stringify(shape.toKeptGeometry())
            ) {
              logOp(this, op);
              return this;
            };
            Shape.prototype.log = logMethod;

            /**
             *
             * # Ease
             *
             * Produces a function for composing easing functions.
             * ```
             * ease(0.00, 0.25, t => sin(t * 25))(ease(0.25, 1.00, t => 5)())
             * ```
             *
             **/

            const ease = (start = 0.0, end = 1.0, op = (t) => 1) => {
              const compose = (next = (t) => 1) => {
                const fn = (t) => {
                  if (t >= start && t <= end) {
                    return op((t - start) / (end - start));
                  } else {
                    return next(t);
                  }
                };
                return fn;
              };
              return compose;
            };

            const linear = (start, end) => (t) => start + t * (end - start);
            ease.linear = linear;

            ease.signature =
              'ease(start:number = 0, end:number = 1, op:function) -> function';
            linear.signature = 'linear(start:number = 0, end:number = 1) -> function';

            function unwrapExports$2 (x) {
            	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
            }

            function createCommonjsModule$3(fn, module) {
            	return module = { exports: {} }, fn(module, module.exports), module.exports;
            }

            var constants$1 = createCommonjsModule$3(function (module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.NORM_2D = 1.0 / 47.0;
            exports.NORM_3D = 1.0 / 103.0;
            exports.NORM_4D = 1.0 / 30.0;
            exports.SQUISH_2D = (Math.sqrt(2 + 1) - 1) / 2;
            exports.SQUISH_3D = (Math.sqrt(3 + 1) - 1) / 3;
            exports.SQUISH_4D = (Math.sqrt(4 + 1) - 1) / 4;
            exports.STRETCH_2D = (1 / Math.sqrt(2 + 1) - 1) / 2;
            exports.STRETCH_3D = (1 / Math.sqrt(3 + 1) - 1) / 3;
            exports.STRETCH_4D = (1 / Math.sqrt(4 + 1) - 1) / 4;
            exports.base2D = [
                [1, 1, 0, 1, 0, 1, 0, 0, 0],
                [1, 1, 0, 1, 0, 1, 2, 1, 1]
            ];
            exports.base3D = [
                [0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1],
                [2, 1, 1, 0, 2, 1, 0, 1, 2, 0, 1, 1, 3, 1, 1, 1],
                [1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 2, 1, 1, 0, 2, 1, 0, 1, 2, 0, 1, 1]
            ];
            exports.base4D = [
                [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1],
                [3, 1, 1, 1, 0, 3, 1, 1, 0, 1, 3, 1, 0, 1, 1, 3, 0, 1, 1, 1, 4, 1, 1, 1, 1],
                [
                    1,
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1,
                    2,
                    1,
                    1,
                    0,
                    0,
                    2,
                    1,
                    0,
                    1,
                    0,
                    2,
                    1,
                    0,
                    0,
                    1,
                    2,
                    0,
                    1,
                    1,
                    0,
                    2,
                    0,
                    1,
                    0,
                    1,
                    2,
                    0,
                    0,
                    1,
                    1
                ],
                [
                    3,
                    1,
                    1,
                    1,
                    0,
                    3,
                    1,
                    1,
                    0,
                    1,
                    3,
                    1,
                    0,
                    1,
                    1,
                    3,
                    0,
                    1,
                    1,
                    1,
                    2,
                    1,
                    1,
                    0,
                    0,
                    2,
                    1,
                    0,
                    1,
                    0,
                    2,
                    1,
                    0,
                    0,
                    1,
                    2,
                    0,
                    1,
                    1,
                    0,
                    2,
                    0,
                    1,
                    0,
                    1,
                    2,
                    0,
                    0,
                    1,
                    1
                ]
            ];
            exports.gradients2D = [
                5,
                2,
                2,
                5,
                -5,
                2,
                -2,
                5,
                5,
                -2,
                2,
                -5,
                -5,
                -2,
                -2,
                -5
            ];
            exports.gradients3D = [
                -11,
                4,
                4,
                -4,
                11,
                4,
                -4,
                4,
                11,
                11,
                4,
                4,
                4,
                11,
                4,
                4,
                4,
                11,
                -11,
                -4,
                4,
                -4,
                -11,
                4,
                -4,
                -4,
                11,
                11,
                -4,
                4,
                4,
                -11,
                4,
                4,
                -4,
                11,
                -11,
                4,
                -4,
                -4,
                11,
                -4,
                -4,
                4,
                -11,
                11,
                4,
                -4,
                4,
                11,
                -4,
                4,
                4,
                -11,
                -11,
                -4,
                -4,
                -4,
                -11,
                -4,
                -4,
                -4,
                -11,
                11,
                -4,
                -4,
                4,
                -11,
                -4,
                4,
                -4,
                -11
            ];
            exports.gradients4D = [
                3,
                1,
                1,
                1,
                1,
                3,
                1,
                1,
                1,
                1,
                3,
                1,
                1,
                1,
                1,
                3,
                -3,
                1,
                1,
                1,
                -1,
                3,
                1,
                1,
                -1,
                1,
                3,
                1,
                -1,
                1,
                1,
                3,
                3,
                -1,
                1,
                1,
                1,
                -3,
                1,
                1,
                1,
                -1,
                3,
                1,
                1,
                -1,
                1,
                3,
                -3,
                -1,
                1,
                1,
                -1,
                -3,
                1,
                1,
                -1,
                -1,
                3,
                1,
                -1,
                -1,
                1,
                3,
                3,
                1,
                -1,
                1,
                1,
                3,
                -1,
                1,
                1,
                1,
                -3,
                1,
                1,
                1,
                -1,
                3,
                -3,
                1,
                -1,
                1,
                -1,
                3,
                -1,
                1,
                -1,
                1,
                -3,
                1,
                -1,
                1,
                -1,
                3,
                3,
                -1,
                -1,
                1,
                1,
                -3,
                -1,
                1,
                1,
                -1,
                -3,
                1,
                1,
                -1,
                -1,
                3,
                -3,
                -1,
                -1,
                1,
                -1,
                -3,
                -1,
                1,
                -1,
                -1,
                -3,
                1,
                -1,
                -1,
                -1,
                3,
                3,
                1,
                1,
                -1,
                1,
                3,
                1,
                -1,
                1,
                1,
                3,
                -1,
                1,
                1,
                1,
                -3,
                -3,
                1,
                1,
                -1,
                -1,
                3,
                1,
                -1,
                -1,
                1,
                3,
                -1,
                -1,
                1,
                1,
                -3,
                3,
                -1,
                1,
                -1,
                1,
                -3,
                1,
                -1,
                1,
                -1,
                3,
                -1,
                1,
                -1,
                1,
                -3,
                -3,
                -1,
                1,
                -1,
                -1,
                -3,
                1,
                -1,
                -1,
                -1,
                3,
                -1,
                -1,
                -1,
                1,
                -3,
                3,
                1,
                -1,
                -1,
                1,
                3,
                -1,
                -1,
                1,
                1,
                -3,
                -1,
                1,
                1,
                -1,
                -3,
                -3,
                1,
                -1,
                -1,
                -1,
                3,
                -1,
                -1,
                -1,
                1,
                -3,
                -1,
                -1,
                1,
                -1,
                -3,
                3,
                -1,
                -1,
                -1,
                1,
                -3,
                -1,
                -1,
                1,
                -1,
                -3,
                -1,
                1,
                -1,
                -1,
                -3,
                -3,
                -1,
                -1,
                -1,
                -1,
                -3,
                -1,
                -1,
                -1,
                -1,
                -3,
                -1,
                -1,
                -1,
                -1,
                -3
            ];
            exports.lookupPairs2D = [
                0,
                1,
                1,
                0,
                4,
                1,
                17,
                0,
                20,
                2,
                21,
                2,
                22,
                5,
                23,
                5,
                26,
                4,
                39,
                3,
                42,
                4,
                43,
                3
            ];
            exports.lookupPairs3D = [
                0,
                2,
                1,
                1,
                2,
                2,
                5,
                1,
                6,
                0,
                7,
                0,
                32,
                2,
                34,
                2,
                129,
                1,
                133,
                1,
                160,
                5,
                161,
                5,
                518,
                0,
                519,
                0,
                546,
                4,
                550,
                4,
                645,
                3,
                647,
                3,
                672,
                5,
                673,
                5,
                674,
                4,
                677,
                3,
                678,
                4,
                679,
                3,
                680,
                13,
                681,
                13,
                682,
                12,
                685,
                14,
                686,
                12,
                687,
                14,
                712,
                20,
                714,
                18,
                809,
                21,
                813,
                23,
                840,
                20,
                841,
                21,
                1198,
                19,
                1199,
                22,
                1226,
                18,
                1230,
                19,
                1325,
                23,
                1327,
                22,
                1352,
                15,
                1353,
                17,
                1354,
                15,
                1357,
                17,
                1358,
                16,
                1359,
                16,
                1360,
                11,
                1361,
                10,
                1362,
                11,
                1365,
                10,
                1366,
                9,
                1367,
                9,
                1392,
                11,
                1394,
                11,
                1489,
                10,
                1493,
                10,
                1520,
                8,
                1521,
                8,
                1878,
                9,
                1879,
                9,
                1906,
                7,
                1910,
                7,
                2005,
                6,
                2007,
                6,
                2032,
                8,
                2033,
                8,
                2034,
                7,
                2037,
                6,
                2038,
                7,
                2039,
                6
            ];
            exports.lookupPairs4D = [
                0,
                3,
                1,
                2,
                2,
                3,
                5,
                2,
                6,
                1,
                7,
                1,
                8,
                3,
                9,
                2,
                10,
                3,
                13,
                2,
                16,
                3,
                18,
                3,
                22,
                1,
                23,
                1,
                24,
                3,
                26,
                3,
                33,
                2,
                37,
                2,
                38,
                1,
                39,
                1,
                41,
                2,
                45,
                2,
                54,
                1,
                55,
                1,
                56,
                0,
                57,
                0,
                58,
                0,
                59,
                0,
                60,
                0,
                61,
                0,
                62,
                0,
                63,
                0,
                256,
                3,
                258,
                3,
                264,
                3,
                266,
                3,
                272,
                3,
                274,
                3,
                280,
                3,
                282,
                3,
                2049,
                2,
                2053,
                2,
                2057,
                2,
                2061,
                2,
                2081,
                2,
                2085,
                2,
                2089,
                2,
                2093,
                2,
                2304,
                9,
                2305,
                9,
                2312,
                9,
                2313,
                9,
                16390,
                1,
                16391,
                1,
                16406,
                1,
                16407,
                1,
                16422,
                1,
                16423,
                1,
                16438,
                1,
                16439,
                1,
                16642,
                8,
                16646,
                8,
                16658,
                8,
                16662,
                8,
                18437,
                6,
                18439,
                6,
                18469,
                6,
                18471,
                6,
                18688,
                9,
                18689,
                9,
                18690,
                8,
                18693,
                6,
                18694,
                8,
                18695,
                6,
                18696,
                9,
                18697,
                9,
                18706,
                8,
                18710,
                8,
                18725,
                6,
                18727,
                6,
                131128,
                0,
                131129,
                0,
                131130,
                0,
                131131,
                0,
                131132,
                0,
                131133,
                0,
                131134,
                0,
                131135,
                0,
                131352,
                7,
                131354,
                7,
                131384,
                7,
                131386,
                7,
                133161,
                5,
                133165,
                5,
                133177,
                5,
                133181,
                5,
                133376,
                9,
                133377,
                9,
                133384,
                9,
                133385,
                9,
                133400,
                7,
                133402,
                7,
                133417,
                5,
                133421,
                5,
                133432,
                7,
                133433,
                5,
                133434,
                7,
                133437,
                5,
                147510,
                4,
                147511,
                4,
                147518,
                4,
                147519,
                4,
                147714,
                8,
                147718,
                8,
                147730,
                8,
                147734,
                8,
                147736,
                7,
                147738,
                7,
                147766,
                4,
                147767,
                4,
                147768,
                7,
                147770,
                7,
                147774,
                4,
                147775,
                4,
                149509,
                6,
                149511,
                6,
                149541,
                6,
                149543,
                6,
                149545,
                5,
                149549,
                5,
                149558,
                4,
                149559,
                4,
                149561,
                5,
                149565,
                5,
                149566,
                4,
                149567,
                4,
                149760,
                9,
                149761,
                9,
                149762,
                8,
                149765,
                6,
                149766,
                8,
                149767,
                6,
                149768,
                9,
                149769,
                9,
                149778,
                8,
                149782,
                8,
                149784,
                7,
                149786,
                7,
                149797,
                6,
                149799,
                6,
                149801,
                5,
                149805,
                5,
                149814,
                4,
                149815,
                4,
                149816,
                7,
                149817,
                5,
                149818,
                7,
                149821,
                5,
                149822,
                4,
                149823,
                4,
                149824,
                37,
                149825,
                37,
                149826,
                36,
                149829,
                34,
                149830,
                36,
                149831,
                34,
                149832,
                37,
                149833,
                37,
                149842,
                36,
                149846,
                36,
                149848,
                35,
                149850,
                35,
                149861,
                34,
                149863,
                34,
                149865,
                33,
                149869,
                33,
                149878,
                32,
                149879,
                32,
                149880,
                35,
                149881,
                33,
                149882,
                35,
                149885,
                33,
                149886,
                32,
                149887,
                32,
                150080,
                49,
                150082,
                48,
                150088,
                49,
                150098,
                48,
                150104,
                47,
                150106,
                47,
                151873,
                46,
                151877,
                45,
                151881,
                46,
                151909,
                45,
                151913,
                44,
                151917,
                44,
                152128,
                49,
                152129,
                46,
                152136,
                49,
                152137,
                46,
                166214,
                43,
                166215,
                42,
                166230,
                43,
                166247,
                42,
                166262,
                41,
                166263,
                41,
                166466,
                48,
                166470,
                43,
                166482,
                48,
                166486,
                43,
                168261,
                45,
                168263,
                42,
                168293,
                45,
                168295,
                42,
                168512,
                31,
                168513,
                28,
                168514,
                31,
                168517,
                28,
                168518,
                25,
                168519,
                25,
                280952,
                40,
                280953,
                39,
                280954,
                40,
                280957,
                39,
                280958,
                38,
                280959,
                38,
                281176,
                47,
                281178,
                47,
                281208,
                40,
                281210,
                40,
                282985,
                44,
                282989,
                44,
                283001,
                39,
                283005,
                39,
                283208,
                30,
                283209,
                27,
                283224,
                30,
                283241,
                27,
                283256,
                22,
                283257,
                22,
                297334,
                41,
                297335,
                41,
                297342,
                38,
                297343,
                38,
                297554,
                29,
                297558,
                24,
                297562,
                29,
                297590,
                24,
                297594,
                21,
                297598,
                21,
                299365,
                26,
                299367,
                23,
                299373,
                26,
                299383,
                23,
                299389,
                20,
                299391,
                20,
                299584,
                31,
                299585,
                28,
                299586,
                31,
                299589,
                28,
                299590,
                25,
                299591,
                25,
                299592,
                30,
                299593,
                27,
                299602,
                29,
                299606,
                24,
                299608,
                30,
                299610,
                29,
                299621,
                26,
                299623,
                23,
                299625,
                27,
                299629,
                26,
                299638,
                24,
                299639,
                23,
                299640,
                22,
                299641,
                22,
                299642,
                21,
                299645,
                20,
                299646,
                21,
                299647,
                20,
                299648,
                61,
                299649,
                60,
                299650,
                61,
                299653,
                60,
                299654,
                59,
                299655,
                59,
                299656,
                58,
                299657,
                57,
                299666,
                55,
                299670,
                54,
                299672,
                58,
                299674,
                55,
                299685,
                52,
                299687,
                51,
                299689,
                57,
                299693,
                52,
                299702,
                54,
                299703,
                51,
                299704,
                56,
                299705,
                56,
                299706,
                53,
                299709,
                50,
                299710,
                53,
                299711,
                50,
                299904,
                61,
                299906,
                61,
                299912,
                58,
                299922,
                55,
                299928,
                58,
                299930,
                55,
                301697,
                60,
                301701,
                60,
                301705,
                57,
                301733,
                52,
                301737,
                57,
                301741,
                52,
                301952,
                79,
                301953,
                79,
                301960,
                76,
                301961,
                76,
                316038,
                59,
                316039,
                59,
                316054,
                54,
                316071,
                51,
                316086,
                54,
                316087,
                51,
                316290,
                78,
                316294,
                78,
                316306,
                73,
                316310,
                73,
                318085,
                77,
                318087,
                77,
                318117,
                70,
                318119,
                70,
                318336,
                79,
                318337,
                79,
                318338,
                78,
                318341,
                77,
                318342,
                78,
                318343,
                77,
                430776,
                56,
                430777,
                56,
                430778,
                53,
                430781,
                50,
                430782,
                53,
                430783,
                50,
                431000,
                75,
                431002,
                72,
                431032,
                75,
                431034,
                72,
                432809,
                74,
                432813,
                69,
                432825,
                74,
                432829,
                69,
                433032,
                76,
                433033,
                76,
                433048,
                75,
                433065,
                74,
                433080,
                75,
                433081,
                74,
                447158,
                71,
                447159,
                68,
                447166,
                71,
                447167,
                68,
                447378,
                73,
                447382,
                73,
                447386,
                72,
                447414,
                71,
                447418,
                72,
                447422,
                71,
                449189,
                70,
                449191,
                70,
                449197,
                69,
                449207,
                68,
                449213,
                69,
                449215,
                68,
                449408,
                67,
                449409,
                67,
                449410,
                66,
                449413,
                64,
                449414,
                66,
                449415,
                64,
                449416,
                67,
                449417,
                67,
                449426,
                66,
                449430,
                66,
                449432,
                65,
                449434,
                65,
                449445,
                64,
                449447,
                64,
                449449,
                63,
                449453,
                63,
                449462,
                62,
                449463,
                62,
                449464,
                65,
                449465,
                63,
                449466,
                65,
                449469,
                63,
                449470,
                62,
                449471,
                62,
                449472,
                19,
                449473,
                19,
                449474,
                18,
                449477,
                16,
                449478,
                18,
                449479,
                16,
                449480,
                19,
                449481,
                19,
                449490,
                18,
                449494,
                18,
                449496,
                17,
                449498,
                17,
                449509,
                16,
                449511,
                16,
                449513,
                15,
                449517,
                15,
                449526,
                14,
                449527,
                14,
                449528,
                17,
                449529,
                15,
                449530,
                17,
                449533,
                15,
                449534,
                14,
                449535,
                14,
                449728,
                19,
                449729,
                19,
                449730,
                18,
                449734,
                18,
                449736,
                19,
                449737,
                19,
                449746,
                18,
                449750,
                18,
                449752,
                17,
                449754,
                17,
                449784,
                17,
                449786,
                17,
                451520,
                19,
                451521,
                19,
                451525,
                16,
                451527,
                16,
                451528,
                19,
                451529,
                19,
                451557,
                16,
                451559,
                16,
                451561,
                15,
                451565,
                15,
                451577,
                15,
                451581,
                15,
                451776,
                19,
                451777,
                19,
                451784,
                19,
                451785,
                19,
                465858,
                18,
                465861,
                16,
                465862,
                18,
                465863,
                16,
                465874,
                18,
                465878,
                18,
                465893,
                16,
                465895,
                16,
                465910,
                14,
                465911,
                14,
                465918,
                14,
                465919,
                14,
                466114,
                18,
                466118,
                18,
                466130,
                18,
                466134,
                18,
                467909,
                16,
                467911,
                16,
                467941,
                16,
                467943,
                16,
                468160,
                13,
                468161,
                13,
                468162,
                13,
                468163,
                13,
                468164,
                13,
                468165,
                13,
                468166,
                13,
                468167,
                13,
                580568,
                17,
                580570,
                17,
                580585,
                15,
                580589,
                15,
                580598,
                14,
                580599,
                14,
                580600,
                17,
                580601,
                15,
                580602,
                17,
                580605,
                15,
                580606,
                14,
                580607,
                14,
                580824,
                17,
                580826,
                17,
                580856,
                17,
                580858,
                17,
                582633,
                15,
                582637,
                15,
                582649,
                15,
                582653,
                15,
                582856,
                12,
                582857,
                12,
                582872,
                12,
                582873,
                12,
                582888,
                12,
                582889,
                12,
                582904,
                12,
                582905,
                12,
                596982,
                14,
                596983,
                14,
                596990,
                14,
                596991,
                14,
                597202,
                11,
                597206,
                11,
                597210,
                11,
                597214,
                11,
                597234,
                11,
                597238,
                11,
                597242,
                11,
                597246,
                11,
                599013,
                10,
                599015,
                10,
                599021,
                10,
                599023,
                10,
                599029,
                10,
                599031,
                10,
                599037,
                10,
                599039,
                10,
                599232,
                13,
                599233,
                13,
                599234,
                13,
                599235,
                13,
                599236,
                13,
                599237,
                13,
                599238,
                13,
                599239,
                13,
                599240,
                12,
                599241,
                12,
                599250,
                11,
                599254,
                11,
                599256,
                12,
                599257,
                12,
                599258,
                11,
                599262,
                11,
                599269,
                10,
                599271,
                10,
                599272,
                12,
                599273,
                12,
                599277,
                10,
                599279,
                10,
                599282,
                11,
                599285,
                10,
                599286,
                11,
                599287,
                10,
                599288,
                12,
                599289,
                12,
                599290,
                11,
                599293,
                10,
                599294,
                11,
                599295,
                10
            ];
            exports.p2D = [
                0,
                0,
                1,
                -1,
                0,
                0,
                -1,
                1,
                0,
                2,
                1,
                1,
                1,
                2,
                2,
                0,
                1,
                2,
                0,
                2,
                1,
                0,
                0,
                0
            ];
            exports.p3D = [
                0,
                0,
                1,
                -1,
                0,
                0,
                1,
                0,
                -1,
                0,
                0,
                -1,
                1,
                0,
                0,
                0,
                1,
                -1,
                0,
                0,
                -1,
                0,
                1,
                0,
                0,
                -1,
                1,
                0,
                2,
                1,
                1,
                0,
                1,
                1,
                1,
                -1,
                0,
                2,
                1,
                0,
                1,
                1,
                1,
                -1,
                1,
                0,
                2,
                0,
                1,
                1,
                1,
                -1,
                1,
                1,
                1,
                3,
                2,
                1,
                0,
                3,
                1,
                2,
                0,
                1,
                3,
                2,
                0,
                1,
                3,
                1,
                0,
                2,
                1,
                3,
                0,
                2,
                1,
                3,
                0,
                1,
                2,
                1,
                1,
                1,
                0,
                0,
                2,
                2,
                0,
                0,
                1,
                1,
                0,
                1,
                0,
                2,
                0,
                2,
                0,
                1,
                1,
                0,
                0,
                1,
                2,
                0,
                0,
                2,
                2,
                0,
                0,
                0,
                0,
                1,
                1,
                -1,
                1,
                2,
                0,
                0,
                0,
                0,
                1,
                -1,
                1,
                1,
                2,
                0,
                0,
                0,
                0,
                1,
                1,
                1,
                -1,
                2,
                3,
                1,
                1,
                1,
                2,
                0,
                0,
                2,
                2,
                3,
                1,
                1,
                1,
                2,
                2,
                0,
                0,
                2,
                3,
                1,
                1,
                1,
                2,
                0,
                2,
                0,
                2,
                1,
                1,
                -1,
                1,
                2,
                0,
                0,
                2,
                2,
                1,
                1,
                -1,
                1,
                2,
                2,
                0,
                0,
                2,
                1,
                -1,
                1,
                1,
                2,
                0,
                0,
                2,
                2,
                1,
                -1,
                1,
                1,
                2,
                0,
                2,
                0,
                2,
                1,
                1,
                1,
                -1,
                2,
                2,
                0,
                0,
                2,
                1,
                1,
                1,
                -1,
                2,
                0,
                2,
                0
            ];
            exports.p4D = [
                0,
                0,
                1,
                -1,
                0,
                0,
                0,
                1,
                0,
                -1,
                0,
                0,
                1,
                0,
                0,
                -1,
                0,
                0,
                -1,
                1,
                0,
                0,
                0,
                0,
                1,
                -1,
                0,
                0,
                0,
                1,
                0,
                -1,
                0,
                0,
                -1,
                0,
                1,
                0,
                0,
                0,
                -1,
                1,
                0,
                0,
                0,
                0,
                1,
                -1,
                0,
                0,
                -1,
                0,
                0,
                1,
                0,
                0,
                -1,
                0,
                1,
                0,
                0,
                0,
                -1,
                1,
                0,
                2,
                1,
                1,
                0,
                0,
                1,
                1,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                0,
                2,
                1,
                0,
                1,
                0,
                1,
                1,
                -1,
                1,
                0,
                1,
                1,
                0,
                1,
                -1,
                0,
                2,
                0,
                1,
                1,
                0,
                1,
                -1,
                1,
                1,
                0,
                1,
                0,
                1,
                1,
                -1,
                0,
                2,
                1,
                0,
                0,
                1,
                1,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                1,
                0,
                2,
                0,
                1,
                0,
                1,
                1,
                -1,
                1,
                0,
                1,
                1,
                0,
                1,
                -1,
                1,
                0,
                2,
                0,
                0,
                1,
                1,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                1,
                1,
                1,
                4,
                2,
                1,
                1,
                0,
                4,
                1,
                2,
                1,
                0,
                4,
                1,
                1,
                2,
                0,
                1,
                4,
                2,
                1,
                0,
                1,
                4,
                1,
                2,
                0,
                1,
                4,
                1,
                1,
                0,
                2,
                1,
                4,
                2,
                0,
                1,
                1,
                4,
                1,
                0,
                2,
                1,
                4,
                1,
                0,
                1,
                2,
                1,
                4,
                0,
                2,
                1,
                1,
                4,
                0,
                1,
                2,
                1,
                4,
                0,
                1,
                1,
                2,
                1,
                2,
                1,
                1,
                0,
                0,
                3,
                2,
                1,
                0,
                0,
                3,
                1,
                2,
                0,
                0,
                1,
                2,
                1,
                0,
                1,
                0,
                3,
                2,
                0,
                1,
                0,
                3,
                1,
                0,
                2,
                0,
                1,
                2,
                0,
                1,
                1,
                0,
                3,
                0,
                2,
                1,
                0,
                3,
                0,
                1,
                2,
                0,
                1,
                2,
                1,
                0,
                0,
                1,
                3,
                2,
                0,
                0,
                1,
                3,
                1,
                0,
                0,
                2,
                1,
                2,
                0,
                1,
                0,
                1,
                3,
                0,
                2,
                0,
                1,
                3,
                0,
                1,
                0,
                2,
                1,
                2,
                0,
                0,
                1,
                1,
                3,
                0,
                0,
                2,
                1,
                3,
                0,
                0,
                1,
                2,
                2,
                3,
                1,
                1,
                1,
                0,
                2,
                1,
                1,
                1,
                -1,
                2,
                2,
                0,
                0,
                0,
                2,
                3,
                1,
                1,
                0,
                1,
                2,
                1,
                1,
                -1,
                1,
                2,
                2,
                0,
                0,
                0,
                2,
                3,
                1,
                0,
                1,
                1,
                2,
                1,
                -1,
                1,
                1,
                2,
                2,
                0,
                0,
                0,
                2,
                3,
                1,
                1,
                1,
                0,
                2,
                1,
                1,
                1,
                -1,
                2,
                0,
                2,
                0,
                0,
                2,
                3,
                1,
                1,
                0,
                1,
                2,
                1,
                1,
                -1,
                1,
                2,
                0,
                2,
                0,
                0,
                2,
                3,
                0,
                1,
                1,
                1,
                2,
                -1,
                1,
                1,
                1,
                2,
                0,
                2,
                0,
                0,
                2,
                3,
                1,
                1,
                1,
                0,
                2,
                1,
                1,
                1,
                -1,
                2,
                0,
                0,
                2,
                0,
                2,
                3,
                1,
                0,
                1,
                1,
                2,
                1,
                -1,
                1,
                1,
                2,
                0,
                0,
                2,
                0,
                2,
                3,
                0,
                1,
                1,
                1,
                2,
                -1,
                1,
                1,
                1,
                2,
                0,
                0,
                2,
                0,
                2,
                3,
                1,
                1,
                0,
                1,
                2,
                1,
                1,
                -1,
                1,
                2,
                0,
                0,
                0,
                2,
                2,
                3,
                1,
                0,
                1,
                1,
                2,
                1,
                -1,
                1,
                1,
                2,
                0,
                0,
                0,
                2,
                2,
                3,
                0,
                1,
                1,
                1,
                2,
                -1,
                1,
                1,
                1,
                2,
                0,
                0,
                0,
                2,
                2,
                1,
                1,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                0,
                0,
                0,
                0,
                0,
                2,
                1,
                1,
                -1,
                1,
                0,
                1,
                1,
                0,
                1,
                -1,
                0,
                0,
                0,
                0,
                0,
                2,
                1,
                -1,
                1,
                1,
                0,
                1,
                0,
                1,
                1,
                -1,
                0,
                0,
                0,
                0,
                0,
                2,
                1,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                1,
                0,
                0,
                0,
                0,
                0,
                2,
                1,
                -1,
                1,
                0,
                1,
                1,
                0,
                1,
                -1,
                1,
                0,
                0,
                0,
                0,
                0,
                2,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                1,
                1,
                0,
                0,
                0,
                0,
                0,
                2,
                1,
                1,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                2,
                2,
                0,
                0,
                0,
                2,
                1,
                1,
                -1,
                1,
                0,
                1,
                1,
                0,
                1,
                -1,
                2,
                2,
                0,
                0,
                0,
                2,
                1,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                1,
                2,
                2,
                0,
                0,
                0,
                2,
                1,
                1,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                2,
                0,
                2,
                0,
                0,
                2,
                1,
                -1,
                1,
                1,
                0,
                1,
                0,
                1,
                1,
                -1,
                2,
                0,
                2,
                0,
                0,
                2,
                1,
                -1,
                1,
                0,
                1,
                1,
                0,
                1,
                -1,
                1,
                2,
                0,
                2,
                0,
                0,
                2,
                1,
                1,
                -1,
                1,
                0,
                1,
                1,
                0,
                1,
                -1,
                2,
                0,
                0,
                2,
                0,
                2,
                1,
                -1,
                1,
                1,
                0,
                1,
                0,
                1,
                1,
                -1,
                2,
                0,
                0,
                2,
                0,
                2,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                1,
                1,
                2,
                0,
                0,
                2,
                0,
                2,
                1,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                1,
                2,
                0,
                0,
                0,
                2,
                2,
                1,
                -1,
                1,
                0,
                1,
                1,
                0,
                1,
                -1,
                1,
                2,
                0,
                0,
                0,
                2,
                2,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                1,
                1,
                2,
                0,
                0,
                0,
                2,
                3,
                1,
                1,
                0,
                0,
                0,
                2,
                2,
                0,
                0,
                0,
                2,
                1,
                1,
                1,
                -1,
                3,
                1,
                0,
                1,
                0,
                0,
                2,
                0,
                2,
                0,
                0,
                2,
                1,
                1,
                1,
                -1,
                3,
                1,
                0,
                0,
                1,
                0,
                2,
                0,
                0,
                2,
                0,
                2,
                1,
                1,
                1,
                -1,
                3,
                1,
                1,
                0,
                0,
                0,
                2,
                2,
                0,
                0,
                0,
                2,
                1,
                1,
                -1,
                1,
                3,
                1,
                0,
                1,
                0,
                0,
                2,
                0,
                2,
                0,
                0,
                2,
                1,
                1,
                -1,
                1,
                3,
                1,
                0,
                0,
                0,
                1,
                2,
                0,
                0,
                0,
                2,
                2,
                1,
                1,
                -1,
                1,
                3,
                1,
                1,
                0,
                0,
                0,
                2,
                2,
                0,
                0,
                0,
                2,
                1,
                -1,
                1,
                1,
                3,
                1,
                0,
                0,
                1,
                0,
                2,
                0,
                0,
                2,
                0,
                2,
                1,
                -1,
                1,
                1,
                3,
                1,
                0,
                0,
                0,
                1,
                2,
                0,
                0,
                0,
                2,
                2,
                1,
                -1,
                1,
                1,
                3,
                1,
                0,
                1,
                0,
                0,
                2,
                0,
                2,
                0,
                0,
                2,
                -1,
                1,
                1,
                1,
                3,
                1,
                0,
                0,
                1,
                0,
                2,
                0,
                0,
                2,
                0,
                2,
                -1,
                1,
                1,
                1,
                3,
                1,
                0,
                0,
                0,
                1,
                2,
                0,
                0,
                0,
                2,
                2,
                -1,
                1,
                1,
                1,
                3,
                3,
                2,
                1,
                0,
                0,
                3,
                1,
                2,
                0,
                0,
                4,
                1,
                1,
                1,
                1,
                3,
                3,
                2,
                0,
                1,
                0,
                3,
                1,
                0,
                2,
                0,
                4,
                1,
                1,
                1,
                1,
                3,
                3,
                0,
                2,
                1,
                0,
                3,
                0,
                1,
                2,
                0,
                4,
                1,
                1,
                1,
                1,
                3,
                3,
                2,
                0,
                0,
                1,
                3,
                1,
                0,
                0,
                2,
                4,
                1,
                1,
                1,
                1,
                3,
                3,
                0,
                2,
                0,
                1,
                3,
                0,
                1,
                0,
                2,
                4,
                1,
                1,
                1,
                1,
                3,
                3,
                0,
                0,
                2,
                1,
                3,
                0,
                0,
                1,
                2,
                4,
                1,
                1,
                1,
                1,
                3,
                3,
                2,
                1,
                0,
                0,
                3,
                1,
                2,
                0,
                0,
                2,
                1,
                1,
                1,
                -1,
                3,
                3,
                2,
                0,
                1,
                0,
                3,
                1,
                0,
                2,
                0,
                2,
                1,
                1,
                1,
                -1,
                3,
                3,
                0,
                2,
                1,
                0,
                3,
                0,
                1,
                2,
                0,
                2,
                1,
                1,
                1,
                -1,
                3,
                3,
                2,
                1,
                0,
                0,
                3,
                1,
                2,
                0,
                0,
                2,
                1,
                1,
                -1,
                1,
                3,
                3,
                2,
                0,
                0,
                1,
                3,
                1,
                0,
                0,
                2,
                2,
                1,
                1,
                -1,
                1,
                3,
                3,
                0,
                2,
                0,
                1,
                3,
                0,
                1,
                0,
                2,
                2,
                1,
                1,
                -1,
                1,
                3,
                3,
                2,
                0,
                1,
                0,
                3,
                1,
                0,
                2,
                0,
                2,
                1,
                -1,
                1,
                1,
                3,
                3,
                2,
                0,
                0,
                1,
                3,
                1,
                0,
                0,
                2,
                2,
                1,
                -1,
                1,
                1,
                3,
                3,
                0,
                0,
                2,
                1,
                3,
                0,
                0,
                1,
                2,
                2,
                1,
                -1,
                1,
                1,
                3,
                3,
                0,
                2,
                1,
                0,
                3,
                0,
                1,
                2,
                0,
                2,
                -1,
                1,
                1,
                1,
                3,
                3,
                0,
                2,
                0,
                1,
                3,
                0,
                1,
                0,
                2,
                2,
                -1,
                1,
                1,
                1,
                3,
                3,
                0,
                0,
                2,
                1,
                3,
                0,
                0,
                1,
                2,
                2,
                -1,
                1,
                1,
                1
            ];
            });

            unwrapExports$2(constants$1);
            var constants_1$1 = constants$1.NORM_2D;
            var constants_2 = constants$1.NORM_3D;
            var constants_3 = constants$1.NORM_4D;
            var constants_4 = constants$1.SQUISH_2D;
            var constants_5 = constants$1.SQUISH_3D;
            var constants_6 = constants$1.SQUISH_4D;
            var constants_7 = constants$1.STRETCH_2D;
            var constants_8 = constants$1.STRETCH_3D;
            var constants_9 = constants$1.STRETCH_4D;
            var constants_10 = constants$1.base2D;
            var constants_11 = constants$1.base3D;
            var constants_12 = constants$1.base4D;
            var constants_13 = constants$1.gradients2D;
            var constants_14 = constants$1.gradients3D;
            var constants_15 = constants$1.gradients4D;
            var constants_16 = constants$1.lookupPairs2D;
            var constants_17 = constants$1.lookupPairs3D;
            var constants_18 = constants$1.lookupPairs4D;
            var constants_19 = constants$1.p2D;
            var constants_20 = constants$1.p3D;
            var constants_21 = constants$1.p4D;

            var lib$1 = createCommonjsModule$3(function (module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });

            function contribution2D(multiplier, xsb, ysb) {
                return {
                    dx: -xsb - multiplier * constants$1.SQUISH_2D,
                    dy: -ysb - multiplier * constants$1.SQUISH_2D,
                    xsb: xsb,
                    ysb: ysb
                };
            }
            function contribution3D(multiplier, xsb, ysb, zsb) {
                return {
                    dx: -xsb - multiplier * constants$1.SQUISH_3D,
                    dy: -ysb - multiplier * constants$1.SQUISH_3D,
                    dz: -zsb - multiplier * constants$1.SQUISH_3D,
                    xsb: xsb,
                    ysb: ysb,
                    zsb: zsb
                };
            }
            function contribution4D(multiplier, xsb, ysb, zsb, wsb) {
                return {
                    dx: -xsb - multiplier * constants$1.SQUISH_4D,
                    dy: -ysb - multiplier * constants$1.SQUISH_4D,
                    dz: -zsb - multiplier * constants$1.SQUISH_4D,
                    dw: -wsb - multiplier * constants$1.SQUISH_4D,
                    xsb: xsb,
                    ysb: ysb,
                    zsb: zsb,
                    wsb: wsb
                };
            }
            function makeNoise2D(clientSeed) {
                var contributions = [];
                for (var i = 0; i < constants$1.p2D.length; i += 4) {
                    var baseSet = constants$1.base2D[constants$1.p2D[i]];
                    var previous = null;
                    var current = null;
                    for (var k = 0; k < baseSet.length; k += 3) {
                        current = contribution2D(baseSet[k], baseSet[k + 1], baseSet[k + 2]);
                        if (previous === null)
                            contributions[i / 4] = current;
                        else
                            previous.next = current;
                        previous = current;
                    }
                    current.next = contribution2D(constants$1.p2D[i + 1], constants$1.p2D[i + 2], constants$1.p2D[i + 3]);
                }
                var lookup = [];
                for (var i = 0; i < constants$1.lookupPairs2D.length; i += 2) {
                    lookup[constants$1.lookupPairs2D[i]] = contributions[constants$1.lookupPairs2D[i + 1]];
                }
                var perm = new Uint8Array(256);
                var perm2D = new Uint8Array(256);
                var source = new Uint8Array(256);
                for (var i = 0; i < 256; i++)
                    source[i] = i;
                var seed = new Uint32Array(1);
                seed[0] = clientSeed;
                seed = shuffleSeed(shuffleSeed(shuffleSeed(seed)));
                for (var i = 255; i >= 0; i--) {
                    seed = shuffleSeed(seed);
                    var r = new Uint32Array(1);
                    r[0] = (seed[0] + 31) % (i + 1);
                    if (r[0] < 0)
                        r[0] += i + 1;
                    perm[i] = source[r[0]];
                    perm2D[i] = perm[i] & 0x0e;
                    source[r[0]] = source[i];
                }
                return function (x, y) {
                    var stretchOffset = (x + y) * constants$1.STRETCH_2D;
                    var xs = x + stretchOffset;
                    var ys = y + stretchOffset;
                    var xsb = Math.floor(xs);
                    var ysb = Math.floor(ys);
                    var squishOffset = (xsb + ysb) * constants$1.SQUISH_2D;
                    var dx0 = x - (xsb + squishOffset);
                    var dy0 = y - (ysb + squishOffset);
                    var xins = xs - xsb;
                    var yins = ys - ysb;
                    var inSum = xins + yins;
                    var hash = (xins - yins + 1) |
                        (inSum << 1) |
                        ((inSum + yins) << 2) |
                        ((inSum + xins) << 4);
                    var value = 0;
                    for (var c = lookup[hash]; c !== undefined; c = c.next) {
                        var dx = dx0 + c.dx;
                        var dy = dy0 + c.dy;
                        var attn = 2 - dx * dx - dy * dy;
                        if (attn > 0) {
                            var px = xsb + c.xsb;
                            var py = ysb + c.ysb;
                            var indexPartA = perm[px & 0xff];
                            var index = perm2D[(indexPartA + py) & 0xff];
                            var valuePart = constants$1.gradients2D[index] * dx + constants$1.gradients2D[index + 1] * dy;
                            value += attn * attn * attn * attn * valuePart;
                        }
                    }
                    return value * constants$1.NORM_2D;
                };
            }
            exports.makeNoise2D = makeNoise2D;
            function makeNoise3D(clientSeed) {
                var contributions = [];
                for (var i = 0; i < constants$1.p3D.length; i += 9) {
                    var baseSet = constants$1.base3D[constants$1.p3D[i]];
                    var previous = null;
                    var current = null;
                    for (var k = 0; k < baseSet.length; k += 4) {
                        current = contribution3D(baseSet[k], baseSet[k + 1], baseSet[k + 2], baseSet[k + 3]);
                        if (previous === null)
                            contributions[i / 9] = current;
                        else
                            previous.next = current;
                        previous = current;
                    }
                    current.next = contribution3D(constants$1.p3D[i + 1], constants$1.p3D[i + 2], constants$1.p3D[i + 3], constants$1.p3D[i + 4]);
                    current.next.next = contribution3D(constants$1.p3D[i + 5], constants$1.p3D[i + 6], constants$1.p3D[i + 7], constants$1.p3D[i + 8]);
                }
                var lookup = [];
                for (var i = 0; i < constants$1.lookupPairs3D.length; i += 2) {
                    lookup[constants$1.lookupPairs3D[i]] = contributions[constants$1.lookupPairs3D[i + 1]];
                }
                var perm = new Uint8Array(256);
                var perm3D = new Uint8Array(256);
                var source = new Uint8Array(256);
                for (var i = 0; i < 256; i++)
                    source[i] = i;
                var seed = new Uint32Array(1);
                seed[0] = clientSeed;
                seed = shuffleSeed(shuffleSeed(shuffleSeed(seed)));
                for (var i = 255; i >= 0; i--) {
                    seed = shuffleSeed(seed);
                    var r = new Uint32Array(1);
                    r[0] = (seed[0] + 31) % (i + 1);
                    if (r[0] < 0)
                        r[0] += i + 1;
                    perm[i] = source[r[0]];
                    perm3D[i] = (perm[i] % 24) * 3;
                    source[r[0]] = source[i];
                }
                return function (x, y, z) {
                    var stretchOffset = (x + y + z) * constants$1.STRETCH_3D;
                    var xs = x + stretchOffset;
                    var ys = y + stretchOffset;
                    var zs = z + stretchOffset;
                    var xsb = Math.floor(xs);
                    var ysb = Math.floor(ys);
                    var zsb = Math.floor(zs);
                    var squishOffset = (xsb + ysb + zsb) * constants$1.SQUISH_3D;
                    var dx0 = x - (xsb + squishOffset);
                    var dy0 = y - (ysb + squishOffset);
                    var dz0 = z - (zsb + squishOffset);
                    var xins = xs - xsb;
                    var yins = ys - ysb;
                    var zins = zs - zsb;
                    var inSum = xins + yins + zins;
                    var hash = (yins - zins + 1) |
                        ((xins - yins + 1) << 1) |
                        ((xins - zins + 1) << 2) |
                        (inSum << 3) |
                        ((inSum + zins) << 5) |
                        ((inSum + yins) << 7) |
                        ((inSum + xins) << 9);
                    var value = 0;
                    for (var c = lookup[hash]; c !== undefined; c = c.next) {
                        var dx = dx0 + c.dx;
                        var dy = dy0 + c.dy;
                        var dz = dz0 + c.dz;
                        var attn = 2 - dx * dx - dy * dy - dz * dz;
                        if (attn > 0) {
                            var px = xsb + c.xsb;
                            var py = ysb + c.ysb;
                            var pz = zsb + c.zsb;
                            var indexPartA = perm[px & 0xff];
                            var indexPartB = perm[(indexPartA + py) & 0xff];
                            var index = perm3D[(indexPartB + pz) & 0xff];
                            var valuePart = constants$1.gradients3D[index] * dx +
                                constants$1.gradients3D[index + 1] * dy +
                                constants$1.gradients3D[index + 2] * dz;
                            value += attn * attn * attn * attn * valuePart;
                        }
                    }
                    return value * constants$1.NORM_3D;
                };
            }
            exports.makeNoise3D = makeNoise3D;
            function makeNoise4D(clientSeed) {
                var contributions = [];
                for (var i = 0; i < constants$1.p4D.length; i += 16) {
                    var baseSet = constants$1.base4D[constants$1.p4D[i]];
                    var previous = null;
                    var current = null;
                    for (var k = 0; k < baseSet.length; k += 5) {
                        current = contribution4D(baseSet[k], baseSet[k + 1], baseSet[k + 2], baseSet[k + 3], baseSet[k + 4]);
                        if (previous === null)
                            contributions[i / 16] = current;
                        else
                            previous.next = current;
                        previous = current;
                    }
                    current.next = contribution4D(constants$1.p4D[i + 1], constants$1.p4D[i + 2], constants$1.p4D[i + 3], constants$1.p4D[i + 4], constants$1.p4D[i + 5]);
                    current.next.next = contribution4D(constants$1.p4D[i + 6], constants$1.p4D[i + 7], constants$1.p4D[i + 8], constants$1.p4D[i + 9], constants$1.p4D[i + 10]);
                    current.next.next.next = contribution4D(constants$1.p4D[i + 11], constants$1.p4D[i + 12], constants$1.p4D[i + 13], constants$1.p4D[i + 14], constants$1.p4D[i + 15]);
                }
                var lookup = [];
                for (var i = 0; i < constants$1.lookupPairs4D.length; i += 2) {
                    lookup[constants$1.lookupPairs4D[i]] = contributions[constants$1.lookupPairs4D[i + 1]];
                }
                var perm = new Uint8Array(256);
                var perm4D = new Uint8Array(256);
                var source = new Uint8Array(256);
                for (var i = 0; i < 256; i++)
                    source[i] = i;
                var seed = new Uint32Array(1);
                seed[0] = clientSeed;
                seed = shuffleSeed(shuffleSeed(shuffleSeed(seed)));
                for (var i = 255; i >= 0; i--) {
                    seed = shuffleSeed(seed);
                    var r = new Uint32Array(1);
                    r[0] = (seed[0] + 31) % (i + 1);
                    if (r[0] < 0)
                        r[0] += i + 1;
                    perm[i] = source[r[0]];
                    perm4D[i] = perm[i] & 0xfc;
                    source[r[0]] = source[i];
                }
                return function (x, y, z, w) {
                    var stretchOffset = (x + y + z + w) * constants$1.STRETCH_4D;
                    var xs = x + stretchOffset;
                    var ys = y + stretchOffset;
                    var zs = z + stretchOffset;
                    var ws = w + stretchOffset;
                    var xsb = Math.floor(xs);
                    var ysb = Math.floor(ys);
                    var zsb = Math.floor(zs);
                    var wsb = Math.floor(ws);
                    var squishOffset = (xsb + ysb + zsb + wsb) * constants$1.SQUISH_4D;
                    var dx0 = x - (xsb + squishOffset);
                    var dy0 = y - (ysb + squishOffset);
                    var dz0 = z - (zsb + squishOffset);
                    var dw0 = w - (wsb + squishOffset);
                    var xins = xs - xsb;
                    var yins = ys - ysb;
                    var zins = zs - zsb;
                    var wins = ws - wsb;
                    var inSum = xins + yins + zins + wins;
                    var hash = (zins - wins + 1) |
                        ((yins - zins + 1) << 1) |
                        ((yins - wins + 1) << 2) |
                        ((xins - yins + 1) << 3) |
                        ((xins - zins + 1) << 4) |
                        ((xins - wins + 1) << 5) |
                        (inSum << 6) |
                        ((inSum + wins) << 8) |
                        ((inSum + zins) << 11) |
                        ((inSum + yins) << 14) |
                        ((inSum + xins) << 17);
                    var value = 0;
                    for (var c = lookup[hash]; c !== undefined; c = c.next) {
                        var dx = dx0 + c.dx;
                        var dy = dy0 + c.dy;
                        var dz = dz0 + c.dz;
                        var dw = dw0 + c.dw;
                        var attn = 2 - dx * dx - dy * dy - dz * dz - dw * dw;
                        if (attn > 0) {
                            var px = xsb + c.xsb;
                            var py = ysb + c.ysb;
                            var pz = zsb + c.zsb;
                            var pw = wsb + c.wsb;
                            var indexPartA = perm[px & 0xff];
                            var indexPartB = perm[(indexPartA + py) & 0xff];
                            var indexPartC = perm[(indexPartB + pz) & 0xff];
                            var index = perm4D[(indexPartC + pw) & 0xff];
                            var valuePart = constants$1.gradients4D[index] * dx +
                                constants$1.gradients4D[index + 1] * dy +
                                constants$1.gradients4D[index + 2] * dz +
                                constants$1.gradients4D[index + 3] * dw;
                            value += attn * attn * attn * attn * valuePart;
                        }
                    }
                    return value * constants$1.NORM_4D;
                };
            }
            exports.makeNoise4D = makeNoise4D;
            function shuffleSeed(seed) {
                var newSeed = new Uint32Array(1);
                newSeed[0] = seed[0] * 1664525 + 1013904223;
                return newSeed;
            }
            });

            var OpenSimplexNoise = unwrapExports$2(lib$1);
            var lib_1 = lib$1.makeNoise2D;
            var lib_2 = lib$1.makeNoise3D;
            var lib_3 = lib$1.makeNoise4D;

            const Noise = (seed = 0) => {
              const generator = OpenSimplexNoise.makeNoise3D(seed);
              const generate = (x = 0, y = 0, z = 0) => generator(x, y, z);
              return generate;
            };

            var Prando = /** @class */ (function () {
                // ================================================================================================================
                // CONSTRUCTOR ----------------------------------------------------------------------------------------------------
                /**
                 * Generate a new Prando pseudo-random number generator.
                 *
                 * @param seed - A number or string seed that determines which pseudo-random number sequence will be created. Defaults to current time.
                 */
                function Prando(seed) {
                    this._value = NaN;
                    if (typeof (seed) === "string") {
                        // String seed
                        this._seed = this.hashCode(seed);
                    }
                    else if (typeof (seed) === "number") {
                        // Numeric seed
                        this._seed = this.getSafeSeed(seed);
                    }
                    else {
                        // Pseudo-random seed
                        this._seed = this.getSafeSeed(Prando.MIN + Math.floor((Prando.MAX - Prando.MIN) * Math.random()));
                    }
                    this.reset();
                }
                // ================================================================================================================
                // PUBLIC INTERFACE -----------------------------------------------------------------------------------------------
                /**
                 * Generates a pseudo-random number between a lower (inclusive) and a higher (exclusive) bounds.
                 *
                 * @param min - The minimum number that can be randomly generated.
                 * @param pseudoMax - The maximum number that can be randomly generated (exclusive).
                 * @return The generated pseudo-random number.
                 */
                Prando.prototype.next = function (min, pseudoMax) {
                    if (min === void 0) { min = 0; }
                    if (pseudoMax === void 0) { pseudoMax = 1; }
                    this.recalculate();
                    return this.map(this._value, Prando.MIN, Prando.MAX, min, pseudoMax);
                };
                /**
                 * Generates a pseudo-random integer number in a range (inclusive).
                 *
                 * @param min - The minimum number that can be randomly generated.
                 * @param max - The maximum number that can be randomly generated.
                 * @return The generated pseudo-random number.
                 */
                Prando.prototype.nextInt = function (min, max) {
                    if (min === void 0) { min = 10; }
                    if (max === void 0) { max = 100; }
                    this.recalculate();
                    return Math.floor(this.map(this._value, Prando.MIN, Prando.MAX, min, max + 1));
                };
                /**
                 * Generates a pseudo-random string sequence of a particular length from a specific character range.
                 *
                 * Note: keep in mind that creating a random string sequence does not guarantee uniqueness; there is always a
                 * 1 in (char_length^string_length) chance of collision. For real unique string ids, always check for
                 * pre-existing ids, or employ a robust GUID/UUID generator.
                 *
                 * @param length - Length of the strting to be generated.
                 * @param chars - Characters that are used when creating the random string. Defaults to all alphanumeric chars (A-Z, a-z, 0-9).
                 * @return The generated string sequence.
                 */
                Prando.prototype.nextString = function (length, chars) {
                    if (length === void 0) { length = 16; }
                    if (chars === void 0) { chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"; }
                    var str = "";
                    while (str.length < length) {
                        str += this.nextChar(chars);
                    }
                    return str;
                };
                /**
                 * Generates a pseudo-random string of 1 character specific character range.
                 *
                 * @param chars - Characters that are used when creating the random string. Defaults to all alphanumeric chars (A-Z, a-z, 0-9).
                 * @return The generated character.
                 */
                Prando.prototype.nextChar = function (chars) {
                    if (chars === void 0) { chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"; }
                    this.recalculate();
                    return chars.substr(this.nextInt(0, chars.length - 1), 1);
                };
                /**
                 * Picks a pseudo-random item from an array. The array is left unmodified.
                 *
                 * Note: keep in mind that while the returned item will be random enough, picking one item from the array at a time
                 * does not guarantee nor imply that a sequence of random non-repeating items will be picked. If you want to
                 * *pick items in a random order* from an array, instead of *pick one random item from an array*, it's best to
                 * apply a *shuffle* transformation to the array instead, then read it linearly.
                 *
                 * @param array - Array of any type containing one or more candidates for random picking.
                 * @return An item from the array.
                 */
                Prando.prototype.nextArrayItem = function (array) {
                    this.recalculate();
                    return array[this.nextInt(0, array.length - 1)];
                };
                /**
                 * Generates a pseudo-random boolean.
                 *
                 * @return A value of true or false.
                 */
                Prando.prototype.nextBoolean = function () {
                    this.recalculate();
                    return this._value > 0.5;
                };
                /**
                 * Skips ahead in the sequence of numbers that are being generated. This is equivalent to
                 * calling next() a specified number of times, but faster since it doesn't need to map the
                 * new random numbers to a range and return it.
                 *
                 * @param iterations - The number of items to skip ahead.
                 */
                Prando.prototype.skip = function (iterations) {
                    if (iterations === void 0) { iterations = 1; }
                    while (iterations-- > 0) {
                        this.recalculate();
                    }
                };
                /**
                 * Reset the pseudo-random number sequence back to its starting seed. Further calls to next()
                 * will then produce the same sequence of numbers it had produced before. This is equivalent to
                 * creating a new Prando instance with the same seed as another Prando instance.
                 *
                 * Example:
                 * let rng = new Prando(12345678);
                 * console.log(rng.next()); // 0.6177754114889017
                 * console.log(rng.next()); // 0.5784605181725837
                 * rng.reset();
                 * console.log(rng.next()); // 0.6177754114889017 again
                 * console.log(rng.next()); // 0.5784605181725837 again
                 */
                Prando.prototype.reset = function () {
                    this._value = this._seed;
                };
                // ================================================================================================================
                // PRIVATE INTERFACE ----------------------------------------------------------------------------------------------
                Prando.prototype.recalculate = function () {
                    this._value = this.xorshift(this._value);
                };
                Prando.prototype.xorshift = function (value) {
                    // Xorshift*32
                    // Based on George Marsaglia's work: http://www.jstatsoft.org/v08/i14/paper
                    value ^= value << 13;
                    value ^= value >> 17;
                    value ^= value << 5;
                    return value;
                };
                Prando.prototype.map = function (val, minFrom, maxFrom, minTo, maxTo) {
                    return ((val - minFrom) / (maxFrom - minFrom)) * (maxTo - minTo) + minTo;
                };
                Prando.prototype.hashCode = function (str) {
                    var hash = 0;
                    if (str) {
                        var l = str.length;
                        for (var i = 0; i < l; i++) {
                            hash = ((hash << 5) - hash) + str.charCodeAt(i);
                            hash |= 0;
                            hash = this.xorshift(hash);
                        }
                    }
                    return this.getSafeSeed(hash);
                };
                Prando.prototype.getSafeSeed = function (seed) {
                    if (seed === 0)
                        return 1;
                    return seed;
                };
                Prando.MIN = -2147483648; // Int32 min
                Prando.MAX = 2147483647; // Int32 max
                return Prando;
            }());

            const makeTo = (g) => (to) => g() * to;
            const makeIn = (g) => (from, to) => g() * (to - from) + from;
            const makeVary = (g) => (degree) => (g() - 0.5) * degree * 2;
            const makePick = (g) => (options) => options[Math.floor(g() * options.length)];

            const Random = (seed = 0) => {
              const rng = new Prando(seed);
              const g = () => rng.next();
              g.in = makeIn(g);
              g.to = makeTo(g);
              g.vary = makeVary(g);
              g.pick = makePick(g);
              return g;
            };

            /**
             *
             * # Arc Cosine
             *
             * Gives the arc cosine converted to degrees.
             * ```
             * acos(a) => Math.acos(a) / (Math.PI * 2) * 360;
             *
             * acos(0) = 90
             * acos(0.5) = 60
             * acos(1) = 0
             * ```
             *
             **/

            const acos = (a) => (Math.acos(a) / (Math.PI * 2)) * 360;
            acos.signature = 'acos(angle:number) -> number';

            /**
             *
             * # Cosine
             *
             * Gives the cosine in degrees.
             * ```
             * cos(a) => Math.cos(a / 360 * Math.PI * 2);
             *
             * cos(0) = 1
             * cos(45) = 0.707
             * cos(90) = 0
             * ```
             *
             **/

            const cos = (a) => Math.cos((a / 360) * Math.PI * 2);

            cos.signature = 'cos(angle:number) -> number';

            /**
             *
             * # Max
             *
             * Produces the maximum of a series of numbers.
             *
             * ```
             * max(1, 2, 3, 4) == 4
             * ```
             *
             **/

            const max$1 = Math.max;

            max$1.signature = 'max(...values:number) -> number';

            /**
             *
             * # Min
             *
             * Produces the minimum of a series of numbers.
             *
             * ```
             * min(1, 2, 3, 4) == 1
             * ```
             *
             **/

            const min$1 = Math.min;

            min$1.signature = 'min(...values:number) -> number';

            /**
             *
             * # Numbers
             *
             * ```
             * numbers({ to: 10 }) is [0, 1, 2, 3, 4, 5, 6, 9].
             * numbers({ from: 3, to: 6 }) is [3, 4, 5, 6].
             * numbers({ from: 2, to: 8, by: 2 }) is [2, 4, 6].
             * numbers({ to: 2 }, { to: 3 }) is [[0, 0], [0, 1], [0, 2], [1, 0], ...];
             * ```
             *
             **/

            const EPSILON$4 = 1e-5;

            const numbers = (
              thunk = (n) => n,
              { from = 0, to, upto, by, resolution } = {}
            ) => {
              const numbers = [];
              if (by === undefined) {
                if (resolution !== undefined) {
                  by = to / resolution;
                } else {
                  by = 1;
                }
              }

              if (to === undefined && upto === undefined) {
                upto = 1;
              }

              if (upto !== undefined) {
                // Exclusive
                for (
                  let number = from, nth = 0;
                  number < to - EPSILON$4;
                  number += by, nth++
                ) {
                  numbers.push(thunk(number, nth));
                }
              } else if (to !== undefined) {
                // Inclusive
                for (
                  let number = from, nth = 0;
                  number <= to + EPSILON$4;
                  number += by, nth++
                ) {
                  numbers.push(thunk(number, nth));
                }
              }
              return numbers;
            };

            numbers.signature = 'numbers(spec) -> numbers';

            /**
             *
             * # Sine
             *
             * Gives the sine in degrees.
             * ```
             * sin(a) => Math.sin(a / 360 * Math.PI * 2);
             *
             * sin(0) = 0
             * sin(45) = 0.707
             * sin(90) = 1
             * ```
             *
             **/

            const sin$1 = (a) => Math.sin((a / 360) * Math.PI * 2);

            /**
             *
             * # Square Root
             *
             * Gives the the square root of a number.
             * ```
             * sqrt(a) => Math.sqrt(a);
             *
             * sqrt(0) = 0
             * sqrt(4) = 2
             * sqrt(16) = 4
             * ```
             *
             **/

            const sqrt = Math.sqrt;

            /**
             *
             * # Spiral
             *
             * These take a function mapping angle to radius.
             *
             * ::: illustration { "view": { "position": [0, 0, 10] } }
             * ```
             * Spiral(angle => [angle],
             *        { to: 360 * 5 });
             * ```
             * :::
             * ::: illustration { "view": { "position": [0, 0, 10] } }
             * ```
             * Spiral({ to: 360 },
             *        (angle) => [[2 + sin(angle * 20)]])
             *   .close()
             *   .interior()
             * ```
             * :::
             **/

            const Spiral = (
              toPathFromAngle = (angle) => [[angle]],
              { from = 0, to = 360, by, resolution } = {}
            ) => {
              if (by === undefined && resolution === undefined) {
                by = 1;
              }
              let path = [null];
              for (const angle of numbers((angle) => angle, { from, to, by, resolution })) {
                const radians = (angle * Math.PI) / 180;
                const subpath = toPathFromAngle(angle);
                path = concatenate(path, rotateZ$1(radians, subpath));
              }
              return Shape.fromPath(path);
            };

            const ofRadius = (radius, angle = 360, { start = 0, sides = 32 } = {}) =>
              Spiral((a) => [[radius]], {
                from: start,
                to: start + angle,
                resolution: sides,
              });

            const Arc = (...args) => ofRadius(...args);
            Arc.ofRadius = ofRadius;

            const isDefined = (value) => value !== undefined;

            const Assembly = (...shapes) =>
              Shape.fromGeometry(
                taggedAssembly(
                  {},
                  ...shapes.filter(isDefined).map((shape) => shape.toGeometry())
                )
              );

            const unitPolygon = (sides = 16) =>
              Shape.fromGeometry(taggedZ0Surface({}, [buildRegularPolygon(sides)]));

            // Note: radius here is circumradius.
            const toRadiusFromEdge = (edge, sides) =>
              edge * regularPolygonEdgeLengthToRadius(1, sides);

            const ofRadius$1 = (radius, { sides = 16 } = {}) =>
              unitPolygon(sides).scale(radius);
            const ofEdge = (edge, { sides = 16 }) =>
              ofRadius$1(toRadiusFromEdge(edge, sides), { sides });
            const ofApothem = (apothem, { sides = 16 }) =>
              ofRadius$1(toRadiusFromApothem(apothem, sides), { sides });
            const ofDiameter = (diameter, ...args) =>
              ofRadius$1(diameter / 2, ...args);
            const ofPoints = (points) =>
              Shape.fromGeometry(buildPolygonFromPoints(points));

            /**
             *
             * # Polygon
             *
             * ::: illustration { "view": { "position": [0, 0, 5] } }
             * ```
             * Polygon([0, 1],
             *         [1, 1],
             *         [1, 0],
             *         [0.2, 0.2])
             * ```
             * :::
             * ::: illustration { "view": { "position": [0, -1, 50] } }
             * ```
             * Polygon({ edge: 10, sides: 6 })
             * ```
             * :::
             * ::: illustration { "view": { "position": [0, -1, 50] } }
             * ```
             * assemble(
             *   Polygon({ apothem: 10, sides: 5 }),
             *   Circle(10).drop())
             * ```
             * :::
             * ::: illustration { "view": { "position": [0, -1, 50] } }
             * ```
             * assemble(
             *   Circle(10),
             *   Polygon({ radius: 10, sides: 5 }).drop())
             * ```
             * :::
             * ::: illustration { "view": { "position": [0, -1, 50] } }
             * ```
             * Polygon({ diameter: 20, sides: 3 })
             * ```
             * :::
             *
             **/

            const Polygon = (...args) => ofRadius$1(...args);

            Polygon.ofEdge = ofEdge;
            Polygon.ofApothem = ofApothem;
            Polygon.ofRadius = ofRadius$1;
            Polygon.ofDiameter = ofDiameter;
            Polygon.ofPoints = ofPoints;
            Polygon.toRadiusFromApothem = toRadiusFromApothem;

            /**
             *
             * # Circle (disc)
             *
             * Circles are approximated as surfaces delimeted by regular polygons.
             *
             * Properly speaking what is produced here are discs.
             * The circle perimeter can be extracted via outline().
             *
             * ::: illustration { "view": { "position": [0, 0, 10] } }
             * ```
             * Circle()
             * ```
             * :::
             * ::: illustration
             * ```
             * Circle(10)
             * ```
             * :::
             * ::: illustration
             * ```
             * Circle.ofRadius(10, { sides: 8 })
             * ```
             * :::
             * ::: illustration
             * ```
             * Circle.ofApothem(10, { sides: 8 })
             * ```
             * :::
             * ::: illustration
             * ```
             * Circle.ofApothem(10, { sides: 5 })
             *       .with(Circle.ofRadius(10, { sides: 5 }).drop(),
             *             Circle.ofRadius(10).outline().moveZ(0.01))
             * ```
             * :::
             * ::: illustration
             * ```
             * Circle.ofDiameter(20, { sides: 16 })
             * ```
             * :::
             * ::: illustration
             * ```
             * Circle.ofEdge(5, { sides: 5 })
             * ```
             * :::
             **/

            const ofEdge$1 = (edge = 1, { sides = 32 } = {}) =>
              Polygon.ofEdge(edge, { sides });

            const ofRadius$2 = (radius = 1, { sides = 32 } = {}) =>
              Polygon.ofRadius(radius, { sides });

            const ofApothem$1 = (apothem = 1, { sides = 32 } = {}) =>
              Polygon.ofApothem(apothem, { sides });

            const ofDiameter$1 = (diameter = 1, { sides = 32 } = {}) =>
              Polygon.ofDiameter(diameter, { sides });

            const Circle = (...args) => ofRadius$2(...args);

            Circle.ofEdge = ofEdge$1;
            Circle.ofApothem = ofApothem$1;
            Circle.ofRadius = ofRadius$2;
            Circle.ofDiameter = ofDiameter$1;
            Circle.toRadiusFromApothem = (radius = 1, sides = 32) =>
              Polygon.toRadiusFromApothem(radius, sides);

            Circle.signature = 'Circle(radius:number = 1, { sides:number = 32 }) -> Shape';
            ofEdge$1.signature =
              'Circle.ofEdge(edge:number = 1, { sides:number = 32 }) -> Shape';
            ofRadius$2.signature =
              'Circle.ofRadius(radius:number = 1, { sides:number = 32 }) -> Shape';
            ofApothem$1.signature =
              'Circle.ofApothem(apothem:number = 1, { sides:number = 32 }) -> Shape';
            ofDiameter$1.signature =
              'Circle.ofDiameter(diameter:number = 1, { sides:number = 32 }) -> Shape';

            const buildPrism = (radius = 1, height = 1, sides = 32) =>
              Shape.fromGeometry(taggedSolid({}, buildRegularPrism(sides))).scale([
                radius,
                radius,
                height,
              ]);

            /**
             *
             * # Prism
             *
             * Generates prisms.
             *
             * ::: illustration { "view": { "position": [10, 10, 10] } }
             * ```
             * Prism()
             * ```
             * :::
             *
             **/

            const ofRadius$3 = (radius = 1, height = 1, { sides = 3 } = {}) =>
              buildPrism(radius, height, sides);
            const ofDiameter$2 = (diameter = 1, ...args) =>
              ofRadius$3(diameter / 2, ...args);

            const toPathFromSurface = (shape) => {
              for (const { surface, z0Surface } of getAnySurfaces(shape.toKeptGeometry())) {
                const anySurface = surface || z0Surface;
                for (const path of anySurface) {
                  return path;
                }
              }
              return [];
            };

            const ofFunction = (op, { resolution, cap = true, context } = {}) =>
              Shape.fromGeometry(
                taggedSolid({}, buildFromFunction(op, resolution, cap, context))
              );

            const ofSlices = (op, { slices = 2, cap = true } = {}) =>
              Shape.fromGeometry(
                taggedSolid(
                  {},
                  buildFromSlices((t) => toPathFromSurface(op(t)), slices, cap)
                )
              );

            const Prism = (...args) => ofRadius$3(...args);

            Prism.ofRadius = ofRadius$3;
            Prism.ofDiameter = ofDiameter$2;
            Prism.ofFunction = ofFunction;
            Prism.ofSlices = ofSlices;

            const ofRadius$4 = (radius = 1, height = 1, { sides = 32 } = {}) => {
              const fn = linear(1, 0);
              return Prism.ofSlices((t) =>
                Circle(fn(t) * radius, { sides }).moveZ(t * height)
              );
            };

            const ofDiameter$3 = (diameter, ...args) =>
              ofRadius$4(diameter / 2, ...args);
            const ofApothem$2 = (apothem, ...args) =>
              ofRadius$4(toRadiusFromApothem(apothem), ...args);

            const Cone = (...args) => ofRadius$4(...args);

            Cone.ofRadius = ofRadius$4;
            Cone.ofDiameter = ofDiameter$3;
            Cone.ofApothem = ofApothem$2;

            /**
             *
             * # Cube (cuboid)
             *
             * Generates cuboids.
             *
             * ::: illustration { "view": { "position": [10, 10, 10] } }
             * ```
             * Cube()
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Cube(10)
             * ```
             * :::
             * ::: illustration { "view": { "position": [80, 80, 80] } }
             * ```
             * Cube(10, 20, 30)
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Cube.ofRadius(8)
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Cube.ofDiameter(16)
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Cube.ofApothem(8)
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Cube.fromCorners([0, 0, 0], [10, 10, 10])
             * ```
             * :::
             *
             **/

            // Geometry construction.

            const edgeScale = regularPolygonEdgeLengthToRadius(1, 4);

            const unitCube = () =>
              Shape.fromGeometry(taggedSolid({}, buildRegularPrism(4)))
                .rotateZ(45)
                .scale([edgeScale, edgeScale, 1]);

            // Cube Interfaces.

            const ofSize = (width = 1, length, height) =>
              unitCube().scale([
                width,
                length === undefined ? width : length,
                height === undefined ? width : height,
              ]);

            const ofRadius$5 = (radius) =>
              Shape.fromGeometry(taggedSolid({}, buildRegularPrism(4)))
                .rotateZ(45)
                .scale([radius, radius, radius / edgeScale]);

            const ofApothem$3 = (apothem) => ofRadius$5(toRadiusFromApothem(apothem, 4));

            const ofDiameter$4 = (diameter) => ofRadius$5(diameter / 2);

            const fromCorners = (corner1, corner2) => {
              const [c1x, c1y, c1z] = corner1;
              const [c2x, c2y, c2z] = corner2;
              const length = c2x - c1x;
              const width = c2y - c1y;
              const height = c2z - c1z;
              const center = [(c1x + c2x) / 2, (c1y + c2y) / 2, (c1z + c2z) / 2];
              return unitCube()
                .scale([length, width, height])
                .move(...center);
            };

            const Cube = (...args) => ofSize(...args);

            Cube.ofSize = ofSize;
            Cube.ofRadius = ofRadius$5;
            Cube.ofApothem = ofApothem$3;
            Cube.ofDiameter = ofDiameter$4;
            Cube.fromCorners = fromCorners;

            const buildPrism$1 = (radius = 1, height = 1, sides = 32) =>
              Shape.fromGeometry(taggedSolid({}, buildRegularPrism(sides))).scale([
                radius,
                radius,
                height,
              ]);

            /**
             *
             * # Cylinder
             *
             * Generates cylinders.
             *
             * ::: illustration { "view": { "position": [10, 10, 10] } }
             * ```
             * Cylinder()
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Cylinder(10, 5)
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Cylinder.ofRadius(6, 10, { sides: 8 })
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Cylinder.ofApothem(6, 10, { sides: 8 })
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Cylinder.ofDiameter(6, 8, { sides: 16 })
             * ```
             * :::
             *
             **/

            const ofRadius$6 = (radius = 1, height = 1, { sides = 32 } = {}) =>
              buildPrism$1(radius, height, sides);
            const ofApothem$4 = (apothem = 1, height = 1, { sides = 32 } = {}) =>
              ofRadius$6(toRadiusFromApothem(apothem, sides), height, { sides });
            const ofDiameter$5 = (diameter = 1, ...args) =>
              ofRadius$6(diameter / 2, ...args);

            const toPathFromShape = (shape) => {
              for (const { paths } of getPaths(shape.toKeptGeometry())) {
                for (const path of paths) {
                  return path;
                }
              }
              return [];
            };

            const ofFunction$1 = (op, { resolution, cap = true, context } = {}) =>
              Shape.fromGeometry(
                taggedSolid({}, buildFromFunction(op, resolution, cap, context))
              );

            const ofSlices$1 = (op, { slices = 2, cap = true } = {}) =>
              Shape.fromGeometry(
                taggedSolid(
                  {},
                  buildFromSlices((slice) => toPathFromShape(op(slice)), slices, cap)
                )
              );

            const Cylinder = (...args) => ofRadius$6(...args);

            Cylinder.ofRadius = ofRadius$6;
            Cylinder.ofApothem = ofApothem$4;
            Cylinder.ofDiameter = ofDiameter$5;
            Cylinder.ofFunction = ofFunction$1;
            Cylinder.ofSlices = ofSlices$1;

            Cylinder.signature =
              'Cylinder(radius:number = 1, height:number = 1, { sides:number = 32 }) -> Shape';
            Cylinder.ofRadius.signature =
              'Cylinder.ofRadius(radius:number = 1, height:number = 1, { sides:number = 32 }) -> Shape';
            Cylinder.ofDiameter.signature =
              'Cylinder.ofDiameter(radius:number = 1, height:number = 1, { sides:number = 32 }) -> Shape';
            Cylinder.ofApothem.signature =
              'Cylinder.ofApothem(radius:number = 1, height:number = 1, { sides:number = 32 }) -> Shape';
            Cylinder.ofSlices.signature =
              'Cylinder.ofSlices(op:function, { slices:number = 2, cap:boolean = true }) -> Shape';
            Cylinder.ofFunction.signature =
              'Cylinder.ofFunction(op:function, { resolution:number, cap:boolean = true, context:Object }) -> Shape';

            const Difference = (first, ...rest) => first.cut(...rest);

            const Empty = (...shapes) =>
              Shape.fromGeometry(taggedDisjointAssembly({}));

            /**
             *
             * # Hexagon
             *
             * ::: illustration { "view": { "position": [0, 0, 5] } }
             * ```
             * Hexagon()
             * ```
             * :::
             * ::: illustration
             * ```
             * Hexagon(20)
             * ```
             * :::
             **/

            const ofEdge$2 = (edge = 1) => Polygon.ofEdge(edge, { sides: 6 });
            const ofApothem$5 = (apothem = 1) =>
              Polygon.ofApothem(apothem, { sides: 6 });
            const ofRadius$7 = (radius = 1) => Polygon.ofRadius(radius, { sides: 6 });
            const ofDiameter$6 = (diameter = 1) =>
              Polygon.ofDiameter(diameter, { sides: 6 });

            const Hexagon = (...args) => ofRadius$7(...args);

            Hexagon.ofRadius = ofRadius$7;
            Hexagon.ofEdge = ofEdge$2;
            Hexagon.ofApothem = ofApothem$5;
            Hexagon.ofRadius = ofRadius$7;
            Hexagon.ofDiameter = ofDiameter$6;

            Hexagon.signature = 'Hexagon(radius:number = 1) -> Shape';
            Hexagon.ofRadius.signature = 'Hexagon.ofRadius(radius:number = 1) -> Shape';
            Hexagon.ofDiameter.signature =
              'Hexagon.ofDiameter(diameter:number = 1) -> Shape';
            Hexagon.ofApothem.signature = 'Hexagon.ofApothem(apothem:number = 1) -> Shape';
            Hexagon.ofEdge.signature = 'Hexagon.ofEdge(edge:number = 1) -> Shape';

            /**
             *
             * # Icosahedron
             *
             * Generates tetrahedrons.
             *
             * ::: illustration { "view": { "position": [8, 8, 8] } }
             * ```
             * Icosahedron()
             * ```
             * :::
             * ::: illustration { "view": { "position": [80, 80, 80] } }
             * ```
             * Icosahedron(10)
             * ```
             * :::
             * ::: illustration { "view": { "position": [60, 60, 60] } }
             * ```
             * Icosahedron({ radius: 8 })
             * ```
             * :::
             * ::: illustration { "view": { "position": [60, 60, 60] } }
             * ```
             * Icosahedron({ diameter: 16 })
             * ```
             * :::
             *
             **/

            const unitIcosahedron = () =>
              Shape.fromPolygonsToSolid(buildRegularIcosahedron());

            const ofRadius$8 = (radius = 1) => unitIcosahedron().scale(radius);
            const ofDiameter$7 = (diameter = 1) =>
              unitIcosahedron().scale(diameter / 2);
            const Icosahedron = (...args) => ofRadius$8(...args);

            Icosahedron.ofRadius = ofRadius$8;
            Icosahedron.ofDiameter = ofDiameter$7;

            Icosahedron.signature = 'Icosahedron(radius:number = 1) -> Shape';
            Icosahedron.ofRadius.signature =
              'Icosahedron.ofRadius(radius:number = 1) -> Shape';
            Icosahedron.ofDiameter.signature =
              'Icosahedron.ofDiameter(diameter:number = 1) -> Shape';

            const Intersection = (first, ...rest) => first.clip(...rest);

            const isDefined$1 = (value) => value;

            const Layers = (...shapes) =>
              Shape.fromGeometry(
                taggedLayers(
                  {},
                  ...shapes.filter(isDefined$1).map((shape) => shape.toGeometry())
                )
              );

            const fromVec3 = (...points) =>
              Shape.fromOpenPath(points.map(([x = 0, y = 0, z = 0]) => [x, y, z]));

            const fromPoints$3 = (...shapes) => {
              const vec3List = [];
              for (const shape of shapes) {
                shape.eachPoint((vec3) => vec3List.push(vec3));
              }
              return fromVec3(...vec3List);
            };

            const Path = (...points) => fromPoints$3(...points);
            Path.fromVec3 = fromVec3;

            const Line = (length) => Path([0, 0, length / -2], [0, 0, length / 2]);

            Line.signature = 'Line(length:number) -> Shape';

            const fromPoint$1 = (x = 0, y = 0, z = 0) => Shape.fromPoint([x, y, z]);
            const Point = (...args) => fromPoint$1(...args);
            Point.fromPoint = fromPoint$1;

            Point.signature = 'Point(point:Point) -> Shape';

            const fromPoints$1$1 = (...args) => Shape.fromPoints(args);

            /**
             *
             * # Points
             *
             * Generates point cloud.
             *
             * Note: The points are not visible in the illustrations below.
             *
             * ::: illustration
             * ```
             * Points([ -0.5, -0.5, -0.5 ],
             *        [ -0.5, -0.5, 0.5 ],
             *        [ -0.5, 0.5, -0.5 ],
             *        [ -0.5, 0.5, 0.5 ],
             *        [ 0.5, -0.5, -0.5 ],
             *        [ 0.5, -0.5, 0.5 ],
             *        [ 0.5, 0.5, -0.5 ],
             *        [ 0.5, 0.5, 0.5 ])
             * ```
             * :::
             * ::: illustration { "view": { "position": [5, 5, 5] } }
             * ```
             * hull(Points([ -0.5, -0.5, -0.5 ],
             *             [ -0.5, -0.5, 0.5 ],
             *             [ -0.5, 0.5, -0.5 ],
             *             [ -0.5, 0.5, 0.5 ],
             *             [ 0.5, -0.5, -0.5 ],
             *             [ 0.5, -0.5, 0.5 ],
             *             [ 0.5, 0.5, -0.5 ],
             *             [ 0.5, 0.5, 0.5 ]))
             * ```
             * :::
             *
             **/

            const Points = (...args) => fromPoints$1$1(...args);
            Points.fromPoints = fromPoints$1$1;

            /**
             *
             * # Polyhedron
             *
             * ::: illustration { "view": { "position": [80, 20, 20] } }
             * ```
             * Polyhedron([[10, 10, 0], [10, -10, 0], [-10, -10, 0], [-10, 10, 0], [0, 0, 10]],
             *            [[4, 1, 0], [4, 2, 1], [4, 3, 2], [4, 0, 3], [3, 0, 1], [3, 1, 2]] })
             * ```
             * :::
             *
             **/

            const ofPointPaths = (points = [], paths = []) => {
              const polygons = [];
              for (const path of paths) {
                polygons.push(path.map((point) => points[point]));
              }
              return Shape.fromPolygonsToSolid(polygons);
            };

            const Polyhedron = (...args) => ofPointPaths(...args);

            Polyhedron.ofPointPaths = ofPointPaths;

            // FIX: This name is confusing wrt Shape.sketch().
            const Sketch = (shape) => shape.Void().with(shape.sketch());

            const SketchMethod = function () {
              return Sketch(this);
            };
            Shape.prototype.Sketch = SketchMethod;

            /**
             *
             * # Sphere
             *
             * Generates spheres.
             *
             * ::: illustration { "view": { "position": [5, 5, 5] } }
             * ```
             * Sphere()
             * ```
             * :::
             * ::: illustration { "view": { "position": [60, 60, 60] } }
             * ```
             * Sphere(10)
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Sphere({ radius: 8, resolution: 5 })
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * Sphere({ diameter: 16, resolution: 64 })
             * ```
             * :::
             *
             **/

            const unitSphere = (resolution = 16) => {
              const shape = Shape.fromGeometry(
                taggedSolid({}, buildRingSphere(resolution))
              );
              return shape;
            };

            const ofRadius$9 = (radius = 1, { resolution = 16 } = {}) =>
              unitSphere(resolution).scale(radius);
            const ofApothem$6 = (apothem = 1, { resolution = 16 } = {}) =>
              ofRadius$9(toRadiusFromApothem(apothem, (2 + resolution) * 2), { resolution });
            const ofDiameter$8 = (diameter = 1, { resolution = 16 } = {}) =>
              ofRadius$9(diameter / 2, { resolution });

            const Sphere = (...args) => ofRadius$9(...args);

            Sphere.ofApothem = ofApothem$6;
            Sphere.ofRadius = ofRadius$9;
            Sphere.ofDiameter = ofDiameter$8;

            /**
             *
             * # Square (rectangle)
             *
             * Properly speaking what is produced here are rectangles.
             *
             * ::: illustration { "view": { "position": [0, 0, 10] } }
             * ```
             * Square()
             * ```
             * :::
             * ::: illustration
             * ```
             * Square(10)
             * ```
             * :::
             * ::: illustration
             * ```
             * Square(6, 12)
             * ```
             * :::
             * ::: illustration
             * ```
             * Square({ edge: 10 })
             * ```
             * :::
             * ::: illustration
             * ```
             * assemble(Circle(10),
             *          Square({ radius: 10 })
             *            .drop())
             * ```
             * :::
             * ::: illustration
             * ```
             * assemble(Square({ apothem: 10 }),
             *          Circle(10).drop())
             * ```
             * :::
             * ::: illustration
             * ```
             * Square({ diameter: 20 })
             * ```
             * :::
             **/

            const toRadiusFromApothem$1 = (apothem) => apothem / Math.cos(Math.PI / 4);

            const edgeScale$1 = regularPolygonEdgeLengthToRadius(1, 4);
            const unitSquare = () =>
              Shape.fromGeometry(taggedZ0Surface({}, [buildRegularPolygon(4)]))
                .rotateZ(45)
                .scale(edgeScale$1);

            const ofSize$1 = (width = 1, length) =>
              unitSquare().scale([width, length === undefined ? width : length, 1]);
            const ofRadius$a = (radius) =>
              Shape.fromGeometry(taggedZ0Surface({}, [buildRegularPolygon(4)]))
                .rotateZ(45)
                .scale(radius);
            const ofApothem$7 = (apothem) => ofRadius$a(toRadiusFromApothem$1(apothem));
            const ofDiameter$9 = (diameter) => ofRadius$a(diameter / 2);

            const fromCorners$1 = (corner1, corner2) => {
              const [c1x, c1y] = corner1;
              const [c2x, c2y] = corner2;
              const length = c2x - c1x;
              const width = c2y - c1y;
              const center = [(c1x + c2x) / 2, (c1y + c2y) / 2];
              return unitSquare().scale([length, width]).translate(center);
            };

            const Square = (...args) => ofSize$1(...args);

            Square.ofSize = ofSize$1;
            Square.ofRadius = ofRadius$a;
            Square.ofApothem = ofApothem$7;
            Square.ofDiameter = ofDiameter$9;
            Square.fromCorners = fromCorners$1;

            Square.signature = 'Square(edge:number) -> Surface';
            Square.ofApothem.signature = 'Square(apothem:number) -> Surface';
            Square.ofDiameter.signature = 'Square(diameter:number) -> Surface';
            Square.ofRadius.signature = 'Square(radius:number) -> Surface';
            Square.ofSize.signature = 'Square(edge:number) -> Surface';
            Square.fromCorners.signature =
              'Square(corner1:Point, corner2:Point) -> Surface';

            /**
             *
             * # Tetrahedron
             *
             * Generates tetrahedrons.
             *
             * ::: illustration { "view": { "position": [8, 8, 8] } }
             * ```
             * Tetrahedron()
             * ```
             * :::
             * ::: illustration { "view": { "position": [80, 80, 80] } }
             * ```
             * Tetrahedron(10)
             * ```
             * :::
             * ::: illustration { "view": { "position": [60, 60, 60] } }
             * ```
             * Tetrahedron({ radius: 8 })
             * ```
             * :::
             * ::: illustration { "view": { "position": [60, 60, 60] } }
             * ```
             * Tetrahedron({ diameter: 16 })
             * ```
             * :::
             *
             **/

            const unitTetrahedron = () =>
              Shape.fromGeometry(taggedSolid({}, buildRegularTetrahedron({})));

            const ofRadius$b = (radius = 1) => unitTetrahedron().scale(radius);
            const ofDiameter$a = (diameter = 1) =>
              unitTetrahedron().scale(diameter / 2);

            const Tetrahedron = (...args) => ofRadius$b(...args);

            Tetrahedron.ofRadius = ofRadius$b;
            Tetrahedron.ofDiameter = ofDiameter$a;

            const Toolpath = (...points) =>
              Path(...points).setTags(['path/Toolpath']);

            /**
             *
             * # Torus
             *
             * ::: illustration { "view": { "position": [-80, -80, 80] } }
             * ```
             * Torus({ thickness: 5,
             *         radius: 20 })
             * ```
             * :::
             * ::: illustration { "view": { "position": [-80, -80, 80] } }
             * ```
             * Torus({ thickness: 5,
             *         radius: 20,
             *         sides: 4 })
             * ```
             * :::
             * ::: illustration { "view": { "position": [-80, -80, 80] } }
             * ```
             * Torus({ thickness: 5,
             *         radius: 20,
             *         sides: 4,
             *         rotation: 45 })
             * ```
             * :::
             *
             **/

            const Torus = (
              radius = 1,
              height = 1,
              { segments = 32, sides = 32, rotation = 0 } = {}
            ) =>
              Circle(height / 2, { sides })
                .rotateZ(rotation)
                .moveY(radius)
                .Loop(360, { sides: segments })
                .rotateY(90);

            /**
             *
             * # Triangle
             *
             * ::: illustration { "view": { "position": [0, 0, 5] } }
             * ```
             * Triangle()
             * ```
             * :::
             * ::: illustration
             * ```
             * Triangle(20)
             * ```
             * :::
             * ::: illustration
             * ```
             * Triangle({ radius: 10 })
             * ```
             * :::
             * ::: illustration
             * ```
             * assemble(Circle(10),
             *          Triangle({ radius: 10 })
             *            .drop())
             * ```
             * :::
             * ::: illustration
             * ```
             * assemble(Triangle({ apothem: 5 }),
             *          Circle(5).drop())
             * ```
             * :::
             * ::: illustration
             * ```
             * assemble(Triangle({ radius: 10 })
             *            .rotateZ(180),
             *          Triangle({ diameter: 10 })
             *            .drop())
             * ```
             * :::
             **/

            const ofEdge$3 = (edge = 1) => Polygon.ofEdge(edge, { sides: 3 });
            const ofApothem$8 = (apothem = 1) =>
              Polygon.ofApothem(apothem, { sides: 3 });
            const ofRadius$c = (radius = 1) => Polygon.ofRadius(radius, { sides: 3 });
            const ofDiameter$b = (diameter = 1) =>
              Polygon.ofDiameter(diameter, { sides: 3 });

            const Triangle = (...args) => ofEdge$3(...args);

            Triangle.ofEdge = ofEdge$3;
            Triangle.ofApothem = ofApothem$8;
            Triangle.ofRadius = ofRadius$c;
            Triangle.ofDiameter = ofDiameter$b;

            const Union = (first, ...rest) => {
              if (first === undefined) {
                return Empty();
              } else {
                return first.add(...rest);
              }
            };

            const UnionMethod = function (...args) {
              return Union(this, ...args);
            };
            Shape.prototype.Union = UnionMethod;

            const Void = (shape) =>
              Shape.fromGeometry(
                rewriteTags(['compose/non-positive'], [], shape.toGeometry())
              );

            const VoidMethod = function () {
              return Void(this);
            };
            Shape.prototype.Void = VoidMethod;

            /**
             *
             * # Wave
             *
             * These take a function mapping X distance to Y distance.
             *
             * ::: illustration { "view": { "position": [0, 0, 10] } }
             * ```
             * Wave(angle => [[sin(angle) * 100]],
             *      { to: 360 });
             * ```
             * :::
             **/

            const Wave = (
              toPathFromXDistance = (xDistance) => [[0]],
              { from = 0, to = 360, by, resolution } = {}
            ) => {
              if (by === undefined && resolution === undefined) {
                by = 1;
              }
              let path = [null];
              for (const xDistance of numbers((distance) => distance, { from, to, by })) {
                const subpath = toPathFromXDistance(xDistance);
                path = concatenate(path, translate([xDistance, 0, 0], subpath));
              }
              return Shape.fromPath(path);
            };

            function unwrapExports$3 (x) {
            	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
            }

            function createCommonjsModule$4(fn, module) {
            	return module = { exports: {} }, fn(module, module.exports), module.exports;
            }

            var toPoints_1 = createCommonjsModule$4(function (module, exports) {

            Object.defineProperty(exports, "__esModule", {
              value: true
            });

            var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

            function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

            var toPoints = function toPoints(_ref) {
              var type = _ref.type,
                  props = _objectWithoutProperties(_ref, ['type']);

              switch (type) {
                case 'circle':
                  return getPointsFromCircle(props);
                case 'ellipse':
                  return getPointsFromEllipse(props);
                case 'line':
                  return getPointsFromLine(props);
                case 'path':
                  return getPointsFromPath(props);
                case 'polygon':
                  return getPointsFromPolygon(props);
                case 'polyline':
                  return getPointsFromPolyline(props);
                case 'rect':
                  return getPointsFromRect(props);
                case 'g':
                  return getPointsFromG(props);
                default:
                  throw new Error('Not a valid shape type');
              }
            };

            var getPointsFromCircle = function getPointsFromCircle(_ref2) {
              var cx = _ref2.cx,
                  cy = _ref2.cy,
                  r = _ref2.r;

              return [{ x: cx, y: cy - r, moveTo: true }, { x: cx, y: cy + r, curve: { type: 'arc', rx: r, ry: r, sweepFlag: 1 } }, { x: cx, y: cy - r, curve: { type: 'arc', rx: r, ry: r, sweepFlag: 1 } }];
            };

            var getPointsFromEllipse = function getPointsFromEllipse(_ref3) {
              var cx = _ref3.cx,
                  cy = _ref3.cy,
                  rx = _ref3.rx,
                  ry = _ref3.ry;

              return [{ x: cx, y: cy - ry, moveTo: true }, { x: cx, y: cy + ry, curve: { type: 'arc', rx: rx, ry: ry, sweepFlag: 1 } }, { x: cx, y: cy - ry, curve: { type: 'arc', rx: rx, ry: ry, sweepFlag: 1 } }];
            };

            var getPointsFromLine = function getPointsFromLine(_ref4) {
              var x1 = _ref4.x1,
                  x2 = _ref4.x2,
                  y1 = _ref4.y1,
                  y2 = _ref4.y2;

              return [{ x: x1, y: y1, moveTo: true }, { x: x2, y: y2 }];
            };

            var validCommands = /[MmLlHhVvCcSsQqTtAaZz]/g;

            var commandLengths = {
              A: 7,
              C: 6,
              H: 1,
              L: 2,
              M: 2,
              Q: 4,
              S: 4,
              T: 2,
              V: 1,
              Z: 0
            };

            var relativeCommands = ['a', 'c', 'h', 'l', 'm', 'q', 's', 't', 'v'];

            var isRelative = function isRelative(command) {
              return relativeCommands.indexOf(command) !== -1;
            };

            var optionalArcKeys = ['xAxisRotation', 'largeArcFlag', 'sweepFlag'];

            var getCommands = function getCommands(d) {
              return d.match(validCommands);
            };

            var getParams = function getParams(d) {
              return d.split(validCommands).map(function (v) {
                return v.replace(/[0-9]+-/g, function (m) {
                  return m.slice(0, -1) + ' -';
                });
              }).map(function (v) {
                return v.replace(/\.[0-9]+/g, function (m) {
                  return m + ' ';
                });
              }).map(function (v) {
                return v.trim();
              }).filter(function (v) {
                return v.length > 0;
              }).map(function (v) {
                return v.split(/[ ,]+/).map(parseFloat).filter(function (n) {
                  return !isNaN(n);
                });
              });
            };

            var getPointsFromPath = function getPointsFromPath(_ref5) {
              var d = _ref5.d;

              var commands = getCommands(d);
              var params = getParams(d);

              var points = [];

              var moveTo = void 0;

              for (var i = 0, l = commands.length; i < l; i++) {
                var command = commands[i];
                var upperCaseCommand = command.toUpperCase();
                var commandLength = commandLengths[upperCaseCommand];
                var relative = isRelative(command);

                if (commandLength > 0) {
                  var commandParams = params.shift();
                  var iterations = commandParams.length / commandLength;

                  for (var j = 0; j < iterations; j++) {
                    var prevPoint = points[points.length - 1] || { x: 0, y: 0 };

                    switch (upperCaseCommand) {
                      case 'M':
                        var x = (relative ? prevPoint.x : 0) + commandParams.shift();
                        var y = (relative ? prevPoint.y : 0) + commandParams.shift();

                        if (j === 0) {
                          moveTo = { x: x, y: y };
                          points.push({ x: x, y: y, moveTo: true });
                        } else {
                          points.push({ x: x, y: y });
                        }

                        break;

                      case 'L':
                        points.push({
                          x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                          y: (relative ? prevPoint.y : 0) + commandParams.shift()
                        });

                        break;

                      case 'H':
                        points.push({
                          x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                          y: prevPoint.y
                        });

                        break;

                      case 'V':
                        points.push({
                          x: prevPoint.x,
                          y: (relative ? prevPoint.y : 0) + commandParams.shift()
                        });

                        break;

                      case 'A':
                        points.push({
                          curve: {
                            type: 'arc',
                            rx: commandParams.shift(),
                            ry: commandParams.shift(),
                            xAxisRotation: commandParams.shift(),
                            largeArcFlag: commandParams.shift(),
                            sweepFlag: commandParams.shift()
                          },
                          x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                          y: (relative ? prevPoint.y : 0) + commandParams.shift()
                        });

                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                          for (var _iterator = optionalArcKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var k = _step.value;

                            if (points[points.length - 1]['curve'][k] === 0) {
                              delete points[points.length - 1]['curve'][k];
                            }
                          }
                        } catch (err) {
                          _didIteratorError = true;
                          _iteratorError = err;
                        } finally {
                          try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                              _iterator.return();
                            }
                          } finally {
                            if (_didIteratorError) {
                              throw _iteratorError;
                            }
                          }
                        }

                        break;

                      case 'C':
                        points.push({
                          curve: {
                            type: 'cubic',
                            x1: (relative ? prevPoint.x : 0) + commandParams.shift(),
                            y1: (relative ? prevPoint.y : 0) + commandParams.shift(),
                            x2: (relative ? prevPoint.x : 0) + commandParams.shift(),
                            y2: (relative ? prevPoint.y : 0) + commandParams.shift()
                          },
                          x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                          y: (relative ? prevPoint.y : 0) + commandParams.shift()
                        });

                        break;

                      case 'S':
                        var sx2 = (relative ? prevPoint.x : 0) + commandParams.shift();
                        var sy2 = (relative ? prevPoint.y : 0) + commandParams.shift();
                        var sx = (relative ? prevPoint.x : 0) + commandParams.shift();
                        var sy = (relative ? prevPoint.y : 0) + commandParams.shift();

                        var diff = {};

                        var sx1 = void 0;
                        var sy1 = void 0;

                        if (prevPoint.curve && prevPoint.curve.type === 'cubic') {
                          diff.x = Math.abs(prevPoint.x - prevPoint.curve.x2);
                          diff.y = Math.abs(prevPoint.y - prevPoint.curve.y2);
                          sx1 = prevPoint.x < prevPoint.curve.x2 ? prevPoint.x - diff.x : prevPoint.x + diff.x;
                          sy1 = prevPoint.y < prevPoint.curve.y2 ? prevPoint.y - diff.y : prevPoint.y + diff.y;
                        } else {
                          diff.x = Math.abs(sx - sx2);
                          diff.y = Math.abs(sy - sy2);
                          sx1 = prevPoint.x;
                          sy1 = prevPoint.y;
                        }

                        points.push({ curve: { type: 'cubic', x1: sx1, y1: sy1, x2: sx2, y2: sy2 }, x: sx, y: sy });

                        break;

                      case 'Q':
                        points.push({
                          curve: {
                            type: 'quadratic',
                            x1: (relative ? prevPoint.x : 0) + commandParams.shift(),
                            y1: (relative ? prevPoint.y : 0) + commandParams.shift()
                          },
                          x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                          y: (relative ? prevPoint.y : 0) + commandParams.shift()
                        });

                        break;

                      case 'T':
                        var tx = (relative ? prevPoint.x : 0) + commandParams.shift();
                        var ty = (relative ? prevPoint.y : 0) + commandParams.shift();

                        var tx1 = void 0;
                        var ty1 = void 0;

                        if (prevPoint.curve && prevPoint.curve.type === 'quadratic') {
                          var _diff = {
                            x: Math.abs(prevPoint.x - prevPoint.curve.x1),
                            y: Math.abs(prevPoint.y - prevPoint.curve.y1)
                          };

                          tx1 = prevPoint.x < prevPoint.curve.x1 ? prevPoint.x - _diff.x : prevPoint.x + _diff.x;
                          ty1 = prevPoint.y < prevPoint.curve.y1 ? prevPoint.y - _diff.y : prevPoint.y + _diff.y;
                        } else {
                          tx1 = prevPoint.x;
                          ty1 = prevPoint.y;
                        }

                        points.push({ curve: { type: 'quadratic', x1: tx1, y1: ty1 }, x: tx, y: ty });

                        break;
                    }
                  }
                } else {
                  var _prevPoint = points[points.length - 1] || { x: 0, y: 0 };

                  if (_prevPoint.x !== moveTo.x || _prevPoint.y !== moveTo.y) {
                    points.push({ x: moveTo.x, y: moveTo.y });
                  }
                }
              }

              return points;
            };

            var getPointsFromPolygon = function getPointsFromPolygon(_ref6) {
              var points = _ref6.points;

              return getPointsFromPoints({ closed: true, points: points });
            };

            var getPointsFromPolyline = function getPointsFromPolyline(_ref7) {
              var points = _ref7.points;

              return getPointsFromPoints({ closed: false, points: points });
            };

            var getPointsFromPoints = function getPointsFromPoints(_ref8) {
              var closed = _ref8.closed,
                  points = _ref8.points;

              var numbers = points.split(/[\s,]+/).map(function (n) {
                return parseFloat(n);
              });

              var p = numbers.reduce(function (arr, point, i) {
                if (i % 2 === 0) {
                  arr.push({ x: point });
                } else {
                  arr[(i - 1) / 2].y = point;
                }

                return arr;
              }, []);

              if (closed) {
                p.push(_extends({}, p[0]));
              }

              p[0].moveTo = true;

              return p;
            };

            var getPointsFromRect = function getPointsFromRect(_ref9) {
              var height = _ref9.height,
                  rx = _ref9.rx,
                  ry = _ref9.ry,
                  width = _ref9.width,
                  x = _ref9.x,
                  y = _ref9.y;

              if (rx || ry) {
                return getPointsFromRectWithCornerRadius({
                  height: height,
                  rx: rx || ry,
                  ry: ry || rx,
                  width: width,
                  x: x,
                  y: y
                });
              }

              return getPointsFromBasicRect({ height: height, width: width, x: x, y: y });
            };

            var getPointsFromBasicRect = function getPointsFromBasicRect(_ref10) {
              var height = _ref10.height,
                  width = _ref10.width,
                  x = _ref10.x,
                  y = _ref10.y;

              return [{ x: x, y: y, moveTo: true }, { x: x + width, y: y }, { x: x + width, y: y + height }, { x: x, y: y + height }, { x: x, y: y }];
            };

            var getPointsFromRectWithCornerRadius = function getPointsFromRectWithCornerRadius(_ref11) {
              var height = _ref11.height,
                  rx = _ref11.rx,
                  ry = _ref11.ry,
                  width = _ref11.width,
                  x = _ref11.x,
                  y = _ref11.y;

              var curve = { type: 'arc', rx: rx, ry: ry, sweepFlag: 1 };

              return [{ x: x + rx, y: y, moveTo: true }, { x: x + width - rx, y: y }, { x: x + width, y: y + ry, curve: curve }, { x: x + width, y: y + height - ry }, { x: x + width - rx, y: y + height, curve: curve }, { x: x + rx, y: y + height }, { x: x, y: y + height - ry, curve: curve }, { x: x, y: y + ry }, { x: x + rx, y: y, curve: curve }];
            };

            var getPointsFromG = function getPointsFromG(_ref12) {
              var shapes = _ref12.shapes;
              return shapes.map(function (s) {
                return toPoints(s);
              });
            };

            exports.default = toPoints;
            });

            unwrapExports$3(toPoints_1);

            var toPath_1 = createCommonjsModule$4(function (module, exports) {

            Object.defineProperty(exports, "__esModule", {
              value: true
            });



            var _toPoints2 = _interopRequireDefault(toPoints_1);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            var pointsToD = function pointsToD(p) {
              var d = '';
              var i = 0;
              var firstPoint = void 0;

              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = p[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var point = _step.value;
                  var _point$curve = point.curve,
                      curve = _point$curve === undefined ? false : _point$curve,
                      moveTo = point.moveTo,
                      x = point.x,
                      y = point.y;

                  var isFirstPoint = i === 0 || moveTo;
                  var isLastPoint = i === p.length - 1 || p[i + 1].moveTo;
                  var prevPoint = i === 0 ? null : p[i - 1];

                  if (isFirstPoint) {
                    firstPoint = point;

                    if (!isLastPoint) {
                      d += 'M' + x + ',' + y;
                    }
                  } else if (curve) {
                    switch (curve.type) {
                      case 'arc':
                        var _point$curve2 = point.curve,
                            _point$curve2$largeAr = _point$curve2.largeArcFlag,
                            largeArcFlag = _point$curve2$largeAr === undefined ? 0 : _point$curve2$largeAr,
                            rx = _point$curve2.rx,
                            ry = _point$curve2.ry,
                            _point$curve2$sweepFl = _point$curve2.sweepFlag,
                            sweepFlag = _point$curve2$sweepFl === undefined ? 0 : _point$curve2$sweepFl,
                            _point$curve2$xAxisRo = _point$curve2.xAxisRotation,
                            xAxisRotation = _point$curve2$xAxisRo === undefined ? 0 : _point$curve2$xAxisRo;

                        d += 'A' + rx + ',' + ry + ',' + xAxisRotation + ',' + largeArcFlag + ',' + sweepFlag + ',' + x + ',' + y;
                        break;
                      case 'cubic':
                        var _point$curve3 = point.curve,
                            cx1 = _point$curve3.x1,
                            cy1 = _point$curve3.y1,
                            cx2 = _point$curve3.x2,
                            cy2 = _point$curve3.y2;

                        d += 'C' + cx1 + ',' + cy1 + ',' + cx2 + ',' + cy2 + ',' + x + ',' + y;
                        break;
                      case 'quadratic':
                        var _point$curve4 = point.curve,
                            qx1 = _point$curve4.x1,
                            qy1 = _point$curve4.y1;

                        d += 'Q' + qx1 + ',' + qy1 + ',' + x + ',' + y;
                        break;
                    }

                    if (isLastPoint && x === firstPoint.x && y === firstPoint.y) {
                      d += 'Z';
                    }
                  } else if (isLastPoint && x === firstPoint.x && y === firstPoint.y) {
                    d += 'Z';
                  } else if (x !== prevPoint.x && y !== prevPoint.y) {
                    d += 'L' + x + ',' + y;
                  } else if (x !== prevPoint.x) {
                    d += 'H' + x;
                  } else if (y !== prevPoint.y) {
                    d += 'V' + y;
                  }

                  i++;
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }

              return d;
            };

            var toPath = function toPath(s) {
              var isPoints = Array.isArray(s);
              var isGroup = isPoints ? Array.isArray(s[0]) : s.type === 'g';
              var points = isPoints ? s : isGroup ? s.shapes.map(function (shp) {
                return (0, _toPoints2.default)(shp);
              }) : (0, _toPoints2.default)(s);

              if (isGroup) {
                return points.map(function (p) {
                  return pointsToD(p);
                });
              }

              return pointsToD(points);
            };

            exports.default = toPath;
            });

            unwrapExports$3(toPath_1);

            var valid_1 = createCommonjsModule$4(function (module, exports) {

            Object.defineProperty(exports, "__esModule", {
              value: true
            });

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

            var getErrors = function getErrors(shape) {
              var rules = getRules(shape);
              var errors = [];

              rules.map(function (_ref) {
                var match = _ref.match,
                    prop = _ref.prop,
                    required = _ref.required,
                    type = _ref.type;

                if (typeof shape[prop] === 'undefined') {
                  if (required) {
                    errors.push(prop + ' prop is required' + (prop === 'type' ? '' : ' on a ' + shape.type));
                  }
                } else {
                  if (typeof type !== 'undefined') {
                    if (type === 'array') {
                      if (!Array.isArray(shape[prop])) {
                        errors.push(prop + ' prop must be of type array');
                      }
                    } else if (_typeof(shape[prop]) !== type) {
                      // eslint-disable-line valid-typeof
                      errors.push(prop + ' prop must be of type ' + type);
                    }
                  }

                  if (Array.isArray(match)) {
                    if (match.indexOf(shape[prop]) === -1) {
                      errors.push(prop + ' prop must be one of ' + match.join(', '));
                    }
                  }
                }
              });

              if (shape.type === 'g' && Array.isArray(shape.shapes)) {
                var childErrors = shape.shapes.map(function (s) {
                  return getErrors(s);
                });
                return [].concat.apply(errors, childErrors);
              }

              return errors;
            };

            var getRules = function getRules(shape) {
              var rules = [{
                match: ['circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'rect', 'g'],
                prop: 'type',
                required: true,
                type: 'string'
              }];

              switch (shape.type) {
                case 'circle':
                  rules.push({ prop: 'cx', required: true, type: 'number' });
                  rules.push({ prop: 'cy', required: true, type: 'number' });
                  rules.push({ prop: 'r', required: true, type: 'number' });
                  break;

                case 'ellipse':
                  rules.push({ prop: 'cx', required: true, type: 'number' });
                  rules.push({ prop: 'cy', required: true, type: 'number' });
                  rules.push({ prop: 'rx', required: true, type: 'number' });
                  rules.push({ prop: 'ry', required: true, type: 'number' });
                  break;

                case 'line':
                  rules.push({ prop: 'x1', required: true, type: 'number' });
                  rules.push({ prop: 'x2', required: true, type: 'number' });
                  rules.push({ prop: 'y1', required: true, type: 'number' });
                  rules.push({ prop: 'y2', required: true, type: 'number' });
                  break;

                case 'path':
                  rules.push({ prop: 'd', required: true, type: 'string' });
                  break;

                case 'polygon':
                case 'polyline':
                  rules.push({ prop: 'points', required: true, type: 'string' });
                  break;

                case 'rect':
                  rules.push({ prop: 'height', required: true, type: 'number' });
                  rules.push({ prop: 'rx', type: 'number' });
                  rules.push({ prop: 'ry', type: 'number' });
                  rules.push({ prop: 'width', required: true, type: 'number' });
                  rules.push({ prop: 'x', required: true, type: 'number' });
                  rules.push({ prop: 'y', required: true, type: 'number' });
                  break;

                case 'g':
                  rules.push({ prop: 'shapes', required: true, type: 'array' });
                  break;
              }

              return rules;
            };

            var valid = function valid(shape) {
              var errors = getErrors(shape);

              return {
                errors: errors,
                valid: errors.length === 0
              };
            };

            exports.default = valid;
            });

            unwrapExports$3(valid_1);

            var cjs = createCommonjsModule$4(function (module, exports) {

            Object.defineProperty(exports, "__esModule", {
              value: true
            });
            exports.valid = exports.toPoints = exports.toPath = undefined;



            var _toPath2 = _interopRequireDefault(toPath_1);



            var _toPoints2 = _interopRequireDefault(toPoints_1);



            var _valid2 = _interopRequireDefault(valid_1);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            exports.toPath = _toPath2.default;
            exports.toPoints = _toPoints2.default;
            exports.valid = _valid2.default;
            });

            var SvgPoints = unwrapExports$3(cjs);
            var cjs_1 = cjs.valid;
            var cjs_2 = cjs.toPoints;
            var cjs_3 = cjs.toPath;

            //[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
            //[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
            //[5]   	Name	   ::=   	NameStartChar (NameChar)*
            var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;//\u10000-\uEFFFF
            var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
            var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
            //var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
            //var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

            //S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
            //S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
            var S_TAG = 0;//tag name offerring
            var S_ATTR = 1;//attr name offerring 
            var S_ATTR_SPACE=2;//attr name end and space offer
            var S_EQ = 3;//=space?
            var S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)
            var S_ATTR_END = 5;//attr value end and no space(quot end)
            var S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)
            var S_TAG_CLOSE = 7;//closed el<el />

            function XMLReader(){
            	
            }

            XMLReader.prototype = {
            	parse:function(source,defaultNSMap,entityMap){
            		var domBuilder = this.domBuilder;
            		domBuilder.startDocument();
            		_copy(defaultNSMap ,defaultNSMap = {});
            		parse$1(source,defaultNSMap,entityMap,
            				domBuilder,this.errorHandler);
            		domBuilder.endDocument();
            	}
            };
            function parse$1(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
            	function fixedFromCharCode(code) {
            		// String.prototype.fromCharCode does not supports
            		// > 2 bytes unicode chars directly
            		if (code > 0xffff) {
            			code -= 0x10000;
            			var surrogate1 = 0xd800 + (code >> 10)
            				, surrogate2 = 0xdc00 + (code & 0x3ff);

            			return String.fromCharCode(surrogate1, surrogate2);
            		} else {
            			return String.fromCharCode(code);
            		}
            	}
            	function entityReplacer(a){
            		var k = a.slice(1,-1);
            		if(k in entityMap){
            			return entityMap[k]; 
            		}else if(k.charAt(0) === '#'){
            			return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
            		}else {
            			errorHandler.error('entity not found:'+a);
            			return a;
            		}
            	}
            	function appendText(end){//has some bugs
            		if(end>start){
            			var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
            			locator&&position(start);
            			domBuilder.characters(xt,0,end-start);
            			start = end;
            		}
            	}
            	function position(p,m){
            		while(p>=lineEnd && (m = linePattern.exec(source))){
            			lineStart = m.index;
            			lineEnd = lineStart + m[0].length;
            			locator.lineNumber++;
            			//console.log('line++:',locator,startPos,endPos)
            		}
            		locator.columnNumber = p-lineStart+1;
            	}
            	var lineStart = 0;
            	var lineEnd = 0;
            	var linePattern = /.*(?:\r\n?|\n)|.*$/g;
            	var locator = domBuilder.locator;
            	
            	var parseStack = [{currentNSMap:defaultNSMapCopy}];
            	var closeMap = {};
            	var start = 0;
            	while(true){
            		try{
            			var tagStart = source.indexOf('<',start);
            			if(tagStart<0){
            				if(!source.substr(start).match(/^\s*$/)){
            					var doc = domBuilder.doc;
            	    			var text = doc.createTextNode(source.substr(start));
            	    			doc.appendChild(text);
            	    			domBuilder.currentElement = text;
            				}
            				return;
            			}
            			if(tagStart>start){
            				appendText(tagStart);
            			}
            			switch(source.charAt(tagStart+1)){
            			case '/':
            				var end = source.indexOf('>',tagStart+3);
            				var tagName = source.substring(tagStart+2,end);
            				var config = parseStack.pop();
            				if(end<0){
            					
            	        		tagName = source.substring(tagStart+2).replace(/[\s<].*/,'');
            	        		//console.error('#@@@@@@'+tagName)
            	        		errorHandler.error("end tag name: "+tagName+' is not complete:'+config.tagName);
            	        		end = tagStart+1+tagName.length;
            	        	}else if(tagName.match(/\s</)){
            	        		tagName = tagName.replace(/[\s<].*/,'');
            	        		errorHandler.error("end tag name: "+tagName+' maybe not complete');
            	        		end = tagStart+1+tagName.length;
            				}
            				//console.error(parseStack.length,parseStack)
            				//console.error(config);
            				var localNSMap = config.localNSMap;
            				var endMatch = config.tagName == tagName;
            				var endIgnoreCaseMach = endMatch || config.tagName&&config.tagName.toLowerCase() == tagName.toLowerCase();
            		        if(endIgnoreCaseMach){
            		        	domBuilder.endElement(config.uri,config.localName,tagName);
            					if(localNSMap){
            						for(var prefix in localNSMap){
            							domBuilder.endPrefixMapping(prefix) ;
            						}
            					}
            					if(!endMatch){
            		            	errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName );
            					}
            		        }else {
            		        	parseStack.push(config);
            		        }
            				
            				end++;
            				break;
            				// end elment
            			case '?':// <?...?>
            				locator&&position(tagStart);
            				end = parseInstruction(source,tagStart,domBuilder);
            				break;
            			case '!':// <!doctype,<![CDATA,<!--
            				locator&&position(tagStart);
            				end = parseDCC(source,tagStart,domBuilder,errorHandler);
            				break;
            			default:
            				locator&&position(tagStart);
            				var el = new ElementAttributes();
            				var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
            				//elStartEnd
            				var end = parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);
            				var len = el.length;
            				
            				
            				if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
            					el.closed = true;
            					if(!entityMap.nbsp){
            						errorHandler.warning('unclosed xml attribute');
            					}
            				}
            				if(locator && len){
            					var locator2 = copyLocator(locator,{});
            					//try{//attribute position fixed
            					for(var i = 0;i<len;i++){
            						var a = el[i];
            						position(a.offset);
            						a.locator = copyLocator(locator,{});
            					}
            					//}catch(e){console.error('@@@@@'+e)}
            					domBuilder.locator = locator2;
            					if(appendElement(el,domBuilder,currentNSMap)){
            						parseStack.push(el);
            					}
            					domBuilder.locator = locator;
            				}else {
            					if(appendElement(el,domBuilder,currentNSMap)){
            						parseStack.push(el);
            					}
            				}
            				
            				
            				
            				if(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){
            					end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder);
            				}else {
            					end++;
            				}
            			}
            		}catch(e){
            			errorHandler.error('element parse error: '+e);
            			//errorHandler.error('element parse error: '+e);
            			end = -1;
            			//throw e;
            		}
            		if(end>start){
            			start = end;
            		}else {
            			//TODO: 这里有可能sax回退，有位置错误风险
            			appendText(Math.max(tagStart,start)+1);
            		}
            	}
            }
            function copyLocator(f,t){
            	t.lineNumber = f.lineNumber;
            	t.columnNumber = f.columnNumber;
            	return t;
            }

            /**
             * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
             * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
             */
            function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){
            	var attrName;
            	var value;
            	var p = ++start;
            	var s = S_TAG;//status
            	while(true){
            		var c = source.charAt(p);
            		switch(c){
            		case '=':
            			if(s === S_ATTR){//attrName
            				attrName = source.slice(start,p);
            				s = S_EQ;
            			}else if(s === S_ATTR_SPACE){
            				s = S_EQ;
            			}else {
            				//fatalError: equal must after attrName or space after attrName
            				throw new Error('attribute equal must after attrName');
            			}
            			break;
            		case '\'':
            		case '"':
            			if(s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE
            				){//equal
            				if(s === S_ATTR){
            					errorHandler.warning('attribute value must after "="');
            					attrName = source.slice(start,p);
            				}
            				start = p+1;
            				p = source.indexOf(c,start);
            				if(p>0){
            					value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
            					el.add(attrName,value,start-1);
            					s = S_ATTR_END;
            				}else {
            					//fatalError: no end quot match
            					throw new Error('attribute value no end \''+c+'\' match');
            				}
            			}else if(s == S_ATTR_NOQUOT_VALUE){
            				value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
            				//console.log(attrName,value,start,p)
            				el.add(attrName,value,start);
            				//console.dir(el)
            				errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
            				start = p+1;
            				s = S_ATTR_END;
            			}else {
            				//fatalError: no equal before
            				throw new Error('attribute value must after "="');
            			}
            			break;
            		case '/':
            			switch(s){
            			case S_TAG:
            				el.setTagName(source.slice(start,p));
            			case S_ATTR_END:
            			case S_TAG_SPACE:
            			case S_TAG_CLOSE:
            				s =S_TAG_CLOSE;
            				el.closed = true;
            			case S_ATTR_NOQUOT_VALUE:
            			case S_ATTR:
            			case S_ATTR_SPACE:
            				break;
            			//case S_EQ:
            			default:
            				throw new Error("attribute invalid close char('/')")
            			}
            			break;
            		case ''://end document
            			//throw new Error('unexpected end of input')
            			errorHandler.error('unexpected end of input');
            			if(s == S_TAG){
            				el.setTagName(source.slice(start,p));
            			}
            			return p;
            		case '>':
            			switch(s){
            			case S_TAG:
            				el.setTagName(source.slice(start,p));
            			case S_ATTR_END:
            			case S_TAG_SPACE:
            			case S_TAG_CLOSE:
            				break;//normal
            			case S_ATTR_NOQUOT_VALUE://Compatible state
            			case S_ATTR:
            				value = source.slice(start,p);
            				if(value.slice(-1) === '/'){
            					el.closed  = true;
            					value = value.slice(0,-1);
            				}
            			case S_ATTR_SPACE:
            				if(s === S_ATTR_SPACE){
            					value = attrName;
            				}
            				if(s == S_ATTR_NOQUOT_VALUE){
            					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
            					el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start);
            				}else {
            					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !value.match(/^(?:disabled|checked|selected)$/i)){
            						errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!');
            					}
            					el.add(value,value,start);
            				}
            				break;
            			case S_EQ:
            				throw new Error('attribute value missed!!');
            			}
            //			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
            			return p;
            		/*xml space '\x20' | #x9 | #xD | #xA; */
            		case '\u0080':
            			c = ' ';
            		default:
            			if(c<= ' '){//space
            				switch(s){
            				case S_TAG:
            					el.setTagName(source.slice(start,p));//tagName
            					s = S_TAG_SPACE;
            					break;
            				case S_ATTR:
            					attrName = source.slice(start,p);
            					s = S_ATTR_SPACE;
            					break;
            				case S_ATTR_NOQUOT_VALUE:
            					var value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
            					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
            					el.add(attrName,value,start);
            				case S_ATTR_END:
            					s = S_TAG_SPACE;
            					break;
            				//case S_TAG_SPACE:
            				//case S_EQ:
            				//case S_ATTR_SPACE:
            				//	void();break;
            				//case S_TAG_CLOSE:
            					//ignore warning
            				}
            			}else {//not space
            //S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
            //S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
            				switch(s){
            				//case S_TAG:void();break;
            				//case S_ATTR:void();break;
            				//case S_ATTR_NOQUOT_VALUE:void();break;
            				case S_ATTR_SPACE:
            					var tagName =  el.tagName;
            					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !attrName.match(/^(?:disabled|checked|selected)$/i)){
            						errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!');
            					}
            					el.add(attrName,attrName,start);
            					start = p;
            					s = S_ATTR;
            					break;
            				case S_ATTR_END:
            					errorHandler.warning('attribute space is required"'+attrName+'"!!');
            				case S_TAG_SPACE:
            					s = S_ATTR;
            					start = p;
            					break;
            				case S_EQ:
            					s = S_ATTR_NOQUOT_VALUE;
            					start = p;
            					break;
            				case S_TAG_CLOSE:
            					throw new Error("elements closed character '/' and '>' must be connected to");
            				}
            			}
            		}//end outer switch
            		//console.log('p++',p)
            		p++;
            	}
            }
            /**
             * @return true if has new namespace define
             */
            function appendElement(el,domBuilder,currentNSMap){
            	var tagName = el.tagName;
            	var localNSMap = null;
            	//var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
            	var i = el.length;
            	while(i--){
            		var a = el[i];
            		var qName = a.qName;
            		var value = a.value;
            		var nsp = qName.indexOf(':');
            		if(nsp>0){
            			var prefix = a.prefix = qName.slice(0,nsp);
            			var localName = qName.slice(nsp+1);
            			var nsPrefix = prefix === 'xmlns' && localName;
            		}else {
            			localName = qName;
            			prefix = null;
            			nsPrefix = qName === 'xmlns' && '';
            		}
            		//can not set prefix,because prefix !== ''
            		a.localName = localName ;
            		//prefix == null for no ns prefix attribute 
            		if(nsPrefix !== false){//hack!!
            			if(localNSMap == null){
            				localNSMap = {};
            				//console.log(currentNSMap,0)
            				_copy(currentNSMap,currentNSMap={});
            				//console.log(currentNSMap,1)
            			}
            			currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
            			a.uri = 'http://www.w3.org/2000/xmlns/';
            			domBuilder.startPrefixMapping(nsPrefix, value); 
            		}
            	}
            	var i = el.length;
            	while(i--){
            		a = el[i];
            		var prefix = a.prefix;
            		if(prefix){//no prefix attribute has no namespace
            			if(prefix === 'xml'){
            				a.uri = 'http://www.w3.org/XML/1998/namespace';
            			}if(prefix !== 'xmlns'){
            				a.uri = currentNSMap[prefix || ''];
            				
            				//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
            			}
            		}
            	}
            	var nsp = tagName.indexOf(':');
            	if(nsp>0){
            		prefix = el.prefix = tagName.slice(0,nsp);
            		localName = el.localName = tagName.slice(nsp+1);
            	}else {
            		prefix = null;//important!!
            		localName = el.localName = tagName;
            	}
            	//no prefix element has default namespace
            	var ns = el.uri = currentNSMap[prefix || ''];
            	domBuilder.startElement(ns,localName,tagName,el);
            	//endPrefixMapping and startPrefixMapping have not any help for dom builder
            	//localNSMap = null
            	if(el.closed){
            		domBuilder.endElement(ns,localName,tagName);
            		if(localNSMap){
            			for(prefix in localNSMap){
            				domBuilder.endPrefixMapping(prefix); 
            			}
            		}
            	}else {
            		el.currentNSMap = currentNSMap;
            		el.localNSMap = localNSMap;
            		//parseStack.push(el);
            		return true;
            	}
            }
            function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
            	if(/^(?:script|textarea)$/i.test(tagName)){
            		var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
            		var text = source.substring(elStartEnd+1,elEndStart);
            		if(/[&<]/.test(text)){
            			if(/^script$/i.test(tagName)){
            				//if(!/\]\]>/.test(text)){
            					//lexHandler.startCDATA();
            					domBuilder.characters(text,0,text.length);
            					//lexHandler.endCDATA();
            					return elEndStart;
            				//}
            			}//}else{//text area
            				text = text.replace(/&#?\w+;/g,entityReplacer);
            				domBuilder.characters(text,0,text.length);
            				return elEndStart;
            			//}
            			
            		}
            	}
            	return elStartEnd+1;
            }
            function fixSelfClosed(source,elStartEnd,tagName,closeMap){
            	//if(tagName in closeMap){
            	var pos = closeMap[tagName];
            	if(pos == null){
            		//console.log(tagName)
            		pos =  source.lastIndexOf('</'+tagName+'>');
            		if(pos<elStartEnd){//忘记闭合
            			pos = source.lastIndexOf('</'+tagName);
            		}
            		closeMap[tagName] =pos;
            	}
            	return pos<elStartEnd;
            	//} 
            }
            function _copy(source,target){
            	for(var n in source){target[n] = source[n];}
            }
            function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
            	var next= source.charAt(start+2);
            	switch(next){
            	case '-':
            		if(source.charAt(start + 3) === '-'){
            			var end = source.indexOf('-->',start+4);
            			//append comment source.substring(4,end)//<!--
            			if(end>start){
            				domBuilder.comment(source,start+4,end-start-4);
            				return end+3;
            			}else {
            				errorHandler.error("Unclosed comment");
            				return -1;
            			}
            		}else {
            			//error
            			return -1;
            		}
            	default:
            		if(source.substr(start+3,6) == 'CDATA['){
            			var end = source.indexOf(']]>',start+9);
            			domBuilder.startCDATA();
            			domBuilder.characters(source,start+9,end-start-9);
            			domBuilder.endCDATA(); 
            			return end+3;
            		}
            		//<!DOCTYPE
            		//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) 
            		var matchs = split$1(source,start);
            		var len = matchs.length;
            		if(len>1 && /!doctype/i.test(matchs[0][0])){
            			var name = matchs[1][0];
            			var pubid = len>3 && /^public$/i.test(matchs[2][0]) && matchs[3][0];
            			var sysid = len>4 && matchs[4][0];
            			var lastMatch = matchs[len-1];
            			domBuilder.startDTD(name,pubid && pubid.replace(/^(['"])(.*?)\1$/,'$2'),
            					sysid && sysid.replace(/^(['"])(.*?)\1$/,'$2'));
            			domBuilder.endDTD();
            			
            			return lastMatch.index+lastMatch[0].length
            		}
            	}
            	return -1;
            }



            function parseInstruction(source,start,domBuilder){
            	var end = source.indexOf('?>',start);
            	if(end){
            		var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
            		if(match){
            			var len = match[0].length;
            			domBuilder.processingInstruction(match[1], match[2]) ;
            			return end+2;
            		}else {//error
            			return -1;
            		}
            	}
            	return -1;
            }

            /**
             * @param source
             */
            function ElementAttributes(source){
            	
            }
            ElementAttributes.prototype = {
            	setTagName:function(tagName){
            		if(!tagNamePattern.test(tagName)){
            			throw new Error('invalid tagName:'+tagName)
            		}
            		this.tagName = tagName;
            	},
            	add:function(qName,value,offset){
            		if(!tagNamePattern.test(qName)){
            			throw new Error('invalid attribute:'+qName)
            		}
            		this[this.length++] = {qName:qName,value:value,offset:offset};
            	},
            	length:0,
            	getLocalName:function(i){return this[i].localName},
            	getLocator:function(i){return this[i].locator},
            	getQName:function(i){return this[i].qName},
            	getURI:function(i){return this[i].uri},
            	getValue:function(i){return this[i].value}
            //	,getIndex:function(uri, localName)){
            //		if(localName){
            //			
            //		}else{
            //			var qName = uri
            //		}
            //	},
            //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
            //	getType:function(uri,localName){}
            //	getType:function(i){},
            };




            function _set_proto_(thiz,parent){
            	thiz.__proto__ = parent;
            	return thiz;
            }
            if(!(_set_proto_({},_set_proto_.prototype) instanceof _set_proto_)){
            	_set_proto_ = function(thiz,parent){
            		function p(){}		p.prototype = parent;
            		p = new p();
            		for(parent in thiz){
            			p[parent] = thiz[parent];
            		}
            		return p;
            	};
            }

            function split$1(source,start){
            	var match;
            	var buf = [];
            	var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
            	reg.lastIndex = start;
            	reg.exec(source);//skip <
            	while(match = reg.exec(source)){
            		buf.push(match);
            		if(match[1])return buf;
            	}
            }

            var XMLReader_1 = XMLReader;

            var sax = {
            	XMLReader: XMLReader_1
            };

            /*
             * DOM Level 2
             * Object DOMException
             * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
             * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
             */

            function copy$1(src,dest){
            	for(var p in src){
            		dest[p] = src[p];
            	}
            }
            /**
            ^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
            ^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
             */
            function _extends(Class,Super){
            	var pt = Class.prototype;
            	if(Object.create){
            		var ppt = Object.create(Super.prototype);
            		pt.__proto__ = ppt;
            	}
            	if(!(pt instanceof Super)){
            		function t(){}		t.prototype = Super.prototype;
            		t = new t();
            		copy$1(pt,t);
            		Class.prototype = pt = t;
            	}
            	if(pt.constructor != Class){
            		if(typeof Class != 'function'){
            			console.error("unknow Class:"+Class);
            		}
            		pt.constructor = Class;
            	}
            }
            var htmlns = 'http://www.w3.org/1999/xhtml' ;
            // Node Types
            var NodeType = {};
            var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
            var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
            var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
            var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
            var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
            var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
            var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
            var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
            var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
            var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
            var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
            var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

            // ExceptionCode
            var ExceptionCode = {};
            var ExceptionMessage = {};
            var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
            var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
            var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
            var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
            var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
            var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
            var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
            var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
            var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
            var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
            //level2
            var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
            var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
            var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
            var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
            var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);


            function DOMException(code, message) {
            	if(message instanceof Error){
            		var error = message;
            	}else {
            		error = this;
            		Error.call(this, ExceptionMessage[code]);
            		this.message = ExceptionMessage[code];
            		if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
            	}
            	error.code = code;
            	if(message) this.message = this.message + ": " + message;
            	return error;
            }DOMException.prototype = Error.prototype;
            copy$1(ExceptionCode,DOMException);
            /**
             * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
             * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
             * The items in the NodeList are accessible via an integral index, starting from 0.
             */
            function NodeList() {
            }NodeList.prototype = {
            	/**
            	 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
            	 * @standard level1
            	 */
            	length:0, 
            	/**
            	 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
            	 * @standard level1
            	 * @param index  unsigned long 
            	 *   Index into the collection.
            	 * @return Node
            	 * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
            	 */
            	item: function(index) {
            		return this[index] || null;
            	},
            	toString:function(isHTML,nodeFilter){
            		for(var buf = [], i = 0;i<this.length;i++){
            			serializeToString(this[i],buf,isHTML,nodeFilter);
            		}
            		return buf.join('');
            	}
            };
            function LiveNodeList(node,refresh){
            	this._node = node;
            	this._refresh = refresh;
            	_updateLiveList(this);
            }
            function _updateLiveList(list){
            	var inc = list._node._inc || list._node.ownerDocument._inc;
            	if(list._inc != inc){
            		var ls = list._refresh(list._node);
            		//console.log(ls.length)
            		__set__(list,'length',ls.length);
            		copy$1(ls,list);
            		list._inc = inc;
            	}
            }
            LiveNodeList.prototype.item = function(i){
            	_updateLiveList(this);
            	return this[i];
            };

            _extends(LiveNodeList,NodeList);
            /**
             * 
             * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
             * NamedNodeMap objects in the DOM are live.
             * used for attributes or DocumentType entities 
             */
            function NamedNodeMap() {
            }
            function _findNodeIndex(list,node){
            	var i = list.length;
            	while(i--){
            		if(list[i] === node){return i}
            	}
            }

            function _addNamedNode(el,list,newAttr,oldAttr){
            	if(oldAttr){
            		list[_findNodeIndex(list,oldAttr)] = newAttr;
            	}else {
            		list[list.length++] = newAttr;
            	}
            	if(el){
            		newAttr.ownerElement = el;
            		var doc = el.ownerDocument;
            		if(doc){
            			oldAttr && _onRemoveAttribute(doc,el,oldAttr);
            			_onAddAttribute(doc,el,newAttr);
            		}
            	}
            }
            function _removeNamedNode(el,list,attr){
            	//console.log('remove attr:'+attr)
            	var i = _findNodeIndex(list,attr);
            	if(i>=0){
            		var lastIndex = list.length-1;
            		while(i<lastIndex){
            			list[i] = list[++i];
            		}
            		list.length = lastIndex;
            		if(el){
            			var doc = el.ownerDocument;
            			if(doc){
            				_onRemoveAttribute(doc,el,attr);
            				attr.ownerElement = null;
            			}
            		}
            	}else {
            		throw DOMException(NOT_FOUND_ERR,new Error(el.tagName+'@'+attr))
            	}
            }
            NamedNodeMap.prototype = {
            	length:0,
            	item:NodeList.prototype.item,
            	getNamedItem: function(key) {
            //		if(key.indexOf(':')>0 || key == 'xmlns'){
            //			return null;
            //		}
            		//console.log()
            		var i = this.length;
            		while(i--){
            			var attr = this[i];
            			//console.log(attr.nodeName,key)
            			if(attr.nodeName == key){
            				return attr;
            			}
            		}
            	},
            	setNamedItem: function(attr) {
            		var el = attr.ownerElement;
            		if(el && el!=this._ownerElement){
            			throw new DOMException(INUSE_ATTRIBUTE_ERR);
            		}
            		var oldAttr = this.getNamedItem(attr.nodeName);
            		_addNamedNode(this._ownerElement,this,attr,oldAttr);
            		return oldAttr;
            	},
            	/* returns Node */
            	setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
            		var el = attr.ownerElement, oldAttr;
            		if(el && el!=this._ownerElement){
            			throw new DOMException(INUSE_ATTRIBUTE_ERR);
            		}
            		oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
            		_addNamedNode(this._ownerElement,this,attr,oldAttr);
            		return oldAttr;
            	},

            	/* returns Node */
            	removeNamedItem: function(key) {
            		var attr = this.getNamedItem(key);
            		_removeNamedNode(this._ownerElement,this,attr);
            		return attr;
            		
            		
            	},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
            	
            	//for level2
            	removeNamedItemNS:function(namespaceURI,localName){
            		var attr = this.getNamedItemNS(namespaceURI,localName);
            		_removeNamedNode(this._ownerElement,this,attr);
            		return attr;
            	},
            	getNamedItemNS: function(namespaceURI, localName) {
            		var i = this.length;
            		while(i--){
            			var node = this[i];
            			if(node.localName == localName && node.namespaceURI == namespaceURI){
            				return node;
            			}
            		}
            		return null;
            	}
            };
            /**
             * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
             */
            function DOMImplementation(/* Object */ features) {
            	this._features = {};
            	if (features) {
            		for (var feature in features) {
            			 this._features = features[feature];
            		}
            	}
            }
            DOMImplementation.prototype = {
            	hasFeature: function(/* string */ feature, /* string */ version) {
            		var versions = this._features[feature.toLowerCase()];
            		if (versions && (!version || version in versions)) {
            			return true;
            		} else {
            			return false;
            		}
            	},
            	// Introduced in DOM Level 2:
            	createDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
            		var doc = new Document();
            		doc.implementation = this;
            		doc.childNodes = new NodeList();
            		doc.doctype = doctype;
            		if(doctype){
            			doc.appendChild(doctype);
            		}
            		if(qualifiedName){
            			var root = doc.createElementNS(namespaceURI,qualifiedName);
            			doc.appendChild(root);
            		}
            		return doc;
            	},
            	// Introduced in DOM Level 2:
            	createDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
            		var node = new DocumentType();
            		node.name = qualifiedName;
            		node.nodeName = qualifiedName;
            		node.publicId = publicId;
            		node.systemId = systemId;
            		// Introduced in DOM Level 2:
            		//readonly attribute DOMString        internalSubset;
            		
            		//TODO:..
            		//  readonly attribute NamedNodeMap     entities;
            		//  readonly attribute NamedNodeMap     notations;
            		return node;
            	}
            };


            /**
             * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
             */

            function Node$2() {
            }
            Node$2.prototype = {
            	firstChild : null,
            	lastChild : null,
            	previousSibling : null,
            	nextSibling : null,
            	attributes : null,
            	parentNode : null,
            	childNodes : null,
            	ownerDocument : null,
            	nodeValue : null,
            	namespaceURI : null,
            	prefix : null,
            	localName : null,
            	// Modified in DOM Level 2:
            	insertBefore:function(newChild, refChild){//raises 
            		return _insertBefore(this,newChild,refChild);
            	},
            	replaceChild:function(newChild, oldChild){//raises 
            		this.insertBefore(newChild,oldChild);
            		if(oldChild){
            			this.removeChild(oldChild);
            		}
            	},
            	removeChild:function(oldChild){
            		return _removeChild(this,oldChild);
            	},
            	appendChild:function(newChild){
            		return this.insertBefore(newChild,null);
            	},
            	hasChildNodes:function(){
            		return this.firstChild != null;
            	},
            	cloneNode:function(deep){
            		return cloneNode(this.ownerDocument||this,this,deep);
            	},
            	// Modified in DOM Level 2:
            	normalize:function(){
            		var child = this.firstChild;
            		while(child){
            			var next = child.nextSibling;
            			if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
            				this.removeChild(next);
            				child.appendData(next.data);
            			}else {
            				child.normalize();
            				child = next;
            			}
            		}
            	},
              	// Introduced in DOM Level 2:
            	isSupported:function(feature, version){
            		return this.ownerDocument.implementation.hasFeature(feature,version);
            	},
                // Introduced in DOM Level 2:
                hasAttributes:function(){
                	return this.attributes.length>0;
                },
                lookupPrefix:function(namespaceURI){
                	var el = this;
                	while(el){
                		var map = el._nsMap;
                		//console.dir(map)
                		if(map){
                			for(var n in map){
                				if(map[n] == namespaceURI){
                					return n;
                				}
                			}
                		}
                		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
                	}
                	return null;
                },
                // Introduced in DOM Level 3:
                lookupNamespaceURI:function(prefix){
                	var el = this;
                	while(el){
                		var map = el._nsMap;
                		//console.dir(map)
                		if(map){
                			if(prefix in map){
                				return map[prefix] ;
                			}
                		}
                		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
                	}
                	return null;
                },
                // Introduced in DOM Level 3:
                isDefaultNamespace:function(namespaceURI){
                	var prefix = this.lookupPrefix(namespaceURI);
                	return prefix == null;
                }
            };


            function _xmlEncoder(c){
            	return c == '<' && '&lt;' ||
                     c == '>' && '&gt;' ||
                     c == '&' && '&amp;' ||
                     c == '"' && '&quot;' ||
                     '&#'+c.charCodeAt()+';'
            }


            copy$1(NodeType,Node$2);
            copy$1(NodeType,Node$2.prototype);

            /**
             * @param callback return true for continue,false for break
             * @return boolean true: break visit;
             */
            function _visitNode(node,callback){
            	if(callback(node)){
            		return true;
            	}
            	if(node = node.firstChild){
            		do{
            			if(_visitNode(node,callback)){return true}
                    }while(node=node.nextSibling)
                }
            }



            function Document(){
            }
            function _onAddAttribute(doc,el,newAttr){
            	doc && doc._inc++;
            	var ns = newAttr.namespaceURI ;
            	if(ns == 'http://www.w3.org/2000/xmlns/'){
            		//update namespace
            		el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value;
            	}
            }
            function _onRemoveAttribute(doc,el,newAttr,remove){
            	doc && doc._inc++;
            	var ns = newAttr.namespaceURI ;
            	if(ns == 'http://www.w3.org/2000/xmlns/'){
            		//update namespace
            		delete el._nsMap[newAttr.prefix?newAttr.localName:''];
            	}
            }
            function _onUpdateChild(doc,el,newChild){
            	if(doc && doc._inc){
            		doc._inc++;
            		//update childNodes
            		var cs = el.childNodes;
            		if(newChild){
            			cs[cs.length++] = newChild;
            		}else {
            			//console.log(1)
            			var child = el.firstChild;
            			var i = 0;
            			while(child){
            				cs[i++] = child;
            				child =child.nextSibling;
            			}
            			cs.length = i;
            		}
            	}
            }

            /**
             * attributes;
             * children;
             * 
             * writeable properties:
             * nodeValue,Attr:value,CharacterData:data
             * prefix
             */
            function _removeChild(parentNode,child){
            	var previous = child.previousSibling;
            	var next = child.nextSibling;
            	if(previous){
            		previous.nextSibling = next;
            	}else {
            		parentNode.firstChild = next;
            	}
            	if(next){
            		next.previousSibling = previous;
            	}else {
            		parentNode.lastChild = previous;
            	}
            	_onUpdateChild(parentNode.ownerDocument,parentNode);
            	return child;
            }
            /**
             * preformance key(refChild == null)
             */
            function _insertBefore(parentNode,newChild,nextChild){
            	var cp = newChild.parentNode;
            	if(cp){
            		cp.removeChild(newChild);//remove and update
            	}
            	if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
            		var newFirst = newChild.firstChild;
            		if (newFirst == null) {
            			return newChild;
            		}
            		var newLast = newChild.lastChild;
            	}else {
            		newFirst = newLast = newChild;
            	}
            	var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

            	newFirst.previousSibling = pre;
            	newLast.nextSibling = nextChild;
            	
            	
            	if(pre){
            		pre.nextSibling = newFirst;
            	}else {
            		parentNode.firstChild = newFirst;
            	}
            	if(nextChild == null){
            		parentNode.lastChild = newLast;
            	}else {
            		nextChild.previousSibling = newLast;
            	}
            	do{
            		newFirst.parentNode = parentNode;
            	}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
            	_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);
            	//console.log(parentNode.lastChild.nextSibling == null)
            	if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
            		newChild.firstChild = newChild.lastChild = null;
            	}
            	return newChild;
            }
            function _appendSingleChild(parentNode,newChild){
            	var cp = newChild.parentNode;
            	if(cp){
            		var pre = parentNode.lastChild;
            		cp.removeChild(newChild);//remove and update
            		var pre = parentNode.lastChild;
            	}
            	var pre = parentNode.lastChild;
            	newChild.parentNode = parentNode;
            	newChild.previousSibling = pre;
            	newChild.nextSibling = null;
            	if(pre){
            		pre.nextSibling = newChild;
            	}else {
            		parentNode.firstChild = newChild;
            	}
            	parentNode.lastChild = newChild;
            	_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);
            	return newChild;
            	//console.log("__aa",parentNode.lastChild.nextSibling == null)
            }
            Document.prototype = {
            	//implementation : null,
            	nodeName :  '#document',
            	nodeType :  DOCUMENT_NODE,
            	doctype :  null,
            	documentElement :  null,
            	_inc : 1,
            	
            	insertBefore :  function(newChild, refChild){//raises 
            		if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
            			var child = newChild.firstChild;
            			while(child){
            				var next = child.nextSibling;
            				this.insertBefore(child,refChild);
            				child = next;
            			}
            			return newChild;
            		}
            		if(this.documentElement == null && newChild.nodeType == ELEMENT_NODE){
            			this.documentElement = newChild;
            		}
            		
            		return _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;
            	},
            	removeChild :  function(oldChild){
            		if(this.documentElement == oldChild){
            			this.documentElement = null;
            		}
            		return _removeChild(this,oldChild);
            	},
            	// Introduced in DOM Level 2:
            	importNode : function(importedNode,deep){
            		return importNode(this,importedNode,deep);
            	},
            	// Introduced in DOM Level 2:
            	getElementById :	function(id){
            		var rtv = null;
            		_visitNode(this.documentElement,function(node){
            			if(node.nodeType == ELEMENT_NODE){
            				if(node.getAttribute('id') == id){
            					rtv = node;
            					return true;
            				}
            			}
            		});
            		return rtv;
            	},
            	
            	//document factory method:
            	createElement :	function(tagName){
            		var node = new Element();
            		node.ownerDocument = this;
            		node.nodeName = tagName;
            		node.tagName = tagName;
            		node.childNodes = new NodeList();
            		var attrs	= node.attributes = new NamedNodeMap();
            		attrs._ownerElement = node;
            		return node;
            	},
            	createDocumentFragment :	function(){
            		var node = new DocumentFragment();
            		node.ownerDocument = this;
            		node.childNodes = new NodeList();
            		return node;
            	},
            	createTextNode :	function(data){
            		var node = new Text();
            		node.ownerDocument = this;
            		node.appendData(data);
            		return node;
            	},
            	createComment :	function(data){
            		var node = new Comment();
            		node.ownerDocument = this;
            		node.appendData(data);
            		return node;
            	},
            	createCDATASection :	function(data){
            		var node = new CDATASection();
            		node.ownerDocument = this;
            		node.appendData(data);
            		return node;
            	},
            	createProcessingInstruction :	function(target,data){
            		var node = new ProcessingInstruction();
            		node.ownerDocument = this;
            		node.tagName = node.target = target;
            		node.nodeValue= node.data = data;
            		return node;
            	},
            	createAttribute :	function(name){
            		var node = new Attr();
            		node.ownerDocument	= this;
            		node.name = name;
            		node.nodeName	= name;
            		node.localName = name;
            		node.specified = true;
            		return node;
            	},
            	createEntityReference :	function(name){
            		var node = new EntityReference();
            		node.ownerDocument	= this;
            		node.nodeName	= name;
            		return node;
            	},
            	// Introduced in DOM Level 2:
            	createElementNS :	function(namespaceURI,qualifiedName){
            		var node = new Element();
            		var pl = qualifiedName.split(':');
            		var attrs	= node.attributes = new NamedNodeMap();
            		node.childNodes = new NodeList();
            		node.ownerDocument = this;
            		node.nodeName = qualifiedName;
            		node.tagName = qualifiedName;
            		node.namespaceURI = namespaceURI;
            		if(pl.length == 2){
            			node.prefix = pl[0];
            			node.localName = pl[1];
            		}else {
            			//el.prefix = null;
            			node.localName = qualifiedName;
            		}
            		attrs._ownerElement = node;
            		return node;
            	},
            	// Introduced in DOM Level 2:
            	createAttributeNS :	function(namespaceURI,qualifiedName){
            		var node = new Attr();
            		var pl = qualifiedName.split(':');
            		node.ownerDocument = this;
            		node.nodeName = qualifiedName;
            		node.name = qualifiedName;
            		node.namespaceURI = namespaceURI;
            		node.specified = true;
            		if(pl.length == 2){
            			node.prefix = pl[0];
            			node.localName = pl[1];
            		}else {
            			//el.prefix = null;
            			node.localName = qualifiedName;
            		}
            		return node;
            	}
            };
            _extends(Document,Node$2);


            function Element() {
            	this._nsMap = {};
            }Element.prototype = {
            	nodeType : ELEMENT_NODE,
            	hasAttribute : function(name){
            		return this.getAttributeNode(name)!=null;
            	},
            	getAttribute : function(name){
            		var attr = this.getAttributeNode(name);
            		return attr && attr.value || '';
            	},
            	getAttributeNode : function(name){
            		return this.attributes.getNamedItem(name);
            	},
            	setAttribute : function(name, value){
            		var attr = this.ownerDocument.createAttribute(name);
            		attr.value = attr.nodeValue = "" + value;
            		this.setAttributeNode(attr);
            	},
            	removeAttribute : function(name){
            		var attr = this.getAttributeNode(name);
            		attr && this.removeAttributeNode(attr);
            	},
            	
            	//four real opeartion method
            	appendChild:function(newChild){
            		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
            			return this.insertBefore(newChild,null);
            		}else {
            			return _appendSingleChild(this,newChild);
            		}
            	},
            	setAttributeNode : function(newAttr){
            		return this.attributes.setNamedItem(newAttr);
            	},
            	setAttributeNodeNS : function(newAttr){
            		return this.attributes.setNamedItemNS(newAttr);
            	},
            	removeAttributeNode : function(oldAttr){
            		//console.log(this == oldAttr.ownerElement)
            		return this.attributes.removeNamedItem(oldAttr.nodeName);
            	},
            	//get real attribute name,and remove it by removeAttributeNode
            	removeAttributeNS : function(namespaceURI, localName){
            		var old = this.getAttributeNodeNS(namespaceURI, localName);
            		old && this.removeAttributeNode(old);
            	},
            	
            	hasAttributeNS : function(namespaceURI, localName){
            		return this.getAttributeNodeNS(namespaceURI, localName)!=null;
            	},
            	getAttributeNS : function(namespaceURI, localName){
            		var attr = this.getAttributeNodeNS(namespaceURI, localName);
            		return attr && attr.value || '';
            	},
            	setAttributeNS : function(namespaceURI, qualifiedName, value){
            		var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
            		attr.value = attr.nodeValue = "" + value;
            		this.setAttributeNode(attr);
            	},
            	getAttributeNodeNS : function(namespaceURI, localName){
            		return this.attributes.getNamedItemNS(namespaceURI, localName);
            	},
            	
            	getElementsByTagName : function(tagName){
            		return new LiveNodeList(this,function(base){
            			var ls = [];
            			_visitNode(base,function(node){
            				if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
            					ls.push(node);
            				}
            			});
            			return ls;
            		});
            	},
            	getElementsByTagNameNS : function(namespaceURI, localName){
            		return new LiveNodeList(this,function(base){
            			var ls = [];
            			_visitNode(base,function(node){
            				if(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){
            					ls.push(node);
            				}
            			});
            			return ls;
            			
            		});
            	}
            };
            Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
            Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


            _extends(Element,Node$2);
            function Attr() {
            }Attr.prototype.nodeType = ATTRIBUTE_NODE;
            _extends(Attr,Node$2);


            function CharacterData() {
            }CharacterData.prototype = {
            	data : '',
            	substringData : function(offset, count) {
            		return this.data.substring(offset, offset+count);
            	},
            	appendData: function(text) {
            		text = this.data+text;
            		this.nodeValue = this.data = text;
            		this.length = text.length;
            	},
            	insertData: function(offset,text) {
            		this.replaceData(offset,0,text);
            	
            	},
            	appendChild:function(newChild){
            		throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])
            	},
            	deleteData: function(offset, count) {
            		this.replaceData(offset,count,"");
            	},
            	replaceData: function(offset, count, text) {
            		var start = this.data.substring(0,offset);
            		var end = this.data.substring(offset+count);
            		text = start + text + end;
            		this.nodeValue = this.data = text;
            		this.length = text.length;
            	}
            };
            _extends(CharacterData,Node$2);
            function Text() {
            }Text.prototype = {
            	nodeName : "#text",
            	nodeType : TEXT_NODE,
            	splitText : function(offset) {
            		var text = this.data;
            		var newText = text.substring(offset);
            		text = text.substring(0, offset);
            		this.data = this.nodeValue = text;
            		this.length = text.length;
            		var newNode = this.ownerDocument.createTextNode(newText);
            		if(this.parentNode){
            			this.parentNode.insertBefore(newNode, this.nextSibling);
            		}
            		return newNode;
            	}
            };
            _extends(Text,CharacterData);
            function Comment() {
            }Comment.prototype = {
            	nodeName : "#comment",
            	nodeType : COMMENT_NODE
            };
            _extends(Comment,CharacterData);

            function CDATASection() {
            }CDATASection.prototype = {
            	nodeName : "#cdata-section",
            	nodeType : CDATA_SECTION_NODE
            };
            _extends(CDATASection,CharacterData);


            function DocumentType() {
            }DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
            _extends(DocumentType,Node$2);

            function Notation() {
            }Notation.prototype.nodeType = NOTATION_NODE;
            _extends(Notation,Node$2);

            function Entity() {
            }Entity.prototype.nodeType = ENTITY_NODE;
            _extends(Entity,Node$2);

            function EntityReference() {
            }EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
            _extends(EntityReference,Node$2);

            function DocumentFragment() {
            }DocumentFragment.prototype.nodeName =	"#document-fragment";
            DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
            _extends(DocumentFragment,Node$2);


            function ProcessingInstruction() {
            }
            ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
            _extends(ProcessingInstruction,Node$2);
            function XMLSerializer(){}
            XMLSerializer.prototype.serializeToString = function(node,isHtml,nodeFilter){
            	return nodeSerializeToString.call(node,isHtml,nodeFilter);
            };
            Node$2.prototype.toString = nodeSerializeToString;
            function nodeSerializeToString(isHtml,nodeFilter){
            	var buf = [];
            	var refNode = this.nodeType == 9?this.documentElement:this;
            	var prefix = refNode.prefix;
            	var uri = refNode.namespaceURI;
            	
            	if(uri && prefix == null){
            		//console.log(prefix)
            		var prefix = refNode.lookupPrefix(uri);
            		if(prefix == null){
            			//isHTML = true;
            			var visibleNamespaces=[
            			{namespace:uri,prefix:null}
            			//{namespace:uri,prefix:''}
            			];
            		}
            	}
            	serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);
            	//console.log('###',this.nodeType,uri,prefix,buf.join(''))
            	return buf.join('');
            }
            function needNamespaceDefine(node,isHTML, visibleNamespaces) {
            	var prefix = node.prefix||'';
            	var uri = node.namespaceURI;
            	if (!prefix && !uri){
            		return false;
            	}
            	if (prefix === "xml" && uri === "http://www.w3.org/XML/1998/namespace" 
            		|| uri == 'http://www.w3.org/2000/xmlns/'){
            		return false;
            	}
            	
            	var i = visibleNamespaces.length; 
            	//console.log('@@@@',node.tagName,prefix,uri,visibleNamespaces)
            	while (i--) {
            		var ns = visibleNamespaces[i];
            		// get namespace prefix
            		//console.log(node.nodeType,node.tagName,ns.prefix,prefix)
            		if (ns.prefix == prefix){
            			return ns.namespace != uri;
            		}
            	}
            	//console.log(isHTML,uri,prefix=='')
            	//if(isHTML && prefix ==null && uri == 'http://www.w3.org/1999/xhtml'){
            	//	return false;
            	//}
            	//node.flag = '11111'
            	//console.error(3,true,node.flag,node.prefix,node.namespaceURI)
            	return true;
            }
            function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){
            	if(nodeFilter){
            		node = nodeFilter(node);
            		if(node){
            			if(typeof node == 'string'){
            				buf.push(node);
            				return;
            			}
            		}else {
            			return;
            		}
            		//buf.sort.apply(attrs, attributeSorter);
            	}
            	switch(node.nodeType){
            	case ELEMENT_NODE:
            		if (!visibleNamespaces) visibleNamespaces = [];
            		var startVisibleNamespaces = visibleNamespaces.length;
            		var attrs = node.attributes;
            		var len = attrs.length;
            		var child = node.firstChild;
            		var nodeName = node.tagName;
            		
            		isHTML =  (htmlns === node.namespaceURI) ||isHTML; 
            		buf.push('<',nodeName);
            		
            		
            		
            		for(var i=0;i<len;i++){
            			// add namespaces for attributes
            			var attr = attrs.item(i);
            			if (attr.prefix == 'xmlns') {
            				visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
            			}else if(attr.nodeName == 'xmlns'){
            				visibleNamespaces.push({ prefix: '', namespace: attr.value });
            			}
            		}
            		for(var i=0;i<len;i++){
            			var attr = attrs.item(i);
            			if (needNamespaceDefine(attr,isHTML, visibleNamespaces)) {
            				var prefix = attr.prefix||'';
            				var uri = attr.namespaceURI;
            				var ns = prefix ? ' xmlns:' + prefix : " xmlns";
            				buf.push(ns, '="' , uri , '"');
            				visibleNamespaces.push({ prefix: prefix, namespace:uri });
            			}
            			serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces);
            		}
            		// add namespace for current node		
            		if (needNamespaceDefine(node,isHTML, visibleNamespaces)) {
            			var prefix = node.prefix||'';
            			var uri = node.namespaceURI;
            			var ns = prefix ? ' xmlns:' + prefix : " xmlns";
            			buf.push(ns, '="' , uri , '"');
            			visibleNamespaces.push({ prefix: prefix, namespace:uri });
            		}
            		
            		if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
            			buf.push('>');
            			//if is cdata child node
            			if(isHTML && /^script$/i.test(nodeName)){
            				while(child){
            					if(child.data){
            						buf.push(child.data);
            					}else {
            						serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
            					}
            					child = child.nextSibling;
            				}
            			}else
            			{
            				while(child){
            					serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
            					child = child.nextSibling;
            				}
            			}
            			buf.push('</',nodeName,'>');
            		}else {
            			buf.push('/>');
            		}
            		// remove added visible namespaces
            		//visibleNamespaces.length = startVisibleNamespaces;
            		return;
            	case DOCUMENT_NODE:
            	case DOCUMENT_FRAGMENT_NODE:
            		var child = node.firstChild;
            		while(child){
            			serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
            			child = child.nextSibling;
            		}
            		return;
            	case ATTRIBUTE_NODE:
            		return buf.push(' ',node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');
            	case TEXT_NODE:
            		return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));
            	case CDATA_SECTION_NODE:
            		return buf.push( '<![CDATA[',node.data,']]>');
            	case COMMENT_NODE:
            		return buf.push( "<!--",node.data,"-->");
            	case DOCUMENT_TYPE_NODE:
            		var pubid = node.publicId;
            		var sysid = node.systemId;
            		buf.push('<!DOCTYPE ',node.name);
            		if(pubid){
            			buf.push(' PUBLIC "',pubid);
            			if (sysid && sysid!='.') {
            				buf.push( '" "',sysid);
            			}
            			buf.push('">');
            		}else if(sysid && sysid!='.'){
            			buf.push(' SYSTEM "',sysid,'">');
            		}else {
            			var sub = node.internalSubset;
            			if(sub){
            				buf.push(" [",sub,"]");
            			}
            			buf.push(">");
            		}
            		return;
            	case PROCESSING_INSTRUCTION_NODE:
            		return buf.push( "<?",node.target," ",node.data,"?>");
            	case ENTITY_REFERENCE_NODE:
            		return buf.push( '&',node.nodeName,';');
            	//case ENTITY_NODE:
            	//case NOTATION_NODE:
            	default:
            		buf.push('??',node.nodeName);
            	}
            }
            function importNode(doc,node,deep){
            	var node2;
            	switch (node.nodeType) {
            	case ELEMENT_NODE:
            		node2 = node.cloneNode(false);
            		node2.ownerDocument = doc;
            		//var attrs = node2.attributes;
            		//var len = attrs.length;
            		//for(var i=0;i<len;i++){
            			//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
            		//}
            	case DOCUMENT_FRAGMENT_NODE:
            		break;
            	case ATTRIBUTE_NODE:
            		deep = true;
            		break;
            	//case ENTITY_REFERENCE_NODE:
            	//case PROCESSING_INSTRUCTION_NODE:
            	////case TEXT_NODE:
            	//case CDATA_SECTION_NODE:
            	//case COMMENT_NODE:
            	//	deep = false;
            	//	break;
            	//case DOCUMENT_NODE:
            	//case DOCUMENT_TYPE_NODE:
            	//cannot be imported.
            	//case ENTITY_NODE:
            	//case NOTATION_NODE：
            	//can not hit in level3
            	//default:throw e;
            	}
            	if(!node2){
            		node2 = node.cloneNode(false);//false
            	}
            	node2.ownerDocument = doc;
            	node2.parentNode = null;
            	if(deep){
            		var child = node.firstChild;
            		while(child){
            			node2.appendChild(importNode(doc,child,deep));
            			child = child.nextSibling;
            		}
            	}
            	return node2;
            }
            //
            //var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
            //					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
            function cloneNode(doc,node,deep){
            	var node2 = new node.constructor();
            	for(var n in node){
            		var v = node[n];
            		if(typeof v != 'object' ){
            			if(v != node2[n]){
            				node2[n] = v;
            			}
            		}
            	}
            	if(node.childNodes){
            		node2.childNodes = new NodeList();
            	}
            	node2.ownerDocument = doc;
            	switch (node2.nodeType) {
            	case ELEMENT_NODE:
            		var attrs	= node.attributes;
            		var attrs2	= node2.attributes = new NamedNodeMap();
            		var len = attrs.length;
            		attrs2._ownerElement = node2;
            		for(var i=0;i<len;i++){
            			node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
            		}
            		break;	case ATTRIBUTE_NODE:
            		deep = true;
            	}
            	if(deep){
            		var child = node.firstChild;
            		while(child){
            			node2.appendChild(cloneNode(doc,child,deep));
            			child = child.nextSibling;
            		}
            	}
            	return node2;
            }

            function __set__(object,key,value){
            	object[key] = value;
            }
            //do dynamic
            try{
            	if(Object.defineProperty){
            		Object.defineProperty(LiveNodeList.prototype,'length',{
            			get:function(){
            				_updateLiveList(this);
            				return this.$$length;
            			}
            		});
            		Object.defineProperty(Node$2.prototype,'textContent',{
            			get:function(){
            				return getTextContent(this);
            			},
            			set:function(data){
            				switch(this.nodeType){
            				case ELEMENT_NODE:
            				case DOCUMENT_FRAGMENT_NODE:
            					while(this.firstChild){
            						this.removeChild(this.firstChild);
            					}
            					if(data || String(data)){
            						this.appendChild(this.ownerDocument.createTextNode(data));
            					}
            					break;
            				default:
            					//TODO:
            					this.data = data;
            					this.value = data;
            					this.nodeValue = data;
            				}
            			}
            		});
            		
            		function getTextContent(node){
            			switch(node.nodeType){
            			case ELEMENT_NODE:
            			case DOCUMENT_FRAGMENT_NODE:
            				var buf = [];
            				node = node.firstChild;
            				while(node){
            					if(node.nodeType!==7 && node.nodeType !==8){
            						buf.push(getTextContent(node));
            					}
            					node = node.nextSibling;
            				}
            				return buf.join('');
            			default:
            				return node.nodeValue;
            			}
            		}
            		__set__ = function(object,key,value){
            			//console.log(value)
            			object['$$'+key] = value;
            		};
            	}
            }catch(e){//ie8
            }

            //if(typeof require == 'function'){
            	var DOMImplementation_1 = DOMImplementation;
            	var XMLSerializer_1 = XMLSerializer;
            //}

            var dom = {
            	DOMImplementation: DOMImplementation_1,
            	XMLSerializer: XMLSerializer_1
            };

            var domParser = createCommonjsModule$4(function (module, exports) {
            function DOMParser(options){
            	this.options = options ||{locator:{}};
            	
            }
            DOMParser.prototype.parseFromString = function(source,mimeType){
            	var options = this.options;
            	var sax =  new XMLReader();
            	var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
            	var errorHandler = options.errorHandler;
            	var locator = options.locator;
            	var defaultNSMap = options.xmlns||{};
            	var entityMap = {'lt':'<','gt':'>','amp':'&','quot':'"','apos':"'"};
            	if(locator){
            		domBuilder.setDocumentLocator(locator);
            	}
            	
            	sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
            	sax.domBuilder = options.domBuilder || domBuilder;
            	if(/\/x?html?$/.test(mimeType)){
            		entityMap.nbsp = '\xa0';
            		entityMap.copy = '\xa9';
            		defaultNSMap['']= 'http://www.w3.org/1999/xhtml';
            	}
            	defaultNSMap.xml = defaultNSMap.xml || 'http://www.w3.org/XML/1998/namespace';
            	if(source){
            		sax.parse(source,defaultNSMap,entityMap);
            	}else {
            		sax.errorHandler.error("invalid doc source");
            	}
            	return domBuilder.doc;
            };
            function buildErrorHandler(errorImpl,domBuilder,locator){
            	if(!errorImpl){
            		if(domBuilder instanceof DOMHandler){
            			return domBuilder;
            		}
            		errorImpl = domBuilder ;
            	}
            	var errorHandler = {};
            	var isCallback = errorImpl instanceof Function;
            	locator = locator||{};
            	function build(key){
            		var fn = errorImpl[key];
            		if(!fn && isCallback){
            			fn = errorImpl.length == 2?function(msg){errorImpl(key,msg);}:errorImpl;
            		}
            		errorHandler[key] = fn && function(msg){
            			fn('[xmldom '+key+']\t'+msg+_locator(locator));
            		}||function(){};
            	}
            	build('warning');
            	build('error');
            	build('fatalError');
            	return errorHandler;
            }

            //console.log('#\n\n\n\n\n\n\n####')
            /**
             * +ContentHandler+ErrorHandler
             * +LexicalHandler+EntityResolver2
             * -DeclHandler-DTDHandler 
             * 
             * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
             * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
             * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
             */
            function DOMHandler() {
                this.cdata = false;
            }
            function position(locator,node){
            	node.lineNumber = locator.lineNumber;
            	node.columnNumber = locator.columnNumber;
            }
            /**
             * @see org.xml.sax.ContentHandler#startDocument
             * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
             */ 
            DOMHandler.prototype = {
            	startDocument : function() {
                	this.doc = new DOMImplementation().createDocument(null, null, null);
                	if (this.locator) {
                    	this.doc.documentURI = this.locator.systemId;
                	}
            	},
            	startElement:function(namespaceURI, localName, qName, attrs) {
            		var doc = this.doc;
            	    var el = doc.createElementNS(namespaceURI, qName||localName);
            	    var len = attrs.length;
            	    appendElement(this, el);
            	    this.currentElement = el;
            	    
            		this.locator && position(this.locator,el);
            	    for (var i = 0 ; i < len; i++) {
            	        var namespaceURI = attrs.getURI(i);
            	        var value = attrs.getValue(i);
            	        var qName = attrs.getQName(i);
            			var attr = doc.createAttributeNS(namespaceURI, qName);
            			this.locator &&position(attrs.getLocator(i),attr);
            			attr.value = attr.nodeValue = value;
            			el.setAttributeNode(attr);
            	    }
            	},
            	endElement:function(namespaceURI, localName, qName) {
            		var current = this.currentElement;
            		var tagName = current.tagName;
            		this.currentElement = current.parentNode;
            	},
            	startPrefixMapping:function(prefix, uri) {
            	},
            	endPrefixMapping:function(prefix) {
            	},
            	processingInstruction:function(target, data) {
            	    var ins = this.doc.createProcessingInstruction(target, data);
            	    this.locator && position(this.locator,ins);
            	    appendElement(this, ins);
            	},
            	ignorableWhitespace:function(ch, start, length) {
            	},
            	characters:function(chars, start, length) {
            		chars = _toString.apply(this,arguments);
            		//console.log(chars)
            		if(chars){
            			if (this.cdata) {
            				var charNode = this.doc.createCDATASection(chars);
            			} else {
            				var charNode = this.doc.createTextNode(chars);
            			}
            			if(this.currentElement){
            				this.currentElement.appendChild(charNode);
            			}else if(/^\s*$/.test(chars)){
            				this.doc.appendChild(charNode);
            				//process xml
            			}
            			this.locator && position(this.locator,charNode);
            		}
            	},
            	skippedEntity:function(name) {
            	},
            	endDocument:function() {
            		this.doc.normalize();
            	},
            	setDocumentLocator:function (locator) {
            	    if(this.locator = locator){// && !('lineNumber' in locator)){
            	    	locator.lineNumber = 0;
            	    }
            	},
            	//LexicalHandler
            	comment:function(chars, start, length) {
            		chars = _toString.apply(this,arguments);
            	    var comm = this.doc.createComment(chars);
            	    this.locator && position(this.locator,comm);
            	    appendElement(this, comm);
            	},
            	
            	startCDATA:function() {
            	    //used in characters() methods
            	    this.cdata = true;
            	},
            	endCDATA:function() {
            	    this.cdata = false;
            	},
            	
            	startDTD:function(name, publicId, systemId) {
            		var impl = this.doc.implementation;
            	    if (impl && impl.createDocumentType) {
            	        var dt = impl.createDocumentType(name, publicId, systemId);
            	        this.locator && position(this.locator,dt);
            	        appendElement(this, dt);
            	    }
            	},
            	/**
            	 * @see org.xml.sax.ErrorHandler
            	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
            	 */
            	warning:function(error) {
            		console.warn('[xmldom warning]\t'+error,_locator(this.locator));
            	},
            	error:function(error) {
            		console.error('[xmldom error]\t'+error,_locator(this.locator));
            	},
            	fatalError:function(error) {
            		console.error('[xmldom fatalError]\t'+error,_locator(this.locator));
            	    throw error;
            	}
            };
            function _locator(l){
            	if(l){
            		return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
            	}
            }
            function _toString(chars,start,length){
            	if(typeof chars == 'string'){
            		return chars.substr(start,length)
            	}else {//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
            		if(chars.length >= start+length || start){
            			return new java.lang.String(chars,start,length)+'';
            		}
            		return chars;
            	}
            }

            /*
             * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
             * used method of org.xml.sax.ext.LexicalHandler:
             *  #comment(chars, start, length)
             *  #startCDATA()
             *  #endCDATA()
             *  #startDTD(name, publicId, systemId)
             *
             *
             * IGNORED method of org.xml.sax.ext.LexicalHandler:
             *  #endDTD()
             *  #startEntity(name)
             *  #endEntity(name)
             *
             *
             * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
             * IGNORED method of org.xml.sax.ext.DeclHandler
             * 	#attributeDecl(eName, aName, type, mode, value)
             *  #elementDecl(name, model)
             *  #externalEntityDecl(name, publicId, systemId)
             *  #internalEntityDecl(name, value)
             * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
             * IGNORED method of org.xml.sax.EntityResolver2
             *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
             *  #resolveEntity(publicId, systemId)
             *  #getExternalSubset(name, baseURI)
             * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
             * IGNORED method of org.xml.sax.DTDHandler
             *  #notationDecl(name, publicId, systemId) {};
             *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
             */
            "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
            	DOMHandler.prototype[key] = function(){return null};
            });

            /* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
            function appendElement (hander,node) {
                if (!hander.currentElement) {
                    hander.doc.appendChild(node);
                } else {
                    hander.currentElement.appendChild(node);
                }
            }//appendChild and setAttributeNS are preformance key

            //if(typeof require == 'function'){
            	var XMLReader = sax.XMLReader;
            	var DOMImplementation = exports.DOMImplementation = dom.DOMImplementation;
            	exports.XMLSerializer = dom.XMLSerializer ;
            	exports.DOMParser = DOMParser;
            //}
            });
            var domParser_1 = domParser.DOMImplementation;
            var domParser_2 = domParser.XMLSerializer;
            var domParser_3 = domParser.DOMParser;

            const X$a = 0;
            const Y$a = 1;

            const toColorFromTags = (tags, otherwise = 'black') => {
              if (tags !== undefined) {
                for (const tag of tags) {
                  if (tag.startsWith('color/')) {
                    return tag.substring(6);
                  }
                }
              }
              return otherwise;
            };

            const toSvg = async (baseGeometry, { padding = 0 } = {}) => {
              const normalize = createNormalize3();
              const [min, max] = measureBoundingBox$4(await baseGeometry);
              const width = max[X$a] - min[X$a];
              const height = max[Y$a] - min[Y$a];
              const translated = translate$4([width / 2, height / 2, 0], await baseGeometry);
              const geometry = canonicalize$9(toKeptGeometry(translated));

              const svg = [
                `<?xml version="1.0" encoding="UTF-8"?>`,
                `<!-- Generated by jsxcad -->`,
                `<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1 Tiny//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11-tiny.dtd">`,
                `<svg baseProfile="tiny" height="${height}mm" width="${width}mm" viewBox="${-padding} ${-padding} ${
      width + 2 * padding
    } ${
      height + 2 * padding
    }" version="1.1" stroke="black" stroke-width=".1" fill="none" xmlns="http://www.w3.org/2000/svg">`,
              ];

              for (const { surface, z0Surface, tags } of getAnyNonVoidSurfaces(geometry)) {
                const anySurface = surface || z0Surface;
                if (anySurface === undefined) throw Error('die');
                const color = toColorFromTags(tags);
                const paths = [];
                for (const polygon of outlineSurface(anySurface, normalize)) {
                  paths.push(
                    `${polygon
          .map(
            (point, index) =>
              `${index === 0 ? 'M' : 'L'}${point[0]} ${point[1]}`
          )
          .join(' ')} z`
                  );
                }
                svg.push(`<path fill="${color}" stroke="none" d="${paths.join(' ')}"/>`);
              }
              for (const { paths, tags } of getNonVoidPaths(geometry)) {
                const color = toColorFromTags(tags);
                for (const path of paths) {
                  if (path[0] === null) {
                    svg.push(
                      `<path stroke="${color}" fill="none" d="${path
            .slice(1)
            .map(
              (point, index) =>
                `${index === 0 ? 'M' : 'L'}${point[0]} ${point[1]}`
            )
            .join(' ')}"/>`
                    );
                  } else {
                    svg.push(
                      `<path stroke="${color}" fill="none" d="${path
            .map(
              (point, index) =>
                `${index === 0 ? 'M' : 'L'}${point[0]} ${point[1]}`
            )
            .join(' ')} z"/>`
                    );
                  }
                }
              }
              svg.push('</svg>');
              const output = svg.join('\n');
              return new TextEncoder('utf8').encode(output);
            };

            var global$1$4 = (typeof global$1 !== "undefined" ? global$1 :
                        typeof self !== "undefined" ? self :
                        typeof window !== "undefined" ? window : {});

            var lookup$1 = [];
            var revLookup$1 = [];
            var Arr$1 = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
            var inited$1 = false;
            function init$3 () {
              inited$1 = true;
              var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
              for (var i = 0, len = code.length; i < len; ++i) {
                lookup$1[i] = code[i];
                revLookup$1[code.charCodeAt(i)] = i;
              }

              revLookup$1['-'.charCodeAt(0)] = 62;
              revLookup$1['_'.charCodeAt(0)] = 63;
            }

            function toByteArray$1 (b64) {
              if (!inited$1) {
                init$3();
              }
              var i, j, l, tmp, placeHolders, arr;
              var len = b64.length;

              if (len % 4 > 0) {
                throw new Error('Invalid string. Length must be a multiple of 4')
              }

              // the number of equal signs (place holders)
              // if there are two placeholders, than the two characters before it
              // represent one byte
              // if there is only one, then the three characters before it represent 2 bytes
              // this is just a cheap hack to not do indexOf twice
              placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

              // base64 is 4/3 + up to two characters of the original data
              arr = new Arr$1(len * 3 / 4 - placeHolders);

              // if there are placeholders, only get up to the last complete 4 chars
              l = placeHolders > 0 ? len - 4 : len;

              var L = 0;

              for (i = 0, j = 0; i < l; i += 4, j += 3) {
                tmp = (revLookup$1[b64.charCodeAt(i)] << 18) | (revLookup$1[b64.charCodeAt(i + 1)] << 12) | (revLookup$1[b64.charCodeAt(i + 2)] << 6) | revLookup$1[b64.charCodeAt(i + 3)];
                arr[L++] = (tmp >> 16) & 0xFF;
                arr[L++] = (tmp >> 8) & 0xFF;
                arr[L++] = tmp & 0xFF;
              }

              if (placeHolders === 2) {
                tmp = (revLookup$1[b64.charCodeAt(i)] << 2) | (revLookup$1[b64.charCodeAt(i + 1)] >> 4);
                arr[L++] = tmp & 0xFF;
              } else if (placeHolders === 1) {
                tmp = (revLookup$1[b64.charCodeAt(i)] << 10) | (revLookup$1[b64.charCodeAt(i + 1)] << 4) | (revLookup$1[b64.charCodeAt(i + 2)] >> 2);
                arr[L++] = (tmp >> 8) & 0xFF;
                arr[L++] = tmp & 0xFF;
              }

              return arr
            }

            function tripletToBase64$1 (num) {
              return lookup$1[num >> 18 & 0x3F] + lookup$1[num >> 12 & 0x3F] + lookup$1[num >> 6 & 0x3F] + lookup$1[num & 0x3F]
            }

            function encodeChunk$1 (uint8, start, end) {
              var tmp;
              var output = [];
              for (var i = start; i < end; i += 3) {
                tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
                output.push(tripletToBase64$1(tmp));
              }
              return output.join('')
            }

            function fromByteArray$1 (uint8) {
              if (!inited$1) {
                init$3();
              }
              var tmp;
              var len = uint8.length;
              var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
              var output = '';
              var parts = [];
              var maxChunkLength = 16383; // must be multiple of 3

              // go through the array every three bytes, we'll deal with trailing stuff later
              for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                parts.push(encodeChunk$1(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
              }

              // pad the end with zeros, but make sure to not forget the extra bytes
              if (extraBytes === 1) {
                tmp = uint8[len - 1];
                output += lookup$1[tmp >> 2];
                output += lookup$1[(tmp << 4) & 0x3F];
                output += '==';
              } else if (extraBytes === 2) {
                tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
                output += lookup$1[tmp >> 10];
                output += lookup$1[(tmp >> 4) & 0x3F];
                output += lookup$1[(tmp << 2) & 0x3F];
                output += '=';
              }

              parts.push(output);

              return parts.join('')
            }

            function read$2 (buffer, offset, isLE, mLen, nBytes) {
              var e, m;
              var eLen = nBytes * 8 - mLen - 1;
              var eMax = (1 << eLen) - 1;
              var eBias = eMax >> 1;
              var nBits = -7;
              var i = isLE ? (nBytes - 1) : 0;
              var d = isLE ? -1 : 1;
              var s = buffer[offset + i];

              i += d;

              e = s & ((1 << (-nBits)) - 1);
              s >>= (-nBits);
              nBits += eLen;
              for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

              m = e & ((1 << (-nBits)) - 1);
              e >>= (-nBits);
              nBits += mLen;
              for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

              if (e === 0) {
                e = 1 - eBias;
              } else if (e === eMax) {
                return m ? NaN : ((s ? -1 : 1) * Infinity)
              } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
              }
              return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
            }

            function write$2 (buffer, value, offset, isLE, mLen, nBytes) {
              var e, m, c;
              var eLen = nBytes * 8 - mLen - 1;
              var eMax = (1 << eLen) - 1;
              var eBias = eMax >> 1;
              var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
              var i = isLE ? 0 : (nBytes - 1);
              var d = isLE ? 1 : -1;
              var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

              value = Math.abs(value);

              if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e = eMax;
              } else {
                e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e)) < 1) {
                  e--;
                  c *= 2;
                }
                if (e + eBias >= 1) {
                  value += rt / c;
                } else {
                  value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                  e++;
                  c /= 2;
                }

                if (e + eBias >= eMax) {
                  m = 0;
                  e = eMax;
                } else if (e + eBias >= 1) {
                  m = (value * c - 1) * Math.pow(2, mLen);
                  e = e + eBias;
                } else {
                  m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                  e = 0;
                }
              }

              for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

              e = (e << mLen) | m;
              eLen += mLen;
              for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

              buffer[offset + i - d] |= s * 128;
            }

            var toString$1 = {}.toString;

            var isArray$2 = Array.isArray || function (arr) {
              return toString$1.call(arr) == '[object Array]';
            };

            var INSPECT_MAX_BYTES$1 = 50;

            /**
             * If `Buffer.TYPED_ARRAY_SUPPORT`:
             *   === true    Use Uint8Array implementation (fastest)
             *   === false   Use Object implementation (most compatible, even IE6)
             *
             * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
             * Opera 11.6+, iOS 4.2+.
             *
             * Due to various browser bugs, sometimes the Object implementation will be used even
             * when the browser supports typed arrays.
             *
             * Note:
             *
             *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
             *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
             *
             *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
             *
             *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
             *     incorrect length in some situations.

             * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
             * get the Object implementation, which is slower but behaves correctly.
             */
            Buffer$1.TYPED_ARRAY_SUPPORT = global$1$4.TYPED_ARRAY_SUPPORT !== undefined
              ? global$1$4.TYPED_ARRAY_SUPPORT
              : true;

            function kMaxLength$1 () {
              return Buffer$1.TYPED_ARRAY_SUPPORT
                ? 0x7fffffff
                : 0x3fffffff
            }

            function createBuffer$1 (that, length) {
              if (kMaxLength$1() < length) {
                throw new RangeError('Invalid typed array length')
              }
              if (Buffer$1.TYPED_ARRAY_SUPPORT) {
                // Return an augmented `Uint8Array` instance, for best performance
                that = new Uint8Array(length);
                that.__proto__ = Buffer$1.prototype;
              } else {
                // Fallback: Return an object instance of the Buffer class
                if (that === null) {
                  that = new Buffer$1(length);
                }
                that.length = length;
              }

              return that
            }

            /**
             * The Buffer constructor returns instances of `Uint8Array` that have their
             * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
             * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
             * and the `Uint8Array` methods. Square bracket notation works as expected -- it
             * returns a single octet.
             *
             * The `Uint8Array` prototype remains unmodified.
             */

            function Buffer$1 (arg, encodingOrOffset, length) {
              if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
                return new Buffer$1(arg, encodingOrOffset, length)
              }

              // Common case.
              if (typeof arg === 'number') {
                if (typeof encodingOrOffset === 'string') {
                  throw new Error(
                    'If encoding is specified then the first argument must be a string'
                  )
                }
                return allocUnsafe$1(this, arg)
              }
              return from$1(this, arg, encodingOrOffset, length)
            }

            Buffer$1.poolSize = 8192; // not used by this implementation

            // TODO: Legacy, not needed anymore. Remove in next major version.
            Buffer$1._augment = function (arr) {
              arr.__proto__ = Buffer$1.prototype;
              return arr
            };

            function from$1 (that, value, encodingOrOffset, length) {
              if (typeof value === 'number') {
                throw new TypeError('"value" argument must not be a number')
              }

              if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
                return fromArrayBuffer$1(that, value, encodingOrOffset, length)
              }

              if (typeof value === 'string') {
                return fromString$1(that, value, encodingOrOffset)
              }

              return fromObject$1(that, value)
            }

            /**
             * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
             * if value is a number.
             * Buffer.from(str[, encoding])
             * Buffer.from(array)
             * Buffer.from(buffer)
             * Buffer.from(arrayBuffer[, byteOffset[, length]])
             **/
            Buffer$1.from = function (value, encodingOrOffset, length) {
              return from$1(null, value, encodingOrOffset, length)
            };

            if (Buffer$1.TYPED_ARRAY_SUPPORT) {
              Buffer$1.prototype.__proto__ = Uint8Array.prototype;
              Buffer$1.__proto__ = Uint8Array;
            }

            function assertSize$1 (size) {
              if (typeof size !== 'number') {
                throw new TypeError('"size" argument must be a number')
              } else if (size < 0) {
                throw new RangeError('"size" argument must not be negative')
              }
            }

            function alloc$1 (that, size, fill, encoding) {
              assertSize$1(size);
              if (size <= 0) {
                return createBuffer$1(that, size)
              }
              if (fill !== undefined) {
                // Only pay attention to encoding if it's a string. This
                // prevents accidentally sending in a number that would
                // be interpretted as a start offset.
                return typeof encoding === 'string'
                  ? createBuffer$1(that, size).fill(fill, encoding)
                  : createBuffer$1(that, size).fill(fill)
              }
              return createBuffer$1(that, size)
            }

            /**
             * Creates a new filled Buffer instance.
             * alloc(size[, fill[, encoding]])
             **/
            Buffer$1.alloc = function (size, fill, encoding) {
              return alloc$1(null, size, fill, encoding)
            };

            function allocUnsafe$1 (that, size) {
              assertSize$1(size);
              that = createBuffer$1(that, size < 0 ? 0 : checked$1(size) | 0);
              if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
                for (var i = 0; i < size; ++i) {
                  that[i] = 0;
                }
              }
              return that
            }

            /**
             * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
             * */
            Buffer$1.allocUnsafe = function (size) {
              return allocUnsafe$1(null, size)
            };
            /**
             * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
             */
            Buffer$1.allocUnsafeSlow = function (size) {
              return allocUnsafe$1(null, size)
            };

            function fromString$1 (that, string, encoding) {
              if (typeof encoding !== 'string' || encoding === '') {
                encoding = 'utf8';
              }

              if (!Buffer$1.isEncoding(encoding)) {
                throw new TypeError('"encoding" must be a valid string encoding')
              }

              var length = byteLength$1(string, encoding) | 0;
              that = createBuffer$1(that, length);

              var actual = that.write(string, encoding);

              if (actual !== length) {
                // Writing a hex string, for example, that contains invalid characters will
                // cause everything after the first invalid character to be ignored. (e.g.
                // 'abxxcd' will be treated as 'ab')
                that = that.slice(0, actual);
              }

              return that
            }

            function fromArrayLike$1 (that, array) {
              var length = array.length < 0 ? 0 : checked$1(array.length) | 0;
              that = createBuffer$1(that, length);
              for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255;
              }
              return that
            }

            function fromArrayBuffer$1 (that, array, byteOffset, length) {
              array.byteLength; // this throws if `array` is not a valid ArrayBuffer

              if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError('\'offset\' is out of bounds')
              }

              if (array.byteLength < byteOffset + (length || 0)) {
                throw new RangeError('\'length\' is out of bounds')
              }

              if (byteOffset === undefined && length === undefined) {
                array = new Uint8Array(array);
              } else if (length === undefined) {
                array = new Uint8Array(array, byteOffset);
              } else {
                array = new Uint8Array(array, byteOffset, length);
              }

              if (Buffer$1.TYPED_ARRAY_SUPPORT) {
                // Return an augmented `Uint8Array` instance, for best performance
                that = array;
                that.__proto__ = Buffer$1.prototype;
              } else {
                // Fallback: Return an object instance of the Buffer class
                that = fromArrayLike$1(that, array);
              }
              return that
            }

            function fromObject$1 (that, obj) {
              if (internalIsBuffer$1(obj)) {
                var len = checked$1(obj.length) | 0;
                that = createBuffer$1(that, len);

                if (that.length === 0) {
                  return that
                }

                obj.copy(that, 0, 0, len);
                return that
              }

              if (obj) {
                if ((typeof ArrayBuffer !== 'undefined' &&
                    obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
                  if (typeof obj.length !== 'number' || isnan$1(obj.length)) {
                    return createBuffer$1(that, 0)
                  }
                  return fromArrayLike$1(that, obj)
                }

                if (obj.type === 'Buffer' && isArray$2(obj.data)) {
                  return fromArrayLike$1(that, obj.data)
                }
              }

              throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
            }

            function checked$1 (length) {
              // Note: cannot use `length < kMaxLength()` here because that fails when
              // length is NaN (which is otherwise coerced to zero.)
              if (length >= kMaxLength$1()) {
                throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                                     'size: 0x' + kMaxLength$1().toString(16) + ' bytes')
              }
              return length | 0
            }
            Buffer$1.isBuffer = isBuffer$2;
            function internalIsBuffer$1 (b) {
              return !!(b != null && b._isBuffer)
            }

            Buffer$1.compare = function compare (a, b) {
              if (!internalIsBuffer$1(a) || !internalIsBuffer$1(b)) {
                throw new TypeError('Arguments must be Buffers')
              }

              if (a === b) return 0

              var x = a.length;
              var y = b.length;

              for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                if (a[i] !== b[i]) {
                  x = a[i];
                  y = b[i];
                  break
                }
              }

              if (x < y) return -1
              if (y < x) return 1
              return 0
            };

            Buffer$1.isEncoding = function isEncoding (encoding) {
              switch (String(encoding).toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'latin1':
                case 'binary':
                case 'base64':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return true
                default:
                  return false
              }
            };

            Buffer$1.concat = function concat (list, length) {
              if (!isArray$2(list)) {
                throw new TypeError('"list" argument must be an Array of Buffers')
              }

              if (list.length === 0) {
                return Buffer$1.alloc(0)
              }

              var i;
              if (length === undefined) {
                length = 0;
                for (i = 0; i < list.length; ++i) {
                  length += list[i].length;
                }
              }

              var buffer = Buffer$1.allocUnsafe(length);
              var pos = 0;
              for (i = 0; i < list.length; ++i) {
                var buf = list[i];
                if (!internalIsBuffer$1(buf)) {
                  throw new TypeError('"list" argument must be an Array of Buffers')
                }
                buf.copy(buffer, pos);
                pos += buf.length;
              }
              return buffer
            };

            function byteLength$1 (string, encoding) {
              if (internalIsBuffer$1(string)) {
                return string.length
              }
              if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
                  (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
                return string.byteLength
              }
              if (typeof string !== 'string') {
                string = '' + string;
              }

              var len = string.length;
              if (len === 0) return 0

              // Use a for loop to avoid recursion
              var loweredCase = false;
              for (;;) {
                switch (encoding) {
                  case 'ascii':
                  case 'latin1':
                  case 'binary':
                    return len
                  case 'utf8':
                  case 'utf-8':
                  case undefined:
                    return utf8ToBytes$1(string).length
                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return len * 2
                  case 'hex':
                    return len >>> 1
                  case 'base64':
                    return base64ToBytes$1(string).length
                  default:
                    if (loweredCase) return utf8ToBytes$1(string).length // assume utf8
                    encoding = ('' + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer$1.byteLength = byteLength$1;

            function slowToString$1 (encoding, start, end) {
              var loweredCase = false;

              // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
              // property of a typed array.

              // This behaves neither like String nor Uint8Array in that we set start/end
              // to their upper/lower bounds if the value passed is out of range.
              // undefined is handled specially as per ECMA-262 6th Edition,
              // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
              if (start === undefined || start < 0) {
                start = 0;
              }
              // Return early if start > this.length. Done here to prevent potential uint32
              // coercion fail below.
              if (start > this.length) {
                return ''
              }

              if (end === undefined || end > this.length) {
                end = this.length;
              }

              if (end <= 0) {
                return ''
              }

              // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
              end >>>= 0;
              start >>>= 0;

              if (end <= start) {
                return ''
              }

              if (!encoding) encoding = 'utf8';

              while (true) {
                switch (encoding) {
                  case 'hex':
                    return hexSlice$1(this, start, end)

                  case 'utf8':
                  case 'utf-8':
                    return utf8Slice$1(this, start, end)

                  case 'ascii':
                    return asciiSlice$1(this, start, end)

                  case 'latin1':
                  case 'binary':
                    return latin1Slice$1(this, start, end)

                  case 'base64':
                    return base64Slice$1(this, start, end)

                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return utf16leSlice$1(this, start, end)

                  default:
                    if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                    encoding = (encoding + '').toLowerCase();
                    loweredCase = true;
                }
              }
            }

            // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
            // Buffer instances.
            Buffer$1.prototype._isBuffer = true;

            function swap$1 (b, n, m) {
              var i = b[n];
              b[n] = b[m];
              b[m] = i;
            }

            Buffer$1.prototype.swap16 = function swap16 () {
              var len = this.length;
              if (len % 2 !== 0) {
                throw new RangeError('Buffer size must be a multiple of 16-bits')
              }
              for (var i = 0; i < len; i += 2) {
                swap$1(this, i, i + 1);
              }
              return this
            };

            Buffer$1.prototype.swap32 = function swap32 () {
              var len = this.length;
              if (len % 4 !== 0) {
                throw new RangeError('Buffer size must be a multiple of 32-bits')
              }
              for (var i = 0; i < len; i += 4) {
                swap$1(this, i, i + 3);
                swap$1(this, i + 1, i + 2);
              }
              return this
            };

            Buffer$1.prototype.swap64 = function swap64 () {
              var len = this.length;
              if (len % 8 !== 0) {
                throw new RangeError('Buffer size must be a multiple of 64-bits')
              }
              for (var i = 0; i < len; i += 8) {
                swap$1(this, i, i + 7);
                swap$1(this, i + 1, i + 6);
                swap$1(this, i + 2, i + 5);
                swap$1(this, i + 3, i + 4);
              }
              return this
            };

            Buffer$1.prototype.toString = function toString () {
              var length = this.length | 0;
              if (length === 0) return ''
              if (arguments.length === 0) return utf8Slice$1(this, 0, length)
              return slowToString$1.apply(this, arguments)
            };

            Buffer$1.prototype.equals = function equals (b) {
              if (!internalIsBuffer$1(b)) throw new TypeError('Argument must be a Buffer')
              if (this === b) return true
              return Buffer$1.compare(this, b) === 0
            };

            Buffer$1.prototype.inspect = function inspect () {
              var str = '';
              var max = INSPECT_MAX_BYTES$1;
              if (this.length > 0) {
                str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
                if (this.length > max) str += ' ... ';
              }
              return '<Buffer ' + str + '>'
            };

            Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
              if (!internalIsBuffer$1(target)) {
                throw new TypeError('Argument must be a Buffer')
              }

              if (start === undefined) {
                start = 0;
              }
              if (end === undefined) {
                end = target ? target.length : 0;
              }
              if (thisStart === undefined) {
                thisStart = 0;
              }
              if (thisEnd === undefined) {
                thisEnd = this.length;
              }

              if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                throw new RangeError('out of range index')
              }

              if (thisStart >= thisEnd && start >= end) {
                return 0
              }
              if (thisStart >= thisEnd) {
                return -1
              }
              if (start >= end) {
                return 1
              }

              start >>>= 0;
              end >>>= 0;
              thisStart >>>= 0;
              thisEnd >>>= 0;

              if (this === target) return 0

              var x = thisEnd - thisStart;
              var y = end - start;
              var len = Math.min(x, y);

              var thisCopy = this.slice(thisStart, thisEnd);
              var targetCopy = target.slice(start, end);

              for (var i = 0; i < len; ++i) {
                if (thisCopy[i] !== targetCopy[i]) {
                  x = thisCopy[i];
                  y = targetCopy[i];
                  break
                }
              }

              if (x < y) return -1
              if (y < x) return 1
              return 0
            };

            // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
            // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
            //
            // Arguments:
            // - buffer - a Buffer to search
            // - val - a string, Buffer, or number
            // - byteOffset - an index into `buffer`; will be clamped to an int32
            // - encoding - an optional encoding, relevant is val is a string
            // - dir - true for indexOf, false for lastIndexOf
            function bidirectionalIndexOf$1 (buffer, val, byteOffset, encoding, dir) {
              // Empty buffer means no match
              if (buffer.length === 0) return -1

              // Normalize byteOffset
              if (typeof byteOffset === 'string') {
                encoding = byteOffset;
                byteOffset = 0;
              } else if (byteOffset > 0x7fffffff) {
                byteOffset = 0x7fffffff;
              } else if (byteOffset < -0x80000000) {
                byteOffset = -0x80000000;
              }
              byteOffset = +byteOffset;  // Coerce to Number.
              if (isNaN(byteOffset)) {
                // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                byteOffset = dir ? 0 : (buffer.length - 1);
              }

              // Normalize byteOffset: negative offsets start from the end of the buffer
              if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
              if (byteOffset >= buffer.length) {
                if (dir) return -1
                else byteOffset = buffer.length - 1;
              } else if (byteOffset < 0) {
                if (dir) byteOffset = 0;
                else return -1
              }

              // Normalize val
              if (typeof val === 'string') {
                val = Buffer$1.from(val, encoding);
              }

              // Finally, search either indexOf (if dir is true) or lastIndexOf
              if (internalIsBuffer$1(val)) {
                // Special case: looking for empty string/buffer always fails
                if (val.length === 0) {
                  return -1
                }
                return arrayIndexOf$1(buffer, val, byteOffset, encoding, dir)
              } else if (typeof val === 'number') {
                val = val & 0xFF; // Search for a byte value [0-255]
                if (Buffer$1.TYPED_ARRAY_SUPPORT &&
                    typeof Uint8Array.prototype.indexOf === 'function') {
                  if (dir) {
                    return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
                  } else {
                    return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
                  }
                }
                return arrayIndexOf$1(buffer, [ val ], byteOffset, encoding, dir)
              }

              throw new TypeError('val must be string, number or Buffer')
            }

            function arrayIndexOf$1 (arr, val, byteOffset, encoding, dir) {
              var indexSize = 1;
              var arrLength = arr.length;
              var valLength = val.length;

              if (encoding !== undefined) {
                encoding = String(encoding).toLowerCase();
                if (encoding === 'ucs2' || encoding === 'ucs-2' ||
                    encoding === 'utf16le' || encoding === 'utf-16le') {
                  if (arr.length < 2 || val.length < 2) {
                    return -1
                  }
                  indexSize = 2;
                  arrLength /= 2;
                  valLength /= 2;
                  byteOffset /= 2;
                }
              }

              function read (buf, i) {
                if (indexSize === 1) {
                  return buf[i]
                } else {
                  return buf.readUInt16BE(i * indexSize)
                }
              }

              var i;
              if (dir) {
                var foundIndex = -1;
                for (i = byteOffset; i < arrLength; i++) {
                  if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                    if (foundIndex === -1) foundIndex = i;
                    if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
                  } else {
                    if (foundIndex !== -1) i -= i - foundIndex;
                    foundIndex = -1;
                  }
                }
              } else {
                if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                for (i = byteOffset; i >= 0; i--) {
                  var found = true;
                  for (var j = 0; j < valLength; j++) {
                    if (read(arr, i + j) !== read(val, j)) {
                      found = false;
                      break
                    }
                  }
                  if (found) return i
                }
              }

              return -1
            }

            Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
              return this.indexOf(val, byteOffset, encoding) !== -1
            };

            Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
              return bidirectionalIndexOf$1(this, val, byteOffset, encoding, true)
            };

            Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
              return bidirectionalIndexOf$1(this, val, byteOffset, encoding, false)
            };

            function hexWrite$1 (buf, string, offset, length) {
              offset = Number(offset) || 0;
              var remaining = buf.length - offset;
              if (!length) {
                length = remaining;
              } else {
                length = Number(length);
                if (length > remaining) {
                  length = remaining;
                }
              }

              // must be an even number of digits
              var strLen = string.length;
              if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

              if (length > strLen / 2) {
                length = strLen / 2;
              }
              for (var i = 0; i < length; ++i) {
                var parsed = parseInt(string.substr(i * 2, 2), 16);
                if (isNaN(parsed)) return i
                buf[offset + i] = parsed;
              }
              return i
            }

            function utf8Write$1 (buf, string, offset, length) {
              return blitBuffer$1(utf8ToBytes$1(string, buf.length - offset), buf, offset, length)
            }

            function asciiWrite$1 (buf, string, offset, length) {
              return blitBuffer$1(asciiToBytes$1(string), buf, offset, length)
            }

            function latin1Write$1 (buf, string, offset, length) {
              return asciiWrite$1(buf, string, offset, length)
            }

            function base64Write$1 (buf, string, offset, length) {
              return blitBuffer$1(base64ToBytes$1(string), buf, offset, length)
            }

            function ucs2Write$1 (buf, string, offset, length) {
              return blitBuffer$1(utf16leToBytes$1(string, buf.length - offset), buf, offset, length)
            }

            Buffer$1.prototype.write = function write (string, offset, length, encoding) {
              // Buffer#write(string)
              if (offset === undefined) {
                encoding = 'utf8';
                length = this.length;
                offset = 0;
              // Buffer#write(string, encoding)
              } else if (length === undefined && typeof offset === 'string') {
                encoding = offset;
                length = this.length;
                offset = 0;
              // Buffer#write(string, offset[, length][, encoding])
              } else if (isFinite(offset)) {
                offset = offset | 0;
                if (isFinite(length)) {
                  length = length | 0;
                  if (encoding === undefined) encoding = 'utf8';
                } else {
                  encoding = length;
                  length = undefined;
                }
              // legacy write(string, encoding, offset, length) - remove in v0.13
              } else {
                throw new Error(
                  'Buffer.write(string, encoding, offset[, length]) is no longer supported'
                )
              }

              var remaining = this.length - offset;
              if (length === undefined || length > remaining) length = remaining;

              if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                throw new RangeError('Attempt to write outside buffer bounds')
              }

              if (!encoding) encoding = 'utf8';

              var loweredCase = false;
              for (;;) {
                switch (encoding) {
                  case 'hex':
                    return hexWrite$1(this, string, offset, length)

                  case 'utf8':
                  case 'utf-8':
                    return utf8Write$1(this, string, offset, length)

                  case 'ascii':
                    return asciiWrite$1(this, string, offset, length)

                  case 'latin1':
                  case 'binary':
                    return latin1Write$1(this, string, offset, length)

                  case 'base64':
                    // Warning: maxLength not taken into account in base64Write
                    return base64Write$1(this, string, offset, length)

                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return ucs2Write$1(this, string, offset, length)

                  default:
                    if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                    encoding = ('' + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            };

            Buffer$1.prototype.toJSON = function toJSON () {
              return {
                type: 'Buffer',
                data: Array.prototype.slice.call(this._arr || this, 0)
              }
            };

            function base64Slice$1 (buf, start, end) {
              if (start === 0 && end === buf.length) {
                return fromByteArray$1(buf)
              } else {
                return fromByteArray$1(buf.slice(start, end))
              }
            }

            function utf8Slice$1 (buf, start, end) {
              end = Math.min(buf.length, end);
              var res = [];

              var i = start;
              while (i < end) {
                var firstByte = buf[i];
                var codePoint = null;
                var bytesPerSequence = (firstByte > 0xEF) ? 4
                  : (firstByte > 0xDF) ? 3
                  : (firstByte > 0xBF) ? 2
                  : 1;

                if (i + bytesPerSequence <= end) {
                  var secondByte, thirdByte, fourthByte, tempCodePoint;

                  switch (bytesPerSequence) {
                    case 1:
                      if (firstByte < 0x80) {
                        codePoint = firstByte;
                      }
                      break
                    case 2:
                      secondByte = buf[i + 1];
                      if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                        if (tempCodePoint > 0x7F) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break
                    case 3:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break
                    case 4:
                      secondByte = buf[i + 1];
                      thirdByte = buf[i + 2];
                      fourthByte = buf[i + 3];
                      if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                          codePoint = tempCodePoint;
                        }
                      }
                  }
                }

                if (codePoint === null) {
                  // we did not generate a valid codePoint so insert a
                  // replacement char (U+FFFD) and advance only 1 byte
                  codePoint = 0xFFFD;
                  bytesPerSequence = 1;
                } else if (codePoint > 0xFFFF) {
                  // encode to utf16 (surrogate pair dance)
                  codePoint -= 0x10000;
                  res.push(codePoint >>> 10 & 0x3FF | 0xD800);
                  codePoint = 0xDC00 | codePoint & 0x3FF;
                }

                res.push(codePoint);
                i += bytesPerSequence;
              }

              return decodeCodePointsArray$1(res)
            }

            // Based on http://stackoverflow.com/a/22747272/680742, the browser with
            // the lowest limit is Chrome, with 0x10000 args.
            // We go 1 magnitude less, for safety
            var MAX_ARGUMENTS_LENGTH$1 = 0x1000;

            function decodeCodePointsArray$1 (codePoints) {
              var len = codePoints.length;
              if (len <= MAX_ARGUMENTS_LENGTH$1) {
                return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
              }

              // Decode in chunks to avoid "call stack size exceeded".
              var res = '';
              var i = 0;
              while (i < len) {
                res += String.fromCharCode.apply(
                  String,
                  codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH$1)
                );
              }
              return res
            }

            function asciiSlice$1 (buf, start, end) {
              var ret = '';
              end = Math.min(buf.length, end);

              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i] & 0x7F);
              }
              return ret
            }

            function latin1Slice$1 (buf, start, end) {
              var ret = '';
              end = Math.min(buf.length, end);

              for (var i = start; i < end; ++i) {
                ret += String.fromCharCode(buf[i]);
              }
              return ret
            }

            function hexSlice$1 (buf, start, end) {
              var len = buf.length;

              if (!start || start < 0) start = 0;
              if (!end || end < 0 || end > len) end = len;

              var out = '';
              for (var i = start; i < end; ++i) {
                out += toHex$1(buf[i]);
              }
              return out
            }

            function utf16leSlice$1 (buf, start, end) {
              var bytes = buf.slice(start, end);
              var res = '';
              for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
              }
              return res
            }

            Buffer$1.prototype.slice = function slice (start, end) {
              var len = this.length;
              start = ~~start;
              end = end === undefined ? len : ~~end;

              if (start < 0) {
                start += len;
                if (start < 0) start = 0;
              } else if (start > len) {
                start = len;
              }

              if (end < 0) {
                end += len;
                if (end < 0) end = 0;
              } else if (end > len) {
                end = len;
              }

              if (end < start) end = start;

              var newBuf;
              if (Buffer$1.TYPED_ARRAY_SUPPORT) {
                newBuf = this.subarray(start, end);
                newBuf.__proto__ = Buffer$1.prototype;
              } else {
                var sliceLen = end - start;
                newBuf = new Buffer$1(sliceLen, undefined);
                for (var i = 0; i < sliceLen; ++i) {
                  newBuf[i] = this[i + start];
                }
              }

              return newBuf
            };

            /*
             * Need to make sure that buffer isn't trying to write out of bounds.
             */
            function checkOffset$1 (offset, ext, length) {
              if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
              if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
            }

            Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset$1(offset, byteLength, this.length);

              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul;
              }

              return val
            };

            Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) {
                checkOffset$1(offset, byteLength, this.length);
              }

              var val = this[offset + --byteLength];
              var mul = 1;
              while (byteLength > 0 && (mul *= 0x100)) {
                val += this[offset + --byteLength] * mul;
              }

              return val
            };

            Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
              if (!noAssert) checkOffset$1(offset, 1, this.length);
              return this[offset]
            };

            Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
              if (!noAssert) checkOffset$1(offset, 2, this.length);
              return this[offset] | (this[offset + 1] << 8)
            };

            Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
              if (!noAssert) checkOffset$1(offset, 2, this.length);
              return (this[offset] << 8) | this[offset + 1]
            };

            Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
              if (!noAssert) checkOffset$1(offset, 4, this.length);

              return ((this[offset]) |
                  (this[offset + 1] << 8) |
                  (this[offset + 2] << 16)) +
                  (this[offset + 3] * 0x1000000)
            };

            Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
              if (!noAssert) checkOffset$1(offset, 4, this.length);

              return (this[offset] * 0x1000000) +
                ((this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                this[offset + 3])
            };

            Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset$1(offset, byteLength, this.length);

              var val = this[offset];
              var mul = 1;
              var i = 0;
              while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul;
              }
              mul *= 0x80;

              if (val >= mul) val -= Math.pow(2, 8 * byteLength);

              return val
            };

            Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) checkOffset$1(offset, byteLength, this.length);

              var i = byteLength;
              var mul = 1;
              var val = this[offset + --i];
              while (i > 0 && (mul *= 0x100)) {
                val += this[offset + --i] * mul;
              }
              mul *= 0x80;

              if (val >= mul) val -= Math.pow(2, 8 * byteLength);

              return val
            };

            Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
              if (!noAssert) checkOffset$1(offset, 1, this.length);
              if (!(this[offset] & 0x80)) return (this[offset])
              return ((0xff - this[offset] + 1) * -1)
            };

            Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
              if (!noAssert) checkOffset$1(offset, 2, this.length);
              var val = this[offset] | (this[offset + 1] << 8);
              return (val & 0x8000) ? val | 0xFFFF0000 : val
            };

            Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
              if (!noAssert) checkOffset$1(offset, 2, this.length);
              var val = this[offset + 1] | (this[offset] << 8);
              return (val & 0x8000) ? val | 0xFFFF0000 : val
            };

            Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
              if (!noAssert) checkOffset$1(offset, 4, this.length);

              return (this[offset]) |
                (this[offset + 1] << 8) |
                (this[offset + 2] << 16) |
                (this[offset + 3] << 24)
            };

            Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
              if (!noAssert) checkOffset$1(offset, 4, this.length);

              return (this[offset] << 24) |
                (this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                (this[offset + 3])
            };

            Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
              if (!noAssert) checkOffset$1(offset, 4, this.length);
              return read$2(this, offset, true, 23, 4)
            };

            Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
              if (!noAssert) checkOffset$1(offset, 4, this.length);
              return read$2(this, offset, false, 23, 4)
            };

            Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
              if (!noAssert) checkOffset$1(offset, 8, this.length);
              return read$2(this, offset, true, 52, 8)
            };

            Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
              if (!noAssert) checkOffset$1(offset, 8, this.length);
              return read$2(this, offset, false, 52, 8)
            };

            function checkInt$1 (buf, value, offset, ext, max, min) {
              if (!internalIsBuffer$1(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
              if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
              if (offset + ext > buf.length) throw new RangeError('Index out of range')
            }

            Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt$1(this, value, offset, byteLength, maxBytes, 0);
              }

              var mul = 1;
              var i = 0;
              this[offset] = value & 0xFF;
              while (++i < byteLength && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xFF;
              }

              return offset + byteLength
            };

            Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              byteLength = byteLength | 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                checkInt$1(this, value, offset, byteLength, maxBytes, 0);
              }

              var i = byteLength - 1;
              var mul = 1;
              this[offset + i] = value & 0xFF;
              while (--i >= 0 && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xFF;
              }

              return offset + byteLength
            };

            Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt$1(this, value, offset, 1, 0xff, 0);
              if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
              this[offset] = (value & 0xff);
              return offset + 1
            };

            function objectWriteUInt16$1 (buf, value, offset, littleEndian) {
              if (value < 0) value = 0xffff + value + 1;
              for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
                buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
                  (littleEndian ? i : 1 - i) * 8;
              }
            }

            Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt$1(this, value, offset, 2, 0xffff, 0);
              if (Buffer$1.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff);
                this[offset + 1] = (value >>> 8);
              } else {
                objectWriteUInt16$1(this, value, offset, true);
              }
              return offset + 2
            };

            Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt$1(this, value, offset, 2, 0xffff, 0);
              if (Buffer$1.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 8);
                this[offset + 1] = (value & 0xff);
              } else {
                objectWriteUInt16$1(this, value, offset, false);
              }
              return offset + 2
            };

            function objectWriteUInt32$1 (buf, value, offset, littleEndian) {
              if (value < 0) value = 0xffffffff + value + 1;
              for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
                buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
              }
            }

            Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt$1(this, value, offset, 4, 0xffffffff, 0);
              if (Buffer$1.TYPED_ARRAY_SUPPORT) {
                this[offset + 3] = (value >>> 24);
                this[offset + 2] = (value >>> 16);
                this[offset + 1] = (value >>> 8);
                this[offset] = (value & 0xff);
              } else {
                objectWriteUInt32$1(this, value, offset, true);
              }
              return offset + 4
            };

            Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt$1(this, value, offset, 4, 0xffffffff, 0);
              if (Buffer$1.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 24);
                this[offset + 1] = (value >>> 16);
                this[offset + 2] = (value >>> 8);
                this[offset + 3] = (value & 0xff);
              } else {
                objectWriteUInt32$1(this, value, offset, false);
              }
              return offset + 4
            };

            Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);

                checkInt$1(this, value, offset, byteLength, limit - 1, -limit);
              }

              var i = 0;
              var mul = 1;
              var sub = 0;
              this[offset] = value & 0xFF;
              while (++i < byteLength && (mul *= 0x100)) {
                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
              }

              return offset + byteLength
            };

            Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);

                checkInt$1(this, value, offset, byteLength, limit - 1, -limit);
              }

              var i = byteLength - 1;
              var mul = 1;
              var sub = 0;
              this[offset + i] = value & 0xFF;
              while (--i >= 0 && (mul *= 0x100)) {
                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                  sub = 1;
                }
                this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
              }

              return offset + byteLength
            };

            Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt$1(this, value, offset, 1, 0x7f, -0x80);
              if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
              if (value < 0) value = 0xff + value + 1;
              this[offset] = (value & 0xff);
              return offset + 1
            };

            Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt$1(this, value, offset, 2, 0x7fff, -0x8000);
              if (Buffer$1.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff);
                this[offset + 1] = (value >>> 8);
              } else {
                objectWriteUInt16$1(this, value, offset, true);
              }
              return offset + 2
            };

            Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt$1(this, value, offset, 2, 0x7fff, -0x8000);
              if (Buffer$1.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 8);
                this[offset + 1] = (value & 0xff);
              } else {
                objectWriteUInt16$1(this, value, offset, false);
              }
              return offset + 2
            };

            Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt$1(this, value, offset, 4, 0x7fffffff, -0x80000000);
              if (Buffer$1.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff);
                this[offset + 1] = (value >>> 8);
                this[offset + 2] = (value >>> 16);
                this[offset + 3] = (value >>> 24);
              } else {
                objectWriteUInt32$1(this, value, offset, true);
              }
              return offset + 4
            };

            Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
              value = +value;
              offset = offset | 0;
              if (!noAssert) checkInt$1(this, value, offset, 4, 0x7fffffff, -0x80000000);
              if (value < 0) value = 0xffffffff + value + 1;
              if (Buffer$1.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 24);
                this[offset + 1] = (value >>> 16);
                this[offset + 2] = (value >>> 8);
                this[offset + 3] = (value & 0xff);
              } else {
                objectWriteUInt32$1(this, value, offset, false);
              }
              return offset + 4
            };

            function checkIEEE754$1 (buf, value, offset, ext, max, min) {
              if (offset + ext > buf.length) throw new RangeError('Index out of range')
              if (offset < 0) throw new RangeError('Index out of range')
            }

            function writeFloat$1 (buf, value, offset, littleEndian, noAssert) {
              if (!noAssert) {
                checkIEEE754$1(buf, value, offset, 4);
              }
              write$2(buf, value, offset, littleEndian, 23, 4);
              return offset + 4
            }

            Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
              return writeFloat$1(this, value, offset, true, noAssert)
            };

            Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
              return writeFloat$1(this, value, offset, false, noAssert)
            };

            function writeDouble$1 (buf, value, offset, littleEndian, noAssert) {
              if (!noAssert) {
                checkIEEE754$1(buf, value, offset, 8);
              }
              write$2(buf, value, offset, littleEndian, 52, 8);
              return offset + 8
            }

            Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
              return writeDouble$1(this, value, offset, true, noAssert)
            };

            Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
              return writeDouble$1(this, value, offset, false, noAssert)
            };

            // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
            Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
              if (!start) start = 0;
              if (!end && end !== 0) end = this.length;
              if (targetStart >= target.length) targetStart = target.length;
              if (!targetStart) targetStart = 0;
              if (end > 0 && end < start) end = start;

              // Copy 0 bytes; we're done
              if (end === start) return 0
              if (target.length === 0 || this.length === 0) return 0

              // Fatal error conditions
              if (targetStart < 0) {
                throw new RangeError('targetStart out of bounds')
              }
              if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
              if (end < 0) throw new RangeError('sourceEnd out of bounds')

              // Are we oob?
              if (end > this.length) end = this.length;
              if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
              }

              var len = end - start;
              var i;

              if (this === target && start < targetStart && targetStart < end) {
                // descending copy from end
                for (i = len - 1; i >= 0; --i) {
                  target[i + targetStart] = this[i + start];
                }
              } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
                // ascending copy from start
                for (i = 0; i < len; ++i) {
                  target[i + targetStart] = this[i + start];
                }
              } else {
                Uint8Array.prototype.set.call(
                  target,
                  this.subarray(start, start + len),
                  targetStart
                );
              }

              return len
            };

            // Usage:
            //    buffer.fill(number[, offset[, end]])
            //    buffer.fill(buffer[, offset[, end]])
            //    buffer.fill(string[, offset[, end]][, encoding])
            Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
              // Handle string cases:
              if (typeof val === 'string') {
                if (typeof start === 'string') {
                  encoding = start;
                  start = 0;
                  end = this.length;
                } else if (typeof end === 'string') {
                  encoding = end;
                  end = this.length;
                }
                if (val.length === 1) {
                  var code = val.charCodeAt(0);
                  if (code < 256) {
                    val = code;
                  }
                }
                if (encoding !== undefined && typeof encoding !== 'string') {
                  throw new TypeError('encoding must be a string')
                }
                if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
                  throw new TypeError('Unknown encoding: ' + encoding)
                }
              } else if (typeof val === 'number') {
                val = val & 255;
              }

              // Invalid ranges are not set to a default, so can range check early.
              if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError('Out of range index')
              }

              if (end <= start) {
                return this
              }

              start = start >>> 0;
              end = end === undefined ? this.length : end >>> 0;

              if (!val) val = 0;

              var i;
              if (typeof val === 'number') {
                for (i = start; i < end; ++i) {
                  this[i] = val;
                }
              } else {
                var bytes = internalIsBuffer$1(val)
                  ? val
                  : utf8ToBytes$1(new Buffer$1(val, encoding).toString());
                var len = bytes.length;
                for (i = 0; i < end - start; ++i) {
                  this[i + start] = bytes[i % len];
                }
              }

              return this
            };

            // HELPER FUNCTIONS
            // ================

            var INVALID_BASE64_RE$1 = /[^+\/0-9A-Za-z-_]/g;

            function base64clean$1 (str) {
              // Node strips out invalid characters like \n and \t from the string, base64-js does not
              str = stringtrim$1(str).replace(INVALID_BASE64_RE$1, '');
              // Node converts strings with length < 2 to ''
              if (str.length < 2) return ''
              // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
              while (str.length % 4 !== 0) {
                str = str + '=';
              }
              return str
            }

            function stringtrim$1 (str) {
              if (str.trim) return str.trim()
              return str.replace(/^\s+|\s+$/g, '')
            }

            function toHex$1 (n) {
              if (n < 16) return '0' + n.toString(16)
              return n.toString(16)
            }

            function utf8ToBytes$1 (string, units) {
              units = units || Infinity;
              var codePoint;
              var length = string.length;
              var leadSurrogate = null;
              var bytes = [];

              for (var i = 0; i < length; ++i) {
                codePoint = string.charCodeAt(i);

                // is surrogate component
                if (codePoint > 0xD7FF && codePoint < 0xE000) {
                  // last char was a lead
                  if (!leadSurrogate) {
                    // no lead yet
                    if (codePoint > 0xDBFF) {
                      // unexpected trail
                      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                      continue
                    } else if (i + 1 === length) {
                      // unpaired lead
                      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                      continue
                    }

                    // valid lead
                    leadSurrogate = codePoint;

                    continue
                  }

                  // 2 leads in a row
                  if (codePoint < 0xDC00) {
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    leadSurrogate = codePoint;
                    continue
                  }

                  // valid surrogate pair
                  codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
                } else if (leadSurrogate) {
                  // valid bmp char, but last char was a lead
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                }

                leadSurrogate = null;

                // encode utf8
                if (codePoint < 0x80) {
                  if ((units -= 1) < 0) break
                  bytes.push(codePoint);
                } else if (codePoint < 0x800) {
                  if ((units -= 2) < 0) break
                  bytes.push(
                    codePoint >> 0x6 | 0xC0,
                    codePoint & 0x3F | 0x80
                  );
                } else if (codePoint < 0x10000) {
                  if ((units -= 3) < 0) break
                  bytes.push(
                    codePoint >> 0xC | 0xE0,
                    codePoint >> 0x6 & 0x3F | 0x80,
                    codePoint & 0x3F | 0x80
                  );
                } else if (codePoint < 0x110000) {
                  if ((units -= 4) < 0) break
                  bytes.push(
                    codePoint >> 0x12 | 0xF0,
                    codePoint >> 0xC & 0x3F | 0x80,
                    codePoint >> 0x6 & 0x3F | 0x80,
                    codePoint & 0x3F | 0x80
                  );
                } else {
                  throw new Error('Invalid code point')
                }
              }

              return bytes
            }

            function asciiToBytes$1 (str) {
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                // Node's code seems to be doing this and not & 0x7F..
                byteArray.push(str.charCodeAt(i) & 0xFF);
              }
              return byteArray
            }

            function utf16leToBytes$1 (str, units) {
              var c, hi, lo;
              var byteArray = [];
              for (var i = 0; i < str.length; ++i) {
                if ((units -= 2) < 0) break

                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
              }

              return byteArray
            }


            function base64ToBytes$1 (str) {
              return toByteArray$1(base64clean$1(str))
            }

            function blitBuffer$1 (src, dst, offset, length) {
              for (var i = 0; i < length; ++i) {
                if ((i + offset >= dst.length) || (i >= src.length)) break
                dst[i + offset] = src[i];
              }
              return i
            }

            function isnan$1 (val) {
              return val !== val // eslint-disable-line no-self-compare
            }


            // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
            // The _isBuffer check is for Safari 5-7 support, because it's missing
            // Object.prototype.constructor. Remove this eventually
            function isBuffer$2(obj) {
              return obj != null && (!!obj._isBuffer || isFastBuffer$1(obj) || isSlowBuffer$1(obj))
            }

            function isFastBuffer$1 (obj) {
              return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
            }

            // For Node v0.10 support. Remove this eventually.
            function isSlowBuffer$1 (obj) {
              return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer$1(obj.slice(0, 0))
            }

            var commonjsGlobal$2 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global$1 !== 'undefined' ? global$1 : typeof self !== 'undefined' ? self : {};

            function unwrapExports$4 (x) {
            	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
            }

            function createCommonjsModule$5(fn, module) {
            	return module = { exports: {} }, fn(module, module.exports), module.exports;
            }

            var require$$0 = {};

            var opentype = createCommonjsModule$5(function (module, exports) {
            /**
             * https://opentype.js.org v0.11.0 | (c) Frederik De Bleser and other contributors | MIT License | Uses tiny-inflate by Devon Govett and string.prototype.codepointat polyfill by Mathias Bynens
             */

            (function (global, factory) {
            	 factory(exports) ;
            }(commonjsGlobal$2, (function (exports) {
            	/*! https://mths.be/codepointat v0.2.0 by @mathias */
            	if (!String.prototype.codePointAt) {
            		(function() {
            			var defineProperty = (function() {
            				// IE 8 only supports `Object.defineProperty` on DOM elements
            				try {
            					var object = {};
            					var $defineProperty = Object.defineProperty;
            					var result = $defineProperty(object, object, object) && $defineProperty;
            				} catch(error) {}
            				return result;
            			}());
            			var codePointAt = function(position) {
            				if (this == null) {
            					throw TypeError();
            				}
            				var string = String(this);
            				var size = string.length;
            				// `ToInteger`
            				var index = position ? Number(position) : 0;
            				if (index != index) { // better `isNaN`
            					index = 0;
            				}
            				// Account for out-of-bounds indices:
            				if (index < 0 || index >= size) {
            					return undefined;
            				}
            				// Get the first code unit
            				var first = string.charCodeAt(index);
            				var second;
            				if ( // check if it’s the start of a surrogate pair
            					first >= 0xD800 && first <= 0xDBFF && // high surrogate
            					size > index + 1 // there is a next code unit
            				) {
            					second = string.charCodeAt(index + 1);
            					if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
            						// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            						return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            					}
            				}
            				return first;
            			};
            			if (defineProperty) {
            				defineProperty(String.prototype, 'codePointAt', {
            					'value': codePointAt,
            					'configurable': true,
            					'writable': true
            				});
            			} else {
            				String.prototype.codePointAt = codePointAt;
            			}
            		}());
            	}

            	var TINF_OK = 0;
            	var TINF_DATA_ERROR = -3;

            	function Tree() {
            	  this.table = new Uint16Array(16);   /* table of code length counts */
            	  this.trans = new Uint16Array(288);  /* code -> symbol translation table */
            	}

            	function Data(source, dest) {
            	  this.source = source;
            	  this.sourceIndex = 0;
            	  this.tag = 0;
            	  this.bitcount = 0;
            	  
            	  this.dest = dest;
            	  this.destLen = 0;
            	  
            	  this.ltree = new Tree();  /* dynamic length/symbol tree */
            	  this.dtree = new Tree();  /* dynamic distance tree */
            	}

            	/* --------------------------------------------------- *
            	 * -- uninitialized global data (static structures) -- *
            	 * --------------------------------------------------- */

            	var sltree = new Tree();
            	var sdtree = new Tree();

            	/* extra bits and base tables for length codes */
            	var length_bits = new Uint8Array(30);
            	var length_base = new Uint16Array(30);

            	/* extra bits and base tables for distance codes */
            	var dist_bits = new Uint8Array(30);
            	var dist_base = new Uint16Array(30);

            	/* special ordering of code length codes */
            	var clcidx = new Uint8Array([
            	  16, 17, 18, 0, 8, 7, 9, 6,
            	  10, 5, 11, 4, 12, 3, 13, 2,
            	  14, 1, 15
            	]);

            	/* used by tinf_decode_trees, avoids allocations every call */
            	var code_tree = new Tree();
            	var lengths = new Uint8Array(288 + 32);

            	/* ----------------------- *
            	 * -- utility functions -- *
            	 * ----------------------- */

            	/* build extra bits and base tables */
            	function tinf_build_bits_base(bits, base, delta, first) {
            	  var i, sum;

            	  /* build bits table */
            	  for (i = 0; i < delta; ++i) { bits[i] = 0; }
            	  for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }

            	  /* build base table */
            	  for (sum = first, i = 0; i < 30; ++i) {
            	    base[i] = sum;
            	    sum += 1 << bits[i];
            	  }
            	}

            	/* build the fixed huffman trees */
            	function tinf_build_fixed_trees(lt, dt) {
            	  var i;

            	  /* build fixed length tree */
            	  for (i = 0; i < 7; ++i) { lt.table[i] = 0; }

            	  lt.table[7] = 24;
            	  lt.table[8] = 152;
            	  lt.table[9] = 112;

            	  for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }
            	  for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }
            	  for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }
            	  for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }

            	  /* build fixed distance tree */
            	  for (i = 0; i < 5; ++i) { dt.table[i] = 0; }

            	  dt.table[5] = 32;

            	  for (i = 0; i < 32; ++i) { dt.trans[i] = i; }
            	}

            	/* given an array of code lengths, build a tree */
            	var offs = new Uint16Array(16);

            	function tinf_build_tree(t, lengths, off, num) {
            	  var i, sum;

            	  /* clear code length count table */
            	  for (i = 0; i < 16; ++i) { t.table[i] = 0; }

            	  /* scan symbol lengths, and sum code length counts */
            	  for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }

            	  t.table[0] = 0;

            	  /* compute offset table for distribution sort */
            	  for (sum = 0, i = 0; i < 16; ++i) {
            	    offs[i] = sum;
            	    sum += t.table[i];
            	  }

            	  /* create code->symbol translation table (symbols sorted by code) */
            	  for (i = 0; i < num; ++i) {
            	    if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }
            	  }
            	}

            	/* ---------------------- *
            	 * -- decode functions -- *
            	 * ---------------------- */

            	/* get one bit from source stream */
            	function tinf_getbit(d) {
            	  /* check if tag is empty */
            	  if (!d.bitcount--) {
            	    /* load next tag */
            	    d.tag = d.source[d.sourceIndex++];
            	    d.bitcount = 7;
            	  }

            	  /* shift bit out of tag */
            	  var bit = d.tag & 1;
            	  d.tag >>>= 1;

            	  return bit;
            	}

            	/* read a num bit value from a stream and add base */
            	function tinf_read_bits(d, num, base) {
            	  if (!num)
            	    { return base; }

            	  while (d.bitcount < 24) {
            	    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
            	    d.bitcount += 8;
            	  }

            	  var val = d.tag & (0xffff >>> (16 - num));
            	  d.tag >>>= num;
            	  d.bitcount -= num;
            	  return val + base;
            	}

            	/* given a data stream and a tree, decode a symbol */
            	function tinf_decode_symbol(d, t) {
            	  while (d.bitcount < 24) {
            	    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
            	    d.bitcount += 8;
            	  }
            	  
            	  var sum = 0, cur = 0, len = 0;
            	  var tag = d.tag;

            	  /* get more bits while code value is above sum */
            	  do {
            	    cur = 2 * cur + (tag & 1);
            	    tag >>>= 1;
            	    ++len;

            	    sum += t.table[len];
            	    cur -= t.table[len];
            	  } while (cur >= 0);
            	  
            	  d.tag = tag;
            	  d.bitcount -= len;

            	  return t.trans[sum + cur];
            	}

            	/* given a data stream, decode dynamic trees from it */
            	function tinf_decode_trees(d, lt, dt) {
            	  var hlit, hdist, hclen;
            	  var i, num, length;

            	  /* get 5 bits HLIT (257-286) */
            	  hlit = tinf_read_bits(d, 5, 257);

            	  /* get 5 bits HDIST (1-32) */
            	  hdist = tinf_read_bits(d, 5, 1);

            	  /* get 4 bits HCLEN (4-19) */
            	  hclen = tinf_read_bits(d, 4, 4);

            	  for (i = 0; i < 19; ++i) { lengths[i] = 0; }

            	  /* read code lengths for code length alphabet */
            	  for (i = 0; i < hclen; ++i) {
            	    /* get 3 bits code length (0-7) */
            	    var clen = tinf_read_bits(d, 3, 0);
            	    lengths[clcidx[i]] = clen;
            	  }

            	  /* build code length tree */
            	  tinf_build_tree(code_tree, lengths, 0, 19);

            	  /* decode code lengths for the dynamic trees */
            	  for (num = 0; num < hlit + hdist;) {
            	    var sym = tinf_decode_symbol(d, code_tree);

            	    switch (sym) {
            	      case 16:
            	        /* copy previous code length 3-6 times (read 2 bits) */
            	        var prev = lengths[num - 1];
            	        for (length = tinf_read_bits(d, 2, 3); length; --length) {
            	          lengths[num++] = prev;
            	        }
            	        break;
            	      case 17:
            	        /* repeat code length 0 for 3-10 times (read 3 bits) */
            	        for (length = tinf_read_bits(d, 3, 3); length; --length) {
            	          lengths[num++] = 0;
            	        }
            	        break;
            	      case 18:
            	        /* repeat code length 0 for 11-138 times (read 7 bits) */
            	        for (length = tinf_read_bits(d, 7, 11); length; --length) {
            	          lengths[num++] = 0;
            	        }
            	        break;
            	      default:
            	        /* values 0-15 represent the actual code lengths */
            	        lengths[num++] = sym;
            	        break;
            	    }
            	  }

            	  /* build dynamic trees */
            	  tinf_build_tree(lt, lengths, 0, hlit);
            	  tinf_build_tree(dt, lengths, hlit, hdist);
            	}

            	/* ----------------------------- *
            	 * -- block inflate functions -- *
            	 * ----------------------------- */

            	/* given a stream and two trees, inflate a block of data */
            	function tinf_inflate_block_data(d, lt, dt) {
            	  while (1) {
            	    var sym = tinf_decode_symbol(d, lt);

            	    /* check for end of block */
            	    if (sym === 256) {
            	      return TINF_OK;
            	    }

            	    if (sym < 256) {
            	      d.dest[d.destLen++] = sym;
            	    } else {
            	      var length, dist, offs;
            	      var i;

            	      sym -= 257;

            	      /* possibly get more bits from length code */
            	      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);

            	      dist = tinf_decode_symbol(d, dt);

            	      /* possibly get more bits from distance code */
            	      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);

            	      /* copy match */
            	      for (i = offs; i < offs + length; ++i) {
            	        d.dest[d.destLen++] = d.dest[i];
            	      }
            	    }
            	  }
            	}

            	/* inflate an uncompressed block of data */
            	function tinf_inflate_uncompressed_block(d) {
            	  var length, invlength;
            	  var i;
            	  
            	  /* unread from bitbuffer */
            	  while (d.bitcount > 8) {
            	    d.sourceIndex--;
            	    d.bitcount -= 8;
            	  }

            	  /* get length */
            	  length = d.source[d.sourceIndex + 1];
            	  length = 256 * length + d.source[d.sourceIndex];

            	  /* get one's complement of length */
            	  invlength = d.source[d.sourceIndex + 3];
            	  invlength = 256 * invlength + d.source[d.sourceIndex + 2];

            	  /* check length */
            	  if (length !== (~invlength & 0x0000ffff))
            	    { return TINF_DATA_ERROR; }

            	  d.sourceIndex += 4;

            	  /* copy block */
            	  for (i = length; i; --i)
            	    { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }

            	  /* make sure we start next block on a byte boundary */
            	  d.bitcount = 0;

            	  return TINF_OK;
            	}

            	/* inflate stream from source to dest */
            	function tinf_uncompress(source, dest) {
            	  var d = new Data(source, dest);
            	  var bfinal, btype, res;

            	  do {
            	    /* read final block flag */
            	    bfinal = tinf_getbit(d);

            	    /* read block type (2 bits) */
            	    btype = tinf_read_bits(d, 2, 0);

            	    /* decompress block */
            	    switch (btype) {
            	      case 0:
            	        /* decompress uncompressed block */
            	        res = tinf_inflate_uncompressed_block(d);
            	        break;
            	      case 1:
            	        /* decompress block with fixed huffman trees */
            	        res = tinf_inflate_block_data(d, sltree, sdtree);
            	        break;
            	      case 2:
            	        /* decompress block with dynamic huffman trees */
            	        tinf_decode_trees(d, d.ltree, d.dtree);
            	        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
            	        break;
            	      default:
            	        res = TINF_DATA_ERROR;
            	    }

            	    if (res !== TINF_OK)
            	      { throw new Error('Data error'); }

            	  } while (!bfinal);

            	  if (d.destLen < d.dest.length) {
            	    if (typeof d.dest.slice === 'function')
            	      { return d.dest.slice(0, d.destLen); }
            	    else
            	      { return d.dest.subarray(0, d.destLen); }
            	  }
            	  
            	  return d.dest;
            	}

            	/* -------------------- *
            	 * -- initialization -- *
            	 * -------------------- */

            	/* build fixed huffman trees */
            	tinf_build_fixed_trees(sltree, sdtree);

            	/* build extra bits and base tables */
            	tinf_build_bits_base(length_bits, length_base, 4, 3);
            	tinf_build_bits_base(dist_bits, dist_base, 2, 1);

            	/* fix a special case */
            	length_bits[28] = 0;
            	length_base[28] = 258;

            	var tinyInflate = tinf_uncompress;

            	// The Bounding Box object

            	function derive(v0, v1, v2, v3, t) {
            	    return Math.pow(1 - t, 3) * v0 +
            	        3 * Math.pow(1 - t, 2) * t * v1 +
            	        3 * (1 - t) * Math.pow(t, 2) * v2 +
            	        Math.pow(t, 3) * v3;
            	}
            	/**
            	 * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.
            	 * It is used to calculate the bounding box of a glyph or text path.
            	 *
            	 * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.
            	 *
            	 * @exports opentype.BoundingBox
            	 * @class
            	 * @constructor
            	 */
            	function BoundingBox() {
            	    this.x1 = Number.NaN;
            	    this.y1 = Number.NaN;
            	    this.x2 = Number.NaN;
            	    this.y2 = Number.NaN;
            	}

            	/**
            	 * Returns true if the bounding box is empty, that is, no points have been added to the box yet.
            	 */
            	BoundingBox.prototype.isEmpty = function() {
            	    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
            	};

            	/**
            	 * Add the point to the bounding box.
            	 * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.
            	 * @param {number} x - The X coordinate of the point.
            	 * @param {number} y - The Y coordinate of the point.
            	 */
            	BoundingBox.prototype.addPoint = function(x, y) {
            	    if (typeof x === 'number') {
            	        if (isNaN(this.x1) || isNaN(this.x2)) {
            	            this.x1 = x;
            	            this.x2 = x;
            	        }
            	        if (x < this.x1) {
            	            this.x1 = x;
            	        }
            	        if (x > this.x2) {
            	            this.x2 = x;
            	        }
            	    }
            	    if (typeof y === 'number') {
            	        if (isNaN(this.y1) || isNaN(this.y2)) {
            	            this.y1 = y;
            	            this.y2 = y;
            	        }
            	        if (y < this.y1) {
            	            this.y1 = y;
            	        }
            	        if (y > this.y2) {
            	            this.y2 = y;
            	        }
            	    }
            	};

            	/**
            	 * Add a X coordinate to the bounding box.
            	 * This extends the bounding box to include the X coordinate.
            	 * This function is used internally inside of addBezier.
            	 * @param {number} x - The X coordinate of the point.
            	 */
            	BoundingBox.prototype.addX = function(x) {
            	    this.addPoint(x, null);
            	};

            	/**
            	 * Add a Y coordinate to the bounding box.
            	 * This extends the bounding box to include the Y coordinate.
            	 * This function is used internally inside of addBezier.
            	 * @param {number} y - The Y coordinate of the point.
            	 */
            	BoundingBox.prototype.addY = function(y) {
            	    this.addPoint(null, y);
            	};

            	/**
            	 * Add a Bézier curve to the bounding box.
            	 * This extends the bounding box to include the entire Bézier.
            	 * @param {number} x0 - The starting X coordinate.
            	 * @param {number} y0 - The starting Y coordinate.
            	 * @param {number} x1 - The X coordinate of the first control point.
            	 * @param {number} y1 - The Y coordinate of the first control point.
            	 * @param {number} x2 - The X coordinate of the second control point.
            	 * @param {number} y2 - The Y coordinate of the second control point.
            	 * @param {number} x - The ending X coordinate.
            	 * @param {number} y - The ending Y coordinate.
            	 */
            	BoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {
            	    var this$1 = this;

            	    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html
            	    // and https://github.com/icons8/svg-path-bounding-box

            	    var p0 = [x0, y0];
            	    var p1 = [x1, y1];
            	    var p2 = [x2, y2];
            	    var p3 = [x, y];

            	    this.addPoint(x0, y0);
            	    this.addPoint(x, y);

            	    for (var i = 0; i <= 1; i++) {
            	        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
            	        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
            	        var c = 3 * p1[i] - 3 * p0[i];

            	        if (a === 0) {
            	            if (b === 0) { continue; }
            	            var t = -c / b;
            	            if (0 < t && t < 1) {
            	                if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t)); }
            	                if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t)); }
            	            }
            	            continue;
            	        }

            	        var b2ac = Math.pow(b, 2) - 4 * c * a;
            	        if (b2ac < 0) { continue; }
            	        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
            	        if (0 < t1 && t1 < 1) {
            	            if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
            	            if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
            	        }
            	        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
            	        if (0 < t2 && t2 < 1) {
            	            if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
            	            if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
            	        }
            	    }
            	};

            	/**
            	 * Add a quadratic curve to the bounding box.
            	 * This extends the bounding box to include the entire quadratic curve.
            	 * @param {number} x0 - The starting X coordinate.
            	 * @param {number} y0 - The starting Y coordinate.
            	 * @param {number} x1 - The X coordinate of the control point.
            	 * @param {number} y1 - The Y coordinate of the control point.
            	 * @param {number} x - The ending X coordinate.
            	 * @param {number} y - The ending Y coordinate.
            	 */
            	BoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {
            	    var cp1x = x0 + 2 / 3 * (x1 - x0);
            	    var cp1y = y0 + 2 / 3 * (y1 - y0);
            	    var cp2x = cp1x + 1 / 3 * (x - x0);
            	    var cp2y = cp1y + 1 / 3 * (y - y0);
            	    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
            	};

            	// Geometric objects

            	/**
            	 * A bézier path containing a set of path commands similar to a SVG path.
            	 * Paths can be drawn on a context using `draw`.
            	 * @exports opentype.Path
            	 * @class
            	 * @constructor
            	 */
            	function Path() {
            	    this.commands = [];
            	    this.fill = 'black';
            	    this.stroke = null;
            	    this.strokeWidth = 1;
            	}

            	/**
            	 * @param  {number} x
            	 * @param  {number} y
            	 */
            	Path.prototype.moveTo = function(x, y) {
            	    this.commands.push({
            	        type: 'M',
            	        x: x,
            	        y: y
            	    });
            	};

            	/**
            	 * @param  {number} x
            	 * @param  {number} y
            	 */
            	Path.prototype.lineTo = function(x, y) {
            	    this.commands.push({
            	        type: 'L',
            	        x: x,
            	        y: y
            	    });
            	};

            	/**
            	 * Draws cubic curve
            	 * @function
            	 * curveTo
            	 * @memberof opentype.Path.prototype
            	 * @param  {number} x1 - x of control 1
            	 * @param  {number} y1 - y of control 1
            	 * @param  {number} x2 - x of control 2
            	 * @param  {number} y2 - y of control 2
            	 * @param  {number} x - x of path point
            	 * @param  {number} y - y of path point
            	 */

            	/**
            	 * Draws cubic curve
            	 * @function
            	 * bezierCurveTo
            	 * @memberof opentype.Path.prototype
            	 * @param  {number} x1 - x of control 1
            	 * @param  {number} y1 - y of control 1
            	 * @param  {number} x2 - x of control 2
            	 * @param  {number} y2 - y of control 2
            	 * @param  {number} x - x of path point
            	 * @param  {number} y - y of path point
            	 * @see curveTo
            	 */
            	Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
            	    this.commands.push({
            	        type: 'C',
            	        x1: x1,
            	        y1: y1,
            	        x2: x2,
            	        y2: y2,
            	        x: x,
            	        y: y
            	    });
            	};

            	/**
            	 * Draws quadratic curve
            	 * @function
            	 * quadraticCurveTo
            	 * @memberof opentype.Path.prototype
            	 * @param  {number} x1 - x of control
            	 * @param  {number} y1 - y of control
            	 * @param  {number} x - x of path point
            	 * @param  {number} y - y of path point
            	 */

            	/**
            	 * Draws quadratic curve
            	 * @function
            	 * quadTo
            	 * @memberof opentype.Path.prototype
            	 * @param  {number} x1 - x of control
            	 * @param  {number} y1 - y of control
            	 * @param  {number} x - x of path point
            	 * @param  {number} y - y of path point
            	 */
            	Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
            	    this.commands.push({
            	        type: 'Q',
            	        x1: x1,
            	        y1: y1,
            	        x: x,
            	        y: y
            	    });
            	};

            	/**
            	 * Closes the path
            	 * @function closePath
            	 * @memberof opentype.Path.prototype
            	 */

            	/**
            	 * Close the path
            	 * @function close
            	 * @memberof opentype.Path.prototype
            	 */
            	Path.prototype.close = Path.prototype.closePath = function() {
            	    this.commands.push({
            	        type: 'Z'
            	    });
            	};

            	/**
            	 * Add the given path or list of commands to the commands of this path.
            	 * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.
            	 */
            	Path.prototype.extend = function(pathOrCommands) {
            	    if (pathOrCommands.commands) {
            	        pathOrCommands = pathOrCommands.commands;
            	    } else if (pathOrCommands instanceof BoundingBox) {
            	        var box = pathOrCommands;
            	        this.moveTo(box.x1, box.y1);
            	        this.lineTo(box.x2, box.y1);
            	        this.lineTo(box.x2, box.y2);
            	        this.lineTo(box.x1, box.y2);
            	        this.close();
            	        return;
            	    }

            	    Array.prototype.push.apply(this.commands, pathOrCommands);
            	};

            	/**
            	 * Calculate the bounding box of the path.
            	 * @returns {opentype.BoundingBox}
            	 */
            	Path.prototype.getBoundingBox = function() {
            	    var this$1 = this;

            	    var box = new BoundingBox();

            	    var startX = 0;
            	    var startY = 0;
            	    var prevX = 0;
            	    var prevY = 0;
            	    for (var i = 0; i < this.commands.length; i++) {
            	        var cmd = this$1.commands[i];
            	        switch (cmd.type) {
            	            case 'M':
            	                box.addPoint(cmd.x, cmd.y);
            	                startX = prevX = cmd.x;
            	                startY = prevY = cmd.y;
            	                break;
            	            case 'L':
            	                box.addPoint(cmd.x, cmd.y);
            	                prevX = cmd.x;
            	                prevY = cmd.y;
            	                break;
            	            case 'Q':
            	                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
            	                prevX = cmd.x;
            	                prevY = cmd.y;
            	                break;
            	            case 'C':
            	                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
            	                prevX = cmd.x;
            	                prevY = cmd.y;
            	                break;
            	            case 'Z':
            	                prevX = startX;
            	                prevY = startY;
            	                break;
            	            default:
            	                throw new Error('Unexpected path command ' + cmd.type);
            	        }
            	    }
            	    if (box.isEmpty()) {
            	        box.addPoint(0, 0);
            	    }
            	    return box;
            	};

            	/**
            	 * Draw the path to a 2D context.
            	 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.
            	 */
            	Path.prototype.draw = function(ctx) {
            	    var this$1 = this;

            	    ctx.beginPath();
            	    for (var i = 0; i < this.commands.length; i += 1) {
            	        var cmd = this$1.commands[i];
            	        if (cmd.type === 'M') {
            	            ctx.moveTo(cmd.x, cmd.y);
            	        } else if (cmd.type === 'L') {
            	            ctx.lineTo(cmd.x, cmd.y);
            	        } else if (cmd.type === 'C') {
            	            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
            	        } else if (cmd.type === 'Q') {
            	            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
            	        } else if (cmd.type === 'Z') {
            	            ctx.closePath();
            	        }
            	    }

            	    if (this.fill) {
            	        ctx.fillStyle = this.fill;
            	        ctx.fill();
            	    }

            	    if (this.stroke) {
            	        ctx.strokeStyle = this.stroke;
            	        ctx.lineWidth = this.strokeWidth;
            	        ctx.stroke();
            	    }
            	};

            	/**
            	 * Convert the Path to a string of path data instructions
            	 * See http://www.w3.org/TR/SVG/paths.html#PathData
            	 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
            	 * @return {string}
            	 */
            	Path.prototype.toPathData = function(decimalPlaces) {
            	    var this$1 = this;

            	    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;

            	    function floatToString(v) {
            	        if (Math.round(v) === v) {
            	            return '' + Math.round(v);
            	        } else {
            	            return v.toFixed(decimalPlaces);
            	        }
            	    }

            	    function packValues() {
            	        var arguments$1 = arguments;

            	        var s = '';
            	        for (var i = 0; i < arguments.length; i += 1) {
            	            var v = arguments$1[i];
            	            if (v >= 0 && i > 0) {
            	                s += ' ';
            	            }

            	            s += floatToString(v);
            	        }

            	        return s;
            	    }

            	    var d = '';
            	    for (var i = 0; i < this.commands.length; i += 1) {
            	        var cmd = this$1.commands[i];
            	        if (cmd.type === 'M') {
            	            d += 'M' + packValues(cmd.x, cmd.y);
            	        } else if (cmd.type === 'L') {
            	            d += 'L' + packValues(cmd.x, cmd.y);
            	        } else if (cmd.type === 'C') {
            	            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
            	        } else if (cmd.type === 'Q') {
            	            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
            	        } else if (cmd.type === 'Z') {
            	            d += 'Z';
            	        }
            	    }

            	    return d;
            	};

            	/**
            	 * Convert the path to an SVG <path> element, as a string.
            	 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
            	 * @return {string}
            	 */
            	Path.prototype.toSVG = function(decimalPlaces) {
            	    var svg = '<path d="';
            	    svg += this.toPathData(decimalPlaces);
            	    svg += '"';
            	    if (this.fill && this.fill !== 'black') {
            	        if (this.fill === null) {
            	            svg += ' fill="none"';
            	        } else {
            	            svg += ' fill="' + this.fill + '"';
            	        }
            	    }

            	    if (this.stroke) {
            	        svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
            	    }

            	    svg += '/>';
            	    return svg;
            	};

            	/**
            	 * Convert the path to a DOM element.
            	 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
            	 * @return {SVGPathElement}
            	 */
            	Path.prototype.toDOMElement = function(decimalPlaces) {
            	    var temporaryPath = this.toPathData(decimalPlaces);
            	    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');

            	    newPath.setAttribute('d', temporaryPath);

            	    return newPath;
            	};

            	// Run-time checking of preconditions.

            	function fail(message) {
            	    throw new Error(message);
            	}

            	// Precondition function that checks if the given predicate is true.
            	// If not, it will throw an error.
            	function argument(predicate, message) {
            	    if (!predicate) {
            	        fail(message);
            	    }
            	}
            	var check = { fail: fail, argument: argument, assert: argument };

            	// Data types used in the OpenType font file.

            	var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
            	var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31

            	/**
            	 * @exports opentype.decode
            	 * @class
            	 */
            	var decode = {};
            	/**
            	 * @exports opentype.encode
            	 * @class
            	 */
            	var encode = {};
            	/**
            	 * @exports opentype.sizeOf
            	 * @class
            	 */
            	var sizeOf = {};

            	// Return a function that always returns the same value.
            	function constant(v) {
            	    return function() {
            	        return v;
            	    };
            	}

            	// OpenType data types //////////////////////////////////////////////////////

            	/**
            	 * Convert an 8-bit unsigned integer to a list of 1 byte.
            	 * @param {number}
            	 * @returns {Array}
            	 */
            	encode.BYTE = function(v) {
            	    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
            	    return [v];
            	};
            	/**
            	 * @constant
            	 * @type {number}
            	 */
            	sizeOf.BYTE = constant(1);

            	/**
            	 * Convert a 8-bit signed integer to a list of 1 byte.
            	 * @param {string}
            	 * @returns {Array}
            	 */
            	encode.CHAR = function(v) {
            	    return [v.charCodeAt(0)];
            	};

            	/**
            	 * @constant
            	 * @type {number}
            	 */
            	sizeOf.CHAR = constant(1);

            	/**
            	 * Convert an ASCII string to a list of bytes.
            	 * @param {string}
            	 * @returns {Array}
            	 */
            	encode.CHARARRAY = function(v) {
            	    var b = [];
            	    for (var i = 0; i < v.length; i += 1) {
            	        b[i] = v.charCodeAt(i);
            	    }

            	    return b;
            	};

            	/**
            	 * @param {Array}
            	 * @returns {number}
            	 */
            	sizeOf.CHARARRAY = function(v) {
            	    return v.length;
            	};

            	/**
            	 * Convert a 16-bit unsigned integer to a list of 2 bytes.
            	 * @param {number}
            	 * @returns {Array}
            	 */
            	encode.USHORT = function(v) {
            	    return [(v >> 8) & 0xFF, v & 0xFF];
            	};

            	/**
            	 * @constant
            	 * @type {number}
            	 */
            	sizeOf.USHORT = constant(2);

            	/**
            	 * Convert a 16-bit signed integer to a list of 2 bytes.
            	 * @param {number}
            	 * @returns {Array}
            	 */
            	encode.SHORT = function(v) {
            	    // Two's complement
            	    if (v >= LIMIT16) {
            	        v = -(2 * LIMIT16 - v);
            	    }

            	    return [(v >> 8) & 0xFF, v & 0xFF];
            	};

            	/**
            	 * @constant
            	 * @type {number}
            	 */
            	sizeOf.SHORT = constant(2);

            	/**
            	 * Convert a 24-bit unsigned integer to a list of 3 bytes.
            	 * @param {number}
            	 * @returns {Array}
            	 */
            	encode.UINT24 = function(v) {
            	    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
            	};

            	/**
            	 * @constant
            	 * @type {number}
            	 */
            	sizeOf.UINT24 = constant(3);

            	/**
            	 * Convert a 32-bit unsigned integer to a list of 4 bytes.
            	 * @param {number}
            	 * @returns {Array}
            	 */
            	encode.ULONG = function(v) {
            	    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
            	};

            	/**
            	 * @constant
            	 * @type {number}
            	 */
            	sizeOf.ULONG = constant(4);

            	/**
            	 * Convert a 32-bit unsigned integer to a list of 4 bytes.
            	 * @param {number}
            	 * @returns {Array}
            	 */
            	encode.LONG = function(v) {
            	    // Two's complement
            	    if (v >= LIMIT32) {
            	        v = -(2 * LIMIT32 - v);
            	    }

            	    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
            	};

            	/**
            	 * @constant
            	 * @type {number}
            	 */
            	sizeOf.LONG = constant(4);

            	encode.FIXED = encode.ULONG;
            	sizeOf.FIXED = sizeOf.ULONG;

            	encode.FWORD = encode.SHORT;
            	sizeOf.FWORD = sizeOf.SHORT;

            	encode.UFWORD = encode.USHORT;
            	sizeOf.UFWORD = sizeOf.USHORT;

            	/**
            	 * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.
            	 * @param {number}
            	 * @returns {Array}
            	 */
            	encode.LONGDATETIME = function(v) {
            	    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
            	};

            	/**
            	 * @constant
            	 * @type {number}
            	 */
            	sizeOf.LONGDATETIME = constant(8);

            	/**
            	 * Convert a 4-char tag to a list of 4 bytes.
            	 * @param {string}
            	 * @returns {Array}
            	 */
            	encode.TAG = function(v) {
            	    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
            	    return [v.charCodeAt(0),
            	            v.charCodeAt(1),
            	            v.charCodeAt(2),
            	            v.charCodeAt(3)];
            	};

            	/**
            	 * @constant
            	 * @type {number}
            	 */
            	sizeOf.TAG = constant(4);

            	// CFF data types ///////////////////////////////////////////////////////////

            	encode.Card8 = encode.BYTE;
            	sizeOf.Card8 = sizeOf.BYTE;

            	encode.Card16 = encode.USHORT;
            	sizeOf.Card16 = sizeOf.USHORT;

            	encode.OffSize = encode.BYTE;
            	sizeOf.OffSize = sizeOf.BYTE;

            	encode.SID = encode.USHORT;
            	sizeOf.SID = sizeOf.USHORT;

            	// Convert a numeric operand or charstring number to a variable-size list of bytes.
            	/**
            	 * Convert a numeric operand or charstring number to a variable-size list of bytes.
            	 * @param {number}
            	 * @returns {Array}
            	 */
            	encode.NUMBER = function(v) {
            	    if (v >= -107 && v <= 107) {
            	        return [v + 139];
            	    } else if (v >= 108 && v <= 1131) {
            	        v = v - 108;
            	        return [(v >> 8) + 247, v & 0xFF];
            	    } else if (v >= -1131 && v <= -108) {
            	        v = -v - 108;
            	        return [(v >> 8) + 251, v & 0xFF];
            	    } else if (v >= -32768 && v <= 32767) {
            	        return encode.NUMBER16(v);
            	    } else {
            	        return encode.NUMBER32(v);
            	    }
            	};

            	/**
            	 * @param {number}
            	 * @returns {number}
            	 */
            	sizeOf.NUMBER = function(v) {
            	    return encode.NUMBER(v).length;
            	};

            	/**
            	 * Convert a signed number between -32768 and +32767 to a three-byte value.
            	 * This ensures we always use three bytes, but is not the most compact format.
            	 * @param {number}
            	 * @returns {Array}
            	 */
            	encode.NUMBER16 = function(v) {
            	    return [28, (v >> 8) & 0xFF, v & 0xFF];
            	};

            	/**
            	 * @constant
            	 * @type {number}
            	 */
            	sizeOf.NUMBER16 = constant(3);

            	/**
            	 * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.
            	 * This is useful if you want to be sure you always use four bytes,
            	 * at the expense of wasting a few bytes for smaller numbers.
            	 * @param {number}
            	 * @returns {Array}
            	 */
            	encode.NUMBER32 = function(v) {
            	    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
            	};

            	/**
            	 * @constant
            	 * @type {number}
            	 */
            	sizeOf.NUMBER32 = constant(5);

            	/**
            	 * @param {number}
            	 * @returns {Array}
            	 */
            	encode.REAL = function(v) {
            	    var value = v.toString();

            	    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)
            	    // This code converts it back to a number without the epsilon.
            	    var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
            	    if (m) {
            	        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
            	        value = (Math.round(v * epsilon) / epsilon).toString();
            	    }

            	    var nibbles = '';
            	    for (var i = 0, ii = value.length; i < ii; i += 1) {
            	        var c = value[i];
            	        if (c === 'e') {
            	            nibbles += value[++i] === '-' ? 'c' : 'b';
            	        } else if (c === '.') {
            	            nibbles += 'a';
            	        } else if (c === '-') {
            	            nibbles += 'e';
            	        } else {
            	            nibbles += c;
            	        }
            	    }

            	    nibbles += (nibbles.length & 1) ? 'f' : 'ff';
            	    var out = [30];
            	    for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {
            	        out.push(parseInt(nibbles.substr(i$1, 2), 16));
            	    }

            	    return out;
            	};

            	/**
            	 * @param {number}
            	 * @returns {number}
            	 */
            	sizeOf.REAL = function(v) {
            	    return encode.REAL(v).length;
            	};

            	encode.NAME = encode.CHARARRAY;
            	sizeOf.NAME = sizeOf.CHARARRAY;

            	encode.STRING = encode.CHARARRAY;
            	sizeOf.STRING = sizeOf.CHARARRAY;

            	/**
            	 * @param {DataView} data
            	 * @param {number} offset
            	 * @param {number} numBytes
            	 * @returns {string}
            	 */
            	decode.UTF8 = function(data, offset, numBytes) {
            	    var codePoints = [];
            	    var numChars = numBytes;
            	    for (var j = 0; j < numChars; j++, offset += 1) {
            	        codePoints[j] = data.getUint8(offset);
            	    }

            	    return String.fromCharCode.apply(null, codePoints);
            	};

            	/**
            	 * @param {DataView} data
            	 * @param {number} offset
            	 * @param {number} numBytes
            	 * @returns {string}
            	 */
            	decode.UTF16 = function(data, offset, numBytes) {
            	    var codePoints = [];
            	    var numChars = numBytes / 2;
            	    for (var j = 0; j < numChars; j++, offset += 2) {
            	        codePoints[j] = data.getUint16(offset);
            	    }

            	    return String.fromCharCode.apply(null, codePoints);
            	};

            	/**
            	 * Convert a JavaScript string to UTF16-BE.
            	 * @param {string}
            	 * @returns {Array}
            	 */
            	encode.UTF16 = function(v) {
            	    var b = [];
            	    for (var i = 0; i < v.length; i += 1) {
            	        var codepoint = v.charCodeAt(i);
            	        b[b.length] = (codepoint >> 8) & 0xFF;
            	        b[b.length] = codepoint & 0xFF;
            	    }

            	    return b;
            	};

            	/**
            	 * @param {string}
            	 * @returns {number}
            	 */
            	sizeOf.UTF16 = function(v) {
            	    return v.length * 2;
            	};

            	// Data for converting old eight-bit Macintosh encodings to Unicode.
            	// This representation is optimized for decoding; encoding is slower
            	// and needs more memory. The assumption is that all opentype.js users
            	// want to open fonts, but saving a font will be comparatively rare
            	// so it can be more expensive. Keyed by IANA character set name.
            	//
            	// Python script for generating these strings:
            	//
            	//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])
            	//     print(s.encode('utf-8'))
            	/**
            	 * @private
            	 */
            	var eightBitMacEncodings = {
            	    'x-mac-croatian':  // Python: 'mac_croatian'
            	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø' +
            	    '¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ',
            	    'x-mac-cyrillic':  // Python: 'mac_cyrillic'
            	    'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњ' +
            	    'јЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю',
            	    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
            	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæø' +
            	    'ṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ',
            	    'x-mac-greek':  // Python: 'mac_greek'
            	    'Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩ' +
            	    'άΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\u00AD',
            	    'x-mac-icelandic':  // Python: 'mac_iceland'
            	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
            	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
            	    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
            	    'ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ' +
            	    'ᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł',
            	    'x-mac-ce':  // Python: 'mac_latin2'
            	    'ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ' +
            	    'ņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ',
            	    macintosh:  // Python: 'mac_roman'
            	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
            	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
            	    'x-mac-romanian':  // Python: 'mac_romanian'
            	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș' +
            	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
            	    'x-mac-turkish':  // Python: 'mac_turkish'
            	    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
            	    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ'
            	};

            	/**
            	 * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript
            	 * string, or 'undefined' if the encoding is unsupported. For example, we do
            	 * not support Chinese, Japanese or Korean because these would need large
            	 * mapping tables.
            	 * @param {DataView} dataView
            	 * @param {number} offset
            	 * @param {number} dataLength
            	 * @param {string} encoding
            	 * @returns {string}
            	 */
            	decode.MACSTRING = function(dataView, offset, dataLength, encoding) {
            	    var table = eightBitMacEncodings[encoding];
            	    if (table === undefined) {
            	        return undefined;
            	    }

            	    var result = '';
            	    for (var i = 0; i < dataLength; i++) {
            	        var c = dataView.getUint8(offset + i);
            	        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
            	        // mapped to U+0000..U+007F; we only need to look up the others.
            	        if (c <= 0x7F) {
            	            result += String.fromCharCode(c);
            	        } else {
            	            result += table[c & 0x7F];
            	        }
            	    }

            	    return result;
            	};

            	// Helper function for encode.MACSTRING. Returns a dictionary for mapping
            	// Unicode character codes to their 8-bit MacOS equivalent. This table
            	// is not exactly a super cheap data structure, but we do not care because
            	// encoding Macintosh strings is only rarely needed in typical applications.
            	var macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();
            	var macEncodingCacheKeys;
            	var getMacEncodingTable = function (encoding) {
            	    // Since we use encoding as a cache key for WeakMap, it has to be
            	    // a String object and not a literal. And at least on NodeJS 2.10.1,
            	    // WeakMap requires that the same String instance is passed for cache hits.
            	    if (!macEncodingCacheKeys) {
            	        macEncodingCacheKeys = {};
            	        for (var e in eightBitMacEncodings) {
            	            /*jshint -W053 */  // Suppress "Do not use String as a constructor."
            	            macEncodingCacheKeys[e] = new String(e);
            	        }
            	    }

            	    var cacheKey = macEncodingCacheKeys[encoding];
            	    if (cacheKey === undefined) {
            	        return undefined;
            	    }

            	    // We can't do "if (cache.has(key)) {return cache.get(key)}" here:
            	    // since garbage collection may run at any time, it could also kick in
            	    // between the calls to cache.has() and cache.get(). In that case,
            	    // we would return 'undefined' even though we do support the encoding.
            	    if (macEncodingTableCache) {
            	        var cachedTable = macEncodingTableCache.get(cacheKey);
            	        if (cachedTable !== undefined) {
            	            return cachedTable;
            	        }
            	    }

            	    var decodingTable = eightBitMacEncodings[encoding];
            	    if (decodingTable === undefined) {
            	        return undefined;
            	    }

            	    var encodingTable = {};
            	    for (var i = 0; i < decodingTable.length; i++) {
            	        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;
            	    }

            	    if (macEncodingTableCache) {
            	        macEncodingTableCache.set(cacheKey, encodingTable);
            	    }

            	    return encodingTable;
            	};

            	/**
            	 * Encodes an old-style Macintosh string. Returns a byte array upon success.
            	 * If the requested encoding is unsupported, or if the input string contains
            	 * a character that cannot be expressed in the encoding, the function returns
            	 * 'undefined'.
            	 * @param {string} str
            	 * @param {string} encoding
            	 * @returns {Array}
            	 */
            	encode.MACSTRING = function(str, encoding) {
            	    var table = getMacEncodingTable(encoding);
            	    if (table === undefined) {
            	        return undefined;
            	    }

            	    var result = [];
            	    for (var i = 0; i < str.length; i++) {
            	        var c = str.charCodeAt(i);

            	        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
            	        // mapped to U+0000..U+007F; we only need to look up the others.
            	        if (c >= 0x80) {
            	            c = table[c];
            	            if (c === undefined) {
            	                // str contains a Unicode character that cannot be encoded
            	                // in the requested encoding.
            	                return undefined;
            	            }
            	        }
            	        result[i] = c;
            	        // result.push(c);
            	    }

            	    return result;
            	};

            	/**
            	 * @param {string} str
            	 * @param {string} encoding
            	 * @returns {number}
            	 */
            	sizeOf.MACSTRING = function(str, encoding) {
            	    var b = encode.MACSTRING(str, encoding);
            	    if (b !== undefined) {
            	        return b.length;
            	    } else {
            	        return 0;
            	    }
            	};

            	// Helper for encode.VARDELTAS
            	function isByteEncodable(value) {
            	    return value >= -128 && value <= 127;
            	}

            	// Helper for encode.VARDELTAS
            	function encodeVarDeltaRunAsZeroes(deltas, pos, result) {
            	    var runLength = 0;
            	    var numDeltas = deltas.length;
            	    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {
            	        ++pos;
            	        ++runLength;
            	    }
            	    result.push(0x80 | (runLength - 1));
            	    return pos;
            	}

            	// Helper for encode.VARDELTAS
            	function encodeVarDeltaRunAsBytes(deltas, offset, result) {
            	    var runLength = 0;
            	    var numDeltas = deltas.length;
            	    var pos = offset;
            	    while (pos < numDeltas && runLength < 64) {
            	        var value = deltas[pos];
            	        if (!isByteEncodable(value)) {
            	            break;
            	        }

            	        // Within a byte-encoded run of deltas, a single zero is best
            	        // stored literally as 0x00 value. However, if we have two or
            	        // more zeroes in a sequence, it is better to start a new run.
            	        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]
            	        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero
            	        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)
            	        // when starting a new run.
            	        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {
            	            break;
            	        }

            	        ++pos;
            	        ++runLength;
            	    }
            	    result.push(runLength - 1);
            	    for (var i = offset; i < pos; ++i) {
            	        result.push((deltas[i] + 256) & 0xff);
            	    }
            	    return pos;
            	}

            	// Helper for encode.VARDELTAS
            	function encodeVarDeltaRunAsWords(deltas, offset, result) {
            	    var runLength = 0;
            	    var numDeltas = deltas.length;
            	    var pos = offset;
            	    while (pos < numDeltas && runLength < 64) {
            	        var value = deltas[pos];

            	        // Within a word-encoded run of deltas, it is easiest to start
            	        // a new run (with a different encoding) whenever we encounter
            	        // a zero value. For example, the sequence [0x6666, 0, 0x7777]
            	        // needs 7 bytes when storing the zero inside the current run
            	        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a
            	        // new run (40 66 66 80 40 77 77).
            	        if (value === 0) {
            	            break;
            	        }

            	        // Within a word-encoded run of deltas, a single value in the
            	        // range (-128..127) should be encoded within the current run
            	        // because it is more compact. For example, the sequence
            	        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value
            	        // literally (42 66 66 00 02 77 77), but 8 bytes when starting
            	        // a new run (40 66 66 00 02 40 77 77).
            	        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {
            	            break;
            	        }

            	        ++pos;
            	        ++runLength;
            	    }
            	    result.push(0x40 | (runLength - 1));
            	    for (var i = offset; i < pos; ++i) {
            	        var val = deltas[i];
            	        result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);
            	    }
            	    return pos;
            	}

            	/**
            	 * Encode a list of variation adjustment deltas.
            	 *
            	 * Variation adjustment deltas are used in ‘gvar’ and ‘cvar’ tables.
            	 * They indicate how points (in ‘gvar’) or values (in ‘cvar’) get adjusted
            	 * when generating instances of variation fonts.
            	 *
            	 * @see https://www.microsoft.com/typography/otspec/gvar.htm
            	 * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html
            	 * @param {Array}
            	 * @return {Array}
            	 */
            	encode.VARDELTAS = function(deltas) {
            	    var pos = 0;
            	    var result = [];
            	    while (pos < deltas.length) {
            	        var value = deltas[pos];
            	        if (value === 0) {
            	            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);
            	        } else if (value >= -128 && value <= 127) {
            	            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);
            	        } else {
            	            pos = encodeVarDeltaRunAsWords(deltas, pos, result);
            	        }
            	    }
            	    return result;
            	};

            	// Convert a list of values to a CFF INDEX structure.
            	// The values should be objects containing name / type / value.
            	/**
            	 * @param {Array} l
            	 * @returns {Array}
            	 */
            	encode.INDEX = function(l) {
            	    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
            	    //    i, v;
            	    // Because we have to know which data type to use to encode the offsets,
            	    // we have to go through the values twice: once to encode the data and
            	    // calculate the offsets, then again to encode the offsets using the fitting data type.
            	    var offset = 1; // First offset is always 1.
            	    var offsets = [offset];
            	    var data = [];
            	    for (var i = 0; i < l.length; i += 1) {
            	        var v = encode.OBJECT(l[i]);
            	        Array.prototype.push.apply(data, v);
            	        offset += v.length;
            	        offsets.push(offset);
            	    }

            	    if (data.length === 0) {
            	        return [0, 0];
            	    }

            	    var encodedOffsets = [];
            	    var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;
            	    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
            	    for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {
            	        var encodedOffset = offsetEncoder(offsets[i$1]);
            	        Array.prototype.push.apply(encodedOffsets, encodedOffset);
            	    }

            	    return Array.prototype.concat(encode.Card16(l.length),
            	                           encode.OffSize(offSize),
            	                           encodedOffsets,
            	                           data);
            	};

            	/**
            	 * @param {Array}
            	 * @returns {number}
            	 */
            	sizeOf.INDEX = function(v) {
            	    return encode.INDEX(v).length;
            	};

            	/**
            	 * Convert an object to a CFF DICT structure.
            	 * The keys should be numeric.
            	 * The values should be objects containing name / type / value.
            	 * @param {Object} m
            	 * @returns {Array}
            	 */
            	encode.DICT = function(m) {
            	    var d = [];
            	    var keys = Object.keys(m);
            	    var length = keys.length;

            	    for (var i = 0; i < length; i += 1) {
            	        // Object.keys() return string keys, but our keys are always numeric.
            	        var k = parseInt(keys[i], 0);
            	        var v = m[k];
            	        // Value comes before the key.
            	        d = d.concat(encode.OPERAND(v.value, v.type));
            	        d = d.concat(encode.OPERATOR(k));
            	    }

            	    return d;
            	};

            	/**
            	 * @param {Object}
            	 * @returns {number}
            	 */
            	sizeOf.DICT = function(m) {
            	    return encode.DICT(m).length;
            	};

            	/**
            	 * @param {number}
            	 * @returns {Array}
            	 */
            	encode.OPERATOR = function(v) {
            	    if (v < 1200) {
            	        return [v];
            	    } else {
            	        return [12, v - 1200];
            	    }
            	};

            	/**
            	 * @param {Array} v
            	 * @param {string}
            	 * @returns {Array}
            	 */
            	encode.OPERAND = function(v, type) {
            	    var d = [];
            	    if (Array.isArray(type)) {
            	        for (var i = 0; i < type.length; i += 1) {
            	            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);
            	            d = d.concat(encode.OPERAND(v[i], type[i]));
            	        }
            	    } else {
            	        if (type === 'SID') {
            	            d = d.concat(encode.NUMBER(v));
            	        } else if (type === 'offset') {
            	            // We make it easy for ourselves and always encode offsets as
            	            // 4 bytes. This makes offset calculation for the top dict easier.
            	            d = d.concat(encode.NUMBER32(v));
            	        } else if (type === 'number') {
            	            d = d.concat(encode.NUMBER(v));
            	        } else if (type === 'real') {
            	            d = d.concat(encode.REAL(v));
            	        } else {
            	            throw new Error('Unknown operand type ' + type);
            	            // FIXME Add support for booleans
            	        }
            	    }

            	    return d;
            	};

            	encode.OP = encode.BYTE;
            	sizeOf.OP = sizeOf.BYTE;

            	// memoize charstring encoding using WeakMap if available
            	var wmm = typeof WeakMap === 'function' && new WeakMap();

            	/**
            	 * Convert a list of CharString operations to bytes.
            	 * @param {Array}
            	 * @returns {Array}
            	 */
            	encode.CHARSTRING = function(ops) {
            	    // See encode.MACSTRING for why we don't do "if (wmm && wmm.has(ops))".
            	    if (wmm) {
            	        var cachedValue = wmm.get(ops);
            	        if (cachedValue !== undefined) {
            	            return cachedValue;
            	        }
            	    }

            	    var d = [];
            	    var length = ops.length;

            	    for (var i = 0; i < length; i += 1) {
            	        var op = ops[i];
            	        d = d.concat(encode[op.type](op.value));
            	    }

            	    if (wmm) {
            	        wmm.set(ops, d);
            	    }

            	    return d;
            	};

            	/**
            	 * @param {Array}
            	 * @returns {number}
            	 */
            	sizeOf.CHARSTRING = function(ops) {
            	    return encode.CHARSTRING(ops).length;
            	};

            	// Utility functions ////////////////////////////////////////////////////////

            	/**
            	 * Convert an object containing name / type / value to bytes.
            	 * @param {Object}
            	 * @returns {Array}
            	 */
            	encode.OBJECT = function(v) {
            	    var encodingFunction = encode[v.type];
            	    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
            	    return encodingFunction(v.value);
            	};

            	/**
            	 * @param {Object}
            	 * @returns {number}
            	 */
            	sizeOf.OBJECT = function(v) {
            	    var sizeOfFunction = sizeOf[v.type];
            	    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);
            	    return sizeOfFunction(v.value);
            	};

            	/**
            	 * Convert a table object to bytes.
            	 * A table contains a list of fields containing the metadata (name, type and default value).
            	 * The table itself has the field values set as attributes.
            	 * @param {opentype.Table}
            	 * @returns {Array}
            	 */
            	encode.TABLE = function(table) {
            	    var d = [];
            	    var length = table.fields.length;
            	    var subtables = [];
            	    var subtableOffsets = [];

            	    for (var i = 0; i < length; i += 1) {
            	        var field = table.fields[i];
            	        var encodingFunction = encode[field.type];
            	        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');
            	        var value = table[field.name];
            	        if (value === undefined) {
            	            value = field.value;
            	        }

            	        var bytes = encodingFunction(value);

            	        if (field.type === 'TABLE') {
            	            subtableOffsets.push(d.length);
            	            d = d.concat([0, 0]);
            	            subtables.push(bytes);
            	        } else {
            	            d = d.concat(bytes);
            	        }
            	    }

            	    for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {
            	        var o = subtableOffsets[i$1];
            	        var offset = d.length;
            	        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');
            	        d[o] = offset >> 8;
            	        d[o + 1] = offset & 0xff;
            	        d = d.concat(subtables[i$1]);
            	    }

            	    return d;
            	};

            	/**
            	 * @param {opentype.Table}
            	 * @returns {number}
            	 */
            	sizeOf.TABLE = function(table) {
            	    var numBytes = 0;
            	    var length = table.fields.length;

            	    for (var i = 0; i < length; i += 1) {
            	        var field = table.fields[i];
            	        var sizeOfFunction = sizeOf[field.type];
            	        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');
            	        var value = table[field.name];
            	        if (value === undefined) {
            	            value = field.value;
            	        }

            	        numBytes += sizeOfFunction(value);

            	        // Subtables take 2 more bytes for offsets.
            	        if (field.type === 'TABLE') {
            	            numBytes += 2;
            	        }
            	    }

            	    return numBytes;
            	};

            	encode.RECORD = encode.TABLE;
            	sizeOf.RECORD = sizeOf.TABLE;

            	// Merge in a list of bytes.
            	encode.LITERAL = function(v) {
            	    return v;
            	};

            	sizeOf.LITERAL = function(v) {
            	    return v.length;
            	};

            	// Table metadata

            	/**
            	 * @exports opentype.Table
            	 * @class
            	 * @param {string} tableName
            	 * @param {Array} fields
            	 * @param {Object} options
            	 * @constructor
            	 */
            	function Table(tableName, fields, options) {
            	    var this$1 = this;

            	    for (var i = 0; i < fields.length; i += 1) {
            	        var field = fields[i];
            	        this$1[field.name] = field.value;
            	    }

            	    this.tableName = tableName;
            	    this.fields = fields;
            	    if (options) {
            	        var optionKeys = Object.keys(options);
            	        for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {
            	            var k = optionKeys[i$1];
            	            var v = options[k];
            	            if (this$1[k] !== undefined) {
            	                this$1[k] = v;
            	            }
            	        }
            	    }
            	}

            	/**
            	 * Encodes the table and returns an array of bytes
            	 * @return {Array}
            	 */
            	Table.prototype.encode = function() {
            	    return encode.TABLE(this);
            	};

            	/**
            	 * Get the size of the table.
            	 * @return {number}
            	 */
            	Table.prototype.sizeOf = function() {
            	    return sizeOf.TABLE(this);
            	};

            	/**
            	 * @private
            	 */
            	function ushortList(itemName, list, count) {
            	    if (count === undefined) {
            	        count = list.length;
            	    }
            	    var fields = new Array(list.length + 1);
            	    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
            	    for (var i = 0; i < list.length; i++) {
            	        fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};
            	    }
            	    return fields;
            	}

            	/**
            	 * @private
            	 */
            	function tableList(itemName, records, itemCallback) {
            	    var count = records.length;
            	    var fields = new Array(count + 1);
            	    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
            	    for (var i = 0; i < count; i++) {
            	        fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};
            	    }
            	    return fields;
            	}

            	/**
            	 * @private
            	 */
            	function recordList(itemName, records, itemCallback) {
            	    var count = records.length;
            	    var fields = [];
            	    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
            	    for (var i = 0; i < count; i++) {
            	        fields = fields.concat(itemCallback(records[i], i));
            	    }
            	    return fields;
            	}

            	// Common Layout Tables

            	/**
            	 * @exports opentype.Coverage
            	 * @class
            	 * @param {opentype.Table}
            	 * @constructor
            	 * @extends opentype.Table
            	 */
            	function Coverage(coverageTable) {
            	    if (coverageTable.format === 1) {
            	        Table.call(this, 'coverageTable',
            	            [{name: 'coverageFormat', type: 'USHORT', value: 1}]
            	            .concat(ushortList('glyph', coverageTable.glyphs))
            	        );
            	    } else {
            	        check.assert(false, 'Can\'t create coverage table format 2 yet.');
            	    }
            	}
            	Coverage.prototype = Object.create(Table.prototype);
            	Coverage.prototype.constructor = Coverage;

            	function ScriptList(scriptListTable) {
            	    Table.call(this, 'scriptListTable',
            	        recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {
            	            var script = scriptRecord.script;
            	            var defaultLangSys = script.defaultLangSys;
            	            check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');
            	            return [
            	                {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},
            	                {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [
            	                    {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [
            	                        {name: 'lookupOrder', type: 'USHORT', value: 0},
            	                        {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]
            	                        .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}
            	                    ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {
            	                        var langSys = langSysRecord.langSys;
            	                        return [
            	                            {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},
            	                            {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [
            	                                {name: 'lookupOrder', type: 'USHORT', value: 0},
            	                                {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}
            	                                ].concat(ushortList('featureIndex', langSys.featureIndexes)))}
            	                        ];
            	                    })))}
            	            ];
            	        })
            	    );
            	}
            	ScriptList.prototype = Object.create(Table.prototype);
            	ScriptList.prototype.constructor = ScriptList;

            	/**
            	 * @exports opentype.FeatureList
            	 * @class
            	 * @param {opentype.Table}
            	 * @constructor
            	 * @extends opentype.Table
            	 */
            	function FeatureList(featureListTable) {
            	    Table.call(this, 'featureListTable',
            	        recordList('featureRecord', featureListTable, function(featureRecord, i) {
            	            var feature = featureRecord.feature;
            	            return [
            	                {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},
            	                {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [
            	                    {name: 'featureParams', type: 'USHORT', value: feature.featureParams} ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}
            	            ];
            	        })
            	    );
            	}
            	FeatureList.prototype = Object.create(Table.prototype);
            	FeatureList.prototype.constructor = FeatureList;

            	/**
            	 * @exports opentype.LookupList
            	 * @class
            	 * @param {opentype.Table}
            	 * @param {Object}
            	 * @constructor
            	 * @extends opentype.Table
            	 */
            	function LookupList(lookupListTable, subtableMakers) {
            	    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {
            	        var subtableCallback = subtableMakers[lookupTable.lookupType];
            	        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');
            	        return new Table('lookupTable', [
            	            {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},
            	            {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}
            	        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));
            	    }));
            	}
            	LookupList.prototype = Object.create(Table.prototype);
            	LookupList.prototype.constructor = LookupList;

            	// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)
            	// Don't use offsets inside Records (probable bug), only in Tables.
            	var table = {
            	    Table: Table,
            	    Record: Table,
            	    Coverage: Coverage,
            	    ScriptList: ScriptList,
            	    FeatureList: FeatureList,
            	    LookupList: LookupList,
            	    ushortList: ushortList,
            	    tableList: tableList,
            	    recordList: recordList,
            	};

            	// Parsing utility functions

            	// Retrieve an unsigned byte from the DataView.
            	function getByte(dataView, offset) {
            	    return dataView.getUint8(offset);
            	}

            	// Retrieve an unsigned 16-bit short from the DataView.
            	// The value is stored in big endian.
            	function getUShort(dataView, offset) {
            	    return dataView.getUint16(offset, false);
            	}

            	// Retrieve a signed 16-bit short from the DataView.
            	// The value is stored in big endian.
            	function getShort(dataView, offset) {
            	    return dataView.getInt16(offset, false);
            	}

            	// Retrieve an unsigned 32-bit long from the DataView.
            	// The value is stored in big endian.
            	function getULong(dataView, offset) {
            	    return dataView.getUint32(offset, false);
            	}

            	// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
            	// The value is stored in big endian.
            	function getFixed(dataView, offset) {
            	    var decimal = dataView.getInt16(offset, false);
            	    var fraction = dataView.getUint16(offset + 2, false);
            	    return decimal + fraction / 65535;
            	}

            	// Retrieve a 4-character tag from the DataView.
            	// Tags are used to identify tables.
            	function getTag(dataView, offset) {
            	    var tag = '';
            	    for (var i = offset; i < offset + 4; i += 1) {
            	        tag += String.fromCharCode(dataView.getInt8(i));
            	    }

            	    return tag;
            	}

            	// Retrieve an offset from the DataView.
            	// Offsets are 1 to 4 bytes in length, depending on the offSize argument.
            	function getOffset(dataView, offset, offSize) {
            	    var v = 0;
            	    for (var i = 0; i < offSize; i += 1) {
            	        v <<= 8;
            	        v += dataView.getUint8(offset + i);
            	    }

            	    return v;
            	}

            	// Retrieve a number of bytes from start offset to the end offset from the DataView.
            	function getBytes(dataView, startOffset, endOffset) {
            	    var bytes = [];
            	    for (var i = startOffset; i < endOffset; i += 1) {
            	        bytes.push(dataView.getUint8(i));
            	    }

            	    return bytes;
            	}

            	// Convert the list of bytes to a string.
            	function bytesToString(bytes) {
            	    var s = '';
            	    for (var i = 0; i < bytes.length; i += 1) {
            	        s += String.fromCharCode(bytes[i]);
            	    }

            	    return s;
            	}

            	var typeOffsets = {
            	    byte: 1,
            	    uShort: 2,
            	    short: 2,
            	    uLong: 4,
            	    fixed: 4,
            	    longDateTime: 8,
            	    tag: 4
            	};

            	// A stateful parser that changes the offset whenever a value is retrieved.
            	// The data is a DataView.
            	function Parser(data, offset) {
            	    this.data = data;
            	    this.offset = offset;
            	    this.relativeOffset = 0;
            	}

            	Parser.prototype.parseByte = function() {
            	    var v = this.data.getUint8(this.offset + this.relativeOffset);
            	    this.relativeOffset += 1;
            	    return v;
            	};

            	Parser.prototype.parseChar = function() {
            	    var v = this.data.getInt8(this.offset + this.relativeOffset);
            	    this.relativeOffset += 1;
            	    return v;
            	};

            	Parser.prototype.parseCard8 = Parser.prototype.parseByte;

            	Parser.prototype.parseUShort = function() {
            	    var v = this.data.getUint16(this.offset + this.relativeOffset);
            	    this.relativeOffset += 2;
            	    return v;
            	};

            	Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
            	Parser.prototype.parseSID = Parser.prototype.parseUShort;
            	Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;

            	Parser.prototype.parseShort = function() {
            	    var v = this.data.getInt16(this.offset + this.relativeOffset);
            	    this.relativeOffset += 2;
            	    return v;
            	};

            	Parser.prototype.parseF2Dot14 = function() {
            	    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
            	    this.relativeOffset += 2;
            	    return v;
            	};

            	Parser.prototype.parseULong = function() {
            	    var v = getULong(this.data, this.offset + this.relativeOffset);
            	    this.relativeOffset += 4;
            	    return v;
            	};

            	Parser.prototype.parseOffset32 = Parser.prototype.parseULong;

            	Parser.prototype.parseFixed = function() {
            	    var v = getFixed(this.data, this.offset + this.relativeOffset);
            	    this.relativeOffset += 4;
            	    return v;
            	};

            	Parser.prototype.parseString = function(length) {
            	    var dataView = this.data;
            	    var offset = this.offset + this.relativeOffset;
            	    var string = '';
            	    this.relativeOffset += length;
            	    for (var i = 0; i < length; i++) {
            	        string += String.fromCharCode(dataView.getUint8(offset + i));
            	    }

            	    return string;
            	};

            	Parser.prototype.parseTag = function() {
            	    return this.parseString(4);
            	};

            	// LONGDATETIME is a 64-bit integer.
            	// JavaScript and unix timestamps traditionally use 32 bits, so we
            	// only take the last 32 bits.
            	// + Since until 2038 those bits will be filled by zeros we can ignore them.
            	Parser.prototype.parseLongDateTime = function() {
            	    var v = getULong(this.data, this.offset + this.relativeOffset + 4);
            	    // Subtract seconds between 01/01/1904 and 01/01/1970
            	    // to convert Apple Mac timestamp to Standard Unix timestamp
            	    v -= 2082844800;
            	    this.relativeOffset += 8;
            	    return v;
            	};

            	Parser.prototype.parseVersion = function(minorBase) {
            	    var major = getUShort(this.data, this.offset + this.relativeOffset);

            	    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
            	    // Default returns the correct number if minor = 0xN000 where N is 0-9
            	    // Set minorBase to 1 for tables that use minor = N where N is 0-9
            	    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
            	    this.relativeOffset += 4;
            	    if (minorBase === undefined) { minorBase = 0x1000; }
            	    return major + minor / minorBase / 10;
            	};

            	Parser.prototype.skip = function(type, amount) {
            	    if (amount === undefined) {
            	        amount = 1;
            	    }

            	    this.relativeOffset += typeOffsets[type] * amount;
            	};

            	///// Parsing lists and records ///////////////////////////////

            	// Parse a list of 32 bit unsigned integers.
            	Parser.prototype.parseULongList = function(count) {
            	    if (count === undefined) { count = this.parseULong(); }
            	    var offsets = new Array(count);
            	    var dataView = this.data;
            	    var offset = this.offset + this.relativeOffset;
            	    for (var i = 0; i < count; i++) {
            	        offsets[i] = dataView.getUint32(offset);
            	        offset += 4;
            	    }

            	    this.relativeOffset += count * 4;
            	    return offsets;
            	};

            	// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream
            	// or provided as an argument.
            	Parser.prototype.parseOffset16List =
            	Parser.prototype.parseUShortList = function(count) {
            	    if (count === undefined) { count = this.parseUShort(); }
            	    var offsets = new Array(count);
            	    var dataView = this.data;
            	    var offset = this.offset + this.relativeOffset;
            	    for (var i = 0; i < count; i++) {
            	        offsets[i] = dataView.getUint16(offset);
            	        offset += 2;
            	    }

            	    this.relativeOffset += count * 2;
            	    return offsets;
            	};

            	// Parses a list of 16 bit signed integers.
            	Parser.prototype.parseShortList = function(count) {
            	    var list = new Array(count);
            	    var dataView = this.data;
            	    var offset = this.offset + this.relativeOffset;
            	    for (var i = 0; i < count; i++) {
            	        list[i] = dataView.getInt16(offset);
            	        offset += 2;
            	    }

            	    this.relativeOffset += count * 2;
            	    return list;
            	};

            	// Parses a list of bytes.
            	Parser.prototype.parseByteList = function(count) {
            	    var list = new Array(count);
            	    var dataView = this.data;
            	    var offset = this.offset + this.relativeOffset;
            	    for (var i = 0; i < count; i++) {
            	        list[i] = dataView.getUint8(offset++);
            	    }

            	    this.relativeOffset += count;
            	    return list;
            	};

            	/**
            	 * Parse a list of items.
            	 * Record count is optional, if omitted it is read from the stream.
            	 * itemCallback is one of the Parser methods.
            	 */
            	Parser.prototype.parseList = function(count, itemCallback) {
            	    var this$1 = this;

            	    if (!itemCallback) {
            	        itemCallback = count;
            	        count = this.parseUShort();
            	    }
            	    var list = new Array(count);
            	    for (var i = 0; i < count; i++) {
            	        list[i] = itemCallback.call(this$1);
            	    }
            	    return list;
            	};

            	Parser.prototype.parseList32 = function(count, itemCallback) {
            	    var this$1 = this;

            	    if (!itemCallback) {
            	        itemCallback = count;
            	        count = this.parseULong();
            	    }
            	    var list = new Array(count);
            	    for (var i = 0; i < count; i++) {
            	        list[i] = itemCallback.call(this$1);
            	    }
            	    return list;
            	};

            	/**
            	 * Parse a list of records.
            	 * Record count is optional, if omitted it is read from the stream.
            	 * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
            	 */
            	Parser.prototype.parseRecordList = function(count, recordDescription) {
            	    var this$1 = this;

            	    // If the count argument is absent, read it in the stream.
            	    if (!recordDescription) {
            	        recordDescription = count;
            	        count = this.parseUShort();
            	    }
            	    var records = new Array(count);
            	    var fields = Object.keys(recordDescription);
            	    for (var i = 0; i < count; i++) {
            	        var rec = {};
            	        for (var j = 0; j < fields.length; j++) {
            	            var fieldName = fields[j];
            	            var fieldType = recordDescription[fieldName];
            	            rec[fieldName] = fieldType.call(this$1);
            	        }
            	        records[i] = rec;
            	    }
            	    return records;
            	};

            	Parser.prototype.parseRecordList32 = function(count, recordDescription) {
            	    var this$1 = this;

            	    // If the count argument is absent, read it in the stream.
            	    if (!recordDescription) {
            	        recordDescription = count;
            	        count = this.parseULong();
            	    }
            	    var records = new Array(count);
            	    var fields = Object.keys(recordDescription);
            	    for (var i = 0; i < count; i++) {
            	        var rec = {};
            	        for (var j = 0; j < fields.length; j++) {
            	            var fieldName = fields[j];
            	            var fieldType = recordDescription[fieldName];
            	            rec[fieldName] = fieldType.call(this$1);
            	        }
            	        records[i] = rec;
            	    }
            	    return records;
            	};

            	// Parse a data structure into an object
            	// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
            	Parser.prototype.parseStruct = function(description) {
            	    var this$1 = this;

            	    if (typeof description === 'function') {
            	        return description.call(this);
            	    } else {
            	        var fields = Object.keys(description);
            	        var struct = {};
            	        for (var j = 0; j < fields.length; j++) {
            	            var fieldName = fields[j];
            	            var fieldType = description[fieldName];
            	            struct[fieldName] = fieldType.call(this$1);
            	        }
            	        return struct;
            	    }
            	};

            	/**
            	 * Parse a GPOS valueRecord
            	 * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
            	 * valueFormat is optional, if omitted it is read from the stream.
            	 */
            	Parser.prototype.parseValueRecord = function(valueFormat) {
            	    if (valueFormat === undefined) {
            	        valueFormat = this.parseUShort();
            	    }
            	    if (valueFormat === 0) {
            	        // valueFormat2 in kerning pairs is most often 0
            	        // in this case return undefined instead of an empty object, to save space
            	        return;
            	    }
            	    var valueRecord = {};

            	    if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }
            	    if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }
            	    if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }
            	    if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }

            	    // Device table (non-variable font) / VariationIndex table (variable font) not supported
            	    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls
            	    if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }
            	    if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }
            	    if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }
            	    if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }

            	    return valueRecord;
            	};

            	/**
            	 * Parse a list of GPOS valueRecords
            	 * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
            	 * valueFormat and valueCount are read from the stream.
            	 */
            	Parser.prototype.parseValueRecordList = function() {
            	    var this$1 = this;

            	    var valueFormat = this.parseUShort();
            	    var valueCount = this.parseUShort();
            	    var values = new Array(valueCount);
            	    for (var i = 0; i < valueCount; i++) {
            	        values[i] = this$1.parseValueRecord(valueFormat);
            	    }
            	    return values;
            	};

            	Parser.prototype.parsePointer = function(description) {
            	    var structOffset = this.parseOffset16();
            	    if (structOffset > 0) {
            	        // NULL offset => return undefined
            	        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
            	    }
            	    return undefined;
            	};

            	Parser.prototype.parsePointer32 = function(description) {
            	    var structOffset = this.parseOffset32();
            	    if (structOffset > 0) {
            	        // NULL offset => return undefined
            	        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
            	    }
            	    return undefined;
            	};

            	/**
            	 * Parse a list of offsets to lists of 16-bit integers,
            	 * or a list of offsets to lists of offsets to any kind of items.
            	 * If itemCallback is not provided, a list of list of UShort is assumed.
            	 * If provided, itemCallback is called on each item and must parse the item.
            	 * See examples in tables/gsub.js
            	 */
            	Parser.prototype.parseListOfLists = function(itemCallback) {
            	    var this$1 = this;

            	    var offsets = this.parseOffset16List();
            	    var count = offsets.length;
            	    var relativeOffset = this.relativeOffset;
            	    var list = new Array(count);
            	    for (var i = 0; i < count; i++) {
            	        var start = offsets[i];
            	        if (start === 0) {
            	            // NULL offset
            	            // Add i as owned property to list. Convenient with assert.
            	            list[i] = undefined;
            	            continue;
            	        }
            	        this$1.relativeOffset = start;
            	        if (itemCallback) {
            	            var subOffsets = this$1.parseOffset16List();
            	            var subList = new Array(subOffsets.length);
            	            for (var j = 0; j < subOffsets.length; j++) {
            	                this$1.relativeOffset = start + subOffsets[j];
            	                subList[j] = itemCallback.call(this$1);
            	            }
            	            list[i] = subList;
            	        } else {
            	            list[i] = this$1.parseUShortList();
            	        }
            	    }
            	    this.relativeOffset = relativeOffset;
            	    return list;
            	};

            	///// Complex tables parsing //////////////////////////////////

            	// Parse a coverage table in a GSUB, GPOS or GDEF table.
            	// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
            	// parser.offset must point to the start of the table containing the coverage.
            	Parser.prototype.parseCoverage = function() {
            	    var this$1 = this;

            	    var startOffset = this.offset + this.relativeOffset;
            	    var format = this.parseUShort();
            	    var count = this.parseUShort();
            	    if (format === 1) {
            	        return {
            	            format: 1,
            	            glyphs: this.parseUShortList(count)
            	        };
            	    } else if (format === 2) {
            	        var ranges = new Array(count);
            	        for (var i = 0; i < count; i++) {
            	            ranges[i] = {
            	                start: this$1.parseUShort(),
            	                end: this$1.parseUShort(),
            	                index: this$1.parseUShort()
            	            };
            	        }
            	        return {
            	            format: 2,
            	            ranges: ranges
            	        };
            	    }
            	    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');
            	};

            	// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
            	// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
            	Parser.prototype.parseClassDef = function() {
            	    var startOffset = this.offset + this.relativeOffset;
            	    var format = this.parseUShort();
            	    if (format === 1) {
            	        return {
            	            format: 1,
            	            startGlyph: this.parseUShort(),
            	            classes: this.parseUShortList()
            	        };
            	    } else if (format === 2) {
            	        return {
            	            format: 2,
            	            ranges: this.parseRecordList({
            	                start: Parser.uShort,
            	                end: Parser.uShort,
            	                classId: Parser.uShort
            	            })
            	        };
            	    }
            	    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');
            	};

            	///// Static methods ///////////////////////////////////
            	// These convenience methods can be used as callbacks and should be called with "this" context set to a Parser instance.

            	Parser.list = function(count, itemCallback) {
            	    return function() {
            	        return this.parseList(count, itemCallback);
            	    };
            	};

            	Parser.list32 = function(count, itemCallback) {
            	    return function() {
            	        return this.parseList32(count, itemCallback);
            	    };
            	};

            	Parser.recordList = function(count, recordDescription) {
            	    return function() {
            	        return this.parseRecordList(count, recordDescription);
            	    };
            	};

            	Parser.recordList32 = function(count, recordDescription) {
            	    return function() {
            	        return this.parseRecordList32(count, recordDescription);
            	    };
            	};

            	Parser.pointer = function(description) {
            	    return function() {
            	        return this.parsePointer(description);
            	    };
            	};

            	Parser.pointer32 = function(description) {
            	    return function() {
            	        return this.parsePointer32(description);
            	    };
            	};

            	Parser.tag = Parser.prototype.parseTag;
            	Parser.byte = Parser.prototype.parseByte;
            	Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort;
            	Parser.uShortList = Parser.prototype.parseUShortList;
            	Parser.uLong = Parser.offset32 = Parser.prototype.parseULong;
            	Parser.uLongList = Parser.prototype.parseULongList;
            	Parser.struct = Parser.prototype.parseStruct;
            	Parser.coverage = Parser.prototype.parseCoverage;
            	Parser.classDef = Parser.prototype.parseClassDef;

            	///// Script, Feature, Lookup lists ///////////////////////////////////////////////
            	// https://www.microsoft.com/typography/OTSPEC/chapter2.htm

            	var langSysTable = {
            	    reserved: Parser.uShort,
            	    reqFeatureIndex: Parser.uShort,
            	    featureIndexes: Parser.uShortList
            	};

            	Parser.prototype.parseScriptList = function() {
            	    return this.parsePointer(Parser.recordList({
            	        tag: Parser.tag,
            	        script: Parser.pointer({
            	            defaultLangSys: Parser.pointer(langSysTable),
            	            langSysRecords: Parser.recordList({
            	                tag: Parser.tag,
            	                langSys: Parser.pointer(langSysTable)
            	            })
            	        })
            	    })) || [];
            	};

            	Parser.prototype.parseFeatureList = function() {
            	    return this.parsePointer(Parser.recordList({
            	        tag: Parser.tag,
            	        feature: Parser.pointer({
            	            featureParams: Parser.offset16,
            	            lookupListIndexes: Parser.uShortList
            	        })
            	    })) || [];
            	};

            	Parser.prototype.parseLookupList = function(lookupTableParsers) {
            	    return this.parsePointer(Parser.list(Parser.pointer(function() {
            	        var lookupType = this.parseUShort();
            	        check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');
            	        var lookupFlag = this.parseUShort();
            	        var useMarkFilteringSet = lookupFlag & 0x10;
            	        return {
            	            lookupType: lookupType,
            	            lookupFlag: lookupFlag,
            	            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),
            	            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined
            	        };
            	    }))) || [];
            	};

            	Parser.prototype.parseFeatureVariationsList = function() {
            	    return this.parsePointer32(function() {
            	        var majorVersion = this.parseUShort();
            	        var minorVersion = this.parseUShort();
            	        check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');
            	        var featureVariations = this.parseRecordList32({
            	            conditionSetOffset: Parser.offset32,
            	            featureTableSubstitutionOffset: Parser.offset32
            	        });
            	        return featureVariations;
            	    }) || [];
            	};

            	var parse = {
            	    getByte: getByte,
            	    getCard8: getByte,
            	    getUShort: getUShort,
            	    getCard16: getUShort,
            	    getShort: getShort,
            	    getULong: getULong,
            	    getFixed: getFixed,
            	    getTag: getTag,
            	    getOffset: getOffset,
            	    getBytes: getBytes,
            	    bytesToString: bytesToString,
            	    Parser: Parser,
            	};

            	// The `cmap` table stores the mappings from characters to glyphs.

            	function parseCmapTableFormat12(cmap, p) {
            	    //Skip reserved.
            	    p.parseUShort();

            	    // Length in bytes of the sub-tables.
            	    cmap.length = p.parseULong();
            	    cmap.language = p.parseULong();

            	    var groupCount;
            	    cmap.groupCount = groupCount = p.parseULong();
            	    cmap.glyphIndexMap = {};

            	    for (var i = 0; i < groupCount; i += 1) {
            	        var startCharCode = p.parseULong();
            	        var endCharCode = p.parseULong();
            	        var startGlyphId = p.parseULong();

            	        for (var c = startCharCode; c <= endCharCode; c += 1) {
            	            cmap.glyphIndexMap[c] = startGlyphId;
            	            startGlyphId++;
            	        }
            	    }
            	}

            	function parseCmapTableFormat4(cmap, p, data, start, offset) {
            	    // Length in bytes of the sub-tables.
            	    cmap.length = p.parseUShort();
            	    cmap.language = p.parseUShort();

            	    // segCount is stored x 2.
            	    var segCount;
            	    cmap.segCount = segCount = p.parseUShort() >> 1;

            	    // Skip searchRange, entrySelector, rangeShift.
            	    p.skip('uShort', 3);

            	    // The "unrolled" mapping from character codes to glyph indices.
            	    cmap.glyphIndexMap = {};
            	    var endCountParser = new parse.Parser(data, start + offset + 14);
            	    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
            	    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
            	    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
            	    var glyphIndexOffset = start + offset + 16 + segCount * 8;
            	    for (var i = 0; i < segCount - 1; i += 1) {
            	        var glyphIndex = (void 0);
            	        var endCount = endCountParser.parseUShort();
            	        var startCount = startCountParser.parseUShort();
            	        var idDelta = idDeltaParser.parseShort();
            	        var idRangeOffset = idRangeOffsetParser.parseUShort();
            	        for (var c = startCount; c <= endCount; c += 1) {
            	            if (idRangeOffset !== 0) {
            	                // The idRangeOffset is relative to the current position in the idRangeOffset array.
            	                // Take the current offset in the idRangeOffset array.
            	                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);

            	                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
            	                glyphIndexOffset += idRangeOffset;

            	                // Then add the character index of the current segment, multiplied by 2 for USHORTs.
            	                glyphIndexOffset += (c - startCount) * 2;
            	                glyphIndex = parse.getUShort(data, glyphIndexOffset);
            	                if (glyphIndex !== 0) {
            	                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;
            	                }
            	            } else {
            	                glyphIndex = (c + idDelta) & 0xFFFF;
            	            }

            	            cmap.glyphIndexMap[c] = glyphIndex;
            	        }
            	    }
            	}

            	// Parse the `cmap` table. This table stores the mappings from characters to glyphs.
            	// There are many available formats, but we only support the Windows format 4 and 12.
            	// This function returns a `CmapEncoding` object or null if no supported format could be found.
            	function parseCmapTable(data, start) {
            	    var cmap = {};
            	    cmap.version = parse.getUShort(data, start);
            	    check.argument(cmap.version === 0, 'cmap table version should be 0.');

            	    // The cmap table can contain many sub-tables, each with their own format.
            	    // We're only interested in a "platform 0" (Unicode format) and "platform 3" (Windows format) table.
            	    cmap.numTables = parse.getUShort(data, start + 2);
            	    var offset = -1;
            	    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {
            	        var platformId = parse.getUShort(data, start + 4 + (i * 8));
            	        var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);
            	        if ((platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) ||
            	            (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4))) {
            	            offset = parse.getULong(data, start + 4 + (i * 8) + 4);
            	            break;
            	        }
            	    }

            	    if (offset === -1) {
            	        // There is no cmap table in the font that we support.
            	        throw new Error('No valid cmap sub-tables found.');
            	    }

            	    var p = new parse.Parser(data, start + offset);
            	    cmap.format = p.parseUShort();

            	    if (cmap.format === 12) {
            	        parseCmapTableFormat12(cmap, p);
            	    } else if (cmap.format === 4) {
            	        parseCmapTableFormat4(cmap, p, data, start, offset);
            	    } else {
            	        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');
            	    }

            	    return cmap;
            	}

            	function addSegment(t, code, glyphIndex) {
            	    t.segments.push({
            	        end: code,
            	        start: code,
            	        delta: -(code - glyphIndex),
            	        offset: 0,
            	        glyphIndex: glyphIndex
            	    });
            	}

            	function addTerminatorSegment(t) {
            	    t.segments.push({
            	        end: 0xFFFF,
            	        start: 0xFFFF,
            	        delta: 1,
            	        offset: 0
            	    });
            	}

            	// Make cmap table, format 4 by default, 12 if needed only
            	function makeCmapTable(glyphs) {
            	    // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)
            	    var isPlan0Only = true;
            	    var i;

            	    // Check if we need to add cmap format 12 or if format 4 only is fine
            	    for (i = glyphs.length - 1; i > 0; i -= 1) {
            	        var g = glyphs.get(i);
            	        if (g.unicode > 65535) {
            	            console.log('Adding CMAP format 12 (needed!)');
            	            isPlan0Only = false;
            	            break;
            	        }
            	    }

            	    var cmapTable = [
            	        {name: 'version', type: 'USHORT', value: 0},
            	        {name: 'numTables', type: 'USHORT', value: isPlan0Only ? 1 : 2},

            	        // CMAP 4 header
            	        {name: 'platformID', type: 'USHORT', value: 3},
            	        {name: 'encodingID', type: 'USHORT', value: 1},
            	        {name: 'offset', type: 'ULONG', value: isPlan0Only ? 12 : (12 + 8)}
            	    ];

            	    if (!isPlan0Only)
            	        { cmapTable = cmapTable.concat([
            	            // CMAP 12 header
            	            {name: 'cmap12PlatformID', type: 'USHORT', value: 3}, // We encode only for PlatformID = 3 (Windows) because it is supported everywhere
            	            {name: 'cmap12EncodingID', type: 'USHORT', value: 10},
            	            {name: 'cmap12Offset', type: 'ULONG', value: 0}
            	        ]); }

            	    cmapTable = cmapTable.concat([
            	        // CMAP 4 Subtable
            	        {name: 'format', type: 'USHORT', value: 4},
            	        {name: 'cmap4Length', type: 'USHORT', value: 0},
            	        {name: 'language', type: 'USHORT', value: 0},
            	        {name: 'segCountX2', type: 'USHORT', value: 0},
            	        {name: 'searchRange', type: 'USHORT', value: 0},
            	        {name: 'entrySelector', type: 'USHORT', value: 0},
            	        {name: 'rangeShift', type: 'USHORT', value: 0}
            	    ]);

            	    var t = new table.Table('cmap', cmapTable);

            	    t.segments = [];
            	    for (i = 0; i < glyphs.length; i += 1) {
            	        var glyph = glyphs.get(i);
            	        for (var j = 0; j < glyph.unicodes.length; j += 1) {
            	            addSegment(t, glyph.unicodes[j], i);
            	        }

            	        t.segments = t.segments.sort(function (a, b) {
            	            return a.start - b.start;
            	        });
            	    }

            	    addTerminatorSegment(t);

            	    var segCount = t.segments.length;
            	    var segCountToRemove = 0;

            	    // CMAP 4
            	    // Set up parallel segment arrays.
            	    var endCounts = [];
            	    var startCounts = [];
            	    var idDeltas = [];
            	    var idRangeOffsets = [];
            	    var glyphIds = [];

            	    // CMAP 12
            	    var cmap12Groups = [];

            	    // Reminder this loop is not following the specification at 100%
            	    // The specification -> find suites of characters and make a group
            	    // Here we're doing one group for each letter
            	    // Doing as the spec can save 8 times (or more) space
            	    for (i = 0; i < segCount; i += 1) {
            	        var segment = t.segments[i];

            	        // CMAP 4
            	        if (segment.end <= 65535 && segment.start <= 65535) {
            	            endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});
            	            startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});
            	            idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});
            	            idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});
            	            if (segment.glyphId !== undefined) {
            	                glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});
            	            }
            	        } else {
            	            // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12
            	            segCountToRemove += 1;
            	        }

            	        // CMAP 12
            	        // Skip Terminator Segment
            	        if (!isPlan0Only && segment.glyphIndex !== undefined) {
            	            cmap12Groups = cmap12Groups.concat({name: 'cmap12Start_' + i, type: 'ULONG', value: segment.start});
            	            cmap12Groups = cmap12Groups.concat({name: 'cmap12End_' + i, type: 'ULONG', value: segment.end});
            	            cmap12Groups = cmap12Groups.concat({name: 'cmap12Glyph_' + i, type: 'ULONG', value: segment.glyphIndex});
            	        }
            	    }

            	    // CMAP 4 Subtable
            	    t.segCountX2 = (segCount - segCountToRemove) * 2;
            	    t.searchRange = Math.pow(2, Math.floor(Math.log((segCount - segCountToRemove)) / Math.log(2))) * 2;
            	    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
            	    t.rangeShift = t.segCountX2 - t.searchRange;

            	    t.fields = t.fields.concat(endCounts);
            	    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});
            	    t.fields = t.fields.concat(startCounts);
            	    t.fields = t.fields.concat(idDeltas);
            	    t.fields = t.fields.concat(idRangeOffsets);
            	    t.fields = t.fields.concat(glyphIds);

            	    t.cmap4Length = 14 + // Subtable header
            	        endCounts.length * 2 +
            	        2 + // reservedPad
            	        startCounts.length * 2 +
            	        idDeltas.length * 2 +
            	        idRangeOffsets.length * 2 +
            	        glyphIds.length * 2;

            	    if (!isPlan0Only) {
            	        // CMAP 12 Subtable
            	        var cmap12Length = 16 + // Subtable header
            	            cmap12Groups.length * 4;

            	        t.cmap12Offset = 12 + (2 * 2) + 4 + t.cmap4Length;
            	        t.fields = t.fields.concat([
            	            {name: 'cmap12Format', type: 'USHORT', value: 12},
            	            {name: 'cmap12Reserved', type: 'USHORT', value: 0},
            	            {name: 'cmap12Length', type: 'ULONG', value: cmap12Length},
            	            {name: 'cmap12Language', type: 'ULONG', value: 0},
            	            {name: 'cmap12nGroups', type: 'ULONG', value: cmap12Groups.length / 3}
            	        ]);

            	        t.fields = t.fields.concat(cmap12Groups);
            	    }

            	    return t;
            	}

            	var cmap = { parse: parseCmapTable, make: makeCmapTable };

            	// Glyph encoding

            	var cffStandardStrings = [
            	    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
            	    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
            	    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
            	    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
            	    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
            	    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
            	    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',
            	    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',
            	    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',
            	    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',
            	    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',
            	    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',
            	    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',
            	    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',
            	    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',
            	    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',
            	    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',
            	    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',
            	    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',
            	    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',
            	    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',
            	    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',
            	    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',
            	    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',
            	    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',
            	    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',
            	    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',
            	    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
            	    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
            	    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
            	    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',
            	    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',
            	    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',
            	    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',
            	    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',
            	    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',
            	    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',
            	    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',
            	    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',
            	    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',
            	    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',
            	    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',
            	    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];

            	var cffStandardEncoding = [
            	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
            	    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
            	    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
            	    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
            	    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
            	    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
            	    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
            	    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',
            	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
            	    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',
            	    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',
            	    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',
            	    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',
            	    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',
            	    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',
            	    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',
            	    'lslash', 'oslash', 'oe', 'germandbls'];

            	var cffExpertEncoding = [
            	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
            	    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',
            	    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',
            	    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',
            	    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',
            	    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',
            	    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',
            	    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',
            	    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
            	    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
            	    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
            	    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',
            	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
            	    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',
            	    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',
            	    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',
            	    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',
            	    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',
            	    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',
            	    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',
            	    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',
            	    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',
            	    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',
            	    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',
            	    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',
            	    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];

            	var standardNames = [
            	    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',
            	    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',
            	    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',
            	    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
            	    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',
            	    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
            	    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',
            	    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',
            	    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',
            	    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',
            	    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',
            	    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',
            	    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',
            	    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',
            	    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',
            	    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',
            	    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',
            	    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',
            	    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',
            	    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',
            	    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',
            	    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',
            	    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',
            	    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',
            	    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];

            	/**
            	 * This is the encoding used for fonts created from scratch.
            	 * It loops through all glyphs and finds the appropriate unicode value.
            	 * Since it's linear time, other encodings will be faster.
            	 * @exports opentype.DefaultEncoding
            	 * @class
            	 * @constructor
            	 * @param {opentype.Font}
            	 */
            	function DefaultEncoding(font) {
            	    this.font = font;
            	}

            	DefaultEncoding.prototype.charToGlyphIndex = function(c) {
            	    var code = c.codePointAt(0);
            	    var glyphs = this.font.glyphs;
            	    if (glyphs) {
            	        for (var i = 0; i < glyphs.length; i += 1) {
            	            var glyph = glyphs.get(i);
            	            for (var j = 0; j < glyph.unicodes.length; j += 1) {
            	                if (glyph.unicodes[j] === code) {
            	                    return i;
            	                }
            	            }
            	        }
            	    }
            	    return null;
            	};

            	/**
            	 * @exports opentype.CmapEncoding
            	 * @class
            	 * @constructor
            	 * @param {Object} cmap - a object with the cmap encoded data
            	 */
            	function CmapEncoding(cmap) {
            	    this.cmap = cmap;
            	}

            	/**
            	 * @param  {string} c - the character
            	 * @return {number} The glyph index.
            	 */
            	CmapEncoding.prototype.charToGlyphIndex = function(c) {
            	    return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;
            	};

            	/**
            	 * @exports opentype.CffEncoding
            	 * @class
            	 * @constructor
            	 * @param {string} encoding - The encoding
            	 * @param {Array} charset - The character set.
            	 */
            	function CffEncoding(encoding, charset) {
            	    this.encoding = encoding;
            	    this.charset = charset;
            	}

            	/**
            	 * @param  {string} s - The character
            	 * @return {number} The index.
            	 */
            	CffEncoding.prototype.charToGlyphIndex = function(s) {
            	    var code = s.codePointAt(0);
            	    var charName = this.encoding[code];
            	    return this.charset.indexOf(charName);
            	};

            	/**
            	 * @exports opentype.GlyphNames
            	 * @class
            	 * @constructor
            	 * @param {Object} post
            	 */
            	function GlyphNames(post) {
            	    var this$1 = this;

            	    switch (post.version) {
            	        case 1:
            	            this.names = standardNames.slice();
            	            break;
            	        case 2:
            	            this.names = new Array(post.numberOfGlyphs);
            	            for (var i = 0; i < post.numberOfGlyphs; i++) {
            	                if (post.glyphNameIndex[i] < standardNames.length) {
            	                    this$1.names[i] = standardNames[post.glyphNameIndex[i]];
            	                } else {
            	                    this$1.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];
            	                }
            	            }

            	            break;
            	        case 2.5:
            	            this.names = new Array(post.numberOfGlyphs);
            	            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
            	                this$1.names[i$1] = standardNames[i$1 + post.glyphNameIndex[i$1]];
            	            }

            	            break;
            	        case 3:
            	            this.names = [];
            	            break;
            	        default:
            	            this.names = [];
            	            break;
            	    }
            	}

            	/**
            	 * Gets the index of a glyph by name.
            	 * @param  {string} name - The glyph name
            	 * @return {number} The index
            	 */
            	GlyphNames.prototype.nameToGlyphIndex = function(name) {
            	    return this.names.indexOf(name);
            	};

            	/**
            	 * @param  {number} gid
            	 * @return {string}
            	 */
            	GlyphNames.prototype.glyphIndexToName = function(gid) {
            	    return this.names[gid];
            	};

            	/**
            	 * @alias opentype.addGlyphNames
            	 * @param {opentype.Font}
            	 */
            	function addGlyphNames(font) {
            	    var glyph;
            	    var glyphIndexMap = font.tables.cmap.glyphIndexMap;
            	    var charCodes = Object.keys(glyphIndexMap);

            	    for (var i = 0; i < charCodes.length; i += 1) {
            	        var c = charCodes[i];
            	        var glyphIndex = glyphIndexMap[c];
            	        glyph = font.glyphs.get(glyphIndex);
            	        glyph.addUnicode(parseInt(c));
            	    }

            	    for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {
            	        glyph = font.glyphs.get(i$1);
            	        if (font.cffEncoding) {
            	            if (font.isCIDFont) {
            	                glyph.name = 'gid' + i$1;
            	            } else {
            	                glyph.name = font.cffEncoding.charset[i$1];
            	            }
            	        } else if (font.glyphNames.names) {
            	            glyph.name = font.glyphNames.glyphIndexToName(i$1);
            	        }
            	    }
            	}

            	// Drawing utility functions.

            	// Draw a line on the given context from point `x1,y1` to point `x2,y2`.
            	function line(ctx, x1, y1, x2, y2) {
            	    ctx.beginPath();
            	    ctx.moveTo(x1, y1);
            	    ctx.lineTo(x2, y2);
            	    ctx.stroke();
            	}

            	var draw = { line: line };

            	// The Glyph object
            	// import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency

            	function getPathDefinition(glyph, path) {
            	    var _path = path || new Path();
            	    return {
            	        configurable: true,

            	        get: function() {
            	            if (typeof _path === 'function') {
            	                _path = _path();
            	            }

            	            return _path;
            	        },

            	        set: function(p) {
            	            _path = p;
            	        }
            	    };
            	}
            	/**
            	 * @typedef GlyphOptions
            	 * @type Object
            	 * @property {string} [name] - The glyph name
            	 * @property {number} [unicode]
            	 * @property {Array} [unicodes]
            	 * @property {number} [xMin]
            	 * @property {number} [yMin]
            	 * @property {number} [xMax]
            	 * @property {number} [yMax]
            	 * @property {number} [advanceWidth]
            	 */

            	// A Glyph is an individual mark that often corresponds to a character.
            	// Some glyphs, such as ligatures, are a combination of many characters.
            	// Glyphs are the basic building blocks of a font.
            	//
            	// The `Glyph` class contains utility methods for drawing the path and its points.
            	/**
            	 * @exports opentype.Glyph
            	 * @class
            	 * @param {GlyphOptions}
            	 * @constructor
            	 */
            	function Glyph(options) {
            	    // By putting all the code on a prototype function (which is only declared once)
            	    // we reduce the memory requirements for larger fonts by some 2%
            	    this.bindConstructorValues(options);
            	}

            	/**
            	 * @param  {GlyphOptions}
            	 */
            	Glyph.prototype.bindConstructorValues = function(options) {
            	    this.index = options.index || 0;

            	    // These three values cannot be deferred for memory optimization:
            	    this.name = options.name || null;
            	    this.unicode = options.unicode || undefined;
            	    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];

            	    // But by binding these values only when necessary, we reduce can
            	    // the memory requirements by almost 3% for larger fonts.
            	    if (options.xMin) {
            	        this.xMin = options.xMin;
            	    }

            	    if (options.yMin) {
            	        this.yMin = options.yMin;
            	    }

            	    if (options.xMax) {
            	        this.xMax = options.xMax;
            	    }

            	    if (options.yMax) {
            	        this.yMax = options.yMax;
            	    }

            	    if (options.advanceWidth) {
            	        this.advanceWidth = options.advanceWidth;
            	    }

            	    // The path for a glyph is the most memory intensive, and is bound as a value
            	    // with a getter/setter to ensure we actually do path parsing only once the
            	    // path is actually needed by anything.
            	    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));
            	};

            	/**
            	 * @param {number}
            	 */
            	Glyph.prototype.addUnicode = function(unicode) {
            	    if (this.unicodes.length === 0) {
            	        this.unicode = unicode;
            	    }

            	    this.unicodes.push(unicode);
            	};

            	/**
            	 * Calculate the minimum bounding box for this glyph.
            	 * @return {opentype.BoundingBox}
            	 */
            	Glyph.prototype.getBoundingBox = function() {
            	    return this.path.getBoundingBox();
            	};

            	/**
            	 * Convert the glyph to a Path we can draw on a drawing context.
            	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
            	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
            	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
            	 * @param  {Object=} options - xScale, yScale to stretch the glyph.
            	 * @param  {opentype.Font} if hinting is to be used, the font
            	 * @return {opentype.Path}
            	 */
            	Glyph.prototype.getPath = function(x, y, fontSize, options, font) {
            	    x = x !== undefined ? x : 0;
            	    y = y !== undefined ? y : 0;
            	    fontSize = fontSize !== undefined ? fontSize : 72;
            	    var commands;
            	    var hPoints;
            	    if (!options) { options = { }; }
            	    var xScale = options.xScale;
            	    var yScale = options.yScale;

            	    if (options.hinting && font && font.hinting) {
            	        // in case of hinting, the hinting engine takes care
            	        // of scaling the points (not the path) before hinting.
            	        hPoints = this.path && font.hinting.exec(this, fontSize);
            	        // in case the hinting engine failed hPoints is undefined
            	        // and thus reverts to plain rending
            	    }

            	    if (hPoints) {
            	        // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency
            	        commands = font.hinting.getCommands(hPoints);
            	        x = Math.round(x);
            	        y = Math.round(y);
            	        // TODO in case of hinting xyScaling is not yet supported
            	        xScale = yScale = 1;
            	    } else {
            	        commands = this.path.commands;
            	        var scale = 1 / this.path.unitsPerEm * fontSize;
            	        if (xScale === undefined) { xScale = scale; }
            	        if (yScale === undefined) { yScale = scale; }
            	    }

            	    var p = new Path();
            	    for (var i = 0; i < commands.length; i += 1) {
            	        var cmd = commands[i];
            	        if (cmd.type === 'M') {
            	            p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
            	        } else if (cmd.type === 'L') {
            	            p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
            	        } else if (cmd.type === 'Q') {
            	            p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
            	                               x + (cmd.x * xScale), y + (-cmd.y * yScale));
            	        } else if (cmd.type === 'C') {
            	            p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
            	                      x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),
            	                      x + (cmd.x * xScale), y + (-cmd.y * yScale));
            	        } else if (cmd.type === 'Z') {
            	            p.closePath();
            	        }
            	    }

            	    return p;
            	};

            	/**
            	 * Split the glyph into contours.
            	 * This function is here for backwards compatibility, and to
            	 * provide raw access to the TrueType glyph outlines.
            	 * @return {Array}
            	 */
            	Glyph.prototype.getContours = function() {
            	    var this$1 = this;

            	    if (this.points === undefined) {
            	        return [];
            	    }

            	    var contours = [];
            	    var currentContour = [];
            	    for (var i = 0; i < this.points.length; i += 1) {
            	        var pt = this$1.points[i];
            	        currentContour.push(pt);
            	        if (pt.lastPointOfContour) {
            	            contours.push(currentContour);
            	            currentContour = [];
            	        }
            	    }

            	    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
            	    return contours;
            	};

            	/**
            	 * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
            	 * @return {Object}
            	 */
            	Glyph.prototype.getMetrics = function() {
            	    var commands = this.path.commands;
            	    var xCoords = [];
            	    var yCoords = [];
            	    for (var i = 0; i < commands.length; i += 1) {
            	        var cmd = commands[i];
            	        if (cmd.type !== 'Z') {
            	            xCoords.push(cmd.x);
            	            yCoords.push(cmd.y);
            	        }

            	        if (cmd.type === 'Q' || cmd.type === 'C') {
            	            xCoords.push(cmd.x1);
            	            yCoords.push(cmd.y1);
            	        }

            	        if (cmd.type === 'C') {
            	            xCoords.push(cmd.x2);
            	            yCoords.push(cmd.y2);
            	        }
            	    }

            	    var metrics = {
            	        xMin: Math.min.apply(null, xCoords),
            	        yMin: Math.min.apply(null, yCoords),
            	        xMax: Math.max.apply(null, xCoords),
            	        yMax: Math.max.apply(null, yCoords),
            	        leftSideBearing: this.leftSideBearing
            	    };

            	    if (!isFinite(metrics.xMin)) {
            	        metrics.xMin = 0;
            	    }

            	    if (!isFinite(metrics.xMax)) {
            	        metrics.xMax = this.advanceWidth;
            	    }

            	    if (!isFinite(metrics.yMin)) {
            	        metrics.yMin = 0;
            	    }

            	    if (!isFinite(metrics.yMax)) {
            	        metrics.yMax = 0;
            	    }

            	    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
            	    return metrics;
            	};

            	/**
            	 * Draw the glyph on the given context.
            	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
            	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
            	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
            	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
            	 * @param  {Object=} options - xScale, yScale to stretch the glyph.
            	 */
            	Glyph.prototype.draw = function(ctx, x, y, fontSize, options) {
            	    this.getPath(x, y, fontSize, options).draw(ctx);
            	};

            	/**
            	 * Draw the points of the glyph.
            	 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
            	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
            	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
            	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
            	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
            	 */
            	Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
            	    function drawCircles(l, x, y, scale) {
            	        var PI_SQ = Math.PI * 2;
            	        ctx.beginPath();
            	        for (var j = 0; j < l.length; j += 1) {
            	            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));
            	            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, PI_SQ, false);
            	        }

            	        ctx.closePath();
            	        ctx.fill();
            	    }

            	    x = x !== undefined ? x : 0;
            	    y = y !== undefined ? y : 0;
            	    fontSize = fontSize !== undefined ? fontSize : 24;
            	    var scale = 1 / this.path.unitsPerEm * fontSize;

            	    var blueCircles = [];
            	    var redCircles = [];
            	    var path = this.path;
            	    for (var i = 0; i < path.commands.length; i += 1) {
            	        var cmd = path.commands[i];
            	        if (cmd.x !== undefined) {
            	            blueCircles.push({x: cmd.x, y: -cmd.y});
            	        }

            	        if (cmd.x1 !== undefined) {
            	            redCircles.push({x: cmd.x1, y: -cmd.y1});
            	        }

            	        if (cmd.x2 !== undefined) {
            	            redCircles.push({x: cmd.x2, y: -cmd.y2});
            	        }
            	    }

            	    ctx.fillStyle = 'blue';
            	    drawCircles(blueCircles, x, y, scale);
            	    ctx.fillStyle = 'red';
            	    drawCircles(redCircles, x, y, scale);
            	};

            	/**
            	 * Draw lines indicating important font measurements.
            	 * Black lines indicate the origin of the coordinate system (point 0,0).
            	 * Blue lines indicate the glyph bounding box.
            	 * Green line indicates the advance width of the glyph.
            	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
            	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
            	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
            	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
            	 */
            	Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
            	    var scale;
            	    x = x !== undefined ? x : 0;
            	    y = y !== undefined ? y : 0;
            	    fontSize = fontSize !== undefined ? fontSize : 24;
            	    scale = 1 / this.path.unitsPerEm * fontSize;
            	    ctx.lineWidth = 1;

            	    // Draw the origin
            	    ctx.strokeStyle = 'black';
            	    draw.line(ctx, x, -10000, x, 10000);
            	    draw.line(ctx, -10000, y, 10000, y);

            	    // This code is here due to memory optimization: by not using
            	    // defaults in the constructor, we save a notable amount of memory.
            	    var xMin = this.xMin || 0;
            	    var yMin = this.yMin || 0;
            	    var xMax = this.xMax || 0;
            	    var yMax = this.yMax || 0;
            	    var advanceWidth = this.advanceWidth || 0;

            	    // Draw the glyph box
            	    ctx.strokeStyle = 'blue';
            	    draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);
            	    draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);
            	    draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));
            	    draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));

            	    // Draw the advance width
            	    ctx.strokeStyle = 'green';
            	    draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);
            	};

            	// The GlyphSet object

            	// Define a property on the glyph that depends on the path being loaded.
            	function defineDependentProperty(glyph, externalName, internalName) {
            	    Object.defineProperty(glyph, externalName, {
            	        get: function() {
            	            // Request the path property to make sure the path is loaded.
            	            glyph.path; // jshint ignore:line
            	            return glyph[internalName];
            	        },
            	        set: function(newValue) {
            	            glyph[internalName] = newValue;
            	        },
            	        enumerable: true,
            	        configurable: true
            	    });
            	}

            	/**
            	 * A GlyphSet represents all glyphs available in the font, but modelled using
            	 * a deferred glyph loader, for retrieving glyphs only once they are absolutely
            	 * necessary, to keep the memory footprint down.
            	 * @exports opentype.GlyphSet
            	 * @class
            	 * @param {opentype.Font}
            	 * @param {Array}
            	 */
            	function GlyphSet(font, glyphs) {
            	    var this$1 = this;

            	    this.font = font;
            	    this.glyphs = {};
            	    if (Array.isArray(glyphs)) {
            	        for (var i = 0; i < glyphs.length; i++) {
            	            this$1.glyphs[i] = glyphs[i];
            	        }
            	    }

            	    this.length = (glyphs && glyphs.length) || 0;
            	}

            	/**
            	 * @param  {number} index
            	 * @return {opentype.Glyph}
            	 */
            	GlyphSet.prototype.get = function(index) {
            	    if (typeof this.glyphs[index] === 'function') {
            	        this.glyphs[index] = this.glyphs[index]();
            	    }

            	    return this.glyphs[index];
            	};

            	/**
            	 * @param  {number} index
            	 * @param  {Object}
            	 */
            	GlyphSet.prototype.push = function(index, loader) {
            	    this.glyphs[index] = loader;
            	    this.length++;
            	};

            	/**
            	 * @alias opentype.glyphLoader
            	 * @param  {opentype.Font} font
            	 * @param  {number} index
            	 * @return {opentype.Glyph}
            	 */
            	function glyphLoader(font, index) {
            	    return new Glyph({index: index, font: font});
            	}

            	/**
            	 * Generate a stub glyph that can be filled with all metadata *except*
            	 * the "points" and "path" properties, which must be loaded only once
            	 * the glyph's path is actually requested for text shaping.
            	 * @alias opentype.ttfGlyphLoader
            	 * @param  {opentype.Font} font
            	 * @param  {number} index
            	 * @param  {Function} parseGlyph
            	 * @param  {Object} data
            	 * @param  {number} position
            	 * @param  {Function} buildPath
            	 * @return {opentype.Glyph}
            	 */
            	function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {
            	    return function() {
            	        var glyph = new Glyph({index: index, font: font});

            	        glyph.path = function() {
            	            parseGlyph(glyph, data, position);
            	            var path = buildPath(font.glyphs, glyph);
            	            path.unitsPerEm = font.unitsPerEm;
            	            return path;
            	        };

            	        defineDependentProperty(glyph, 'xMin', '_xMin');
            	        defineDependentProperty(glyph, 'xMax', '_xMax');
            	        defineDependentProperty(glyph, 'yMin', '_yMin');
            	        defineDependentProperty(glyph, 'yMax', '_yMax');

            	        return glyph;
            	    };
            	}
            	/**
            	 * @alias opentype.cffGlyphLoader
            	 * @param  {opentype.Font} font
            	 * @param  {number} index
            	 * @param  {Function} parseCFFCharstring
            	 * @param  {string} charstring
            	 * @return {opentype.Glyph}
            	 */
            	function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {
            	    return function() {
            	        var glyph = new Glyph({index: index, font: font});

            	        glyph.path = function() {
            	            var path = parseCFFCharstring(font, glyph, charstring);
            	            path.unitsPerEm = font.unitsPerEm;
            	            return path;
            	        };

            	        return glyph;
            	    };
            	}

            	var glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };

            	// The `CFF` table contains the glyph outlines in PostScript format.

            	// Custom equals function that can also check lists.
            	function equals(a, b) {
            	    if (a === b) {
            	        return true;
            	    } else if (Array.isArray(a) && Array.isArray(b)) {
            	        if (a.length !== b.length) {
            	            return false;
            	        }

            	        for (var i = 0; i < a.length; i += 1) {
            	            if (!equals(a[i], b[i])) {
            	                return false;
            	            }
            	        }

            	        return true;
            	    } else {
            	        return false;
            	    }
            	}

            	// Subroutines are encoded using the negative half of the number space.
            	// See type 2 chapter 4.7 "Subroutine operators".
            	function calcCFFSubroutineBias(subrs) {
            	    var bias;
            	    if (subrs.length < 1240) {
            	        bias = 107;
            	    } else if (subrs.length < 33900) {
            	        bias = 1131;
            	    } else {
            	        bias = 32768;
            	    }

            	    return bias;
            	}

            	// Parse a `CFF` INDEX array.
            	// An index array consists of a list of offsets, then a list of objects at those offsets.
            	function parseCFFIndex(data, start, conversionFn) {
            	    var offsets = [];
            	    var objects = [];
            	    var count = parse.getCard16(data, start);
            	    var objectOffset;
            	    var endOffset;
            	    if (count !== 0) {
            	        var offsetSize = parse.getByte(data, start + 2);
            	        objectOffset = start + ((count + 1) * offsetSize) + 2;
            	        var pos = start + 3;
            	        for (var i = 0; i < count + 1; i += 1) {
            	            offsets.push(parse.getOffset(data, pos, offsetSize));
            	            pos += offsetSize;
            	        }

            	        // The total size of the index array is 4 header bytes + the value of the last offset.
            	        endOffset = objectOffset + offsets[count];
            	    } else {
            	        endOffset = start + 2;
            	    }

            	    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {
            	        var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);
            	        if (conversionFn) {
            	            value = conversionFn(value);
            	        }

            	        objects.push(value);
            	    }

            	    return {objects: objects, startOffset: start, endOffset: endOffset};
            	}

            	// Parse a `CFF` DICT real value.
            	function parseFloatOperand(parser) {
            	    var s = '';
            	    var eof = 15;
            	    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
            	    while (true) {
            	        var b = parser.parseByte();
            	        var n1 = b >> 4;
            	        var n2 = b & 15;

            	        if (n1 === eof) {
            	            break;
            	        }

            	        s += lookup[n1];

            	        if (n2 === eof) {
            	            break;
            	        }

            	        s += lookup[n2];
            	    }

            	    return parseFloat(s);
            	}

            	// Parse a `CFF` DICT operand.
            	function parseOperand(parser, b0) {
            	    var b1;
            	    var b2;
            	    var b3;
            	    var b4;
            	    if (b0 === 28) {
            	        b1 = parser.parseByte();
            	        b2 = parser.parseByte();
            	        return b1 << 8 | b2;
            	    }

            	    if (b0 === 29) {
            	        b1 = parser.parseByte();
            	        b2 = parser.parseByte();
            	        b3 = parser.parseByte();
            	        b4 = parser.parseByte();
            	        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
            	    }

            	    if (b0 === 30) {
            	        return parseFloatOperand(parser);
            	    }

            	    if (b0 >= 32 && b0 <= 246) {
            	        return b0 - 139;
            	    }

            	    if (b0 >= 247 && b0 <= 250) {
            	        b1 = parser.parseByte();
            	        return (b0 - 247) * 256 + b1 + 108;
            	    }

            	    if (b0 >= 251 && b0 <= 254) {
            	        b1 = parser.parseByte();
            	        return -(b0 - 251) * 256 - b1 - 108;
            	    }

            	    throw new Error('Invalid b0 ' + b0);
            	}

            	// Convert the entries returned by `parseDict` to a proper dictionary.
            	// If a value is a list of one, it is unpacked.
            	function entriesToObject(entries) {
            	    var o = {};
            	    for (var i = 0; i < entries.length; i += 1) {
            	        var key = entries[i][0];
            	        var values = entries[i][1];
            	        var value = (void 0);
            	        if (values.length === 1) {
            	            value = values[0];
            	        } else {
            	            value = values;
            	        }

            	        if (o.hasOwnProperty(key) && !isNaN(o[key])) {
            	            throw new Error('Object ' + o + ' already has key ' + key);
            	        }

            	        o[key] = value;
            	    }

            	    return o;
            	}

            	// Parse a `CFF` DICT object.
            	// A dictionary contains key-value pairs in a compact tokenized format.
            	function parseCFFDict(data, start, size) {
            	    start = start !== undefined ? start : 0;
            	    var parser = new parse.Parser(data, start);
            	    var entries = [];
            	    var operands = [];
            	    size = size !== undefined ? size : data.length;

            	    while (parser.relativeOffset < size) {
            	        var op = parser.parseByte();

            	        // The first byte for each dict item distinguishes between operator (key) and operand (value).
            	        // Values <= 21 are operators.
            	        if (op <= 21) {
            	            // Two-byte operators have an initial escape byte of 12.
            	            if (op === 12) {
            	                op = 1200 + parser.parseByte();
            	            }

            	            entries.push([op, operands]);
            	            operands = [];
            	        } else {
            	            // Since the operands (values) come before the operators (keys), we store all operands in a list
            	            // until we encounter an operator.
            	            operands.push(parseOperand(parser, op));
            	        }
            	    }

            	    return entriesToObject(entries);
            	}

            	// Given a String Index (SID), return the value of the string.
            	// Strings below index 392 are standard CFF strings and are not encoded in the font.
            	function getCFFString(strings, index) {
            	    if (index <= 390) {
            	        index = cffStandardStrings[index];
            	    } else {
            	        index = strings[index - 391];
            	    }

            	    return index;
            	}

            	// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
            	// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
            	function interpretDict(dict, meta, strings) {
            	    var newDict = {};
            	    var value;

            	    // Because we also want to include missing values, we start out from the meta list
            	    // and lookup values in the dict.
            	    for (var i = 0; i < meta.length; i += 1) {
            	        var m = meta[i];

            	        if (Array.isArray(m.type)) {
            	            var values = [];
            	            values.length = m.type.length;
            	            for (var j = 0; j < m.type.length; j++) {
            	                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;
            	                if (value === undefined) {
            	                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;
            	                }
            	                if (m.type[j] === 'SID') {
            	                    value = getCFFString(strings, value);
            	                }
            	                values[j] = value;
            	            }
            	            newDict[m.name] = values;
            	        } else {
            	            value = dict[m.op];
            	            if (value === undefined) {
            	                value = m.value !== undefined ? m.value : null;
            	            }

            	            if (m.type === 'SID') {
            	                value = getCFFString(strings, value);
            	            }
            	            newDict[m.name] = value;
            	        }
            	    }

            	    return newDict;
            	}

            	// Parse the CFF header.
            	function parseCFFHeader(data, start) {
            	    var header = {};
            	    header.formatMajor = parse.getCard8(data, start);
            	    header.formatMinor = parse.getCard8(data, start + 1);
            	    header.size = parse.getCard8(data, start + 2);
            	    header.offsetSize = parse.getCard8(data, start + 3);
            	    header.startOffset = start;
            	    header.endOffset = start + 4;
            	    return header;
            	}

            	var TOP_DICT_META = [
            	    {name: 'version', op: 0, type: 'SID'},
            	    {name: 'notice', op: 1, type: 'SID'},
            	    {name: 'copyright', op: 1200, type: 'SID'},
            	    {name: 'fullName', op: 2, type: 'SID'},
            	    {name: 'familyName', op: 3, type: 'SID'},
            	    {name: 'weight', op: 4, type: 'SID'},
            	    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},
            	    {name: 'italicAngle', op: 1202, type: 'number', value: 0},
            	    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},
            	    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},
            	    {name: 'paintType', op: 1205, type: 'number', value: 0},
            	    {name: 'charstringType', op: 1206, type: 'number', value: 2},
            	    {
            	        name: 'fontMatrix',
            	        op: 1207,
            	        type: ['real', 'real', 'real', 'real', 'real', 'real'],
            	        value: [0.001, 0, 0, 0.001, 0, 0]
            	    },
            	    {name: 'uniqueId', op: 13, type: 'number'},
            	    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},
            	    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},
            	    {name: 'xuid', op: 14, type: [], value: null},
            	    {name: 'charset', op: 15, type: 'offset', value: 0},
            	    {name: 'encoding', op: 16, type: 'offset', value: 0},
            	    {name: 'charStrings', op: 17, type: 'offset', value: 0},
            	    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},
            	    {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},
            	    {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},
            	    {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},
            	    {name: 'cidFontType', op: 1233, type: 'number', value: 0},
            	    {name: 'cidCount', op: 1234, type: 'number', value: 8720},
            	    {name: 'uidBase', op: 1235, type: 'number'},
            	    {name: 'fdArray', op: 1236, type: 'offset'},
            	    {name: 'fdSelect', op: 1237, type: 'offset'},
            	    {name: 'fontName', op: 1238, type: 'SID'}
            	];

            	var PRIVATE_DICT_META = [
            	    {name: 'subrs', op: 19, type: 'offset', value: 0},
            	    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},
            	    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}
            	];

            	// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
            	// The top dictionary contains the essential metadata for the font, together with the private dictionary.
            	function parseCFFTopDict(data, strings) {
            	    var dict = parseCFFDict(data, 0, data.byteLength);
            	    return interpretDict(dict, TOP_DICT_META, strings);
            	}

            	// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
            	function parseCFFPrivateDict(data, start, size, strings) {
            	    var dict = parseCFFDict(data, start, size);
            	    return interpretDict(dict, PRIVATE_DICT_META, strings);
            	}

            	// Returns a list of "Top DICT"s found using an INDEX list.
            	// Used to read both the usual high-level Top DICTs and also the FDArray
            	// discovered inside CID-keyed fonts.  When a Top DICT has a reference to
            	// a Private DICT that is read and saved into the Top DICT.
            	//
            	// In addition to the expected/optional values as outlined in TOP_DICT_META
            	// the following values might be saved into the Top DICT.
            	//
            	//    _subrs []        array of local CFF subroutines from Private DICT
            	//    _subrsBias       bias value computed from number of subroutines
            	//                      (see calcCFFSubroutineBias() and parseCFFCharstring())
            	//    _defaultWidthX   default widths for CFF characters
            	//    _nominalWidthX   bias added to width embedded within glyph description
            	//
            	//    _privateDict     saved copy of parsed Private DICT from Top DICT
            	function gatherCFFTopDicts(data, start, cffIndex, strings) {
            	    var topDictArray = [];
            	    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {
            	        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);
            	        var topDict = parseCFFTopDict(topDictData, strings);
            	        topDict._subrs = [];
            	        topDict._subrsBias = 0;
            	        var privateSize = topDict.private[0];
            	        var privateOffset = topDict.private[1];
            	        if (privateSize !== 0 && privateOffset !== 0) {
            	            var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);
            	            topDict._defaultWidthX = privateDict.defaultWidthX;
            	            topDict._nominalWidthX = privateDict.nominalWidthX;
            	            if (privateDict.subrs !== 0) {
            	                var subrOffset = privateOffset + privateDict.subrs;
            	                var subrIndex = parseCFFIndex(data, subrOffset + start);
            	                topDict._subrs = subrIndex.objects;
            	                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);
            	            }
            	            topDict._privateDict = privateDict;
            	        }
            	        topDictArray.push(topDict);
            	    }
            	    return topDictArray;
            	}

            	// Parse the CFF charset table, which contains internal names for all the glyphs.
            	// This function will return a list of glyph names.
            	// See Adobe TN #5176 chapter 13, "Charsets".
            	function parseCFFCharset(data, start, nGlyphs, strings) {
            	    var sid;
            	    var count;
            	    var parser = new parse.Parser(data, start);

            	    // The .notdef glyph is not included, so subtract 1.
            	    nGlyphs -= 1;
            	    var charset = ['.notdef'];

            	    var format = parser.parseCard8();
            	    if (format === 0) {
            	        for (var i = 0; i < nGlyphs; i += 1) {
            	            sid = parser.parseSID();
            	            charset.push(getCFFString(strings, sid));
            	        }
            	    } else if (format === 1) {
            	        while (charset.length <= nGlyphs) {
            	            sid = parser.parseSID();
            	            count = parser.parseCard8();
            	            for (var i$1 = 0; i$1 <= count; i$1 += 1) {
            	                charset.push(getCFFString(strings, sid));
            	                sid += 1;
            	            }
            	        }
            	    } else if (format === 2) {
            	        while (charset.length <= nGlyphs) {
            	            sid = parser.parseSID();
            	            count = parser.parseCard16();
            	            for (var i$2 = 0; i$2 <= count; i$2 += 1) {
            	                charset.push(getCFFString(strings, sid));
            	                sid += 1;
            	            }
            	        }
            	    } else {
            	        throw new Error('Unknown charset format ' + format);
            	    }

            	    return charset;
            	}

            	// Parse the CFF encoding data. Only one encoding can be specified per font.
            	// See Adobe TN #5176 chapter 12, "Encodings".
            	function parseCFFEncoding(data, start, charset) {
            	    var code;
            	    var enc = {};
            	    var parser = new parse.Parser(data, start);
            	    var format = parser.parseCard8();
            	    if (format === 0) {
            	        var nCodes = parser.parseCard8();
            	        for (var i = 0; i < nCodes; i += 1) {
            	            code = parser.parseCard8();
            	            enc[code] = i;
            	        }
            	    } else if (format === 1) {
            	        var nRanges = parser.parseCard8();
            	        code = 1;
            	        for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {
            	            var first = parser.parseCard8();
            	            var nLeft = parser.parseCard8();
            	            for (var j = first; j <= first + nLeft; j += 1) {
            	                enc[j] = code;
            	                code += 1;
            	            }
            	        }
            	    } else {
            	        throw new Error('Unknown encoding format ' + format);
            	    }

            	    return new CffEncoding(enc, charset);
            	}

            	// Take in charstring code and return a Glyph object.
            	// The encoding is described in the Type 2 Charstring Format
            	// https://www.microsoft.com/typography/OTSPEC/charstr2.htm
            	function parseCFFCharstring(font, glyph, code) {
            	    var c1x;
            	    var c1y;
            	    var c2x;
            	    var c2y;
            	    var p = new Path();
            	    var stack = [];
            	    var nStems = 0;
            	    var haveWidth = false;
            	    var open = false;
            	    var x = 0;
            	    var y = 0;
            	    var subrs;
            	    var subrsBias;
            	    var defaultWidthX;
            	    var nominalWidthX;
            	    if (font.isCIDFont) {
            	        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];
            	        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];
            	        subrs = fdDict._subrs;
            	        subrsBias = fdDict._subrsBias;
            	        defaultWidthX = fdDict._defaultWidthX;
            	        nominalWidthX = fdDict._nominalWidthX;
            	    } else {
            	        subrs = font.tables.cff.topDict._subrs;
            	        subrsBias = font.tables.cff.topDict._subrsBias;
            	        defaultWidthX = font.tables.cff.topDict._defaultWidthX;
            	        nominalWidthX = font.tables.cff.topDict._nominalWidthX;
            	    }
            	    var width = defaultWidthX;

            	    function newContour(x, y) {
            	        if (open) {
            	            p.closePath();
            	        }

            	        p.moveTo(x, y);
            	        open = true;
            	    }

            	    function parseStems() {
            	        var hasWidthArg;

            	        // The number of stem operators on the stack is always even.
            	        // If the value is uneven, that means a width is specified.
            	        hasWidthArg = stack.length % 2 !== 0;
            	        if (hasWidthArg && !haveWidth) {
            	            width = stack.shift() + nominalWidthX;
            	        }

            	        nStems += stack.length >> 1;
            	        stack.length = 0;
            	        haveWidth = true;
            	    }

            	    function parse$$1(code) {
            	        var b1;
            	        var b2;
            	        var b3;
            	        var b4;
            	        var codeIndex;
            	        var subrCode;
            	        var jpx;
            	        var jpy;
            	        var c3x;
            	        var c3y;
            	        var c4x;
            	        var c4y;

            	        var i = 0;
            	        while (i < code.length) {
            	            var v = code[i];
            	            i += 1;
            	            switch (v) {
            	                case 1: // hstem
            	                    parseStems();
            	                    break;
            	                case 3: // vstem
            	                    parseStems();
            	                    break;
            	                case 4: // vmoveto
            	                    if (stack.length > 1 && !haveWidth) {
            	                        width = stack.shift() + nominalWidthX;
            	                        haveWidth = true;
            	                    }

            	                    y += stack.pop();
            	                    newContour(x, y);
            	                    break;
            	                case 5: // rlineto
            	                    while (stack.length > 0) {
            	                        x += stack.shift();
            	                        y += stack.shift();
            	                        p.lineTo(x, y);
            	                    }

            	                    break;
            	                case 6: // hlineto
            	                    while (stack.length > 0) {
            	                        x += stack.shift();
            	                        p.lineTo(x, y);
            	                        if (stack.length === 0) {
            	                            break;
            	                        }

            	                        y += stack.shift();
            	                        p.lineTo(x, y);
            	                    }

            	                    break;
            	                case 7: // vlineto
            	                    while (stack.length > 0) {
            	                        y += stack.shift();
            	                        p.lineTo(x, y);
            	                        if (stack.length === 0) {
            	                            break;
            	                        }

            	                        x += stack.shift();
            	                        p.lineTo(x, y);
            	                    }

            	                    break;
            	                case 8: // rrcurveto
            	                    while (stack.length > 0) {
            	                        c1x = x + stack.shift();
            	                        c1y = y + stack.shift();
            	                        c2x = c1x + stack.shift();
            	                        c2y = c1y + stack.shift();
            	                        x = c2x + stack.shift();
            	                        y = c2y + stack.shift();
            	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
            	                    }

            	                    break;
            	                case 10: // callsubr
            	                    codeIndex = stack.pop() + subrsBias;
            	                    subrCode = subrs[codeIndex];
            	                    if (subrCode) {
            	                        parse$$1(subrCode);
            	                    }

            	                    break;
            	                case 11: // return
            	                    return;
            	                case 12: // flex operators
            	                    v = code[i];
            	                    i += 1;
            	                    switch (v) {
            	                        case 35: // flex
            	                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-
            	                            c1x = x   + stack.shift();    // dx1
            	                            c1y = y   + stack.shift();    // dy1
            	                            c2x = c1x + stack.shift();    // dx2
            	                            c2y = c1y + stack.shift();    // dy2
            	                            jpx = c2x + stack.shift();    // dx3
            	                            jpy = c2y + stack.shift();    // dy3
            	                            c3x = jpx + stack.shift();    // dx4
            	                            c3y = jpy + stack.shift();    // dy4
            	                            c4x = c3x + stack.shift();    // dx5
            	                            c4y = c3y + stack.shift();    // dy5
            	                            x = c4x   + stack.shift();    // dx6
            	                            y = c4y   + stack.shift();    // dy6
            	                            stack.shift();                // flex depth
            	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
            	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
            	                            break;
            	                        case 34: // hflex
            	                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-
            	                            c1x = x   + stack.shift();    // dx1
            	                            c1y = y;                      // dy1
            	                            c2x = c1x + stack.shift();    // dx2
            	                            c2y = c1y + stack.shift();    // dy2
            	                            jpx = c2x + stack.shift();    // dx3
            	                            jpy = c2y;                    // dy3
            	                            c3x = jpx + stack.shift();    // dx4
            	                            c3y = c2y;                    // dy4
            	                            c4x = c3x + stack.shift();    // dx5
            	                            c4y = y;                      // dy5
            	                            x = c4x + stack.shift();      // dx6
            	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
            	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
            	                            break;
            	                        case 36: // hflex1
            	                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-
            	                            c1x = x   + stack.shift();    // dx1
            	                            c1y = y   + stack.shift();    // dy1
            	                            c2x = c1x + stack.shift();    // dx2
            	                            c2y = c1y + stack.shift();    // dy2
            	                            jpx = c2x + stack.shift();    // dx3
            	                            jpy = c2y;                    // dy3
            	                            c3x = jpx + stack.shift();    // dx4
            	                            c3y = c2y;                    // dy4
            	                            c4x = c3x + stack.shift();    // dx5
            	                            c4y = c3y + stack.shift();    // dy5
            	                            x = c4x + stack.shift();      // dx6
            	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
            	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
            	                            break;
            	                        case 37: // flex1
            	                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-
            	                            c1x = x   + stack.shift();    // dx1
            	                            c1y = y   + stack.shift();    // dy1
            	                            c2x = c1x + stack.shift();    // dx2
            	                            c2y = c1y + stack.shift();    // dy2
            	                            jpx = c2x + stack.shift();    // dx3
            	                            jpy = c2y + stack.shift();    // dy3
            	                            c3x = jpx + stack.shift();    // dx4
            	                            c3y = jpy + stack.shift();    // dy4
            	                            c4x = c3x + stack.shift();    // dx5
            	                            c4y = c3y + stack.shift();    // dy5
            	                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
            	                                x = c4x + stack.shift();
            	                            } else {
            	                                y = c4y + stack.shift();
            	                            }

            	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
            	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
            	                            break;
            	                        default:
            	                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);
            	                            stack.length = 0;
            	                    }
            	                    break;
            	                case 14: // endchar
            	                    if (stack.length > 0 && !haveWidth) {
            	                        width = stack.shift() + nominalWidthX;
            	                        haveWidth = true;
            	                    }

            	                    if (open) {
            	                        p.closePath();
            	                        open = false;
            	                    }

            	                    break;
            	                case 18: // hstemhm
            	                    parseStems();
            	                    break;
            	                case 19: // hintmask
            	                case 20: // cntrmask
            	                    parseStems();
            	                    i += (nStems + 7) >> 3;
            	                    break;
            	                case 21: // rmoveto
            	                    if (stack.length > 2 && !haveWidth) {
            	                        width = stack.shift() + nominalWidthX;
            	                        haveWidth = true;
            	                    }

            	                    y += stack.pop();
            	                    x += stack.pop();
            	                    newContour(x, y);
            	                    break;
            	                case 22: // hmoveto
            	                    if (stack.length > 1 && !haveWidth) {
            	                        width = stack.shift() + nominalWidthX;
            	                        haveWidth = true;
            	                    }

            	                    x += stack.pop();
            	                    newContour(x, y);
            	                    break;
            	                case 23: // vstemhm
            	                    parseStems();
            	                    break;
            	                case 24: // rcurveline
            	                    while (stack.length > 2) {
            	                        c1x = x + stack.shift();
            	                        c1y = y + stack.shift();
            	                        c2x = c1x + stack.shift();
            	                        c2y = c1y + stack.shift();
            	                        x = c2x + stack.shift();
            	                        y = c2y + stack.shift();
            	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
            	                    }

            	                    x += stack.shift();
            	                    y += stack.shift();
            	                    p.lineTo(x, y);
            	                    break;
            	                case 25: // rlinecurve
            	                    while (stack.length > 6) {
            	                        x += stack.shift();
            	                        y += stack.shift();
            	                        p.lineTo(x, y);
            	                    }

            	                    c1x = x + stack.shift();
            	                    c1y = y + stack.shift();
            	                    c2x = c1x + stack.shift();
            	                    c2y = c1y + stack.shift();
            	                    x = c2x + stack.shift();
            	                    y = c2y + stack.shift();
            	                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
            	                    break;
            	                case 26: // vvcurveto
            	                    if (stack.length % 2) {
            	                        x += stack.shift();
            	                    }

            	                    while (stack.length > 0) {
            	                        c1x = x;
            	                        c1y = y + stack.shift();
            	                        c2x = c1x + stack.shift();
            	                        c2y = c1y + stack.shift();
            	                        x = c2x;
            	                        y = c2y + stack.shift();
            	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
            	                    }

            	                    break;
            	                case 27: // hhcurveto
            	                    if (stack.length % 2) {
            	                        y += stack.shift();
            	                    }

            	                    while (stack.length > 0) {
            	                        c1x = x + stack.shift();
            	                        c1y = y;
            	                        c2x = c1x + stack.shift();
            	                        c2y = c1y + stack.shift();
            	                        x = c2x + stack.shift();
            	                        y = c2y;
            	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
            	                    }

            	                    break;
            	                case 28: // shortint
            	                    b1 = code[i];
            	                    b2 = code[i + 1];
            	                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);
            	                    i += 2;
            	                    break;
            	                case 29: // callgsubr
            	                    codeIndex = stack.pop() + font.gsubrsBias;
            	                    subrCode = font.gsubrs[codeIndex];
            	                    if (subrCode) {
            	                        parse$$1(subrCode);
            	                    }

            	                    break;
            	                case 30: // vhcurveto
            	                    while (stack.length > 0) {
            	                        c1x = x;
            	                        c1y = y + stack.shift();
            	                        c2x = c1x + stack.shift();
            	                        c2y = c1y + stack.shift();
            	                        x = c2x + stack.shift();
            	                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
            	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
            	                        if (stack.length === 0) {
            	                            break;
            	                        }

            	                        c1x = x + stack.shift();
            	                        c1y = y;
            	                        c2x = c1x + stack.shift();
            	                        c2y = c1y + stack.shift();
            	                        y = c2y + stack.shift();
            	                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
            	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
            	                    }

            	                    break;
            	                case 31: // hvcurveto
            	                    while (stack.length > 0) {
            	                        c1x = x + stack.shift();
            	                        c1y = y;
            	                        c2x = c1x + stack.shift();
            	                        c2y = c1y + stack.shift();
            	                        y = c2y + stack.shift();
            	                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
            	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
            	                        if (stack.length === 0) {
            	                            break;
            	                        }

            	                        c1x = x;
            	                        c1y = y + stack.shift();
            	                        c2x = c1x + stack.shift();
            	                        c2y = c1y + stack.shift();
            	                        x = c2x + stack.shift();
            	                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
            	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
            	                    }

            	                    break;
            	                default:
            	                    if (v < 32) {
            	                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);
            	                    } else if (v < 247) {
            	                        stack.push(v - 139);
            	                    } else if (v < 251) {
            	                        b1 = code[i];
            	                        i += 1;
            	                        stack.push((v - 247) * 256 + b1 + 108);
            	                    } else if (v < 255) {
            	                        b1 = code[i];
            	                        i += 1;
            	                        stack.push(-(v - 251) * 256 - b1 - 108);
            	                    } else {
            	                        b1 = code[i];
            	                        b2 = code[i + 1];
            	                        b3 = code[i + 2];
            	                        b4 = code[i + 3];
            	                        i += 4;
            	                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);
            	                    }
            	            }
            	        }
            	    }

            	    parse$$1(code);

            	    glyph.advanceWidth = width;
            	    return p;
            	}

            	function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {
            	    var fdSelect = [];
            	    var fdIndex;
            	    var parser = new parse.Parser(data, start);
            	    var format = parser.parseCard8();
            	    if (format === 0) {
            	        // Simple list of nGlyphs elements
            	        for (var iGid = 0; iGid < nGlyphs; iGid++) {
            	            fdIndex = parser.parseCard8();
            	            if (fdIndex >= fdArrayCount) {
            	                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
            	            }
            	            fdSelect.push(fdIndex);
            	        }
            	    } else if (format === 3) {
            	        // Ranges
            	        var nRanges = parser.parseCard16();
            	        var first = parser.parseCard16();
            	        if (first !== 0) {
            	            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);
            	        }
            	        var next;
            	        for (var iRange = 0; iRange < nRanges; iRange++) {
            	            fdIndex = parser.parseCard8();
            	            next = parser.parseCard16();
            	            if (fdIndex >= fdArrayCount) {
            	                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
            	            }
            	            if (next > nGlyphs) {
            	                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);
            	            }
            	            for (; first < next; first++) {
            	                fdSelect.push(fdIndex);
            	            }
            	            first = next;
            	        }
            	        if (next !== nGlyphs) {
            	            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);
            	        }
            	    } else {
            	        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);
            	    }
            	    return fdSelect;
            	}

            	// Parse the `CFF` table, which contains the glyph outlines in PostScript format.
            	function parseCFFTable(data, start, font) {
            	    font.tables.cff = {};
            	    var header = parseCFFHeader(data, start);
            	    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
            	    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
            	    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
            	    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
            	    font.gsubrs = globalSubrIndex.objects;
            	    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);

            	    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);
            	    if (topDictArray.length !== 1) {
            	        throw new Error('CFF table has too many fonts in \'FontSet\' - count of fonts NameIndex.length = ' + topDictArray.length);
            	    }

            	    var topDict = topDictArray[0];
            	    font.tables.cff.topDict = topDict;

            	    if (topDict._privateDict) {
            	        font.defaultWidthX = topDict._privateDict.defaultWidthX;
            	        font.nominalWidthX = topDict._privateDict.nominalWidthX;
            	    }

            	    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {
            	        font.isCIDFont = true;
            	    }

            	    if (font.isCIDFont) {
            	        var fdArrayOffset = topDict.fdArray;
            	        var fdSelectOffset = topDict.fdSelect;
            	        if (fdArrayOffset === 0 || fdSelectOffset === 0) {
            	            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');
            	        }
            	        fdArrayOffset += start;
            	        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);
            	        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);
            	        topDict._fdArray = fdArray;
            	        fdSelectOffset += start;
            	        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);
            	    }

            	    var privateDictOffset = start + topDict.private[1];
            	    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);
            	    font.defaultWidthX = privateDict.defaultWidthX;
            	    font.nominalWidthX = privateDict.nominalWidthX;

            	    if (privateDict.subrs !== 0) {
            	        var subrOffset = privateDictOffset + privateDict.subrs;
            	        var subrIndex = parseCFFIndex(data, subrOffset);
            	        font.subrs = subrIndex.objects;
            	        font.subrsBias = calcCFFSubroutineBias(font.subrs);
            	    } else {
            	        font.subrs = [];
            	        font.subrsBias = 0;
            	    }

            	    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
            	    var charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
            	    font.nGlyphs = charStringsIndex.objects.length;

            	    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
            	    if (topDict.encoding === 0) {
            	        // Standard encoding
            	        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);
            	    } else if (topDict.encoding === 1) {
            	        // Expert encoding
            	        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);
            	    } else {
            	        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
            	    }

            	    // Prefer the CMAP encoding to the CFF encoding.
            	    font.encoding = font.encoding || font.cffEncoding;

            	    font.glyphs = new glyphset.GlyphSet(font);
            	    for (var i = 0; i < font.nGlyphs; i += 1) {
            	        var charString = charStringsIndex.objects[i];
            	        font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
            	    }
            	}

            	// Convert a string to a String ID (SID).
            	// The list of strings is modified in place.
            	function encodeString(s, strings) {
            	    var sid;

            	    // Is the string in the CFF standard strings?
            	    var i = cffStandardStrings.indexOf(s);
            	    if (i >= 0) {
            	        sid = i;
            	    }

            	    // Is the string already in the string index?
            	    i = strings.indexOf(s);
            	    if (i >= 0) {
            	        sid = i + cffStandardStrings.length;
            	    } else {
            	        sid = cffStandardStrings.length + strings.length;
            	        strings.push(s);
            	    }

            	    return sid;
            	}

            	function makeHeader() {
            	    return new table.Record('Header', [
            	        {name: 'major', type: 'Card8', value: 1},
            	        {name: 'minor', type: 'Card8', value: 0},
            	        {name: 'hdrSize', type: 'Card8', value: 4},
            	        {name: 'major', type: 'Card8', value: 1}
            	    ]);
            	}

            	function makeNameIndex(fontNames) {
            	    var t = new table.Record('Name INDEX', [
            	        {name: 'names', type: 'INDEX', value: []}
            	    ]);
            	    t.names = [];
            	    for (var i = 0; i < fontNames.length; i += 1) {
            	        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});
            	    }

            	    return t;
            	}

            	// Given a dictionary's metadata, create a DICT structure.
            	function makeDict(meta, attrs, strings) {
            	    var m = {};
            	    for (var i = 0; i < meta.length; i += 1) {
            	        var entry = meta[i];
            	        var value = attrs[entry.name];
            	        if (value !== undefined && !equals(value, entry.value)) {
            	            if (entry.type === 'SID') {
            	                value = encodeString(value, strings);
            	            }

            	            m[entry.op] = {name: entry.name, type: entry.type, value: value};
            	        }
            	    }

            	    return m;
            	}

            	// The Top DICT houses the global font attributes.
            	function makeTopDict(attrs, strings) {
            	    var t = new table.Record('Top DICT', [
            	        {name: 'dict', type: 'DICT', value: {}}
            	    ]);
            	    t.dict = makeDict(TOP_DICT_META, attrs, strings);
            	    return t;
            	}

            	function makeTopDictIndex(topDict) {
            	    var t = new table.Record('Top DICT INDEX', [
            	        {name: 'topDicts', type: 'INDEX', value: []}
            	    ]);
            	    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];
            	    return t;
            	}

            	function makeStringIndex(strings) {
            	    var t = new table.Record('String INDEX', [
            	        {name: 'strings', type: 'INDEX', value: []}
            	    ]);
            	    t.strings = [];
            	    for (var i = 0; i < strings.length; i += 1) {
            	        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});
            	    }

            	    return t;
            	}

            	function makeGlobalSubrIndex() {
            	    // Currently we don't use subroutines.
            	    return new table.Record('Global Subr INDEX', [
            	        {name: 'subrs', type: 'INDEX', value: []}
            	    ]);
            	}

            	function makeCharsets(glyphNames, strings) {
            	    var t = new table.Record('Charsets', [
            	        {name: 'format', type: 'Card8', value: 0}
            	    ]);
            	    for (var i = 0; i < glyphNames.length; i += 1) {
            	        var glyphName = glyphNames[i];
            	        var glyphSID = encodeString(glyphName, strings);
            	        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});
            	    }

            	    return t;
            	}

            	function glyphToOps(glyph) {
            	    var ops = [];
            	    var path = glyph.path;
            	    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});
            	    var x = 0;
            	    var y = 0;
            	    for (var i = 0; i < path.commands.length; i += 1) {
            	        var dx = (void 0);
            	        var dy = (void 0);
            	        var cmd = path.commands[i];
            	        if (cmd.type === 'Q') {
            	            // CFF only supports bézier curves, so convert the quad to a bézier.
            	            var _13 = 1 / 3;
            	            var _23 = 2 / 3;

            	            // We're going to create a new command so we don't change the original path.
            	            cmd = {
            	                type: 'C',
            	                x: cmd.x,
            	                y: cmd.y,
            	                x1: _13 * x + _23 * cmd.x1,
            	                y1: _13 * y + _23 * cmd.y1,
            	                x2: _13 * cmd.x + _23 * cmd.x1,
            	                y2: _13 * cmd.y + _23 * cmd.y1
            	            };
            	        }

            	        if (cmd.type === 'M') {
            	            dx = Math.round(cmd.x - x);
            	            dy = Math.round(cmd.y - y);
            	            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            	            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            	            ops.push({name: 'rmoveto', type: 'OP', value: 21});
            	            x = Math.round(cmd.x);
            	            y = Math.round(cmd.y);
            	        } else if (cmd.type === 'L') {
            	            dx = Math.round(cmd.x - x);
            	            dy = Math.round(cmd.y - y);
            	            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            	            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            	            ops.push({name: 'rlineto', type: 'OP', value: 5});
            	            x = Math.round(cmd.x);
            	            y = Math.round(cmd.y);
            	        } else if (cmd.type === 'C') {
            	            var dx1 = Math.round(cmd.x1 - x);
            	            var dy1 = Math.round(cmd.y1 - y);
            	            var dx2 = Math.round(cmd.x2 - cmd.x1);
            	            var dy2 = Math.round(cmd.y2 - cmd.y1);
            	            dx = Math.round(cmd.x - cmd.x2);
            	            dy = Math.round(cmd.y - cmd.y2);
            	            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});
            	            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});
            	            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});
            	            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});
            	            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            	            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            	            ops.push({name: 'rrcurveto', type: 'OP', value: 8});
            	            x = Math.round(cmd.x);
            	            y = Math.round(cmd.y);
            	        }

            	        // Contours are closed automatically.
            	    }

            	    ops.push({name: 'endchar', type: 'OP', value: 14});
            	    return ops;
            	}

            	function makeCharStringsIndex(glyphs) {
            	    var t = new table.Record('CharStrings INDEX', [
            	        {name: 'charStrings', type: 'INDEX', value: []}
            	    ]);

            	    for (var i = 0; i < glyphs.length; i += 1) {
            	        var glyph = glyphs.get(i);
            	        var ops = glyphToOps(glyph);
            	        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});
            	    }

            	    return t;
            	}

            	function makePrivateDict(attrs, strings) {
            	    var t = new table.Record('Private DICT', [
            	        {name: 'dict', type: 'DICT', value: {}}
            	    ]);
            	    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
            	    return t;
            	}

            	function makeCFFTable(glyphs, options) {
            	    var t = new table.Table('CFF ', [
            	        {name: 'header', type: 'RECORD'},
            	        {name: 'nameIndex', type: 'RECORD'},
            	        {name: 'topDictIndex', type: 'RECORD'},
            	        {name: 'stringIndex', type: 'RECORD'},
            	        {name: 'globalSubrIndex', type: 'RECORD'},
            	        {name: 'charsets', type: 'RECORD'},
            	        {name: 'charStringsIndex', type: 'RECORD'},
            	        {name: 'privateDict', type: 'RECORD'}
            	    ]);

            	    var fontScale = 1 / options.unitsPerEm;
            	    // We use non-zero values for the offsets so that the DICT encodes them.
            	    // This is important because the size of the Top DICT plays a role in offset calculation,
            	    // and the size shouldn't change after we've written correct offsets.
            	    var attrs = {
            	        version: options.version,
            	        fullName: options.fullName,
            	        familyName: options.familyName,
            	        weight: options.weightName,
            	        fontBBox: options.fontBBox || [0, 0, 0, 0],
            	        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
            	        charset: 999,
            	        encoding: 0,
            	        charStrings: 999,
            	        private: [0, 999]
            	    };

            	    var privateAttrs = {};

            	    var glyphNames = [];
            	    var glyph;

            	    // Skip first glyph (.notdef)
            	    for (var i = 1; i < glyphs.length; i += 1) {
            	        glyph = glyphs.get(i);
            	        glyphNames.push(glyph.name);
            	    }

            	    var strings = [];

            	    t.header = makeHeader();
            	    t.nameIndex = makeNameIndex([options.postScriptName]);
            	    var topDict = makeTopDict(attrs, strings);
            	    t.topDictIndex = makeTopDictIndex(topDict);
            	    t.globalSubrIndex = makeGlobalSubrIndex();
            	    t.charsets = makeCharsets(glyphNames, strings);
            	    t.charStringsIndex = makeCharStringsIndex(glyphs);
            	    t.privateDict = makePrivateDict(privateAttrs, strings);

            	    // Needs to come at the end, to encode all custom strings used in the font.
            	    t.stringIndex = makeStringIndex(strings);

            	    var startOffset = t.header.sizeOf() +
            	        t.nameIndex.sizeOf() +
            	        t.topDictIndex.sizeOf() +
            	        t.stringIndex.sizeOf() +
            	        t.globalSubrIndex.sizeOf();
            	    attrs.charset = startOffset;

            	    // We use the CFF standard encoding; proper encoding will be handled in cmap.
            	    attrs.encoding = 0;
            	    attrs.charStrings = attrs.charset + t.charsets.sizeOf();
            	    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();

            	    // Recreate the Top DICT INDEX with the correct offsets.
            	    topDict = makeTopDict(attrs, strings);
            	    t.topDictIndex = makeTopDictIndex(topDict);

            	    return t;
            	}

            	var cff = { parse: parseCFFTable, make: makeCFFTable };

            	// The `head` table contains global information about the font.

            	// Parse the header `head` table
            	function parseHeadTable(data, start) {
            	    var head = {};
            	    var p = new parse.Parser(data, start);
            	    head.version = p.parseVersion();
            	    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
            	    head.checkSumAdjustment = p.parseULong();
            	    head.magicNumber = p.parseULong();
            	    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
            	    head.flags = p.parseUShort();
            	    head.unitsPerEm = p.parseUShort();
            	    head.created = p.parseLongDateTime();
            	    head.modified = p.parseLongDateTime();
            	    head.xMin = p.parseShort();
            	    head.yMin = p.parseShort();
            	    head.xMax = p.parseShort();
            	    head.yMax = p.parseShort();
            	    head.macStyle = p.parseUShort();
            	    head.lowestRecPPEM = p.parseUShort();
            	    head.fontDirectionHint = p.parseShort();
            	    head.indexToLocFormat = p.parseShort();
            	    head.glyphDataFormat = p.parseShort();
            	    return head;
            	}

            	function makeHeadTable(options) {
            	    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970
            	    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;
            	    var createdTimestamp = timestamp;

            	    if (options.createdTimestamp) {
            	        createdTimestamp = options.createdTimestamp + 2082844800;
            	    }

            	    return new table.Table('head', [
            	        {name: 'version', type: 'FIXED', value: 0x00010000},
            	        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},
            	        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},
            	        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},
            	        {name: 'flags', type: 'USHORT', value: 0},
            	        {name: 'unitsPerEm', type: 'USHORT', value: 1000},
            	        {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},
            	        {name: 'modified', type: 'LONGDATETIME', value: timestamp},
            	        {name: 'xMin', type: 'SHORT', value: 0},
            	        {name: 'yMin', type: 'SHORT', value: 0},
            	        {name: 'xMax', type: 'SHORT', value: 0},
            	        {name: 'yMax', type: 'SHORT', value: 0},
            	        {name: 'macStyle', type: 'USHORT', value: 0},
            	        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},
            	        {name: 'fontDirectionHint', type: 'SHORT', value: 2},
            	        {name: 'indexToLocFormat', type: 'SHORT', value: 0},
            	        {name: 'glyphDataFormat', type: 'SHORT', value: 0}
            	    ], options);
            	}

            	var head = { parse: parseHeadTable, make: makeHeadTable };

            	// The `hhea` table contains information for horizontal layout.

            	// Parse the horizontal header `hhea` table
            	function parseHheaTable(data, start) {
            	    var hhea = {};
            	    var p = new parse.Parser(data, start);
            	    hhea.version = p.parseVersion();
            	    hhea.ascender = p.parseShort();
            	    hhea.descender = p.parseShort();
            	    hhea.lineGap = p.parseShort();
            	    hhea.advanceWidthMax = p.parseUShort();
            	    hhea.minLeftSideBearing = p.parseShort();
            	    hhea.minRightSideBearing = p.parseShort();
            	    hhea.xMaxExtent = p.parseShort();
            	    hhea.caretSlopeRise = p.parseShort();
            	    hhea.caretSlopeRun = p.parseShort();
            	    hhea.caretOffset = p.parseShort();
            	    p.relativeOffset += 8;
            	    hhea.metricDataFormat = p.parseShort();
            	    hhea.numberOfHMetrics = p.parseUShort();
            	    return hhea;
            	}

            	function makeHheaTable(options) {
            	    return new table.Table('hhea', [
            	        {name: 'version', type: 'FIXED', value: 0x00010000},
            	        {name: 'ascender', type: 'FWORD', value: 0},
            	        {name: 'descender', type: 'FWORD', value: 0},
            	        {name: 'lineGap', type: 'FWORD', value: 0},
            	        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},
            	        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},
            	        {name: 'minRightSideBearing', type: 'FWORD', value: 0},
            	        {name: 'xMaxExtent', type: 'FWORD', value: 0},
            	        {name: 'caretSlopeRise', type: 'SHORT', value: 1},
            	        {name: 'caretSlopeRun', type: 'SHORT', value: 0},
            	        {name: 'caretOffset', type: 'SHORT', value: 0},
            	        {name: 'reserved1', type: 'SHORT', value: 0},
            	        {name: 'reserved2', type: 'SHORT', value: 0},
            	        {name: 'reserved3', type: 'SHORT', value: 0},
            	        {name: 'reserved4', type: 'SHORT', value: 0},
            	        {name: 'metricDataFormat', type: 'SHORT', value: 0},
            	        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}
            	    ], options);
            	}

            	var hhea = { parse: parseHheaTable, make: makeHheaTable };

            	// The `hmtx` table contains the horizontal metrics for all glyphs.

            	// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.
            	// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
            	function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {
            	    var advanceWidth;
            	    var leftSideBearing;
            	    var p = new parse.Parser(data, start);
            	    for (var i = 0; i < numGlyphs; i += 1) {
            	        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
            	        if (i < numMetrics) {
            	            advanceWidth = p.parseUShort();
            	            leftSideBearing = p.parseShort();
            	        }

            	        var glyph = glyphs.get(i);
            	        glyph.advanceWidth = advanceWidth;
            	        glyph.leftSideBearing = leftSideBearing;
            	    }
            	}

            	function makeHmtxTable(glyphs) {
            	    var t = new table.Table('hmtx', []);
            	    for (var i = 0; i < glyphs.length; i += 1) {
            	        var glyph = glyphs.get(i);
            	        var advanceWidth = glyph.advanceWidth || 0;
            	        var leftSideBearing = glyph.leftSideBearing || 0;
            	        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});
            	        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});
            	    }

            	    return t;
            	}

            	var hmtx = { parse: parseHmtxTable, make: makeHmtxTable };

            	// The `ltag` table stores IETF BCP-47 language tags. It allows supporting

            	function makeLtagTable(tags) {
            	    var result = new table.Table('ltag', [
            	        {name: 'version', type: 'ULONG', value: 1},
            	        {name: 'flags', type: 'ULONG', value: 0},
            	        {name: 'numTags', type: 'ULONG', value: tags.length}
            	    ]);

            	    var stringPool = '';
            	    var stringPoolOffset = 12 + tags.length * 4;
            	    for (var i = 0; i < tags.length; ++i) {
            	        var pos = stringPool.indexOf(tags[i]);
            	        if (pos < 0) {
            	            pos = stringPool.length;
            	            stringPool += tags[i];
            	        }

            	        result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});
            	        result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});
            	    }

            	    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});
            	    return result;
            	}

            	function parseLtagTable(data, start) {
            	    var p = new parse.Parser(data, start);
            	    var tableVersion = p.parseULong();
            	    check.argument(tableVersion === 1, 'Unsupported ltag table version.');
            	    // The 'ltag' specification does not define any flags; skip the field.
            	    p.skip('uLong', 1);
            	    var numTags = p.parseULong();

            	    var tags = [];
            	    for (var i = 0; i < numTags; i++) {
            	        var tag = '';
            	        var offset = start + p.parseUShort();
            	        var length = p.parseUShort();
            	        for (var j = offset; j < offset + length; ++j) {
            	            tag += String.fromCharCode(data.getInt8(j));
            	        }

            	        tags.push(tag);
            	    }

            	    return tags;
            	}

            	var ltag = { make: makeLtagTable, parse: parseLtagTable };

            	// The `maxp` table establishes the memory requirements for the font.

            	// Parse the maximum profile `maxp` table.
            	function parseMaxpTable(data, start) {
            	    var maxp = {};
            	    var p = new parse.Parser(data, start);
            	    maxp.version = p.parseVersion();
            	    maxp.numGlyphs = p.parseUShort();
            	    if (maxp.version === 1.0) {
            	        maxp.maxPoints = p.parseUShort();
            	        maxp.maxContours = p.parseUShort();
            	        maxp.maxCompositePoints = p.parseUShort();
            	        maxp.maxCompositeContours = p.parseUShort();
            	        maxp.maxZones = p.parseUShort();
            	        maxp.maxTwilightPoints = p.parseUShort();
            	        maxp.maxStorage = p.parseUShort();
            	        maxp.maxFunctionDefs = p.parseUShort();
            	        maxp.maxInstructionDefs = p.parseUShort();
            	        maxp.maxStackElements = p.parseUShort();
            	        maxp.maxSizeOfInstructions = p.parseUShort();
            	        maxp.maxComponentElements = p.parseUShort();
            	        maxp.maxComponentDepth = p.parseUShort();
            	    }

            	    return maxp;
            	}

            	function makeMaxpTable(numGlyphs) {
            	    return new table.Table('maxp', [
            	        {name: 'version', type: 'FIXED', value: 0x00005000},
            	        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}
            	    ]);
            	}

            	var maxp = { parse: parseMaxpTable, make: makeMaxpTable };

            	// The `name` naming table.

            	// NameIDs for the name table.
            	var nameTableNames = [
            	    'copyright',              // 0
            	    'fontFamily',             // 1
            	    'fontSubfamily',          // 2
            	    'uniqueID',               // 3
            	    'fullName',               // 4
            	    'version',                // 5
            	    'postScriptName',         // 6
            	    'trademark',              // 7
            	    'manufacturer',           // 8
            	    'designer',               // 9
            	    'description',            // 10
            	    'manufacturerURL',        // 11
            	    'designerURL',            // 12
            	    'license',                // 13
            	    'licenseURL',             // 14
            	    'reserved',               // 15
            	    'preferredFamily',        // 16
            	    'preferredSubfamily',     // 17
            	    'compatibleFullName',     // 18
            	    'sampleText',             // 19
            	    'postScriptFindFontName', // 20
            	    'wwsFamily',              // 21
            	    'wwsSubfamily'            // 22
            	];

            	var macLanguages = {
            	    0: 'en',
            	    1: 'fr',
            	    2: 'de',
            	    3: 'it',
            	    4: 'nl',
            	    5: 'sv',
            	    6: 'es',
            	    7: 'da',
            	    8: 'pt',
            	    9: 'no',
            	    10: 'he',
            	    11: 'ja',
            	    12: 'ar',
            	    13: 'fi',
            	    14: 'el',
            	    15: 'is',
            	    16: 'mt',
            	    17: 'tr',
            	    18: 'hr',
            	    19: 'zh-Hant',
            	    20: 'ur',
            	    21: 'hi',
            	    22: 'th',
            	    23: 'ko',
            	    24: 'lt',
            	    25: 'pl',
            	    26: 'hu',
            	    27: 'es',
            	    28: 'lv',
            	    29: 'se',
            	    30: 'fo',
            	    31: 'fa',
            	    32: 'ru',
            	    33: 'zh',
            	    34: 'nl-BE',
            	    35: 'ga',
            	    36: 'sq',
            	    37: 'ro',
            	    38: 'cz',
            	    39: 'sk',
            	    40: 'si',
            	    41: 'yi',
            	    42: 'sr',
            	    43: 'mk',
            	    44: 'bg',
            	    45: 'uk',
            	    46: 'be',
            	    47: 'uz',
            	    48: 'kk',
            	    49: 'az-Cyrl',
            	    50: 'az-Arab',
            	    51: 'hy',
            	    52: 'ka',
            	    53: 'mo',
            	    54: 'ky',
            	    55: 'tg',
            	    56: 'tk',
            	    57: 'mn-CN',
            	    58: 'mn',
            	    59: 'ps',
            	    60: 'ks',
            	    61: 'ku',
            	    62: 'sd',
            	    63: 'bo',
            	    64: 'ne',
            	    65: 'sa',
            	    66: 'mr',
            	    67: 'bn',
            	    68: 'as',
            	    69: 'gu',
            	    70: 'pa',
            	    71: 'or',
            	    72: 'ml',
            	    73: 'kn',
            	    74: 'ta',
            	    75: 'te',
            	    76: 'si',
            	    77: 'my',
            	    78: 'km',
            	    79: 'lo',
            	    80: 'vi',
            	    81: 'id',
            	    82: 'tl',
            	    83: 'ms',
            	    84: 'ms-Arab',
            	    85: 'am',
            	    86: 'ti',
            	    87: 'om',
            	    88: 'so',
            	    89: 'sw',
            	    90: 'rw',
            	    91: 'rn',
            	    92: 'ny',
            	    93: 'mg',
            	    94: 'eo',
            	    128: 'cy',
            	    129: 'eu',
            	    130: 'ca',
            	    131: 'la',
            	    132: 'qu',
            	    133: 'gn',
            	    134: 'ay',
            	    135: 'tt',
            	    136: 'ug',
            	    137: 'dz',
            	    138: 'jv',
            	    139: 'su',
            	    140: 'gl',
            	    141: 'af',
            	    142: 'br',
            	    143: 'iu',
            	    144: 'gd',
            	    145: 'gv',
            	    146: 'ga',
            	    147: 'to',
            	    148: 'el-polyton',
            	    149: 'kl',
            	    150: 'az',
            	    151: 'nn'
            	};

            	// MacOS language ID → MacOS script ID
            	//
            	// Note that the script ID is not sufficient to determine what encoding
            	// to use in TrueType files. For some languages, MacOS used a modification
            	// of a mainstream script. For example, an Icelandic name would be stored
            	// with smRoman in the TrueType naming table, but the actual encoding
            	// is a special Icelandic version of the normal Macintosh Roman encoding.
            	// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal
            	// Syllables but MacOS had run out of available script codes, so this was
            	// done as a (pretty radical) "modification" of Ethiopic.
            	//
            	// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
            	var macLanguageToScript = {
            	    0: 0,  // langEnglish → smRoman
            	    1: 0,  // langFrench → smRoman
            	    2: 0,  // langGerman → smRoman
            	    3: 0,  // langItalian → smRoman
            	    4: 0,  // langDutch → smRoman
            	    5: 0,  // langSwedish → smRoman
            	    6: 0,  // langSpanish → smRoman
            	    7: 0,  // langDanish → smRoman
            	    8: 0,  // langPortuguese → smRoman
            	    9: 0,  // langNorwegian → smRoman
            	    10: 5,  // langHebrew → smHebrew
            	    11: 1,  // langJapanese → smJapanese
            	    12: 4,  // langArabic → smArabic
            	    13: 0,  // langFinnish → smRoman
            	    14: 6,  // langGreek → smGreek
            	    15: 0,  // langIcelandic → smRoman (modified)
            	    16: 0,  // langMaltese → smRoman
            	    17: 0,  // langTurkish → smRoman (modified)
            	    18: 0,  // langCroatian → smRoman (modified)
            	    19: 2,  // langTradChinese → smTradChinese
            	    20: 4,  // langUrdu → smArabic
            	    21: 9,  // langHindi → smDevanagari
            	    22: 21,  // langThai → smThai
            	    23: 3,  // langKorean → smKorean
            	    24: 29,  // langLithuanian → smCentralEuroRoman
            	    25: 29,  // langPolish → smCentralEuroRoman
            	    26: 29,  // langHungarian → smCentralEuroRoman
            	    27: 29,  // langEstonian → smCentralEuroRoman
            	    28: 29,  // langLatvian → smCentralEuroRoman
            	    29: 0,  // langSami → smRoman
            	    30: 0,  // langFaroese → smRoman (modified)
            	    31: 4,  // langFarsi → smArabic (modified)
            	    32: 7,  // langRussian → smCyrillic
            	    33: 25,  // langSimpChinese → smSimpChinese
            	    34: 0,  // langFlemish → smRoman
            	    35: 0,  // langIrishGaelic → smRoman (modified)
            	    36: 0,  // langAlbanian → smRoman
            	    37: 0,  // langRomanian → smRoman (modified)
            	    38: 29,  // langCzech → smCentralEuroRoman
            	    39: 29,  // langSlovak → smCentralEuroRoman
            	    40: 0,  // langSlovenian → smRoman (modified)
            	    41: 5,  // langYiddish → smHebrew
            	    42: 7,  // langSerbian → smCyrillic
            	    43: 7,  // langMacedonian → smCyrillic
            	    44: 7,  // langBulgarian → smCyrillic
            	    45: 7,  // langUkrainian → smCyrillic (modified)
            	    46: 7,  // langByelorussian → smCyrillic
            	    47: 7,  // langUzbek → smCyrillic
            	    48: 7,  // langKazakh → smCyrillic
            	    49: 7,  // langAzerbaijani → smCyrillic
            	    50: 4,  // langAzerbaijanAr → smArabic
            	    51: 24,  // langArmenian → smArmenian
            	    52: 23,  // langGeorgian → smGeorgian
            	    53: 7,  // langMoldavian → smCyrillic
            	    54: 7,  // langKirghiz → smCyrillic
            	    55: 7,  // langTajiki → smCyrillic
            	    56: 7,  // langTurkmen → smCyrillic
            	    57: 27,  // langMongolian → smMongolian
            	    58: 7,  // langMongolianCyr → smCyrillic
            	    59: 4,  // langPashto → smArabic
            	    60: 4,  // langKurdish → smArabic
            	    61: 4,  // langKashmiri → smArabic
            	    62: 4,  // langSindhi → smArabic
            	    63: 26,  // langTibetan → smTibetan
            	    64: 9,  // langNepali → smDevanagari
            	    65: 9,  // langSanskrit → smDevanagari
            	    66: 9,  // langMarathi → smDevanagari
            	    67: 13,  // langBengali → smBengali
            	    68: 13,  // langAssamese → smBengali
            	    69: 11,  // langGujarati → smGujarati
            	    70: 10,  // langPunjabi → smGurmukhi
            	    71: 12,  // langOriya → smOriya
            	    72: 17,  // langMalayalam → smMalayalam
            	    73: 16,  // langKannada → smKannada
            	    74: 14,  // langTamil → smTamil
            	    75: 15,  // langTelugu → smTelugu
            	    76: 18,  // langSinhalese → smSinhalese
            	    77: 19,  // langBurmese → smBurmese
            	    78: 20,  // langKhmer → smKhmer
            	    79: 22,  // langLao → smLao
            	    80: 30,  // langVietnamese → smVietnamese
            	    81: 0,  // langIndonesian → smRoman
            	    82: 0,  // langTagalog → smRoman
            	    83: 0,  // langMalayRoman → smRoman
            	    84: 4,  // langMalayArabic → smArabic
            	    85: 28,  // langAmharic → smEthiopic
            	    86: 28,  // langTigrinya → smEthiopic
            	    87: 28,  // langOromo → smEthiopic
            	    88: 0,  // langSomali → smRoman
            	    89: 0,  // langSwahili → smRoman
            	    90: 0,  // langKinyarwanda → smRoman
            	    91: 0,  // langRundi → smRoman
            	    92: 0,  // langNyanja → smRoman
            	    93: 0,  // langMalagasy → smRoman
            	    94: 0,  // langEsperanto → smRoman
            	    128: 0,  // langWelsh → smRoman (modified)
            	    129: 0,  // langBasque → smRoman
            	    130: 0,  // langCatalan → smRoman
            	    131: 0,  // langLatin → smRoman
            	    132: 0,  // langQuechua → smRoman
            	    133: 0,  // langGuarani → smRoman
            	    134: 0,  // langAymara → smRoman
            	    135: 7,  // langTatar → smCyrillic
            	    136: 4,  // langUighur → smArabic
            	    137: 26,  // langDzongkha → smTibetan
            	    138: 0,  // langJavaneseRom → smRoman
            	    139: 0,  // langSundaneseRom → smRoman
            	    140: 0,  // langGalician → smRoman
            	    141: 0,  // langAfrikaans → smRoman
            	    142: 0,  // langBreton → smRoman (modified)
            	    143: 28,  // langInuktitut → smEthiopic (modified)
            	    144: 0,  // langScottishGaelic → smRoman (modified)
            	    145: 0,  // langManxGaelic → smRoman (modified)
            	    146: 0,  // langIrishGaelicScript → smRoman (modified)
            	    147: 0,  // langTongan → smRoman
            	    148: 6,  // langGreekAncient → smRoman
            	    149: 0,  // langGreenlandic → smRoman
            	    150: 0,  // langAzerbaijanRoman → smRoman
            	    151: 0   // langNynorsk → smRoman
            	};

            	// While Microsoft indicates a region/country for all its language
            	// IDs, we omit the region code if it's equal to the "most likely
            	// region subtag" according to Unicode CLDR. For scripts, we omit
            	// the subtag if it is equal to the Suppress-Script entry in the
            	// IANA language subtag registry for IETF BCP 47.
            	//
            	// For example, Microsoft states that its language code 0x041A is
            	// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'
            	// and not 'hr-HR' because Croatia is the default country for Croatian,
            	// according to Unicode CLDR. As another example, Microsoft states
            	// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform
            	// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script
            	// for the Croatian language, according to IANA.
            	//
            	// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html
            	// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
            	var windowsLanguages = {
            	    0x0436: 'af',
            	    0x041C: 'sq',
            	    0x0484: 'gsw',
            	    0x045E: 'am',
            	    0x1401: 'ar-DZ',
            	    0x3C01: 'ar-BH',
            	    0x0C01: 'ar',
            	    0x0801: 'ar-IQ',
            	    0x2C01: 'ar-JO',
            	    0x3401: 'ar-KW',
            	    0x3001: 'ar-LB',
            	    0x1001: 'ar-LY',
            	    0x1801: 'ary',
            	    0x2001: 'ar-OM',
            	    0x4001: 'ar-QA',
            	    0x0401: 'ar-SA',
            	    0x2801: 'ar-SY',
            	    0x1C01: 'aeb',
            	    0x3801: 'ar-AE',
            	    0x2401: 'ar-YE',
            	    0x042B: 'hy',
            	    0x044D: 'as',
            	    0x082C: 'az-Cyrl',
            	    0x042C: 'az',
            	    0x046D: 'ba',
            	    0x042D: 'eu',
            	    0x0423: 'be',
            	    0x0845: 'bn',
            	    0x0445: 'bn-IN',
            	    0x201A: 'bs-Cyrl',
            	    0x141A: 'bs',
            	    0x047E: 'br',
            	    0x0402: 'bg',
            	    0x0403: 'ca',
            	    0x0C04: 'zh-HK',
            	    0x1404: 'zh-MO',
            	    0x0804: 'zh',
            	    0x1004: 'zh-SG',
            	    0x0404: 'zh-TW',
            	    0x0483: 'co',
            	    0x041A: 'hr',
            	    0x101A: 'hr-BA',
            	    0x0405: 'cs',
            	    0x0406: 'da',
            	    0x048C: 'prs',
            	    0x0465: 'dv',
            	    0x0813: 'nl-BE',
            	    0x0413: 'nl',
            	    0x0C09: 'en-AU',
            	    0x2809: 'en-BZ',
            	    0x1009: 'en-CA',
            	    0x2409: 'en-029',
            	    0x4009: 'en-IN',
            	    0x1809: 'en-IE',
            	    0x2009: 'en-JM',
            	    0x4409: 'en-MY',
            	    0x1409: 'en-NZ',
            	    0x3409: 'en-PH',
            	    0x4809: 'en-SG',
            	    0x1C09: 'en-ZA',
            	    0x2C09: 'en-TT',
            	    0x0809: 'en-GB',
            	    0x0409: 'en',
            	    0x3009: 'en-ZW',
            	    0x0425: 'et',
            	    0x0438: 'fo',
            	    0x0464: 'fil',
            	    0x040B: 'fi',
            	    0x080C: 'fr-BE',
            	    0x0C0C: 'fr-CA',
            	    0x040C: 'fr',
            	    0x140C: 'fr-LU',
            	    0x180C: 'fr-MC',
            	    0x100C: 'fr-CH',
            	    0x0462: 'fy',
            	    0x0456: 'gl',
            	    0x0437: 'ka',
            	    0x0C07: 'de-AT',
            	    0x0407: 'de',
            	    0x1407: 'de-LI',
            	    0x1007: 'de-LU',
            	    0x0807: 'de-CH',
            	    0x0408: 'el',
            	    0x046F: 'kl',
            	    0x0447: 'gu',
            	    0x0468: 'ha',
            	    0x040D: 'he',
            	    0x0439: 'hi',
            	    0x040E: 'hu',
            	    0x040F: 'is',
            	    0x0470: 'ig',
            	    0x0421: 'id',
            	    0x045D: 'iu',
            	    0x085D: 'iu-Latn',
            	    0x083C: 'ga',
            	    0x0434: 'xh',
            	    0x0435: 'zu',
            	    0x0410: 'it',
            	    0x0810: 'it-CH',
            	    0x0411: 'ja',
            	    0x044B: 'kn',
            	    0x043F: 'kk',
            	    0x0453: 'km',
            	    0x0486: 'quc',
            	    0x0487: 'rw',
            	    0x0441: 'sw',
            	    0x0457: 'kok',
            	    0x0412: 'ko',
            	    0x0440: 'ky',
            	    0x0454: 'lo',
            	    0x0426: 'lv',
            	    0x0427: 'lt',
            	    0x082E: 'dsb',
            	    0x046E: 'lb',
            	    0x042F: 'mk',
            	    0x083E: 'ms-BN',
            	    0x043E: 'ms',
            	    0x044C: 'ml',
            	    0x043A: 'mt',
            	    0x0481: 'mi',
            	    0x047A: 'arn',
            	    0x044E: 'mr',
            	    0x047C: 'moh',
            	    0x0450: 'mn',
            	    0x0850: 'mn-CN',
            	    0x0461: 'ne',
            	    0x0414: 'nb',
            	    0x0814: 'nn',
            	    0x0482: 'oc',
            	    0x0448: 'or',
            	    0x0463: 'ps',
            	    0x0415: 'pl',
            	    0x0416: 'pt',
            	    0x0816: 'pt-PT',
            	    0x0446: 'pa',
            	    0x046B: 'qu-BO',
            	    0x086B: 'qu-EC',
            	    0x0C6B: 'qu',
            	    0x0418: 'ro',
            	    0x0417: 'rm',
            	    0x0419: 'ru',
            	    0x243B: 'smn',
            	    0x103B: 'smj-NO',
            	    0x143B: 'smj',
            	    0x0C3B: 'se-FI',
            	    0x043B: 'se',
            	    0x083B: 'se-SE',
            	    0x203B: 'sms',
            	    0x183B: 'sma-NO',
            	    0x1C3B: 'sms',
            	    0x044F: 'sa',
            	    0x1C1A: 'sr-Cyrl-BA',
            	    0x0C1A: 'sr',
            	    0x181A: 'sr-Latn-BA',
            	    0x081A: 'sr-Latn',
            	    0x046C: 'nso',
            	    0x0432: 'tn',
            	    0x045B: 'si',
            	    0x041B: 'sk',
            	    0x0424: 'sl',
            	    0x2C0A: 'es-AR',
            	    0x400A: 'es-BO',
            	    0x340A: 'es-CL',
            	    0x240A: 'es-CO',
            	    0x140A: 'es-CR',
            	    0x1C0A: 'es-DO',
            	    0x300A: 'es-EC',
            	    0x440A: 'es-SV',
            	    0x100A: 'es-GT',
            	    0x480A: 'es-HN',
            	    0x080A: 'es-MX',
            	    0x4C0A: 'es-NI',
            	    0x180A: 'es-PA',
            	    0x3C0A: 'es-PY',
            	    0x280A: 'es-PE',
            	    0x500A: 'es-PR',

            	    // Microsoft has defined two different language codes for
            	    // “Spanish with modern sorting” and “Spanish with traditional
            	    // sorting”. This makes sense for collation APIs, and it would be
            	    // possible to express this in BCP 47 language tags via Unicode
            	    // extensions (eg., es-u-co-trad is Spanish with traditional
            	    // sorting). However, for storing names in fonts, the distinction
            	    // does not make sense, so we give “es” in both cases.
            	    0x0C0A: 'es',
            	    0x040A: 'es',

            	    0x540A: 'es-US',
            	    0x380A: 'es-UY',
            	    0x200A: 'es-VE',
            	    0x081D: 'sv-FI',
            	    0x041D: 'sv',
            	    0x045A: 'syr',
            	    0x0428: 'tg',
            	    0x085F: 'tzm',
            	    0x0449: 'ta',
            	    0x0444: 'tt',
            	    0x044A: 'te',
            	    0x041E: 'th',
            	    0x0451: 'bo',
            	    0x041F: 'tr',
            	    0x0442: 'tk',
            	    0x0480: 'ug',
            	    0x0422: 'uk',
            	    0x042E: 'hsb',
            	    0x0420: 'ur',
            	    0x0843: 'uz-Cyrl',
            	    0x0443: 'uz',
            	    0x042A: 'vi',
            	    0x0452: 'cy',
            	    0x0488: 'wo',
            	    0x0485: 'sah',
            	    0x0478: 'ii',
            	    0x046A: 'yo'
            	};

            	// Returns a IETF BCP 47 language code, for example 'zh-Hant'
            	// for 'Chinese in the traditional script'.
            	function getLanguageCode(platformID, languageID, ltag) {
            	    switch (platformID) {
            	        case 0:  // Unicode
            	            if (languageID === 0xFFFF) {
            	                return 'und';
            	            } else if (ltag) {
            	                return ltag[languageID];
            	            }

            	            break;

            	        case 1:  // Macintosh
            	            return macLanguages[languageID];

            	        case 3:  // Windows
            	            return windowsLanguages[languageID];
            	    }

            	    return undefined;
            	}

            	var utf16 = 'utf-16';

            	// MacOS script ID → encoding. This table stores the default case,
            	// which can be overridden by macLanguageEncodings.
            	var macScriptEncodings = {
            	    0: 'macintosh',           // smRoman
            	    1: 'x-mac-japanese',      // smJapanese
            	    2: 'x-mac-chinesetrad',   // smTradChinese
            	    3: 'x-mac-korean',        // smKorean
            	    6: 'x-mac-greek',         // smGreek
            	    7: 'x-mac-cyrillic',      // smCyrillic
            	    9: 'x-mac-devanagai',     // smDevanagari
            	    10: 'x-mac-gurmukhi',     // smGurmukhi
            	    11: 'x-mac-gujarati',     // smGujarati
            	    12: 'x-mac-oriya',        // smOriya
            	    13: 'x-mac-bengali',      // smBengali
            	    14: 'x-mac-tamil',        // smTamil
            	    15: 'x-mac-telugu',       // smTelugu
            	    16: 'x-mac-kannada',      // smKannada
            	    17: 'x-mac-malayalam',    // smMalayalam
            	    18: 'x-mac-sinhalese',    // smSinhalese
            	    19: 'x-mac-burmese',      // smBurmese
            	    20: 'x-mac-khmer',        // smKhmer
            	    21: 'x-mac-thai',         // smThai
            	    22: 'x-mac-lao',          // smLao
            	    23: 'x-mac-georgian',     // smGeorgian
            	    24: 'x-mac-armenian',     // smArmenian
            	    25: 'x-mac-chinesesimp',  // smSimpChinese
            	    26: 'x-mac-tibetan',      // smTibetan
            	    27: 'x-mac-mongolian',    // smMongolian
            	    28: 'x-mac-ethiopic',     // smEthiopic
            	    29: 'x-mac-ce',           // smCentralEuroRoman
            	    30: 'x-mac-vietnamese',   // smVietnamese
            	    31: 'x-mac-extarabic'     // smExtArabic
            	};

            	// MacOS language ID → encoding. This table stores the exceptional
            	// cases, which override macScriptEncodings. For writing MacOS naming
            	// tables, we need to emit a MacOS script ID. Therefore, we cannot
            	// merge macScriptEncodings into macLanguageEncodings.
            	//
            	// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
            	var macLanguageEncodings = {
            	    15: 'x-mac-icelandic',    // langIcelandic
            	    17: 'x-mac-turkish',      // langTurkish
            	    18: 'x-mac-croatian',     // langCroatian
            	    24: 'x-mac-ce',           // langLithuanian
            	    25: 'x-mac-ce',           // langPolish
            	    26: 'x-mac-ce',           // langHungarian
            	    27: 'x-mac-ce',           // langEstonian
            	    28: 'x-mac-ce',           // langLatvian
            	    30: 'x-mac-icelandic',    // langFaroese
            	    37: 'x-mac-romanian',     // langRomanian
            	    38: 'x-mac-ce',           // langCzech
            	    39: 'x-mac-ce',           // langSlovak
            	    40: 'x-mac-ce',           // langSlovenian
            	    143: 'x-mac-inuit',       // langInuktitut
            	    146: 'x-mac-gaelic'       // langIrishGaelicScript
            	};

            	function getEncoding(platformID, encodingID, languageID) {
            	    switch (platformID) {
            	        case 0:  // Unicode
            	            return utf16;

            	        case 1:  // Apple Macintosh
            	            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];

            	        case 3:  // Microsoft Windows
            	            if (encodingID === 1 || encodingID === 10) {
            	                return utf16;
            	            }

            	            break;
            	    }

            	    return undefined;
            	}

            	// Parse the naming `name` table.
            	// FIXME: Format 1 additional fields are not supported yet.
            	// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].
            	function parseNameTable(data, start, ltag) {
            	    var name = {};
            	    var p = new parse.Parser(data, start);
            	    var format = p.parseUShort();
            	    var count = p.parseUShort();
            	    var stringOffset = p.offset + p.parseUShort();
            	    for (var i = 0; i < count; i++) {
            	        var platformID = p.parseUShort();
            	        var encodingID = p.parseUShort();
            	        var languageID = p.parseUShort();
            	        var nameID = p.parseUShort();
            	        var property = nameTableNames[nameID] || nameID;
            	        var byteLength = p.parseUShort();
            	        var offset = p.parseUShort();
            	        var language = getLanguageCode(platformID, languageID, ltag);
            	        var encoding = getEncoding(platformID, encodingID, languageID);
            	        if (encoding !== undefined && language !== undefined) {
            	            var text = (void 0);
            	            if (encoding === utf16) {
            	                text = decode.UTF16(data, stringOffset + offset, byteLength);
            	            } else {
            	                text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);
            	            }

            	            if (text) {
            	                var translations = name[property];
            	                if (translations === undefined) {
            	                    translations = name[property] = {};
            	                }

            	                translations[language] = text;
            	            }
            	        }
            	    }

            	    var langTagCount = 0;
            	    if (format === 1) {
            	        // FIXME: Also handle Microsoft's 'name' table 1.
            	        langTagCount = p.parseUShort();
            	    }

            	    return name;
            	}

            	// {23: 'foo'} → {'foo': 23}
            	// ['bar', 'baz'] → {'bar': 0, 'baz': 1}
            	function reverseDict(dict) {
            	    var result = {};
            	    for (var key in dict) {
            	        result[dict[key]] = parseInt(key);
            	    }

            	    return result;
            	}

            	function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
            	    return new table.Record('NameRecord', [
            	        {name: 'platformID', type: 'USHORT', value: platformID},
            	        {name: 'encodingID', type: 'USHORT', value: encodingID},
            	        {name: 'languageID', type: 'USHORT', value: languageID},
            	        {name: 'nameID', type: 'USHORT', value: nameID},
            	        {name: 'length', type: 'USHORT', value: length},
            	        {name: 'offset', type: 'USHORT', value: offset}
            	    ]);
            	}

            	// Finds the position of needle in haystack, or -1 if not there.
            	// Like String.indexOf(), but for arrays.
            	function findSubArray(needle, haystack) {
            	    var needleLength = needle.length;
            	    var limit = haystack.length - needleLength + 1;

            	    loop:
            	    for (var pos = 0; pos < limit; pos++) {
            	        for (; pos < limit; pos++) {
            	            for (var k = 0; k < needleLength; k++) {
            	                if (haystack[pos + k] !== needle[k]) {
            	                    continue loop;
            	                }
            	            }

            	            return pos;
            	        }
            	    }

            	    return -1;
            	}

            	function addStringToPool(s, pool) {
            	    var offset = findSubArray(s, pool);
            	    if (offset < 0) {
            	        offset = pool.length;
            	        var i = 0;
            	        var len = s.length;
            	        for (; i < len; ++i) {
            	            pool.push(s[i]);
            	        }

            	    }

            	    return offset;
            	}

            	function makeNameTable(names, ltag) {
            	    var nameID;
            	    var nameIDs = [];

            	    var namesWithNumericKeys = {};
            	    var nameTableIds = reverseDict(nameTableNames);
            	    for (var key in names) {
            	        var id = nameTableIds[key];
            	        if (id === undefined) {
            	            id = key;
            	        }

            	        nameID = parseInt(id);

            	        if (isNaN(nameID)) {
            	            throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
            	        }

            	        namesWithNumericKeys[nameID] = names[key];
            	        nameIDs.push(nameID);
            	    }

            	    var macLanguageIds = reverseDict(macLanguages);
            	    var windowsLanguageIds = reverseDict(windowsLanguages);

            	    var nameRecords = [];
            	    var stringPool = [];

            	    for (var i = 0; i < nameIDs.length; i++) {
            	        nameID = nameIDs[i];
            	        var translations = namesWithNumericKeys[nameID];
            	        for (var lang in translations) {
            	            var text = translations[lang];

            	            // For MacOS, we try to emit the name in the form that was introduced
            	            // in the initial version of the TrueType spec (in the late 1980s).
            	            // However, this can fail for various reasons: the requested BCP 47
            	            // language code might not have an old-style Mac equivalent;
            	            // we might not have a codec for the needed character encoding;
            	            // or the name might contain characters that cannot be expressed
            	            // in the old-style Macintosh encoding. In case of failure, we emit
            	            // the name in a more modern fashion (Unicode encoding with BCP 47
            	            // language tags) that is recognized by MacOS 10.5, released in 2009.
            	            // If fonts were only read by operating systems, we could simply
            	            // emit all names in the modern form; this would be much easier.
            	            // However, there are many applications and libraries that read
            	            // 'name' tables directly, and these will usually only recognize
            	            // the ancient form (silently skipping the unrecognized names).
            	            var macPlatform = 1;  // Macintosh
            	            var macLanguage = macLanguageIds[lang];
            	            var macScript = macLanguageToScript[macLanguage];
            	            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
            	            var macName = encode.MACSTRING(text, macEncoding);
            	            if (macName === undefined) {
            	                macPlatform = 0;  // Unicode
            	                macLanguage = ltag.indexOf(lang);
            	                if (macLanguage < 0) {
            	                    macLanguage = ltag.length;
            	                    ltag.push(lang);
            	                }

            	                macScript = 4;  // Unicode 2.0 and later
            	                macName = encode.UTF16(text);
            	            }

            	            var macNameOffset = addStringToPool(macName, stringPool);
            	            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,
            	                                            nameID, macName.length, macNameOffset));

            	            var winLanguage = windowsLanguageIds[lang];
            	            if (winLanguage !== undefined) {
            	                var winName = encode.UTF16(text);
            	                var winNameOffset = addStringToPool(winName, stringPool);
            	                nameRecords.push(makeNameRecord(3, 1, winLanguage,
            	                                                nameID, winName.length, winNameOffset));
            	            }
            	        }
            	    }

            	    nameRecords.sort(function(a, b) {
            	        return ((a.platformID - b.platformID) ||
            	                (a.encodingID - b.encodingID) ||
            	                (a.languageID - b.languageID) ||
            	                (a.nameID - b.nameID));
            	    });

            	    var t = new table.Table('name', [
            	        {name: 'format', type: 'USHORT', value: 0},
            	        {name: 'count', type: 'USHORT', value: nameRecords.length},
            	        {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}
            	    ]);

            	    for (var r = 0; r < nameRecords.length; r++) {
            	        t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});
            	    }

            	    t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});
            	    return t;
            	}

            	var _name = { parse: parseNameTable, make: makeNameTable };

            	// The `OS/2` table contains metrics required in OpenType fonts.

            	var unicodeRanges = [
            	    {begin: 0x0000, end: 0x007F}, // Basic Latin
            	    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement
            	    {begin: 0x0100, end: 0x017F}, // Latin Extended-A
            	    {begin: 0x0180, end: 0x024F}, // Latin Extended-B
            	    {begin: 0x0250, end: 0x02AF}, // IPA Extensions
            	    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters
            	    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks
            	    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic
            	    {begin: 0x2C80, end: 0x2CFF}, // Coptic
            	    {begin: 0x0400, end: 0x04FF}, // Cyrillic
            	    {begin: 0x0530, end: 0x058F}, // Armenian
            	    {begin: 0x0590, end: 0x05FF}, // Hebrew
            	    {begin: 0xA500, end: 0xA63F}, // Vai
            	    {begin: 0x0600, end: 0x06FF}, // Arabic
            	    {begin: 0x07C0, end: 0x07FF}, // NKo
            	    {begin: 0x0900, end: 0x097F}, // Devanagari
            	    {begin: 0x0980, end: 0x09FF}, // Bengali
            	    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi
            	    {begin: 0x0A80, end: 0x0AFF}, // Gujarati
            	    {begin: 0x0B00, end: 0x0B7F}, // Oriya
            	    {begin: 0x0B80, end: 0x0BFF}, // Tamil
            	    {begin: 0x0C00, end: 0x0C7F}, // Telugu
            	    {begin: 0x0C80, end: 0x0CFF}, // Kannada
            	    {begin: 0x0D00, end: 0x0D7F}, // Malayalam
            	    {begin: 0x0E00, end: 0x0E7F}, // Thai
            	    {begin: 0x0E80, end: 0x0EFF}, // Lao
            	    {begin: 0x10A0, end: 0x10FF}, // Georgian
            	    {begin: 0x1B00, end: 0x1B7F}, // Balinese
            	    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo
            	    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional
            	    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended
            	    {begin: 0x2000, end: 0x206F}, // General Punctuation
            	    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts
            	    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol
            	    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols
            	    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols
            	    {begin: 0x2150, end: 0x218F}, // Number Forms
            	    {begin: 0x2190, end: 0x21FF}, // Arrows
            	    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators
            	    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical
            	    {begin: 0x2400, end: 0x243F}, // Control Pictures
            	    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition
            	    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics
            	    {begin: 0x2500, end: 0x257F}, // Box Drawing
            	    {begin: 0x2580, end: 0x259F}, // Block Elements
            	    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes
            	    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols
            	    {begin: 0x2700, end: 0x27BF}, // Dingbats
            	    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation
            	    {begin: 0x3040, end: 0x309F}, // Hiragana
            	    {begin: 0x30A0, end: 0x30FF}, // Katakana
            	    {begin: 0x3100, end: 0x312F}, // Bopomofo
            	    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo
            	    {begin: 0xA840, end: 0xA87F}, // Phags-pa
            	    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months
            	    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility
            	    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables
            	    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *
            	    {begin: 0x10900, end: 0x1091F}, // Phoenicia
            	    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs
            	    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)
            	    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes
            	    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms
            	    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A
            	    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks
            	    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms
            	    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants
            	    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B
            	    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms
            	    {begin: 0xFFF0, end: 0xFFFF}, // Specials
            	    {begin: 0x0F00, end: 0x0FFF}, // Tibetan
            	    {begin: 0x0700, end: 0x074F}, // Syriac
            	    {begin: 0x0780, end: 0x07BF}, // Thaana
            	    {begin: 0x0D80, end: 0x0DFF}, // Sinhala
            	    {begin: 0x1000, end: 0x109F}, // Myanmar
            	    {begin: 0x1200, end: 0x137F}, // Ethiopic
            	    {begin: 0x13A0, end: 0x13FF}, // Cherokee
            	    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics
            	    {begin: 0x1680, end: 0x169F}, // Ogham
            	    {begin: 0x16A0, end: 0x16FF}, // Runic
            	    {begin: 0x1780, end: 0x17FF}, // Khmer
            	    {begin: 0x1800, end: 0x18AF}, // Mongolian
            	    {begin: 0x2800, end: 0x28FF}, // Braille Patterns
            	    {begin: 0xA000, end: 0xA48F}, // Yi Syllables
            	    {begin: 0x1700, end: 0x171F}, // Tagalog
            	    {begin: 0x10300, end: 0x1032F}, // Old Italic
            	    {begin: 0x10330, end: 0x1034F}, // Gothic
            	    {begin: 0x10400, end: 0x1044F}, // Deseret
            	    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols
            	    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols
            	    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)
            	    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors
            	    {begin: 0xE0000, end: 0xE007F}, // Tags
            	    {begin: 0x1900, end: 0x194F}, // Limbu
            	    {begin: 0x1950, end: 0x197F}, // Tai Le
            	    {begin: 0x1980, end: 0x19DF}, // New Tai Lue
            	    {begin: 0x1A00, end: 0x1A1F}, // Buginese
            	    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic
            	    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh
            	    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols
            	    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri
            	    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary
            	    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers
            	    {begin: 0x10380, end: 0x1039F}, // Ugaritic
            	    {begin: 0x103A0, end: 0x103DF}, // Old Persian
            	    {begin: 0x10450, end: 0x1047F}, // Shavian
            	    {begin: 0x10480, end: 0x104AF}, // Osmanya
            	    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary
            	    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi
            	    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols
            	    {begin: 0x12000, end: 0x123FF}, // Cuneiform
            	    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals
            	    {begin: 0x1B80, end: 0x1BBF}, // Sundanese
            	    {begin: 0x1C00, end: 0x1C4F}, // Lepcha
            	    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki
            	    {begin: 0xA880, end: 0xA8DF}, // Saurashtra
            	    {begin: 0xA900, end: 0xA92F}, // Kayah Li
            	    {begin: 0xA930, end: 0xA95F}, // Rejang
            	    {begin: 0xAA00, end: 0xAA5F}, // Cham
            	    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols
            	    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc
            	    {begin: 0x102A0, end: 0x102DF}, // Carian
            	    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles
            	];

            	function getUnicodeRange(unicode) {
            	    for (var i = 0; i < unicodeRanges.length; i += 1) {
            	        var range = unicodeRanges[i];
            	        if (unicode >= range.begin && unicode < range.end) {
            	            return i;
            	        }
            	    }

            	    return -1;
            	}

            	// Parse the OS/2 and Windows metrics `OS/2` table
            	function parseOS2Table(data, start) {
            	    var os2 = {};
            	    var p = new parse.Parser(data, start);
            	    os2.version = p.parseUShort();
            	    os2.xAvgCharWidth = p.parseShort();
            	    os2.usWeightClass = p.parseUShort();
            	    os2.usWidthClass = p.parseUShort();
            	    os2.fsType = p.parseUShort();
            	    os2.ySubscriptXSize = p.parseShort();
            	    os2.ySubscriptYSize = p.parseShort();
            	    os2.ySubscriptXOffset = p.parseShort();
            	    os2.ySubscriptYOffset = p.parseShort();
            	    os2.ySuperscriptXSize = p.parseShort();
            	    os2.ySuperscriptYSize = p.parseShort();
            	    os2.ySuperscriptXOffset = p.parseShort();
            	    os2.ySuperscriptYOffset = p.parseShort();
            	    os2.yStrikeoutSize = p.parseShort();
            	    os2.yStrikeoutPosition = p.parseShort();
            	    os2.sFamilyClass = p.parseShort();
            	    os2.panose = [];
            	    for (var i = 0; i < 10; i++) {
            	        os2.panose[i] = p.parseByte();
            	    }

            	    os2.ulUnicodeRange1 = p.parseULong();
            	    os2.ulUnicodeRange2 = p.parseULong();
            	    os2.ulUnicodeRange3 = p.parseULong();
            	    os2.ulUnicodeRange4 = p.parseULong();
            	    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
            	    os2.fsSelection = p.parseUShort();
            	    os2.usFirstCharIndex = p.parseUShort();
            	    os2.usLastCharIndex = p.parseUShort();
            	    os2.sTypoAscender = p.parseShort();
            	    os2.sTypoDescender = p.parseShort();
            	    os2.sTypoLineGap = p.parseShort();
            	    os2.usWinAscent = p.parseUShort();
            	    os2.usWinDescent = p.parseUShort();
            	    if (os2.version >= 1) {
            	        os2.ulCodePageRange1 = p.parseULong();
            	        os2.ulCodePageRange2 = p.parseULong();
            	    }

            	    if (os2.version >= 2) {
            	        os2.sxHeight = p.parseShort();
            	        os2.sCapHeight = p.parseShort();
            	        os2.usDefaultChar = p.parseUShort();
            	        os2.usBreakChar = p.parseUShort();
            	        os2.usMaxContent = p.parseUShort();
            	    }

            	    return os2;
            	}

            	function makeOS2Table(options) {
            	    return new table.Table('OS/2', [
            	        {name: 'version', type: 'USHORT', value: 0x0003},
            	        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},
            	        {name: 'usWeightClass', type: 'USHORT', value: 0},
            	        {name: 'usWidthClass', type: 'USHORT', value: 0},
            	        {name: 'fsType', type: 'USHORT', value: 0},
            	        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},
            	        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},
            	        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},
            	        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},
            	        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},
            	        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},
            	        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},
            	        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},
            	        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},
            	        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},
            	        {name: 'sFamilyClass', type: 'SHORT', value: 0},
            	        {name: 'bFamilyType', type: 'BYTE', value: 0},
            	        {name: 'bSerifStyle', type: 'BYTE', value: 0},
            	        {name: 'bWeight', type: 'BYTE', value: 0},
            	        {name: 'bProportion', type: 'BYTE', value: 0},
            	        {name: 'bContrast', type: 'BYTE', value: 0},
            	        {name: 'bStrokeVariation', type: 'BYTE', value: 0},
            	        {name: 'bArmStyle', type: 'BYTE', value: 0},
            	        {name: 'bLetterform', type: 'BYTE', value: 0},
            	        {name: 'bMidline', type: 'BYTE', value: 0},
            	        {name: 'bXHeight', type: 'BYTE', value: 0},
            	        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},
            	        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},
            	        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},
            	        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},
            	        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},
            	        {name: 'fsSelection', type: 'USHORT', value: 0},
            	        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},
            	        {name: 'usLastCharIndex', type: 'USHORT', value: 0},
            	        {name: 'sTypoAscender', type: 'SHORT', value: 0},
            	        {name: 'sTypoDescender', type: 'SHORT', value: 0},
            	        {name: 'sTypoLineGap', type: 'SHORT', value: 0},
            	        {name: 'usWinAscent', type: 'USHORT', value: 0},
            	        {name: 'usWinDescent', type: 'USHORT', value: 0},
            	        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},
            	        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},
            	        {name: 'sxHeight', type: 'SHORT', value: 0},
            	        {name: 'sCapHeight', type: 'SHORT', value: 0},
            	        {name: 'usDefaultChar', type: 'USHORT', value: 0},
            	        {name: 'usBreakChar', type: 'USHORT', value: 0},
            	        {name: 'usMaxContext', type: 'USHORT', value: 0}
            	    ], options);
            	}

            	var os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange };

            	// The `post` table stores additional PostScript information, such as glyph names.

            	// Parse the PostScript `post` table
            	function parsePostTable(data, start) {
            	    var post = {};
            	    var p = new parse.Parser(data, start);
            	    post.version = p.parseVersion();
            	    post.italicAngle = p.parseFixed();
            	    post.underlinePosition = p.parseShort();
            	    post.underlineThickness = p.parseShort();
            	    post.isFixedPitch = p.parseULong();
            	    post.minMemType42 = p.parseULong();
            	    post.maxMemType42 = p.parseULong();
            	    post.minMemType1 = p.parseULong();
            	    post.maxMemType1 = p.parseULong();
            	    switch (post.version) {
            	        case 1:
            	            post.names = standardNames.slice();
            	            break;
            	        case 2:
            	            post.numberOfGlyphs = p.parseUShort();
            	            post.glyphNameIndex = new Array(post.numberOfGlyphs);
            	            for (var i = 0; i < post.numberOfGlyphs; i++) {
            	                post.glyphNameIndex[i] = p.parseUShort();
            	            }

            	            post.names = [];
            	            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
            	                if (post.glyphNameIndex[i$1] >= standardNames.length) {
            	                    var nameLength = p.parseChar();
            	                    post.names.push(p.parseString(nameLength));
            	                }
            	            }

            	            break;
            	        case 2.5:
            	            post.numberOfGlyphs = p.parseUShort();
            	            post.offset = new Array(post.numberOfGlyphs);
            	            for (var i$2 = 0; i$2 < post.numberOfGlyphs; i$2++) {
            	                post.offset[i$2] = p.parseChar();
            	            }

            	            break;
            	    }
            	    return post;
            	}

            	function makePostTable() {
            	    return new table.Table('post', [
            	        {name: 'version', type: 'FIXED', value: 0x00030000},
            	        {name: 'italicAngle', type: 'FIXED', value: 0},
            	        {name: 'underlinePosition', type: 'FWORD', value: 0},
            	        {name: 'underlineThickness', type: 'FWORD', value: 0},
            	        {name: 'isFixedPitch', type: 'ULONG', value: 0},
            	        {name: 'minMemType42', type: 'ULONG', value: 0},
            	        {name: 'maxMemType42', type: 'ULONG', value: 0},
            	        {name: 'minMemType1', type: 'ULONG', value: 0},
            	        {name: 'maxMemType1', type: 'ULONG', value: 0}
            	    ]);
            	}

            	var post = { parse: parsePostTable, make: makePostTable };

            	// The `GSUB` table contains ligatures, among other things.

            	var subtableParsers = new Array(9);         // subtableParsers[0] is unused

            	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS
            	subtableParsers[1] = function parseLookup1() {
            	    var start = this.offset + this.relativeOffset;
            	    var substFormat = this.parseUShort();
            	    if (substFormat === 1) {
            	        return {
            	            substFormat: 1,
            	            coverage: this.parsePointer(Parser.coverage),
            	            deltaGlyphId: this.parseUShort()
            	        };
            	    } else if (substFormat === 2) {
            	        return {
            	            substFormat: 2,
            	            coverage: this.parsePointer(Parser.coverage),
            	            substitute: this.parseOffset16List()
            	        };
            	    }
            	    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');
            	};

            	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS
            	subtableParsers[2] = function parseLookup2() {
            	    var substFormat = this.parseUShort();
            	    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');
            	    return {
            	        substFormat: substFormat,
            	        coverage: this.parsePointer(Parser.coverage),
            	        sequences: this.parseListOfLists()
            	    };
            	};

            	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS
            	subtableParsers[3] = function parseLookup3() {
            	    var substFormat = this.parseUShort();
            	    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');
            	    return {
            	        substFormat: substFormat,
            	        coverage: this.parsePointer(Parser.coverage),
            	        alternateSets: this.parseListOfLists()
            	    };
            	};

            	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS
            	subtableParsers[4] = function parseLookup4() {
            	    var substFormat = this.parseUShort();
            	    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');
            	    return {
            	        substFormat: substFormat,
            	        coverage: this.parsePointer(Parser.coverage),
            	        ligatureSets: this.parseListOfLists(function() {
            	            return {
            	                ligGlyph: this.parseUShort(),
            	                components: this.parseUShortList(this.parseUShort() - 1)
            	            };
            	        })
            	    };
            	};

            	var lookupRecordDesc = {
            	    sequenceIndex: Parser.uShort,
            	    lookupListIndex: Parser.uShort
            	};

            	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF
            	subtableParsers[5] = function parseLookup5() {
            	    var start = this.offset + this.relativeOffset;
            	    var substFormat = this.parseUShort();

            	    if (substFormat === 1) {
            	        return {
            	            substFormat: substFormat,
            	            coverage: this.parsePointer(Parser.coverage),
            	            ruleSets: this.parseListOfLists(function() {
            	                var glyphCount = this.parseUShort();
            	                var substCount = this.parseUShort();
            	                return {
            	                    input: this.parseUShortList(glyphCount - 1),
            	                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
            	                };
            	            })
            	        };
            	    } else if (substFormat === 2) {
            	        return {
            	            substFormat: substFormat,
            	            coverage: this.parsePointer(Parser.coverage),
            	            classDef: this.parsePointer(Parser.classDef),
            	            classSets: this.parseListOfLists(function() {
            	                var glyphCount = this.parseUShort();
            	                var substCount = this.parseUShort();
            	                return {
            	                    classes: this.parseUShortList(glyphCount - 1),
            	                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
            	                };
            	            })
            	        };
            	    } else if (substFormat === 3) {
            	        var glyphCount = this.parseUShort();
            	        var substCount = this.parseUShort();
            	        return {
            	            substFormat: substFormat,
            	            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),
            	            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
            	        };
            	    }
            	    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');
            	};

            	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC
            	subtableParsers[6] = function parseLookup6() {
            	    var start = this.offset + this.relativeOffset;
            	    var substFormat = this.parseUShort();
            	    if (substFormat === 1) {
            	        return {
            	            substFormat: 1,
            	            coverage: this.parsePointer(Parser.coverage),
            	            chainRuleSets: this.parseListOfLists(function() {
            	                return {
            	                    backtrack: this.parseUShortList(),
            	                    input: this.parseUShortList(this.parseShort() - 1),
            	                    lookahead: this.parseUShortList(),
            	                    lookupRecords: this.parseRecordList(lookupRecordDesc)
            	                };
            	            })
            	        };
            	    } else if (substFormat === 2) {
            	        return {
            	            substFormat: 2,
            	            coverage: this.parsePointer(Parser.coverage),
            	            backtrackClassDef: this.parsePointer(Parser.classDef),
            	            inputClassDef: this.parsePointer(Parser.classDef),
            	            lookaheadClassDef: this.parsePointer(Parser.classDef),
            	            chainClassSet: this.parseListOfLists(function() {
            	                return {
            	                    backtrack: this.parseUShortList(),
            	                    input: this.parseUShortList(this.parseShort() - 1),
            	                    lookahead: this.parseUShortList(),
            	                    lookupRecords: this.parseRecordList(lookupRecordDesc)
            	                };
            	            })
            	        };
            	    } else if (substFormat === 3) {
            	        return {
            	            substFormat: 3,
            	            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            	            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            	            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            	            lookupRecords: this.parseRecordList(lookupRecordDesc)
            	        };
            	    }
            	    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');
            	};

            	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES
            	subtableParsers[7] = function parseLookup7() {
            	    // Extension Substitution subtable
            	    var substFormat = this.parseUShort();
            	    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');
            	    var extensionLookupType = this.parseUShort();
            	    var extensionParser = new Parser(this.data, this.offset + this.parseULong());
            	    return {
            	        substFormat: 1,
            	        lookupType: extensionLookupType,
            	        extension: subtableParsers[extensionLookupType].call(extensionParser)
            	    };
            	};

            	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS
            	subtableParsers[8] = function parseLookup8() {
            	    var substFormat = this.parseUShort();
            	    check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');
            	    return {
            	        substFormat: substFormat,
            	        coverage: this.parsePointer(Parser.coverage),
            	        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            	        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            	        substitutes: this.parseUShortList()
            	    };
            	};

            	// https://www.microsoft.com/typography/OTSPEC/gsub.htm
            	function parseGsubTable(data, start) {
            	    start = start || 0;
            	    var p = new Parser(data, start);
            	    var tableVersion = p.parseVersion(1);
            	    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GSUB table version.');
            	    if (tableVersion === 1) {
            	        return {
            	            version: tableVersion,
            	            scripts: p.parseScriptList(),
            	            features: p.parseFeatureList(),
            	            lookups: p.parseLookupList(subtableParsers)
            	        };
            	    } else {
            	        return {
            	            version: tableVersion,
            	            scripts: p.parseScriptList(),
            	            features: p.parseFeatureList(),
            	            lookups: p.parseLookupList(subtableParsers),
            	            variations: p.parseFeatureVariationsList()
            	        };
            	    }

            	}

            	// GSUB Writing //////////////////////////////////////////////
            	var subtableMakers = new Array(9);

            	subtableMakers[1] = function makeLookup1(subtable) {
            	    if (subtable.substFormat === 1) {
            	        return new table.Table('substitutionTable', [
            	            {name: 'substFormat', type: 'USHORT', value: 1},
            	            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)},
            	            {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}
            	        ]);
            	    } else {
            	        return new table.Table('substitutionTable', [
            	            {name: 'substFormat', type: 'USHORT', value: 2},
            	            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
            	        ].concat(table.ushortList('substitute', subtable.substitute)));
            	    }
            	};

            	subtableMakers[3] = function makeLookup3(subtable) {
            	    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');
            	    return new table.Table('substitutionTable', [
            	        {name: 'substFormat', type: 'USHORT', value: 1},
            	        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
            	    ].concat(table.tableList('altSet', subtable.alternateSets, function(alternateSet) {
            	        return new table.Table('alternateSetTable', table.ushortList('alternate', alternateSet));
            	    })));
            	};

            	subtableMakers[4] = function makeLookup4(subtable) {
            	    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');
            	    return new table.Table('substitutionTable', [
            	        {name: 'substFormat', type: 'USHORT', value: 1},
            	        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
            	    ].concat(table.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {
            	        return new table.Table('ligatureSetTable', table.tableList('ligature', ligatureSet, function(ligature) {
            	            return new table.Table('ligatureTable',
            	                [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]
            	                .concat(table.ushortList('component', ligature.components, ligature.components.length + 1))
            	            );
            	        }));
            	    })));
            	};

            	function makeGsubTable(gsub) {
            	    return new table.Table('GSUB', [
            	        {name: 'version', type: 'ULONG', value: 0x10000},
            	        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gsub.scripts)},
            	        {name: 'features', type: 'TABLE', value: new table.FeatureList(gsub.features)},
            	        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gsub.lookups, subtableMakers)}
            	    ]);
            	}

            	var gsub = { parse: parseGsubTable, make: makeGsubTable };

            	// The `GPOS` table contains kerning pairs, among other things.

            	// Parse the metadata `meta` table.
            	// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html
            	function parseMetaTable(data, start) {
            	    var p = new parse.Parser(data, start);
            	    var tableVersion = p.parseULong();
            	    check.argument(tableVersion === 1, 'Unsupported META table version.');
            	    p.parseULong(); // flags - currently unused and set to 0
            	    p.parseULong(); // tableOffset
            	    var numDataMaps = p.parseULong();

            	    var tags = {};
            	    for (var i = 0; i < numDataMaps; i++) {
            	        var tag = p.parseTag();
            	        var dataOffset = p.parseULong();
            	        var dataLength = p.parseULong();
            	        var text = decode.UTF8(data, start + dataOffset, dataLength);

            	        tags[tag] = text;
            	    }
            	    return tags;
            	}

            	function makeMetaTable(tags) {
            	    var numTags = Object.keys(tags).length;
            	    var stringPool = '';
            	    var stringPoolOffset = 16 + numTags * 12;

            	    var result = new table.Table('meta', [
            	        {name: 'version', type: 'ULONG', value: 1},
            	        {name: 'flags', type: 'ULONG', value: 0},
            	        {name: 'offset', type: 'ULONG', value: stringPoolOffset},
            	        {name: 'numTags', type: 'ULONG', value: numTags}
            	    ]);

            	    for (var tag in tags) {
            	        var pos = stringPool.length;
            	        stringPool += tags[tag];

            	        result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});
            	        result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});
            	        result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});
            	    }

            	    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});

            	    return result;
            	}

            	var meta = { parse: parseMetaTable, make: makeMetaTable };

            	// The `sfnt` wrapper provides organization for the tables in the font.

            	function log2(v) {
            	    return Math.log(v) / Math.log(2) | 0;
            	}

            	function computeCheckSum(bytes) {
            	    while (bytes.length % 4 !== 0) {
            	        bytes.push(0);
            	    }

            	    var sum = 0;
            	    for (var i = 0; i < bytes.length; i += 4) {
            	        sum += (bytes[i] << 24) +
            	            (bytes[i + 1] << 16) +
            	            (bytes[i + 2] << 8) +
            	            (bytes[i + 3]);
            	    }

            	    sum %= Math.pow(2, 32);
            	    return sum;
            	}

            	function makeTableRecord(tag, checkSum, offset, length) {
            	    return new table.Record('Table Record', [
            	        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},
            	        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},
            	        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},
            	        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}
            	    ]);
            	}

            	function makeSfntTable(tables) {
            	    var sfnt = new table.Table('sfnt', [
            	        {name: 'version', type: 'TAG', value: 'OTTO'},
            	        {name: 'numTables', type: 'USHORT', value: 0},
            	        {name: 'searchRange', type: 'USHORT', value: 0},
            	        {name: 'entrySelector', type: 'USHORT', value: 0},
            	        {name: 'rangeShift', type: 'USHORT', value: 0}
            	    ]);
            	    sfnt.tables = tables;
            	    sfnt.numTables = tables.length;
            	    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
            	    sfnt.searchRange = 16 * highestPowerOf2;
            	    sfnt.entrySelector = log2(highestPowerOf2);
            	    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;

            	    var recordFields = [];
            	    var tableFields = [];

            	    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);
            	    while (offset % 4 !== 0) {
            	        offset += 1;
            	        tableFields.push({name: 'padding', type: 'BYTE', value: 0});
            	    }

            	    for (var i = 0; i < tables.length; i += 1) {
            	        var t = tables[i];
            	        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
            	        var tableLength = t.sizeOf();
            	        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
            	        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});
            	        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});
            	        offset += tableLength;
            	        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');
            	        while (offset % 4 !== 0) {
            	            offset += 1;
            	            tableFields.push({name: 'padding', type: 'BYTE', value: 0});
            	        }
            	    }

            	    // Table records need to be sorted alphabetically.
            	    recordFields.sort(function(r1, r2) {
            	        if (r1.value.tag > r2.value.tag) {
            	            return 1;
            	        } else {
            	            return -1;
            	        }
            	    });

            	    sfnt.fields = sfnt.fields.concat(recordFields);
            	    sfnt.fields = sfnt.fields.concat(tableFields);
            	    return sfnt;
            	}

            	// Get the metrics for a character. If the string has more than one character
            	// this function returns metrics for the first available character.
            	// You can provide optional fallback metrics if no characters are available.
            	function metricsForChar(font, chars, notFoundMetrics) {
            	    for (var i = 0; i < chars.length; i += 1) {
            	        var glyphIndex = font.charToGlyphIndex(chars[i]);
            	        if (glyphIndex > 0) {
            	            var glyph = font.glyphs.get(glyphIndex);
            	            return glyph.getMetrics();
            	        }
            	    }

            	    return notFoundMetrics;
            	}

            	function average(vs) {
            	    var sum = 0;
            	    for (var i = 0; i < vs.length; i += 1) {
            	        sum += vs[i];
            	    }

            	    return sum / vs.length;
            	}

            	// Convert the font object to a SFNT data structure.
            	// This structure contains all the necessary tables and metadata to create a binary OTF file.
            	function fontToSfntTable(font) {
            	    var xMins = [];
            	    var yMins = [];
            	    var xMaxs = [];
            	    var yMaxs = [];
            	    var advanceWidths = [];
            	    var leftSideBearings = [];
            	    var rightSideBearings = [];
            	    var firstCharIndex;
            	    var lastCharIndex = 0;
            	    var ulUnicodeRange1 = 0;
            	    var ulUnicodeRange2 = 0;
            	    var ulUnicodeRange3 = 0;
            	    var ulUnicodeRange4 = 0;

            	    for (var i = 0; i < font.glyphs.length; i += 1) {
            	        var glyph = font.glyphs.get(i);
            	        var unicode = glyph.unicode | 0;

            	        if (isNaN(glyph.advanceWidth)) {
            	            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');
            	        }

            	        if (firstCharIndex > unicode || firstCharIndex === undefined) {
            	            // ignore .notdef char
            	            if (unicode > 0) {
            	                firstCharIndex = unicode;
            	            }
            	        }

            	        if (lastCharIndex < unicode) {
            	            lastCharIndex = unicode;
            	        }

            	        var position = os2.getUnicodeRange(unicode);
            	        if (position < 32) {
            	            ulUnicodeRange1 |= 1 << position;
            	        } else if (position < 64) {
            	            ulUnicodeRange2 |= 1 << position - 32;
            	        } else if (position < 96) {
            	            ulUnicodeRange3 |= 1 << position - 64;
            	        } else if (position < 123) {
            	            ulUnicodeRange4 |= 1 << position - 96;
            	        } else {
            	            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');
            	        }
            	        // Skip non-important characters.
            	        if (glyph.name === '.notdef') { continue; }
            	        var metrics = glyph.getMetrics();
            	        xMins.push(metrics.xMin);
            	        yMins.push(metrics.yMin);
            	        xMaxs.push(metrics.xMax);
            	        yMaxs.push(metrics.yMax);
            	        leftSideBearings.push(metrics.leftSideBearing);
            	        rightSideBearings.push(metrics.rightSideBearing);
            	        advanceWidths.push(glyph.advanceWidth);
            	    }

            	    var globals = {
            	        xMin: Math.min.apply(null, xMins),
            	        yMin: Math.min.apply(null, yMins),
            	        xMax: Math.max.apply(null, xMaxs),
            	        yMax: Math.max.apply(null, yMaxs),
            	        advanceWidthMax: Math.max.apply(null, advanceWidths),
            	        advanceWidthAvg: average(advanceWidths),
            	        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
            	        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
            	        minRightSideBearing: Math.min.apply(null, rightSideBearings)
            	    };
            	    globals.ascender = font.ascender;
            	    globals.descender = font.descender;

            	    var headTable = head.make({
            	        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)
            	        unitsPerEm: font.unitsPerEm,
            	        xMin: globals.xMin,
            	        yMin: globals.yMin,
            	        xMax: globals.xMax,
            	        yMax: globals.yMax,
            	        lowestRecPPEM: 3,
            	        createdTimestamp: font.createdTimestamp
            	    });

            	    var hheaTable = hhea.make({
            	        ascender: globals.ascender,
            	        descender: globals.descender,
            	        advanceWidthMax: globals.advanceWidthMax,
            	        minLeftSideBearing: globals.minLeftSideBearing,
            	        minRightSideBearing: globals.minRightSideBearing,
            	        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
            	        numberOfHMetrics: font.glyphs.length
            	    });

            	    var maxpTable = maxp.make(font.glyphs.length);

            	    var os2Table = os2.make({
            	        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
            	        usWeightClass: font.tables.os2.usWeightClass,
            	        usWidthClass: font.tables.os2.usWidthClass,
            	        usFirstCharIndex: firstCharIndex,
            	        usLastCharIndex: lastCharIndex,
            	        ulUnicodeRange1: ulUnicodeRange1,
            	        ulUnicodeRange2: ulUnicodeRange2,
            	        ulUnicodeRange3: ulUnicodeRange3,
            	        ulUnicodeRange4: ulUnicodeRange4,
            	        fsSelection: font.tables.os2.fsSelection, // REGULAR
            	        // See http://typophile.com/node/13081 for more info on vertical metrics.
            	        // We get metrics for typical characters (such as "x" for xHeight).
            	        // We provide some fallback characters if characters are unavailable: their
            	        // ordering was chosen experimentally.
            	        sTypoAscender: globals.ascender,
            	        sTypoDescender: globals.descender,
            	        sTypoLineGap: 0,
            	        usWinAscent: globals.yMax,
            	        usWinDescent: Math.abs(globals.yMin),
            	        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now
            	        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,
            	        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
            	        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.
            	        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.
            	    });

            	    var hmtxTable = hmtx.make(font.glyphs);
            	    var cmapTable = cmap.make(font.glyphs);

            	    var englishFamilyName = font.getEnglishName('fontFamily');
            	    var englishStyleName = font.getEnglishName('fontSubfamily');
            	    var englishFullName = englishFamilyName + ' ' + englishStyleName;
            	    var postScriptName = font.getEnglishName('postScriptName');
            	    if (!postScriptName) {
            	        postScriptName = englishFamilyName.replace(/\s/g, '') + '-' + englishStyleName;
            	    }

            	    var names = {};
            	    for (var n in font.names) {
            	        names[n] = font.names[n];
            	    }

            	    if (!names.uniqueID) {
            	        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};
            	    }

            	    if (!names.postScriptName) {
            	        names.postScriptName = {en: postScriptName};
            	    }

            	    if (!names.preferredFamily) {
            	        names.preferredFamily = font.names.fontFamily;
            	    }

            	    if (!names.preferredSubfamily) {
            	        names.preferredSubfamily = font.names.fontSubfamily;
            	    }

            	    var languageTags = [];
            	    var nameTable = _name.make(names, languageTags);
            	    var ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);

            	    var postTable = post.make();
            	    var cffTable = cff.make(font.glyphs, {
            	        version: font.getEnglishName('version'),
            	        fullName: englishFullName,
            	        familyName: englishFamilyName,
            	        weightName: englishStyleName,
            	        postScriptName: postScriptName,
            	        unitsPerEm: font.unitsPerEm,
            	        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]
            	    });

            	    var metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;

            	    // The order does not matter because makeSfntTable() will sort them.
            	    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
            	    if (ltagTable) {
            	        tables.push(ltagTable);
            	    }
            	    // Optional tables
            	    if (font.tables.gsub) {
            	        tables.push(gsub.make(font.tables.gsub));
            	    }
            	    if (metaTable) {
            	        tables.push(metaTable);
            	    }

            	    var sfntTable = makeSfntTable(tables);

            	    // Compute the font's checkSum and store it in head.checkSumAdjustment.
            	    var bytes = sfntTable.encode();
            	    var checkSum = computeCheckSum(bytes);
            	    var tableFields = sfntTable.fields;
            	    var checkSumAdjusted = false;
            	    for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {
            	        if (tableFields[i$1].name === 'head table') {
            	            tableFields[i$1].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;
            	            checkSumAdjusted = true;
            	            break;
            	        }
            	    }

            	    if (!checkSumAdjusted) {
            	        throw new Error('Could not find head table with checkSum to adjust.');
            	    }

            	    return sfntTable;
            	}

            	var sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum };

            	// The Layout object is the prototype of Substitution objects, and provides

            	function searchTag(arr, tag) {
            	    /* jshint bitwise: false */
            	    var imin = 0;
            	    var imax = arr.length - 1;
            	    while (imin <= imax) {
            	        var imid = (imin + imax) >>> 1;
            	        var val = arr[imid].tag;
            	        if (val === tag) {
            	            return imid;
            	        } else if (val < tag) {
            	            imin = imid + 1;
            	        } else { imax = imid - 1; }
            	    }
            	    // Not found: return -1-insertion point
            	    return -imin - 1;
            	}

            	function binSearch(arr, value) {
            	    /* jshint bitwise: false */
            	    var imin = 0;
            	    var imax = arr.length - 1;
            	    while (imin <= imax) {
            	        var imid = (imin + imax) >>> 1;
            	        var val = arr[imid];
            	        if (val === value) {
            	            return imid;
            	        } else if (val < value) {
            	            imin = imid + 1;
            	        } else { imax = imid - 1; }
            	    }
            	    // Not found: return -1-insertion point
            	    return -imin - 1;
            	}

            	// binary search in a list of ranges (coverage, class definition)
            	function searchRange(ranges, value) {
            	    // jshint bitwise: false
            	    var range;
            	    var imin = 0;
            	    var imax = ranges.length - 1;
            	    while (imin <= imax) {
            	        var imid = (imin + imax) >>> 1;
            	        range = ranges[imid];
            	        var start = range.start;
            	        if (start === value) {
            	            return range;
            	        } else if (start < value) {
            	            imin = imid + 1;
            	        } else { imax = imid - 1; }
            	    }
            	    if (imin > 0) {
            	        range = ranges[imin - 1];
            	        if (value > range.end) { return 0; }
            	        return range;
            	    }
            	}

            	/**
            	 * @exports opentype.Layout
            	 * @class
            	 */
            	function Layout(font, tableName) {
            	    this.font = font;
            	    this.tableName = tableName;
            	}

            	Layout.prototype = {

            	    /**
            	     * Binary search an object by "tag" property
            	     * @instance
            	     * @function searchTag
            	     * @memberof opentype.Layout
            	     * @param  {Array} arr
            	     * @param  {string} tag
            	     * @return {number}
            	     */
            	    searchTag: searchTag,

            	    /**
            	     * Binary search in a list of numbers
            	     * @instance
            	     * @function binSearch
            	     * @memberof opentype.Layout
            	     * @param  {Array} arr
            	     * @param  {number} value
            	     * @return {number}
            	     */
            	    binSearch: binSearch,

            	    /**
            	     * Get or create the Layout table (GSUB, GPOS etc).
            	     * @param  {boolean} create - Whether to create a new one.
            	     * @return {Object} The GSUB or GPOS table.
            	     */
            	    getTable: function(create) {
            	        var layout = this.font.tables[this.tableName];
            	        if (!layout && create) {
            	            layout = this.font.tables[this.tableName] = this.createDefaultTable();
            	        }
            	        return layout;
            	    },

            	    /**
            	     * Returns all scripts in the substitution table.
            	     * @instance
            	     * @return {Array}
            	     */
            	    getScriptNames: function() {
            	        var layout = this.getTable();
            	        if (!layout) { return []; }
            	        return layout.scripts.map(function(script) {
            	            return script.tag;
            	        });
            	    },

            	    /**
            	     * Returns the best bet for a script name.
            	     * Returns 'DFLT' if it exists.
            	     * If not, returns 'latn' if it exists.
            	     * If neither exist, returns undefined.
            	     */
            	    getDefaultScriptName: function() {
            	        var layout = this.getTable();
            	        if (!layout) { return; }
            	        var hasLatn = false;
            	        for (var i = 0; i < layout.scripts.length; i++) {
            	            var name = layout.scripts[i].tag;
            	            if (name === 'DFLT') { return name; }
            	            if (name === 'latn') { hasLatn = true; }
            	        }
            	        if (hasLatn) { return 'latn'; }
            	    },

            	    /**
            	     * Returns all LangSysRecords in the given script.
            	     * @instance
            	     * @param {string} [script='DFLT']
            	     * @param {boolean} create - forces the creation of this script table if it doesn't exist.
            	     * @return {Object} An object with tag and script properties.
            	     */
            	    getScriptTable: function(script, create) {
            	        var layout = this.getTable(create);
            	        if (layout) {
            	            script = script || 'DFLT';
            	            var scripts = layout.scripts;
            	            var pos = searchTag(layout.scripts, script);
            	            if (pos >= 0) {
            	                return scripts[pos].script;
            	            } else if (create) {
            	                var scr = {
            	                    tag: script,
            	                    script: {
            	                        defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},
            	                        langSysRecords: []
            	                    }
            	                };
            	                scripts.splice(-1 - pos, 0, scr);
            	                return scr.script;
            	            }
            	        }
            	    },

            	    /**
            	     * Returns a language system table
            	     * @instance
            	     * @param {string} [script='DFLT']
            	     * @param {string} [language='dlft']
            	     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.
            	     * @return {Object}
            	     */
            	    getLangSysTable: function(script, language, create) {
            	        var scriptTable = this.getScriptTable(script, create);
            	        if (scriptTable) {
            	            if (!language || language === 'dflt' || language === 'DFLT') {
            	                return scriptTable.defaultLangSys;
            	            }
            	            var pos = searchTag(scriptTable.langSysRecords, language);
            	            if (pos >= 0) {
            	                return scriptTable.langSysRecords[pos].langSys;
            	            } else if (create) {
            	                var langSysRecord = {
            	                    tag: language,
            	                    langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}
            	                };
            	                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
            	                return langSysRecord.langSys;
            	            }
            	        }
            	    },

            	    /**
            	     * Get a specific feature table.
            	     * @instance
            	     * @param {string} [script='DFLT']
            	     * @param {string} [language='dlft']
            	     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm
            	     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.
            	     * @return {Object}
            	     */
            	    getFeatureTable: function(script, language, feature, create) {
            	        var langSysTable = this.getLangSysTable(script, language, create);
            	        if (langSysTable) {
            	            var featureRecord;
            	            var featIndexes = langSysTable.featureIndexes;
            	            var allFeatures = this.font.tables[this.tableName].features;
            	            // The FeatureIndex array of indices is in arbitrary order,
            	            // even if allFeatures is sorted alphabetically by feature tag.
            	            for (var i = 0; i < featIndexes.length; i++) {
            	                featureRecord = allFeatures[featIndexes[i]];
            	                if (featureRecord.tag === feature) {
            	                    return featureRecord.feature;
            	                }
            	            }
            	            if (create) {
            	                var index = allFeatures.length;
            	                // Automatic ordering of features would require to shift feature indexes in the script list.
            	                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');
            	                featureRecord = {
            	                    tag: feature,
            	                    feature: { params: 0, lookupListIndexes: [] }
            	                };
            	                allFeatures.push(featureRecord);
            	                featIndexes.push(index);
            	                return featureRecord.feature;
            	            }
            	        }
            	    },

            	    /**
            	     * Get the lookup tables of a given type for a script/language/feature.
            	     * @instance
            	     * @param {string} [script='DFLT']
            	     * @param {string} [language='dlft']
            	     * @param {string} feature - 4-letter feature code
            	     * @param {number} lookupType - 1 to 9
            	     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.
            	     * @return {Object[]}
            	     */
            	    getLookupTables: function(script, language, feature, lookupType, create) {
            	        var featureTable = this.getFeatureTable(script, language, feature, create);
            	        var tables = [];
            	        if (featureTable) {
            	            var lookupTable;
            	            var lookupListIndexes = featureTable.lookupListIndexes;
            	            var allLookups = this.font.tables[this.tableName].lookups;
            	            // lookupListIndexes are in no particular order, so use naive search.
            	            for (var i = 0; i < lookupListIndexes.length; i++) {
            	                lookupTable = allLookups[lookupListIndexes[i]];
            	                if (lookupTable.lookupType === lookupType) {
            	                    tables.push(lookupTable);
            	                }
            	            }
            	            if (tables.length === 0 && create) {
            	                lookupTable = {
            	                    lookupType: lookupType,
            	                    lookupFlag: 0,
            	                    subtables: [],
            	                    markFilteringSet: undefined
            	                };
            	                var index = allLookups.length;
            	                allLookups.push(lookupTable);
            	                lookupListIndexes.push(index);
            	                return [lookupTable];
            	            }
            	        }
            	        return tables;
            	    },

            	    /**
            	     * Find a glyph in a class definition table
            	     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table
            	     * @param {object} classDefTable - an OpenType Layout class definition table
            	     * @param {number} glyphIndex - the index of the glyph to find
            	     * @returns {number} -1 if not found
            	     */
            	    getGlyphClass: function(classDefTable, glyphIndex) {
            	        switch (classDefTable.format) {
            	            case 1:
            	                if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {
            	                    return classDefTable.classes[glyphIndex - classDefTable.startGlyph];
            	                }
            	                return 0;
            	            case 2:
            	                var range = searchRange(classDefTable.ranges, glyphIndex);
            	                return range ? range.classId : 0;
            	        }
            	    },

            	    /**
            	     * Find a glyph in a coverage table
            	     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table
            	     * @param {object} coverageTable - an OpenType Layout coverage table
            	     * @param {number} glyphIndex - the index of the glyph to find
            	     * @returns {number} -1 if not found
            	     */
            	    getCoverageIndex: function(coverageTable, glyphIndex) {
            	        switch (coverageTable.format) {
            	            case 1:
            	                var index = binSearch(coverageTable.glyphs, glyphIndex);
            	                return index >= 0 ? index : -1;
            	            case 2:
            	                var range = searchRange(coverageTable.ranges, glyphIndex);
            	                return range ? range.index + glyphIndex - range.start : -1;
            	        }
            	    },

            	    /**
            	     * Returns the list of glyph indexes of a coverage table.
            	     * Format 1: the list is stored raw
            	     * Format 2: compact list as range records.
            	     * @instance
            	     * @param  {Object} coverageTable
            	     * @return {Array}
            	     */
            	    expandCoverage: function(coverageTable) {
            	        if (coverageTable.format === 1) {
            	            return coverageTable.glyphs;
            	        } else {
            	            var glyphs = [];
            	            var ranges = coverageTable.ranges;
            	            for (var i = 0; i < ranges.length; i++) {
            	                var range = ranges[i];
            	                var start = range.start;
            	                var end = range.end;
            	                for (var j = start; j <= end; j++) {
            	                    glyphs.push(j);
            	                }
            	            }
            	            return glyphs;
            	        }
            	    }

            	};

            	// The Position object provides utility methods to manipulate

            	/**
            	 * @exports opentype.Position
            	 * @class
            	 * @extends opentype.Layout
            	 * @param {opentype.Font}
            	 * @constructor
            	 */
            	function Position(font) {
            	    Layout.call(this, font, 'gpos');
            	}

            	Position.prototype = Layout.prototype;

            	/**
            	 * Init some data for faster and easier access later.
            	 */
            	Position.prototype.init = function() {
            	    var script = this.getDefaultScriptName();
            	    this.defaultKerningTables = this.getKerningTables(script);
            	};

            	/**
            	 * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.
            	 *
            	 * @param {integer} leftIndex - left glyph index
            	 * @param {integer} rightIndex - right glyph index
            	 * @returns {integer}
            	 */
            	Position.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {
            	    var this$1 = this;

            	    for (var i = 0; i < kerningLookups.length; i++) {
            	        var subtables = kerningLookups[i].subtables;
            	        for (var j = 0; j < subtables.length; j++) {
            	            var subtable = subtables[j];
            	            var covIndex = this$1.getCoverageIndex(subtable.coverage, leftIndex);
            	            if (covIndex < 0) { continue; }
            	            switch (subtable.posFormat) {
            	                case 1:
            	                    // Search Pair Adjustment Positioning Format 1
            	                    var pairSet = subtable.pairSets[covIndex];
            	                    for (var k = 0; k < pairSet.length; k++) {
            	                        var pair = pairSet[k];
            	                        if (pair.secondGlyph === rightIndex) {
            	                            return pair.value1 && pair.value1.xAdvance || 0;
            	                        }
            	                    }
            	                    break;      // left glyph found, not right glyph - try next subtable
            	                case 2:
            	                    // Search Pair Adjustment Positioning Format 2
            	                    var class1 = this$1.getGlyphClass(subtable.classDef1, leftIndex);
            	                    var class2 = this$1.getGlyphClass(subtable.classDef2, rightIndex);
            	                    var pair$1 = subtable.classRecords[class1][class2];
            	                    return pair$1.value1 && pair$1.value1.xAdvance || 0;
            	            }
            	        }
            	    }
            	    return 0;
            	};

            	/**
            	 * List all kerning lookup tables.
            	 *
            	 * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value
            	 * @param {string} [language='dflt']
            	 * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)
            	 */
            	Position.prototype.getKerningTables = function(script, language) {
            	    if (this.font.tables.gpos) {
            	        return this.getLookupTables(script, language, 'kern', 2);
            	    }
            	};

            	// The Substitution object provides utility methods to manipulate

            	/**
            	 * @exports opentype.Substitution
            	 * @class
            	 * @extends opentype.Layout
            	 * @param {opentype.Font}
            	 * @constructor
            	 */
            	function Substitution(font) {
            	    Layout.call(this, font, 'gsub');
            	}

            	// Check if 2 arrays of primitives are equal.
            	function arraysEqual(ar1, ar2) {
            	    var n = ar1.length;
            	    if (n !== ar2.length) { return false; }
            	    for (var i = 0; i < n; i++) {
            	        if (ar1[i] !== ar2[i]) { return false; }
            	    }
            	    return true;
            	}

            	// Find the first subtable of a lookup table in a particular format.
            	function getSubstFormat(lookupTable, format, defaultSubtable) {
            	    var subtables = lookupTable.subtables;
            	    for (var i = 0; i < subtables.length; i++) {
            	        var subtable = subtables[i];
            	        if (subtable.substFormat === format) {
            	            return subtable;
            	        }
            	    }
            	    if (defaultSubtable) {
            	        subtables.push(defaultSubtable);
            	        return defaultSubtable;
            	    }
            	    return undefined;
            	}

            	Substitution.prototype = Layout.prototype;

            	/**
            	 * Create a default GSUB table.
            	 * @return {Object} gsub - The GSUB table.
            	 */
            	Substitution.prototype.createDefaultTable = function() {
            	    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.
            	    return {
            	        version: 1,
            	        scripts: [{
            	            tag: 'DFLT',
            	            script: {
            	                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },
            	                langSysRecords: []
            	            }
            	        }],
            	        features: [],
            	        lookups: []
            	    };
            	};

            	/**
            	 * List all single substitutions (lookup type 1) for a given script, language, and feature.
            	 * @param {string} [script='DFLT']
            	 * @param {string} [language='dflt']
            	 * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)
            	 * @return {Array} substitutions - The list of substitutions.
            	 */
            	Substitution.prototype.getSingle = function(feature, script, language) {
            	    var this$1 = this;

            	    var substitutions = [];
            	    var lookupTables = this.getLookupTables(script, language, feature, 1);
            	    for (var idx = 0; idx < lookupTables.length; idx++) {
            	        var subtables = lookupTables[idx].subtables;
            	        for (var i = 0; i < subtables.length; i++) {
            	            var subtable = subtables[i];
            	            var glyphs = this$1.expandCoverage(subtable.coverage);
            	            var j = (void 0);
            	            if (subtable.substFormat === 1) {
            	                var delta = subtable.deltaGlyphId;
            	                for (j = 0; j < glyphs.length; j++) {
            	                    var glyph = glyphs[j];
            	                    substitutions.push({ sub: glyph, by: glyph + delta });
            	                }
            	            } else {
            	                var substitute = subtable.substitute;
            	                for (j = 0; j < glyphs.length; j++) {
            	                    substitutions.push({ sub: glyphs[j], by: substitute[j] });
            	                }
            	            }
            	        }
            	    }
            	    return substitutions;
            	};

            	/**
            	 * List all alternates (lookup type 3) for a given script, language, and feature.
            	 * @param {string} [script='DFLT']
            	 * @param {string} [language='dflt']
            	 * @param {string} feature - 4-character feature name ('aalt', 'salt'...)
            	 * @return {Array} alternates - The list of alternates
            	 */
            	Substitution.prototype.getAlternates = function(feature, script, language) {
            	    var this$1 = this;

            	    var alternates = [];
            	    var lookupTables = this.getLookupTables(script, language, feature, 3);
            	    for (var idx = 0; idx < lookupTables.length; idx++) {
            	        var subtables = lookupTables[idx].subtables;
            	        for (var i = 0; i < subtables.length; i++) {
            	            var subtable = subtables[i];
            	            var glyphs = this$1.expandCoverage(subtable.coverage);
            	            var alternateSets = subtable.alternateSets;
            	            for (var j = 0; j < glyphs.length; j++) {
            	                alternates.push({ sub: glyphs[j], by: alternateSets[j] });
            	            }
            	        }
            	    }
            	    return alternates;
            	};

            	/**
            	 * List all ligatures (lookup type 4) for a given script, language, and feature.
            	 * The result is an array of ligature objects like { sub: [ids], by: id }
            	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
            	 * @param {string} [script='DFLT']
            	 * @param {string} [language='dflt']
            	 * @return {Array} ligatures - The list of ligatures.
            	 */
            	Substitution.prototype.getLigatures = function(feature, script, language) {
            	    var this$1 = this;

            	    var ligatures = [];
            	    var lookupTables = this.getLookupTables(script, language, feature, 4);
            	    for (var idx = 0; idx < lookupTables.length; idx++) {
            	        var subtables = lookupTables[idx].subtables;
            	        for (var i = 0; i < subtables.length; i++) {
            	            var subtable = subtables[i];
            	            var glyphs = this$1.expandCoverage(subtable.coverage);
            	            var ligatureSets = subtable.ligatureSets;
            	            for (var j = 0; j < glyphs.length; j++) {
            	                var startGlyph = glyphs[j];
            	                var ligSet = ligatureSets[j];
            	                for (var k = 0; k < ligSet.length; k++) {
            	                    var lig = ligSet[k];
            	                    ligatures.push({
            	                        sub: [startGlyph].concat(lig.components),
            	                        by: lig.ligGlyph
            	                    });
            	                }
            	            }
            	        }
            	    }
            	    return ligatures;
            	};

            	/**
            	 * Add or modify a single substitution (lookup type 1)
            	 * Format 2, more flexible, is always used.
            	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
            	 * @param {Object} substitution - { sub: id, delta: number } for format 1 or { sub: id, by: id } for format 2.
            	 * @param {string} [script='DFLT']
            	 * @param {string} [language='dflt']
            	 */
            	Substitution.prototype.addSingle = function(feature, substitution, script, language) {
            	    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];
            	    var subtable = getSubstFormat(lookupTable, 2, {                // lookup type 1 subtable, format 2, coverage format 1
            	        substFormat: 2,
            	        coverage: {format: 1, glyphs: []},
            	        substitute: []
            	    });
            	    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
            	    var coverageGlyph = substitution.sub;
            	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
            	    if (pos < 0) {
            	        pos = -1 - pos;
            	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
            	        subtable.substitute.splice(pos, 0, 0);
            	    }
            	    subtable.substitute[pos] = substitution.by;
            	};

            	/**
            	 * Add or modify an alternate substitution (lookup type 1)
            	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
            	 * @param {Object} substitution - { sub: id, by: [ids] }
            	 * @param {string} [script='DFLT']
            	 * @param {string} [language='dflt']
            	 */
            	Substitution.prototype.addAlternate = function(feature, substitution, script, language) {
            	    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];
            	    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 3 subtable, format 1, coverage format 1
            	        substFormat: 1,
            	        coverage: {format: 1, glyphs: []},
            	        alternateSets: []
            	    });
            	    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
            	    var coverageGlyph = substitution.sub;
            	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
            	    if (pos < 0) {
            	        pos = -1 - pos;
            	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
            	        subtable.alternateSets.splice(pos, 0, 0);
            	    }
            	    subtable.alternateSets[pos] = substitution.by;
            	};

            	/**
            	 * Add a ligature (lookup type 4)
            	 * Ligatures with more components must be stored ahead of those with fewer components in order to be found
            	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
            	 * @param {Object} ligature - { sub: [ids], by: id }
            	 * @param {string} [script='DFLT']
            	 * @param {string} [language='dflt']
            	 */
            	Substitution.prototype.addLigature = function(feature, ligature, script, language) {
            	    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];
            	    var subtable = lookupTable.subtables[0];
            	    if (!subtable) {
            	        subtable = {                // lookup type 4 subtable, format 1, coverage format 1
            	            substFormat: 1,
            	            coverage: { format: 1, glyphs: [] },
            	            ligatureSets: []
            	        };
            	        lookupTable.subtables[0] = subtable;
            	    }
            	    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
            	    var coverageGlyph = ligature.sub[0];
            	    var ligComponents = ligature.sub.slice(1);
            	    var ligatureTable = {
            	        ligGlyph: ligature.by,
            	        components: ligComponents
            	    };
            	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
            	    if (pos >= 0) {
            	        // ligatureSet already exists
            	        var ligatureSet = subtable.ligatureSets[pos];
            	        for (var i = 0; i < ligatureSet.length; i++) {
            	            // If ligature already exists, return.
            	            if (arraysEqual(ligatureSet[i].components, ligComponents)) {
            	                return;
            	            }
            	        }
            	        // ligature does not exist: add it.
            	        ligatureSet.push(ligatureTable);
            	    } else {
            	        // Create a new ligatureSet and add coverage for the first glyph.
            	        pos = -1 - pos;
            	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
            	        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
            	    }
            	};

            	/**
            	 * List all feature data for a given script and language.
            	 * @param {string} feature - 4-letter feature name
            	 * @param {string} [script='DFLT']
            	 * @param {string} [language='dflt']
            	 * @return {Array} substitutions - The list of substitutions.
            	 */
            	Substitution.prototype.getFeature = function(feature, script, language) {
            	    if (/ss\d\d/.test(feature)) {
            	        // ss01 - ss20
            	        return this.getSingle(feature, script, language);
            	    }
            	    switch (feature) {
            	        case 'aalt':
            	        case 'salt':
            	            return this.getSingle(feature, script, language)
            	                    .concat(this.getAlternates(feature, script, language));
            	        case 'dlig':
            	        case 'liga':
            	        case 'rlig': return this.getLigatures(feature, script, language);
            	    }
            	    return undefined;
            	};

            	/**
            	 * Add a substitution to a feature for a given script and language.
            	 * @param {string} feature - 4-letter feature name
            	 * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })
            	 * @param {string} [script='DFLT']
            	 * @param {string} [language='dflt']
            	 */
            	Substitution.prototype.add = function(feature, sub, script, language) {
            	    if (/ss\d\d/.test(feature)) {
            	        // ss01 - ss20
            	        return this.addSingle(feature, sub, script, language);
            	    }
            	    switch (feature) {
            	        case 'aalt':
            	        case 'salt':
            	            if (typeof sub.by === 'number') {
            	                return this.addSingle(feature, sub, script, language);
            	            }
            	            return this.addAlternate(feature, sub, script, language);
            	        case 'dlig':
            	        case 'liga':
            	        case 'rlig':
            	            return this.addLigature(feature, sub, script, language);
            	    }
            	    return undefined;
            	};

            	function isBrowser() {
            	    return typeof window !== 'undefined';
            	}

            	function nodeBufferToArrayBuffer(buffer) {
            	    var ab = new ArrayBuffer(buffer.length);
            	    var view = new Uint8Array(ab);
            	    for (var i = 0; i < buffer.length; ++i) {
            	        view[i] = buffer[i];
            	    }

            	    return ab;
            	}

            	function arrayBufferToNodeBuffer(ab) {
            	    var buffer = new Buffer$1(ab.byteLength);
            	    var view = new Uint8Array(ab);
            	    for (var i = 0; i < buffer.length; ++i) {
            	        buffer[i] = view[i];
            	    }

            	    return buffer;
            	}

            	function checkArgument(expression, message) {
            	    if (!expression) {
            	        throw message;
            	    }
            	}

            	// The `glyf` table describes the glyphs in TrueType outline format.

            	// Parse the coordinate data for a glyph.
            	function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
            	    var v;
            	    if ((flag & shortVectorBitMask) > 0) {
            	        // The coordinate is 1 byte long.
            	        v = p.parseByte();
            	        // The `same` bit is re-used for short values to signify the sign of the value.
            	        if ((flag & sameBitMask) === 0) {
            	            v = -v;
            	        }

            	        v = previousValue + v;
            	    } else {
            	        //  The coordinate is 2 bytes long.
            	        // If the `same` bit is set, the coordinate is the same as the previous coordinate.
            	        if ((flag & sameBitMask) > 0) {
            	            v = previousValue;
            	        } else {
            	            // Parse the coordinate as a signed 16-bit delta value.
            	            v = previousValue + p.parseShort();
            	        }
            	    }

            	    return v;
            	}

            	// Parse a TrueType glyph.
            	function parseGlyph(glyph, data, start) {
            	    var p = new parse.Parser(data, start);
            	    glyph.numberOfContours = p.parseShort();
            	    glyph._xMin = p.parseShort();
            	    glyph._yMin = p.parseShort();
            	    glyph._xMax = p.parseShort();
            	    glyph._yMax = p.parseShort();
            	    var flags;
            	    var flag;

            	    if (glyph.numberOfContours > 0) {
            	        // This glyph is not a composite.
            	        var endPointIndices = glyph.endPointIndices = [];
            	        for (var i = 0; i < glyph.numberOfContours; i += 1) {
            	            endPointIndices.push(p.parseUShort());
            	        }

            	        glyph.instructionLength = p.parseUShort();
            	        glyph.instructions = [];
            	        for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {
            	            glyph.instructions.push(p.parseByte());
            	        }

            	        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
            	        flags = [];
            	        for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {
            	            flag = p.parseByte();
            	            flags.push(flag);
            	            // If bit 3 is set, we repeat this flag n times, where n is the next byte.
            	            if ((flag & 8) > 0) {
            	                var repeatCount = p.parseByte();
            	                for (var j = 0; j < repeatCount; j += 1) {
            	                    flags.push(flag);
            	                    i$2 += 1;
            	                }
            	            }
            	        }

            	        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');

            	        if (endPointIndices.length > 0) {
            	            var points = [];
            	            var point;
            	            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
            	            if (numberOfCoordinates > 0) {
            	                for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {
            	                    flag = flags[i$3];
            	                    point = {};
            	                    point.onCurve = !!(flag & 1);
            	                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;
            	                    points.push(point);
            	                }

            	                var px = 0;
            	                for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {
            	                    flag = flags[i$4];
            	                    point = points[i$4];
            	                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
            	                    px = point.x;
            	                }

            	                var py = 0;
            	                for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {
            	                    flag = flags[i$5];
            	                    point = points[i$5];
            	                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
            	                    py = point.y;
            	                }
            	            }

            	            glyph.points = points;
            	        } else {
            	            glyph.points = [];
            	        }
            	    } else if (glyph.numberOfContours === 0) {
            	        glyph.points = [];
            	    } else {
            	        glyph.isComposite = true;
            	        glyph.points = [];
            	        glyph.components = [];
            	        var moreComponents = true;
            	        while (moreComponents) {
            	            flags = p.parseUShort();
            	            var component = {
            	                glyphIndex: p.parseUShort(),
            	                xScale: 1,
            	                scale01: 0,
            	                scale10: 0,
            	                yScale: 1,
            	                dx: 0,
            	                dy: 0
            	            };
            	            if ((flags & 1) > 0) {
            	                // The arguments are words
            	                if ((flags & 2) > 0) {
            	                    // values are offset
            	                    component.dx = p.parseShort();
            	                    component.dy = p.parseShort();
            	                } else {
            	                    // values are matched points
            	                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];
            	                }

            	            } else {
            	                // The arguments are bytes
            	                if ((flags & 2) > 0) {
            	                    // values are offset
            	                    component.dx = p.parseChar();
            	                    component.dy = p.parseChar();
            	                } else {
            	                    // values are matched points
            	                    component.matchedPoints = [p.parseByte(), p.parseByte()];
            	                }
            	            }

            	            if ((flags & 8) > 0) {
            	                // We have a scale
            	                component.xScale = component.yScale = p.parseF2Dot14();
            	            } else if ((flags & 64) > 0) {
            	                // We have an X / Y scale
            	                component.xScale = p.parseF2Dot14();
            	                component.yScale = p.parseF2Dot14();
            	            } else if ((flags & 128) > 0) {
            	                // We have a 2x2 transformation
            	                component.xScale = p.parseF2Dot14();
            	                component.scale01 = p.parseF2Dot14();
            	                component.scale10 = p.parseF2Dot14();
            	                component.yScale = p.parseF2Dot14();
            	            }

            	            glyph.components.push(component);
            	            moreComponents = !!(flags & 32);
            	        }
            	        if (flags & 0x100) {
            	            // We have instructions
            	            glyph.instructionLength = p.parseUShort();
            	            glyph.instructions = [];
            	            for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {
            	                glyph.instructions.push(p.parseByte());
            	            }
            	        }
            	    }
            	}

            	// Transform an array of points and return a new array.
            	function transformPoints(points, transform) {
            	    var newPoints = [];
            	    for (var i = 0; i < points.length; i += 1) {
            	        var pt = points[i];
            	        var newPt = {
            	            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
            	            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
            	            onCurve: pt.onCurve,
            	            lastPointOfContour: pt.lastPointOfContour
            	        };
            	        newPoints.push(newPt);
            	    }

            	    return newPoints;
            	}

            	function getContours(points) {
            	    var contours = [];
            	    var currentContour = [];
            	    for (var i = 0; i < points.length; i += 1) {
            	        var pt = points[i];
            	        currentContour.push(pt);
            	        if (pt.lastPointOfContour) {
            	            contours.push(currentContour);
            	            currentContour = [];
            	        }
            	    }

            	    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
            	    return contours;
            	}

            	// Convert the TrueType glyph outline to a Path.
            	function getPath(points) {
            	    var p = new Path();
            	    if (!points) {
            	        return p;
            	    }

            	    var contours = getContours(points);

            	    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {
            	        var contour = contours[contourIndex];

            	        var prev = null;
            	        var curr = contour[contour.length - 1];
            	        var next = contour[0];

            	        if (curr.onCurve) {
            	            p.moveTo(curr.x, curr.y);
            	        } else {
            	            if (next.onCurve) {
            	                p.moveTo(next.x, next.y);
            	            } else {
            	                // If both first and last points are off-curve, start at their middle.
            	                var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};
            	                p.moveTo(start.x, start.y);
            	            }
            	        }

            	        for (var i = 0; i < contour.length; ++i) {
            	            prev = curr;
            	            curr = next;
            	            next = contour[(i + 1) % contour.length];

            	            if (curr.onCurve) {
            	                // This is a straight line.
            	                p.lineTo(curr.x, curr.y);
            	            } else {
            	                var prev2 = prev;
            	                var next2 = next;

            	                if (!prev.onCurve) {
            	                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };
            	                }

            	                if (!next.onCurve) {
            	                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
            	                }

            	                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);
            	            }
            	        }

            	        p.closePath();
            	    }
            	    return p;
            	}

            	function buildPath(glyphs, glyph) {
            	    if (glyph.isComposite) {
            	        for (var j = 0; j < glyph.components.length; j += 1) {
            	            var component = glyph.components[j];
            	            var componentGlyph = glyphs.get(component.glyphIndex);
            	            // Force the ttfGlyphLoader to parse the glyph.
            	            componentGlyph.getPath();
            	            if (componentGlyph.points) {
            	                var transformedPoints = (void 0);
            	                if (component.matchedPoints === undefined) {
            	                    // component positioned by offset
            	                    transformedPoints = transformPoints(componentGlyph.points, component);
            	                } else {
            	                    // component positioned by matched points
            	                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||
            	                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {
            	                        throw Error('Matched points out of range in ' + glyph.name);
            	                    }
            	                    var firstPt = glyph.points[component.matchedPoints[0]];
            	                    var secondPt = componentGlyph.points[component.matchedPoints[1]];
            	                    var transform = {
            	                        xScale: component.xScale, scale01: component.scale01,
            	                        scale10: component.scale10, yScale: component.yScale,
            	                        dx: 0, dy: 0
            	                    };
            	                    secondPt = transformPoints([secondPt], transform)[0];
            	                    transform.dx = firstPt.x - secondPt.x;
            	                    transform.dy = firstPt.y - secondPt.y;
            	                    transformedPoints = transformPoints(componentGlyph.points, transform);
            	                }
            	                glyph.points = glyph.points.concat(transformedPoints);
            	            }
            	        }
            	    }

            	    return getPath(glyph.points);
            	}

            	// Parse all the glyphs according to the offsets from the `loca` table.
            	function parseGlyfTable(data, start, loca, font) {
            	    var glyphs = new glyphset.GlyphSet(font);

            	    // The last element of the loca table is invalid.
            	    for (var i = 0; i < loca.length - 1; i += 1) {
            	        var offset = loca[i];
            	        var nextOffset = loca[i + 1];
            	        if (offset !== nextOffset) {
            	            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
            	        } else {
            	            glyphs.push(i, glyphset.glyphLoader(font, i));
            	        }
            	    }

            	    return glyphs;
            	}

            	var glyf = { getPath: getPath, parse: parseGlyfTable };

            	/* A TrueType font hinting interpreter.
            	*
            	* (c) 2017 Axel Kittenberger
            	*
            	* This interpreter has been implemented according to this documentation:
            	* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html
            	*
            	* According to the documentation F24DOT6 values are used for pixels.
            	* That means calculation is 1/64 pixel accurate and uses integer operations.
            	* However, Javascript has floating point operations by default and only
            	* those are available. One could make a case to simulate the 1/64 accuracy
            	* exactly by truncating after every division operation
            	* (for example with << 0) to get pixel exactly results as other TrueType
            	* implementations. It may make sense since some fonts are pixel optimized
            	* by hand using DELTAP instructions. The current implementation doesn't
            	* and rather uses full floating point precision.
            	*
            	* xScale, yScale and rotation is currently ignored.
            	*
            	* A few non-trivial instructions are missing as I didn't encounter yet
            	* a font that used them to test a possible implementation.
            	*
            	* Some fonts seem to use undocumented features regarding the twilight zone.
            	* Only some of them are implemented as they were encountered.
            	*
            	* The exports.DEBUG statements are removed on the minified distribution file.
            	*/

            	var instructionTable;
            	var exec;
            	var execGlyph;
            	var execComponent;

            	/*
            	* Creates a hinting object.
            	*
            	* There ought to be exactly one
            	* for each truetype font that is used for hinting.
            	*/
            	function Hinting(font) {
            	    // the font this hinting object is for
            	    this.font = font;

            	    this.getCommands = function (hPoints) {
            	        return glyf.getPath(hPoints).commands;
            	    };

            	    // cached states
            	    this._fpgmState  =
            	    this._prepState  =
            	        undefined;

            	    // errorState
            	    // 0 ... all okay
            	    // 1 ... had an error in a glyf,
            	    //       continue working but stop spamming
            	    //       the console
            	    // 2 ... error at prep, stop hinting at this ppem
            	    // 3 ... error at fpeg, stop hinting for this font at all
            	    this._errorState = 0;
            	}

            	/*
            	* Not rounding.
            	*/
            	function roundOff(v) {
            	    return v;
            	}

            	/*
            	* Rounding to grid.
            	*/
            	function roundToGrid(v) {
            	    //Rounding in TT is supposed to "symmetrical around zero"
            	    return Math.sign(v) * Math.round(Math.abs(v));
            	}

            	/*
            	* Rounding to double grid.
            	*/
            	function roundToDoubleGrid(v) {
            	    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;
            	}

            	/*
            	* Rounding to half grid.
            	*/
            	function roundToHalfGrid(v) {
            	    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);
            	}

            	/*
            	* Rounding to up to grid.
            	*/
            	function roundUpToGrid(v) {
            	    return Math.sign(v) * Math.ceil(Math.abs(v));
            	}

            	/*
            	* Rounding to down to grid.
            	*/
            	function roundDownToGrid(v) {
            	    return Math.sign(v) * Math.floor(Math.abs(v));
            	}

            	/*
            	* Super rounding.
            	*/
            	var roundSuper = function (v) {
            	    var period = this.srPeriod;
            	    var phase = this.srPhase;
            	    var threshold = this.srThreshold;
            	    var sign = 1;

            	    if (v < 0) {
            	        v = -v;
            	        sign = -1;
            	    }

            	    v += threshold - phase;

            	    v = Math.trunc(v / period) * period;

            	    v += phase;

            	    // according to http://xgridfit.sourceforge.net/round.html
            	    if (v < 0) { return phase * sign; }

            	    return v * sign;
            	};

            	/*
            	* Unit vector of x-axis.
            	*/
            	var xUnitVector = {
            	    x: 1,

            	    y: 0,

            	    axis: 'x',

            	    // Gets the projected distance between two points.
            	    // o1/o2 ... if true, respective original position is used.
            	    distance: function (p1, p2, o1, o2) {
            	        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);
            	    },

            	    // Moves point p so the moved position has the same relative
            	    // position to the moved positions of rp1 and rp2 than the
            	    // original positions had.
            	    //
            	    // See APPENDIX on INTERPOLATE at the bottom of this file.
            	    interpolate: function (p, rp1, rp2, pv) {
            	        var do1;
            	        var do2;
            	        var doa1;
            	        var doa2;
            	        var dm1;
            	        var dm2;
            	        var dt;

            	        if (!pv || pv === this) {
            	            do1 = p.xo - rp1.xo;
            	            do2 = p.xo - rp2.xo;
            	            dm1 = rp1.x - rp1.xo;
            	            dm2 = rp2.x - rp2.xo;
            	            doa1 = Math.abs(do1);
            	            doa2 = Math.abs(do2);
            	            dt = doa1 + doa2;

            	            if (dt === 0) {
            	                p.x = p.xo + (dm1 + dm2) / 2;
            	                return;
            	            }

            	            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;
            	            return;
            	        }

            	        do1 = pv.distance(p, rp1, true, true);
            	        do2 = pv.distance(p, rp2, true, true);
            	        dm1 = pv.distance(rp1, rp1, false, true);
            	        dm2 = pv.distance(rp2, rp2, false, true);
            	        doa1 = Math.abs(do1);
            	        doa2 = Math.abs(do2);
            	        dt = doa1 + doa2;

            	        if (dt === 0) {
            	            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
            	            return;
            	        }

            	        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
            	    },

            	    // Slope of line normal to this
            	    normalSlope: Number.NEGATIVE_INFINITY,

            	    // Sets the point 'p' relative to point 'rp'
            	    // by the distance 'd'.
            	    //
            	    // See APPENDIX on SETRELATIVE at the bottom of this file.
            	    //
            	    // p   ... point to set
            	    // rp  ... reference point
            	    // d   ... distance on projection vector
            	    // pv  ... projection vector (undefined = this)
            	    // org ... if true, uses the original position of rp as reference.
            	    setRelative: function (p, rp, d, pv, org) {
            	        if (!pv || pv === this) {
            	            p.x = (org ? rp.xo : rp.x) + d;
            	            return;
            	        }

            	        var rpx = org ? rp.xo : rp.x;
            	        var rpy = org ? rp.yo : rp.y;
            	        var rpdx = rpx + d * pv.x;
            	        var rpdy = rpy + d * pv.y;

            	        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;
            	    },

            	    // Slope of vector line.
            	    slope: 0,

            	    // Touches the point p.
            	    touch: function (p) {
            	        p.xTouched = true;
            	    },

            	    // Tests if a point p is touched.
            	    touched: function (p) {
            	        return p.xTouched;
            	    },

            	    // Untouches the point p.
            	    untouch: function (p) {
            	        p.xTouched = false;
            	    }
            	};

            	/*
            	* Unit vector of y-axis.
            	*/
            	var yUnitVector = {
            	    x: 0,

            	    y: 1,

            	    axis: 'y',

            	    // Gets the projected distance between two points.
            	    // o1/o2 ... if true, respective original position is used.
            	    distance: function (p1, p2, o1, o2) {
            	        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);
            	    },

            	    // Moves point p so the moved position has the same relative
            	    // position to the moved positions of rp1 and rp2 than the
            	    // original positions had.
            	    //
            	    // See APPENDIX on INTERPOLATE at the bottom of this file.
            	    interpolate: function (p, rp1, rp2, pv) {
            	        var do1;
            	        var do2;
            	        var doa1;
            	        var doa2;
            	        var dm1;
            	        var dm2;
            	        var dt;

            	        if (!pv || pv === this) {
            	            do1 = p.yo - rp1.yo;
            	            do2 = p.yo - rp2.yo;
            	            dm1 = rp1.y - rp1.yo;
            	            dm2 = rp2.y - rp2.yo;
            	            doa1 = Math.abs(do1);
            	            doa2 = Math.abs(do2);
            	            dt = doa1 + doa2;

            	            if (dt === 0) {
            	                p.y = p.yo + (dm1 + dm2) / 2;
            	                return;
            	            }

            	            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;
            	            return;
            	        }

            	        do1 = pv.distance(p, rp1, true, true);
            	        do2 = pv.distance(p, rp2, true, true);
            	        dm1 = pv.distance(rp1, rp1, false, true);
            	        dm2 = pv.distance(rp2, rp2, false, true);
            	        doa1 = Math.abs(do1);
            	        doa2 = Math.abs(do2);
            	        dt = doa1 + doa2;

            	        if (dt === 0) {
            	            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
            	            return;
            	        }

            	        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
            	    },

            	    // Slope of line normal to this.
            	    normalSlope: 0,

            	    // Sets the point 'p' relative to point 'rp'
            	    // by the distance 'd'
            	    //
            	    // See APPENDIX on SETRELATIVE at the bottom of this file.
            	    //
            	    // p   ... point to set
            	    // rp  ... reference point
            	    // d   ... distance on projection vector
            	    // pv  ... projection vector (undefined = this)
            	    // org ... if true, uses the original position of rp as reference.
            	    setRelative: function (p, rp, d, pv, org) {
            	        if (!pv || pv === this) {
            	            p.y = (org ? rp.yo : rp.y) + d;
            	            return;
            	        }

            	        var rpx = org ? rp.xo : rp.x;
            	        var rpy = org ? rp.yo : rp.y;
            	        var rpdx = rpx + d * pv.x;
            	        var rpdy = rpy + d * pv.y;

            	        p.y = rpdy + pv.normalSlope * (p.x - rpdx);
            	    },

            	    // Slope of vector line.
            	    slope: Number.POSITIVE_INFINITY,

            	    // Touches the point p.
            	    touch: function (p) {
            	        p.yTouched = true;
            	    },

            	    // Tests if a point p is touched.
            	    touched: function (p) {
            	        return p.yTouched;
            	    },

            	    // Untouches the point p.
            	    untouch: function (p) {
            	        p.yTouched = false;
            	    }
            	};

            	Object.freeze(xUnitVector);
            	Object.freeze(yUnitVector);

            	/*
            	* Creates a unit vector that is not x- or y-axis.
            	*/
            	function UnitVector(x, y) {
            	    this.x = x;
            	    this.y = y;
            	    this.axis = undefined;
            	    this.slope = y / x;
            	    this.normalSlope = -x / y;
            	    Object.freeze(this);
            	}

            	/*
            	* Gets the projected distance between two points.
            	* o1/o2 ... if true, respective original position is used.
            	*/
            	UnitVector.prototype.distance = function(p1, p2, o1, o2) {
            	    return (
            	        this.x * xUnitVector.distance(p1, p2, o1, o2) +
            	        this.y * yUnitVector.distance(p1, p2, o1, o2)
            	    );
            	};

            	/*
            	* Moves point p so the moved position has the same relative
            	* position to the moved positions of rp1 and rp2 than the
            	* original positions had.
            	*
            	* See APPENDIX on INTERPOLATE at the bottom of this file.
            	*/
            	UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {
            	    var dm1;
            	    var dm2;
            	    var do1;
            	    var do2;
            	    var doa1;
            	    var doa2;
            	    var dt;

            	    do1 = pv.distance(p, rp1, true, true);
            	    do2 = pv.distance(p, rp2, true, true);
            	    dm1 = pv.distance(rp1, rp1, false, true);
            	    dm2 = pv.distance(rp2, rp2, false, true);
            	    doa1 = Math.abs(do1);
            	    doa2 = Math.abs(do2);
            	    dt = doa1 + doa2;

            	    if (dt === 0) {
            	        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
            	        return;
            	    }

            	    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
            	};

            	/*
            	* Sets the point 'p' relative to point 'rp'
            	* by the distance 'd'
            	*
            	* See APPENDIX on SETRELATIVE at the bottom of this file.
            	*
            	* p   ...  point to set
            	* rp  ... reference point
            	* d   ... distance on projection vector
            	* pv  ... projection vector (undefined = this)
            	* org ... if true, uses the original position of rp as reference.
            	*/
            	UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {
            	    pv = pv || this;

            	    var rpx = org ? rp.xo : rp.x;
            	    var rpy = org ? rp.yo : rp.y;
            	    var rpdx = rpx + d * pv.x;
            	    var rpdy = rpy + d * pv.y;

            	    var pvns = pv.normalSlope;
            	    var fvs = this.slope;

            	    var px = p.x;
            	    var py = p.y;

            	    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);
            	    p.y = fvs * (p.x - px) + py;
            	};

            	/*
            	* Touches the point p.
            	*/
            	UnitVector.prototype.touch = function(p) {
            	    p.xTouched = true;
            	    p.yTouched = true;
            	};

            	/*
            	* Returns a unit vector with x/y coordinates.
            	*/
            	function getUnitVector(x, y) {
            	    var d = Math.sqrt(x * x + y * y);

            	    x /= d;
            	    y /= d;

            	    if (x === 1 && y === 0) { return xUnitVector; }
            	    else if (x === 0 && y === 1) { return yUnitVector; }
            	    else { return new UnitVector(x, y); }
            	}

            	/*
            	* Creates a point in the hinting engine.
            	*/
            	function HPoint(
            	    x,
            	    y,
            	    lastPointOfContour,
            	    onCurve
            	) {
            	    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value
            	    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value

            	    this.lastPointOfContour = lastPointOfContour;
            	    this.onCurve = onCurve;
            	    this.prevPointOnContour = undefined;
            	    this.nextPointOnContour = undefined;
            	    this.xTouched = false;
            	    this.yTouched = false;

            	    Object.preventExtensions(this);
            	}

            	/*
            	* Returns the next touched point on the contour.
            	*
            	* v  ... unit vector to test touch axis.
            	*/
            	HPoint.prototype.nextTouched = function(v) {
            	    var p = this.nextPointOnContour;

            	    while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }

            	    return p;
            	};

            	/*
            	* Returns the previous touched point on the contour
            	*
            	* v  ... unit vector to test touch axis.
            	*/
            	HPoint.prototype.prevTouched = function(v) {
            	    var p = this.prevPointOnContour;

            	    while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }

            	    return p;
            	};

            	/*
            	* The zero point.
            	*/
            	var HPZero = Object.freeze(new HPoint(0, 0));

            	/*
            	* The default state of the interpreter.
            	*
            	* Note: Freezing the defaultState and then deriving from it
            	* makes the V8 Javascript engine going awkward,
            	* so this is avoided, albeit the defaultState shouldn't
            	* ever change.
            	*/
            	var defaultState = {
            	    cvCutIn: 17 / 16,    // control value cut in
            	    deltaBase: 9,
            	    deltaShift: 0.125,
            	    loop: 1,             // loops some instructions
            	    minDis: 1,           // minimum distance
            	    autoFlip: true
            	};

            	/*
            	* The current state of the interpreter.
            	*
            	* env  ... 'fpgm' or 'prep' or 'glyf'
            	* prog ... the program
            	*/
            	function State(env, prog) {
            	    this.env = env;
            	    this.stack = [];
            	    this.prog = prog;

            	    switch (env) {
            	        case 'glyf' :
            	            this.zp0 = this.zp1 = this.zp2 = 1;
            	            this.rp0 = this.rp1 = this.rp2 = 0;
            	            /* fall through */
            	        case 'prep' :
            	            this.fv = this.pv = this.dpv = xUnitVector;
            	            this.round = roundToGrid;
            	    }
            	}

            	/*
            	* Executes a glyph program.
            	*
            	* This does the hinting for each glyph.
            	*
            	* Returns an array of moved points.
            	*
            	* glyph: the glyph to hint
            	* ppem: the size the glyph is rendered for
            	*/
            	Hinting.prototype.exec = function(glyph, ppem) {
            	    if (typeof ppem !== 'number') {
            	        throw new Error('Point size is not a number!');
            	    }

            	    // Received a fatal error, don't do any hinting anymore.
            	    if (this._errorState > 2) { return; }

            	    var font = this.font;
            	    var prepState = this._prepState;

            	    if (!prepState || prepState.ppem !== ppem) {
            	        var fpgmState = this._fpgmState;

            	        if (!fpgmState) {
            	            // Executes the fpgm state.
            	            // This is used by fonts to define functions.
            	            State.prototype = defaultState;

            	            fpgmState =
            	            this._fpgmState =
            	                new State('fpgm', font.tables.fpgm);

            	            fpgmState.funcs = [ ];
            	            fpgmState.font = font;

            	            if (exports.DEBUG) {
            	                console.log('---EXEC FPGM---');
            	                fpgmState.step = -1;
            	            }

            	            try {
            	                exec(fpgmState);
            	            } catch (e) {
            	                console.log('Hinting error in FPGM:' + e);
            	                this._errorState = 3;
            	                return;
            	            }
            	        }

            	        // Executes the prep program for this ppem setting.
            	        // This is used by fonts to set cvt values
            	        // depending on to be rendered font size.

            	        State.prototype = fpgmState;
            	        prepState =
            	        this._prepState =
            	            new State('prep', font.tables.prep);

            	        prepState.ppem = ppem;

            	        // Creates a copy of the cvt table
            	        // and scales it to the current ppem setting.
            	        var oCvt = font.tables.cvt;
            	        if (oCvt) {
            	            var cvt = prepState.cvt = new Array(oCvt.length);
            	            var scale = ppem / font.unitsPerEm;
            	            for (var c = 0; c < oCvt.length; c++) {
            	                cvt[c] = oCvt[c] * scale;
            	            }
            	        } else {
            	            prepState.cvt = [];
            	        }

            	        if (exports.DEBUG) {
            	            console.log('---EXEC PREP---');
            	            prepState.step = -1;
            	        }

            	        try {
            	            exec(prepState);
            	        } catch (e) {
            	            if (this._errorState < 2) {
            	                console.log('Hinting error in PREP:' + e);
            	            }
            	            this._errorState = 2;
            	        }
            	    }

            	    if (this._errorState > 1) { return; }

            	    try {
            	        return execGlyph(glyph, prepState);
            	    } catch (e) {
            	        if (this._errorState < 1) {
            	            console.log('Hinting error:' + e);
            	            console.log('Note: further hinting errors are silenced');
            	        }
            	        this._errorState = 1;
            	        return undefined;
            	    }
            	};

            	/*
            	* Executes the hinting program for a glyph.
            	*/
            	execGlyph = function(glyph, prepState) {
            	    // original point positions
            	    var xScale = prepState.ppem / prepState.font.unitsPerEm;
            	    var yScale = xScale;
            	    var components = glyph.components;
            	    var contours;
            	    var gZone;
            	    var state;

            	    State.prototype = prepState;
            	    if (!components) {
            	        state = new State('glyf', glyph.instructions);
            	        if (exports.DEBUG) {
            	            console.log('---EXEC GLYPH---');
            	            state.step = -1;
            	        }
            	        execComponent(glyph, state, xScale, yScale);
            	        gZone = state.gZone;
            	    } else {
            	        var font = prepState.font;
            	        gZone = [];
            	        contours = [];
            	        for (var i = 0; i < components.length; i++) {
            	            var c = components[i];
            	            var cg = font.glyphs.get(c.glyphIndex);

            	            state = new State('glyf', cg.instructions);

            	            if (exports.DEBUG) {
            	                console.log('---EXEC COMP ' + i + '---');
            	                state.step = -1;
            	            }

            	            execComponent(cg, state, xScale, yScale);
            	            // appends the computed points to the result array
            	            // post processes the component points
            	            var dx = Math.round(c.dx * xScale);
            	            var dy = Math.round(c.dy * yScale);
            	            var gz = state.gZone;
            	            var cc = state.contours;
            	            for (var pi = 0; pi < gz.length; pi++) {
            	                var p = gz[pi];
            	                p.xTouched = p.yTouched = false;
            	                p.xo = p.x = p.x + dx;
            	                p.yo = p.y = p.y + dy;
            	            }

            	            var gLen = gZone.length;
            	            gZone.push.apply(gZone, gz);
            	            for (var j = 0; j < cc.length; j++) {
            	                contours.push(cc[j] + gLen);
            	            }
            	        }

            	        if (glyph.instructions && !state.inhibitGridFit) {
            	            // the composite has instructions on its own
            	            state = new State('glyf', glyph.instructions);

            	            state.gZone = state.z0 = state.z1 = state.z2 = gZone;

            	            state.contours = contours;

            	            // note: HPZero cannot be used here, since
            	            //       the point might be modified
            	            gZone.push(
            	                new HPoint(0, 0),
            	                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
            	            );

            	            if (exports.DEBUG) {
            	                console.log('---EXEC COMPOSITE---');
            	                state.step = -1;
            	            }

            	            exec(state);

            	            gZone.length -= 2;
            	        }
            	    }

            	    return gZone;
            	};

            	/*
            	* Executes the hinting program for a component of a multi-component glyph
            	* or of the glyph itself for a non-component glyph.
            	*/
            	execComponent = function(glyph, state, xScale, yScale)
            	{
            	    var points = glyph.points || [];
            	    var pLen = points.length;
            	    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];
            	    var contours = state.contours = [];

            	    // Scales the original points and
            	    // makes copies for the hinted points.
            	    var cp; // current point
            	    for (var i = 0; i < pLen; i++) {
            	        cp = points[i];

            	        gZone[i] = new HPoint(
            	            cp.x * xScale,
            	            cp.y * yScale,
            	            cp.lastPointOfContour,
            	            cp.onCurve
            	        );
            	    }

            	    // Chain links the contours.
            	    var sp; // start point
            	    var np; // next point

            	    for (var i$1 = 0; i$1 < pLen; i$1++) {
            	        cp = gZone[i$1];

            	        if (!sp) {
            	            sp = cp;
            	            contours.push(i$1);
            	        }

            	        if (cp.lastPointOfContour) {
            	            cp.nextPointOnContour = sp;
            	            sp.prevPointOnContour = cp;
            	            sp = undefined;
            	        } else {
            	            np = gZone[i$1 + 1];
            	            cp.nextPointOnContour = np;
            	            np.prevPointOnContour = cp;
            	        }
            	    }

            	    if (state.inhibitGridFit) { return; }

            	    if (exports.DEBUG) {
            	        console.log('PROCESSING GLYPH', state.stack);
            	        for (var i$2 = 0; i$2 < pLen; i$2++) {
            	            console.log(i$2, gZone[i$2].x, gZone[i$2].y);
            	        }
            	    }

            	    gZone.push(
            	        new HPoint(0, 0),
            	        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
            	    );

            	    exec(state);

            	    // Removes the extra points.
            	    gZone.length -= 2;

            	    if (exports.DEBUG) {
            	        console.log('FINISHED GLYPH', state.stack);
            	        for (var i$3 = 0; i$3 < pLen; i$3++) {
            	            console.log(i$3, gZone[i$3].x, gZone[i$3].y);
            	        }
            	    }
            	};

            	/*
            	* Executes the program loaded in state.
            	*/
            	exec = function(state) {
            	    var prog = state.prog;

            	    if (!prog) { return; }

            	    var pLen = prog.length;
            	    var ins;

            	    for (state.ip = 0; state.ip < pLen; state.ip++) {
            	        if (exports.DEBUG) { state.step++; }
            	        ins = instructionTable[prog[state.ip]];

            	        if (!ins) {
            	            throw new Error(
            	                'unknown instruction: 0x' +
            	                Number(prog[state.ip]).toString(16)
            	            );
            	        }

            	        ins(state);

            	        // very extensive debugging for each step
            	        /*
            	        if (exports.DEBUG) {
            	            var da;
            	            if (state.gZone) {
            	                da = [];
            	                for (let i = 0; i < state.gZone.length; i++)
            	                {
            	                    da.push(i + ' ' +
            	                        state.gZone[i].x * 64 + ' ' +
            	                        state.gZone[i].y * 64 + ' ' +
            	                        (state.gZone[i].xTouched ? 'x' : '') +
            	                        (state.gZone[i].yTouched ? 'y' : '')
            	                    );
            	                }
            	                console.log('GZ', da);
            	            }

            	            if (state.tZone) {
            	                da = [];
            	                for (let i = 0; i < state.tZone.length; i++) {
            	                    da.push(i + ' ' +
            	                        state.tZone[i].x * 64 + ' ' +
            	                        state.tZone[i].y * 64 + ' ' +
            	                        (state.tZone[i].xTouched ? 'x' : '') +
            	                        (state.tZone[i].yTouched ? 'y' : '')
            	                    );
            	                }
            	                console.log('TZ', da);
            	            }

            	            if (state.stack.length > 10) {
            	                console.log(
            	                    state.stack.length,
            	                    '...', state.stack.slice(state.stack.length - 10)
            	                );
            	            } else {
            	                console.log(state.stack.length, state.stack);
            	            }
            	        }
            	        */
            	    }
            	};

            	/*
            	* Initializes the twilight zone.
            	*
            	* This is only done if a SZPx instruction
            	* refers to the twilight zone.
            	*/
            	function initTZone(state)
            	{
            	    var tZone = state.tZone = new Array(state.gZone.length);

            	    // no idea if this is actually correct...
            	    for (var i = 0; i < tZone.length; i++)
            	    {
            	        tZone[i] = new HPoint(0, 0);
            	    }
            	}

            	/*
            	* Skips the instruction pointer ahead over an IF/ELSE block.
            	* handleElse .. if true breaks on matching ELSE
            	*/
            	function skip(state, handleElse)
            	{
            	    var prog = state.prog;
            	    var ip = state.ip;
            	    var nesting = 1;
            	    var ins;

            	    do {
            	        ins = prog[++ip];
            	        if (ins === 0x58) // IF
            	            { nesting++; }
            	        else if (ins === 0x59) // EIF
            	            { nesting--; }
            	        else if (ins === 0x40) // NPUSHB
            	            { ip += prog[ip + 1] + 1; }
            	        else if (ins === 0x41) // NPUSHW
            	            { ip += 2 * prog[ip + 1] + 1; }
            	        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB
            	            { ip += ins - 0xB0 + 1; }
            	        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW
            	            { ip += (ins - 0xB8 + 1) * 2; }
            	        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE
            	            { break; }
            	    } while (nesting > 0);

            	    state.ip = ip;
            	}

            	/*----------------------------------------------------------*
            	*          And then a lot of instructions...                *
            	*----------------------------------------------------------*/

            	// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis
            	// 0x00-0x01
            	function SVTCA(v, state) {
            	    if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }

            	    state.fv = state.pv = state.dpv = v;
            	}

            	// SPVTCA[a] Set Projection Vector to Coordinate Axis
            	// 0x02-0x03
            	function SPVTCA(v, state) {
            	    if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }

            	    state.pv = state.dpv = v;
            	}

            	// SFVTCA[a] Set Freedom Vector to Coordinate Axis
            	// 0x04-0x05
            	function SFVTCA(v, state) {
            	    if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }

            	    state.fv = v;
            	}

            	// SPVTL[a] Set Projection Vector To Line
            	// 0x06-0x07
            	function SPVTL(a, state) {
            	    var stack = state.stack;
            	    var p2i = stack.pop();
            	    var p1i = stack.pop();
            	    var p2 = state.z2[p2i];
            	    var p1 = state.z1[p1i];

            	    if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }

            	    var dx;
            	    var dy;

            	    if (!a) {
            	        dx = p1.x - p2.x;
            	        dy = p1.y - p2.y;
            	    } else {
            	        dx = p2.y - p1.y;
            	        dy = p1.x - p2.x;
            	    }

            	    state.pv = state.dpv = getUnitVector(dx, dy);
            	}

            	// SFVTL[a] Set Freedom Vector To Line
            	// 0x08-0x09
            	function SFVTL(a, state) {
            	    var stack = state.stack;
            	    var p2i = stack.pop();
            	    var p1i = stack.pop();
            	    var p2 = state.z2[p2i];
            	    var p1 = state.z1[p1i];

            	    if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }

            	    var dx;
            	    var dy;

            	    if (!a) {
            	        dx = p1.x - p2.x;
            	        dy = p1.y - p2.y;
            	    } else {
            	        dx = p2.y - p1.y;
            	        dy = p1.x - p2.x;
            	    }

            	    state.fv = getUnitVector(dx, dy);
            	}

            	// SPVFS[] Set Projection Vector From Stack
            	// 0x0A
            	function SPVFS(state) {
            	    var stack = state.stack;
            	    var y = stack.pop();
            	    var x = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }

            	    state.pv = state.dpv = getUnitVector(x, y);
            	}

            	// SFVFS[] Set Freedom Vector From Stack
            	// 0x0B
            	function SFVFS(state) {
            	    var stack = state.stack;
            	    var y = stack.pop();
            	    var x = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }

            	    state.fv = getUnitVector(x, y);
            	}

            	// GPV[] Get Projection Vector
            	// 0x0C
            	function GPV(state) {
            	    var stack = state.stack;
            	    var pv = state.pv;

            	    if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }

            	    stack.push(pv.x * 0x4000);
            	    stack.push(pv.y * 0x4000);
            	}

            	// GFV[] Get Freedom Vector
            	// 0x0C
            	function GFV(state) {
            	    var stack = state.stack;
            	    var fv = state.fv;

            	    if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }

            	    stack.push(fv.x * 0x4000);
            	    stack.push(fv.y * 0x4000);
            	}

            	// SFVTPV[] Set Freedom Vector To Projection Vector
            	// 0x0E
            	function SFVTPV(state) {
            	    state.fv = state.pv;

            	    if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }
            	}

            	// ISECT[] moves point p to the InterSECTion of two lines
            	// 0x0F
            	function ISECT(state)
            	{
            	    var stack = state.stack;
            	    var pa0i = stack.pop();
            	    var pa1i = stack.pop();
            	    var pb0i = stack.pop();
            	    var pb1i = stack.pop();
            	    var pi = stack.pop();
            	    var z0 = state.z0;
            	    var z1 = state.z1;
            	    var pa0 = z0[pa0i];
            	    var pa1 = z0[pa1i];
            	    var pb0 = z1[pb0i];
            	    var pb1 = z1[pb1i];
            	    var p = state.z2[pi];

            	    if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }

            	    // math from
            	    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line

            	    var x1 = pa0.x;
            	    var y1 = pa0.y;
            	    var x2 = pa1.x;
            	    var y2 = pa1.y;
            	    var x3 = pb0.x;
            	    var y3 = pb0.y;
            	    var x4 = pb1.x;
            	    var y4 = pb1.y;

            	    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            	    var f1 = x1 * y2 - y1 * x2;
            	    var f2 = x3 * y4 - y3 * x4;

            	    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;
            	    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;
            	}

            	// SRP0[] Set Reference Point 0
            	// 0x10
            	function SRP0(state) {
            	    state.rp0 = state.stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }
            	}

            	// SRP1[] Set Reference Point 1
            	// 0x11
            	function SRP1(state) {
            	    state.rp1 = state.stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }
            	}

            	// SRP1[] Set Reference Point 2
            	// 0x12
            	function SRP2(state) {
            	    state.rp2 = state.stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }
            	}

            	// SZP0[] Set Zone Pointer 0
            	// 0x13
            	function SZP0(state) {
            	    var n = state.stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }

            	    state.zp0 = n;

            	    switch (n) {
            	        case 0:
            	            if (!state.tZone) { initTZone(state); }
            	            state.z0 = state.tZone;
            	            break;
            	        case 1 :
            	            state.z0 = state.gZone;
            	            break;
            	        default :
            	            throw new Error('Invalid zone pointer');
            	    }
            	}

            	// SZP1[] Set Zone Pointer 1
            	// 0x14
            	function SZP1(state) {
            	    var n = state.stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }

            	    state.zp1 = n;

            	    switch (n) {
            	        case 0:
            	            if (!state.tZone) { initTZone(state); }
            	            state.z1 = state.tZone;
            	            break;
            	        case 1 :
            	            state.z1 = state.gZone;
            	            break;
            	        default :
            	            throw new Error('Invalid zone pointer');
            	    }
            	}

            	// SZP2[] Set Zone Pointer 2
            	// 0x15
            	function SZP2(state) {
            	    var n = state.stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }

            	    state.zp2 = n;

            	    switch (n) {
            	        case 0:
            	            if (!state.tZone) { initTZone(state); }
            	            state.z2 = state.tZone;
            	            break;
            	        case 1 :
            	            state.z2 = state.gZone;
            	            break;
            	        default :
            	            throw new Error('Invalid zone pointer');
            	    }
            	}

            	// SZPS[] Set Zone PointerS
            	// 0x16
            	function SZPS(state) {
            	    var n = state.stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }

            	    state.zp0 = state.zp1 = state.zp2 = n;

            	    switch (n) {
            	        case 0:
            	            if (!state.tZone) { initTZone(state); }
            	            state.z0 = state.z1 = state.z2 = state.tZone;
            	            break;
            	        case 1 :
            	            state.z0 = state.z1 = state.z2 = state.gZone;
            	            break;
            	        default :
            	            throw new Error('Invalid zone pointer');
            	    }
            	}

            	// SLOOP[] Set LOOP variable
            	// 0x17
            	function SLOOP(state) {
            	    state.loop = state.stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }
            	}

            	// RTG[] Round To Grid
            	// 0x18
            	function RTG(state) {
            	    if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }

            	    state.round = roundToGrid;
            	}

            	// RTHG[] Round To Half Grid
            	// 0x19
            	function RTHG(state) {
            	    if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }

            	    state.round = roundToHalfGrid;
            	}

            	// SMD[] Set Minimum Distance
            	// 0x1A
            	function SMD(state) {
            	    var d = state.stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }

            	    state.minDis = d / 0x40;
            	}

            	// ELSE[] ELSE clause
            	// 0x1B
            	function ELSE(state) {
            	    // This instruction has been reached by executing a then branch
            	    // so it just skips ahead until matching EIF.
            	    //
            	    // In case the IF was negative the IF[] instruction already
            	    // skipped forward over the ELSE[]

            	    if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }

            	    skip(state, false);
            	}

            	// JMPR[] JuMP Relative
            	// 0x1C
            	function JMPR(state) {
            	    var o = state.stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }

            	    // A jump by 1 would do nothing.
            	    state.ip += o - 1;
            	}

            	// SCVTCI[] Set Control Value Table Cut-In
            	// 0x1D
            	function SCVTCI(state) {
            	    var n = state.stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }

            	    state.cvCutIn = n / 0x40;
            	}

            	// DUP[] DUPlicate top stack element
            	// 0x20
            	function DUP(state) {
            	    var stack = state.stack;

            	    if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }

            	    stack.push(stack[stack.length - 1]);
            	}

            	// POP[] POP top stack element
            	// 0x21
            	function POP(state) {
            	    if (exports.DEBUG) { console.log(state.step, 'POP[]'); }

            	    state.stack.pop();
            	}

            	// CLEAR[] CLEAR the stack
            	// 0x22
            	function CLEAR(state) {
            	    if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }

            	    state.stack.length = 0;
            	}

            	// SWAP[] SWAP the top two elements on the stack
            	// 0x23
            	function SWAP(state) {
            	    var stack = state.stack;

            	    var a = stack.pop();
            	    var b = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }

            	    stack.push(a);
            	    stack.push(b);
            	}

            	// DEPTH[] DEPTH of the stack
            	// 0x24
            	function DEPTH(state) {
            	    var stack = state.stack;

            	    if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }

            	    stack.push(stack.length);
            	}

            	// LOOPCALL[] LOOPCALL function
            	// 0x2A
            	function LOOPCALL(state) {
            	    var stack = state.stack;
            	    var fn = stack.pop();
            	    var c = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }

            	    // saves callers program
            	    var cip = state.ip;
            	    var cprog = state.prog;

            	    state.prog = state.funcs[fn];

            	    // executes the function
            	    for (var i = 0; i < c; i++) {
            	        exec(state);

            	        if (exports.DEBUG) { console.log(
            	            ++state.step,
            	            i + 1 < c ? 'next loopcall' : 'done loopcall',
            	            i
            	        ); }
            	    }

            	    // restores the callers program
            	    state.ip = cip;
            	    state.prog = cprog;
            	}

            	// CALL[] CALL function
            	// 0x2B
            	function CALL(state) {
            	    var fn = state.stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }

            	    // saves callers program
            	    var cip = state.ip;
            	    var cprog = state.prog;

            	    state.prog = state.funcs[fn];

            	    // executes the function
            	    exec(state);

            	    // restores the callers program
            	    state.ip = cip;
            	    state.prog = cprog;

            	    if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }
            	}

            	// CINDEX[] Copy the INDEXed element to the top of the stack
            	// 0x25
            	function CINDEX(state) {
            	    var stack = state.stack;
            	    var k = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }

            	    // In case of k == 1, it copies the last element after popping
            	    // thus stack.length - k.
            	    stack.push(stack[stack.length - k]);
            	}

            	// MINDEX[] Move the INDEXed element to the top of the stack
            	// 0x26
            	function MINDEX(state) {
            	    var stack = state.stack;
            	    var k = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }

            	    stack.push(stack.splice(stack.length - k, 1)[0]);
            	}

            	// FDEF[] Function DEFinition
            	// 0x2C
            	function FDEF(state) {
            	    if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }
            	    var stack = state.stack;
            	    var prog = state.prog;
            	    var ip = state.ip;

            	    var fn = stack.pop();
            	    var ipBegin = ip;

            	    if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }

            	    while (prog[++ip] !== 0x2D){ }

            	    state.ip = ip;
            	    state.funcs[fn] = prog.slice(ipBegin + 1, ip);
            	}

            	// MDAP[a] Move Direct Absolute Point
            	// 0x2E-0x2F
            	function MDAP(round, state) {
            	    var pi = state.stack.pop();
            	    var p = state.z0[pi];
            	    var fv = state.fv;
            	    var pv = state.pv;

            	    if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }

            	    var d = pv.distance(p, HPZero);

            	    if (round) { d = state.round(d); }

            	    fv.setRelative(p, HPZero, d, pv);
            	    fv.touch(p);

            	    state.rp0 = state.rp1 = pi;
            	}

            	// IUP[a] Interpolate Untouched Points through the outline
            	// 0x30
            	function IUP(v, state) {
            	    var z2 = state.z2;
            	    var pLen = z2.length - 2;
            	    var cp;
            	    var pp;
            	    var np;

            	    if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }

            	    for (var i = 0; i < pLen; i++) {
            	        cp = z2[i]; // current point

            	        // if this point has been touched go on
            	        if (v.touched(cp)) { continue; }

            	        pp = cp.prevTouched(v);

            	        // no point on the contour has been touched?
            	        if (pp === cp) { continue; }

            	        np = cp.nextTouched(v);

            	        if (pp === np) {
            	            // only one point on the contour has been touched
            	            // so simply moves the point like that

            	            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);
            	        }

            	        v.interpolate(cp, pp, np, v);
            	    }
            	}

            	// SHP[] SHift Point using reference point
            	// 0x32-0x33
            	function SHP(a, state) {
            	    var stack = state.stack;
            	    var rpi = a ? state.rp1 : state.rp2;
            	    var rp = (a ? state.z0 : state.z1)[rpi];
            	    var fv = state.fv;
            	    var pv = state.pv;
            	    var loop = state.loop;
            	    var z2 = state.z2;

            	    while (loop--)
            	    {
            	        var pi = stack.pop();
            	        var p = z2[pi];

            	        var d = pv.distance(rp, rp, false, true);
            	        fv.setRelative(p, p, d, pv);
            	        fv.touch(p);

            	        if (exports.DEBUG) {
            	            console.log(
            	                state.step,
            	                (state.loop > 1 ?
            	                   'loop ' + (state.loop - loop) + ': ' :
            	                   ''
            	                ) +
            	                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi
            	            );
            	        }
            	    }

            	    state.loop = 1;
            	}

            	// SHC[] SHift Contour using reference point
            	// 0x36-0x37
            	function SHC(a, state) {
            	    var stack = state.stack;
            	    var rpi = a ? state.rp1 : state.rp2;
            	    var rp = (a ? state.z0 : state.z1)[rpi];
            	    var fv = state.fv;
            	    var pv = state.pv;
            	    var ci = stack.pop();
            	    var sp = state.z2[state.contours[ci]];
            	    var p = sp;

            	    if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }

            	    var d = pv.distance(rp, rp, false, true);

            	    do {
            	        if (p !== rp) { fv.setRelative(p, p, d, pv); }
            	        p = p.nextPointOnContour;
            	    } while (p !== sp);
            	}

            	// SHZ[] SHift Zone using reference point
            	// 0x36-0x37
            	function SHZ(a, state) {
            	    var stack = state.stack;
            	    var rpi = a ? state.rp1 : state.rp2;
            	    var rp = (a ? state.z0 : state.z1)[rpi];
            	    var fv = state.fv;
            	    var pv = state.pv;

            	    var e = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }

            	    var z;
            	    switch (e) {
            	        case 0 : z = state.tZone; break;
            	        case 1 : z = state.gZone; break;
            	        default : throw new Error('Invalid zone');
            	    }

            	    var p;
            	    var d = pv.distance(rp, rp, false, true);
            	    var pLen = z.length - 2;
            	    for (var i = 0; i < pLen; i++)
            	    {
            	        p = z[i];
            	        fv.setRelative(p, p, d, pv);
            	        //if (p !== rp) fv.setRelative(p, p, d, pv);
            	    }
            	}

            	// SHPIX[] SHift point by a PIXel amount
            	// 0x38
            	function SHPIX(state) {
            	    var stack = state.stack;
            	    var loop = state.loop;
            	    var fv = state.fv;
            	    var d = stack.pop() / 0x40;
            	    var z2 = state.z2;

            	    while (loop--) {
            	        var pi = stack.pop();
            	        var p = z2[pi];

            	        if (exports.DEBUG) {
            	            console.log(
            	                state.step,
            	                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
            	                'SHPIX[]', pi, d
            	            );
            	        }

            	        fv.setRelative(p, p, d);
            	        fv.touch(p);
            	    }

            	    state.loop = 1;
            	}

            	// IP[] Interpolate Point
            	// 0x39
            	function IP(state) {
            	    var stack = state.stack;
            	    var rp1i = state.rp1;
            	    var rp2i = state.rp2;
            	    var loop = state.loop;
            	    var rp1 = state.z0[rp1i];
            	    var rp2 = state.z1[rp2i];
            	    var fv = state.fv;
            	    var pv = state.dpv;
            	    var z2 = state.z2;

            	    while (loop--) {
            	        var pi = stack.pop();
            	        var p = z2[pi];

            	        if (exports.DEBUG) {
            	            console.log(
            	                state.step,
            	                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
            	                'IP[]', pi, rp1i, '<->', rp2i
            	            );
            	        }

            	        fv.interpolate(p, rp1, rp2, pv);

            	        fv.touch(p);
            	    }

            	    state.loop = 1;
            	}

            	// MSIRP[a] Move Stack Indirect Relative Point
            	// 0x3A-0x3B
            	function MSIRP(a, state) {
            	    var stack = state.stack;
            	    var d = stack.pop() / 64;
            	    var pi = stack.pop();
            	    var p = state.z1[pi];
            	    var rp0 = state.z0[state.rp0];
            	    var fv = state.fv;
            	    var pv = state.pv;

            	    fv.setRelative(p, rp0, d, pv);
            	    fv.touch(p);

            	    if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }

            	    state.rp1 = state.rp0;
            	    state.rp2 = pi;
            	    if (a) { state.rp0 = pi; }
            	}

            	// ALIGNRP[] Align to reference point.
            	// 0x3C
            	function ALIGNRP(state) {
            	    var stack = state.stack;
            	    var rp0i = state.rp0;
            	    var rp0 = state.z0[rp0i];
            	    var loop = state.loop;
            	    var fv = state.fv;
            	    var pv = state.pv;
            	    var z1 = state.z1;

            	    while (loop--) {
            	        var pi = stack.pop();
            	        var p = z1[pi];

            	        if (exports.DEBUG) {
            	            console.log(
            	                state.step,
            	                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
            	                'ALIGNRP[]', pi
            	            );
            	        }

            	        fv.setRelative(p, rp0, 0, pv);
            	        fv.touch(p);
            	    }

            	    state.loop = 1;
            	}

            	// RTG[] Round To Double Grid
            	// 0x3D
            	function RTDG(state) {
            	    if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }

            	    state.round = roundToDoubleGrid;
            	}

            	// MIAP[a] Move Indirect Absolute Point
            	// 0x3E-0x3F
            	function MIAP(round, state) {
            	    var stack = state.stack;
            	    var n = stack.pop();
            	    var pi = stack.pop();
            	    var p = state.z0[pi];
            	    var fv = state.fv;
            	    var pv = state.pv;
            	    var cv = state.cvt[n];

            	    if (exports.DEBUG) {
            	        console.log(
            	            state.step,
            	            'MIAP[' + round + ']',
            	            n, '(', cv, ')', pi
            	        );
            	    }

            	    var d = pv.distance(p, HPZero);

            	    if (round) {
            	        if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }

            	        d = state.round(d);
            	    }

            	    fv.setRelative(p, HPZero, d, pv);

            	    if (state.zp0 === 0) {
            	        p.xo = p.x;
            	        p.yo = p.y;
            	    }

            	    fv.touch(p);

            	    state.rp0 = state.rp1 = pi;
            	}

            	// NPUSB[] PUSH N Bytes
            	// 0x40
            	function NPUSHB(state) {
            	    var prog = state.prog;
            	    var ip = state.ip;
            	    var stack = state.stack;

            	    var n = prog[++ip];

            	    if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }

            	    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }

            	    state.ip = ip;
            	}

            	// NPUSHW[] PUSH N Words
            	// 0x41
            	function NPUSHW(state) {
            	    var ip = state.ip;
            	    var prog = state.prog;
            	    var stack = state.stack;
            	    var n = prog[++ip];

            	    if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }

            	    for (var i = 0; i < n; i++) {
            	        var w = (prog[++ip] << 8) | prog[++ip];
            	        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
            	        stack.push(w);
            	    }

            	    state.ip = ip;
            	}

            	// WS[] Write Store
            	// 0x42
            	function WS(state) {
            	    var stack = state.stack;
            	    var store = state.store;

            	    if (!store) { store = state.store = []; }

            	    var v = stack.pop();
            	    var l = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }

            	    store[l] = v;
            	}

            	// RS[] Read Store
            	// 0x43
            	function RS(state) {
            	    var stack = state.stack;
            	    var store = state.store;

            	    var l = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'RS', l); }

            	    var v = (store && store[l]) || 0;

            	    stack.push(v);
            	}

            	// WCVTP[] Write Control Value Table in Pixel units
            	// 0x44
            	function WCVTP(state) {
            	    var stack = state.stack;

            	    var v = stack.pop();
            	    var l = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }

            	    state.cvt[l] = v / 0x40;
            	}

            	// RCVT[] Read Control Value Table entry
            	// 0x45
            	function RCVT(state) {
            	    var stack = state.stack;
            	    var cvte = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }

            	    stack.push(state.cvt[cvte] * 0x40);
            	}

            	// GC[] Get Coordinate projected onto the projection vector
            	// 0x46-0x47
            	function GC(a, state) {
            	    var stack = state.stack;
            	    var pi = stack.pop();
            	    var p = state.z2[pi];

            	    if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }

            	    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);
            	}

            	// MD[a] Measure Distance
            	// 0x49-0x4A
            	function MD(a, state) {
            	    var stack = state.stack;
            	    var pi2 = stack.pop();
            	    var pi1 = stack.pop();
            	    var p2 = state.z1[pi2];
            	    var p1 = state.z0[pi1];
            	    var d = state.dpv.distance(p1, p2, a, a);

            	    if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }

            	    state.stack.push(Math.round(d * 64));
            	}

            	// MPPEM[] Measure Pixels Per EM
            	// 0x4B
            	function MPPEM(state) {
            	    if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }
            	    state.stack.push(state.ppem);
            	}

            	// FLIPON[] set the auto FLIP Boolean to ON
            	// 0x4D
            	function FLIPON(state) {
            	    if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }
            	    state.autoFlip = true;
            	}

            	// LT[] Less Than
            	// 0x50
            	function LT(state) {
            	    var stack = state.stack;
            	    var e2 = stack.pop();
            	    var e1 = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }

            	    stack.push(e1 < e2 ? 1 : 0);
            	}

            	// LTEQ[] Less Than or EQual
            	// 0x53
            	function LTEQ(state) {
            	    var stack = state.stack;
            	    var e2 = stack.pop();
            	    var e1 = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }

            	    stack.push(e1 <= e2 ? 1 : 0);
            	}

            	// GTEQ[] Greater Than
            	// 0x52
            	function GT(state) {
            	    var stack = state.stack;
            	    var e2 = stack.pop();
            	    var e1 = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }

            	    stack.push(e1 > e2 ? 1 : 0);
            	}

            	// GTEQ[] Greater Than or EQual
            	// 0x53
            	function GTEQ(state) {
            	    var stack = state.stack;
            	    var e2 = stack.pop();
            	    var e1 = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }

            	    stack.push(e1 >= e2 ? 1 : 0);
            	}

            	// EQ[] EQual
            	// 0x54
            	function EQ(state) {
            	    var stack = state.stack;
            	    var e2 = stack.pop();
            	    var e1 = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }

            	    stack.push(e2 === e1 ? 1 : 0);
            	}

            	// NEQ[] Not EQual
            	// 0x55
            	function NEQ(state) {
            	    var stack = state.stack;
            	    var e2 = stack.pop();
            	    var e1 = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }

            	    stack.push(e2 !== e1 ? 1 : 0);
            	}

            	// ODD[] ODD
            	// 0x56
            	function ODD(state) {
            	    var stack = state.stack;
            	    var n = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }

            	    stack.push(Math.trunc(n) % 2 ? 1 : 0);
            	}

            	// EVEN[] EVEN
            	// 0x57
            	function EVEN(state) {
            	    var stack = state.stack;
            	    var n = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }

            	    stack.push(Math.trunc(n) % 2 ? 0 : 1);
            	}

            	// IF[] IF test
            	// 0x58
            	function IF(state) {
            	    var test = state.stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }

            	    // if test is true it just continues
            	    // if not the ip is skipped until matching ELSE or EIF
            	    if (!test) {
            	        skip(state, true);

            	        if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }
            	    }
            	}

            	// EIF[] End IF
            	// 0x59
            	function EIF(state) {
            	    // this can be reached normally when
            	    // executing an else branch.
            	    // -> just ignore it

            	    if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }
            	}

            	// AND[] logical AND
            	// 0x5A
            	function AND(state) {
            	    var stack = state.stack;
            	    var e2 = stack.pop();
            	    var e1 = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }

            	    stack.push(e2 && e1 ? 1 : 0);
            	}

            	// OR[] logical OR
            	// 0x5B
            	function OR(state) {
            	    var stack = state.stack;
            	    var e2 = stack.pop();
            	    var e1 = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }

            	    stack.push(e2 || e1 ? 1 : 0);
            	}

            	// NOT[] logical NOT
            	// 0x5C
            	function NOT(state) {
            	    var stack = state.stack;
            	    var e = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }

            	    stack.push(e ? 0 : 1);
            	}

            	// DELTAP1[] DELTA exception P1
            	// DELTAP2[] DELTA exception P2
            	// DELTAP3[] DELTA exception P3
            	// 0x5D, 0x71, 0x72
            	function DELTAP123(b, state) {
            	    var stack = state.stack;
            	    var n = stack.pop();
            	    var fv = state.fv;
            	    var pv = state.pv;
            	    var ppem = state.ppem;
            	    var base = state.deltaBase + (b - 1) * 16;
            	    var ds = state.deltaShift;
            	    var z0 = state.z0;

            	    if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }

            	    for (var i = 0; i < n; i++) {
            	        var pi = stack.pop();
            	        var arg = stack.pop();
            	        var appem = base + ((arg & 0xF0) >> 4);
            	        if (appem !== ppem) { continue; }

            	        var mag = (arg & 0x0F) - 8;
            	        if (mag >= 0) { mag++; }
            	        if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }

            	        var p = z0[pi];
            	        fv.setRelative(p, p, mag * ds, pv);
            	    }
            	}

            	// SDB[] Set Delta Base in the graphics state
            	// 0x5E
            	function SDB(state) {
            	    var stack = state.stack;
            	    var n = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }

            	    state.deltaBase = n;
            	}

            	// SDS[] Set Delta Shift in the graphics state
            	// 0x5F
            	function SDS(state) {
            	    var stack = state.stack;
            	    var n = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }

            	    state.deltaShift = Math.pow(0.5, n);
            	}

            	// ADD[] ADD
            	// 0x60
            	function ADD(state) {
            	    var stack = state.stack;
            	    var n2 = stack.pop();
            	    var n1 = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }

            	    stack.push(n1 + n2);
            	}

            	// SUB[] SUB
            	// 0x61
            	function SUB(state) {
            	    var stack = state.stack;
            	    var n2 = stack.pop();
            	    var n1 = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }

            	    stack.push(n1 - n2);
            	}

            	// DIV[] DIV
            	// 0x62
            	function DIV(state) {
            	    var stack = state.stack;
            	    var n2 = stack.pop();
            	    var n1 = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }

            	    stack.push(n1 * 64 / n2);
            	}

            	// MUL[] MUL
            	// 0x63
            	function MUL(state) {
            	    var stack = state.stack;
            	    var n2 = stack.pop();
            	    var n1 = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }

            	    stack.push(n1 * n2 / 64);
            	}

            	// ABS[] ABSolute value
            	// 0x64
            	function ABS(state) {
            	    var stack = state.stack;
            	    var n = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }

            	    stack.push(Math.abs(n));
            	}

            	// NEG[] NEGate
            	// 0x65
            	function NEG(state) {
            	    var stack = state.stack;
            	    var n = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }

            	    stack.push(-n);
            	}

            	// FLOOR[] FLOOR
            	// 0x66
            	function FLOOR(state) {
            	    var stack = state.stack;
            	    var n = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }

            	    stack.push(Math.floor(n / 0x40) * 0x40);
            	}

            	// CEILING[] CEILING
            	// 0x67
            	function CEILING(state) {
            	    var stack = state.stack;
            	    var n = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }

            	    stack.push(Math.ceil(n / 0x40) * 0x40);
            	}

            	// ROUND[ab] ROUND value
            	// 0x68-0x6B
            	function ROUND(dt, state) {
            	    var stack = state.stack;
            	    var n = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }

            	    stack.push(state.round(n / 0x40) * 0x40);
            	}

            	// WCVTF[] Write Control Value Table in Funits
            	// 0x70
            	function WCVTF(state) {
            	    var stack = state.stack;
            	    var v = stack.pop();
            	    var l = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }

            	    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;
            	}

            	// DELTAC1[] DELTA exception C1
            	// DELTAC2[] DELTA exception C2
            	// DELTAC3[] DELTA exception C3
            	// 0x73, 0x74, 0x75
            	function DELTAC123(b, state) {
            	    var stack = state.stack;
            	    var n = stack.pop();
            	    var ppem = state.ppem;
            	    var base = state.deltaBase + (b - 1) * 16;
            	    var ds = state.deltaShift;

            	    if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }

            	    for (var i = 0; i < n; i++) {
            	        var c = stack.pop();
            	        var arg = stack.pop();
            	        var appem = base + ((arg & 0xF0) >> 4);
            	        if (appem !== ppem) { continue; }

            	        var mag = (arg & 0x0F) - 8;
            	        if (mag >= 0) { mag++; }

            	        var delta = mag * ds;

            	        if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }

            	        state.cvt[c] += delta;
            	    }
            	}

            	// SROUND[] Super ROUND
            	// 0x76
            	function SROUND(state) {
            	    var n = state.stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }

            	    state.round = roundSuper;

            	    var period;

            	    switch (n & 0xC0) {
            	        case 0x00:
            	            period = 0.5;
            	            break;
            	        case 0x40:
            	            period = 1;
            	            break;
            	        case 0x80:
            	            period = 2;
            	            break;
            	        default:
            	            throw new Error('invalid SROUND value');
            	    }

            	    state.srPeriod = period;

            	    switch (n & 0x30) {
            	        case 0x00:
            	            state.srPhase = 0;
            	            break;
            	        case 0x10:
            	            state.srPhase = 0.25 * period;
            	            break;
            	        case 0x20:
            	            state.srPhase = 0.5  * period;
            	            break;
            	        case 0x30:
            	            state.srPhase = 0.75 * period;
            	            break;
            	        default: throw new Error('invalid SROUND value');
            	    }

            	    n &= 0x0F;

            	    if (n === 0) { state.srThreshold = 0; }
            	    else { state.srThreshold = (n / 8 - 0.5) * period; }
            	}

            	// S45ROUND[] Super ROUND 45 degrees
            	// 0x77
            	function S45ROUND(state) {
            	    var n = state.stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }

            	    state.round = roundSuper;

            	    var period;

            	    switch (n & 0xC0) {
            	        case 0x00:
            	            period = Math.sqrt(2) / 2;
            	            break;
            	        case 0x40:
            	            period = Math.sqrt(2);
            	            break;
            	        case 0x80:
            	            period = 2 * Math.sqrt(2);
            	            break;
            	        default:
            	            throw new Error('invalid S45ROUND value');
            	    }

            	    state.srPeriod = period;

            	    switch (n & 0x30) {
            	        case 0x00:
            	            state.srPhase = 0;
            	            break;
            	        case 0x10:
            	            state.srPhase = 0.25 * period;
            	            break;
            	        case 0x20:
            	            state.srPhase = 0.5  * period;
            	            break;
            	        case 0x30:
            	            state.srPhase = 0.75 * period;
            	            break;
            	        default:
            	            throw new Error('invalid S45ROUND value');
            	    }

            	    n &= 0x0F;

            	    if (n === 0) { state.srThreshold = 0; }
            	    else { state.srThreshold = (n / 8 - 0.5) * period; }
            	}

            	// ROFF[] Round Off
            	// 0x7A
            	function ROFF(state) {
            	    if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }

            	    state.round = roundOff;
            	}

            	// RUTG[] Round Up To Grid
            	// 0x7C
            	function RUTG(state) {
            	    if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }

            	    state.round = roundUpToGrid;
            	}

            	// RDTG[] Round Down To Grid
            	// 0x7D
            	function RDTG(state) {
            	    if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }

            	    state.round = roundDownToGrid;
            	}

            	// SCANCTRL[] SCAN conversion ConTRoL
            	// 0x85
            	function SCANCTRL(state) {
            	    var n = state.stack.pop();

            	    // ignored by opentype.js

            	    if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }
            	}

            	// SDPVTL[a] Set Dual Projection Vector To Line
            	// 0x86-0x87
            	function SDPVTL(a, state) {
            	    var stack = state.stack;
            	    var p2i = stack.pop();
            	    var p1i = stack.pop();
            	    var p2 = state.z2[p2i];
            	    var p1 = state.z1[p1i];

            	    if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }

            	    var dx;
            	    var dy;

            	    if (!a) {
            	        dx = p1.x - p2.x;
            	        dy = p1.y - p2.y;
            	    } else {
            	        dx = p2.y - p1.y;
            	        dy = p1.x - p2.x;
            	    }

            	    state.dpv = getUnitVector(dx, dy);
            	}

            	// GETINFO[] GET INFOrmation
            	// 0x88
            	function GETINFO(state) {
            	    var stack = state.stack;
            	    var sel = stack.pop();
            	    var r = 0;

            	    if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }

            	    // v35 as in no subpixel hinting
            	    if (sel & 0x01) { r = 35; }

            	    // TODO rotation and stretch currently not supported
            	    // and thus those GETINFO are always 0.

            	    // opentype.js is always gray scaling
            	    if (sel & 0x20) { r |= 0x1000; }

            	    stack.push(r);
            	}

            	// ROLL[] ROLL the top three stack elements
            	// 0x8A
            	function ROLL(state) {
            	    var stack = state.stack;
            	    var a = stack.pop();
            	    var b = stack.pop();
            	    var c = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }

            	    stack.push(b);
            	    stack.push(a);
            	    stack.push(c);
            	}

            	// MAX[] MAXimum of top two stack elements
            	// 0x8B
            	function MAX(state) {
            	    var stack = state.stack;
            	    var e2 = stack.pop();
            	    var e1 = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }

            	    stack.push(Math.max(e1, e2));
            	}

            	// MIN[] MINimum of top two stack elements
            	// 0x8C
            	function MIN(state) {
            	    var stack = state.stack;
            	    var e2 = stack.pop();
            	    var e1 = stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }

            	    stack.push(Math.min(e1, e2));
            	}

            	// SCANTYPE[] SCANTYPE
            	// 0x8D
            	function SCANTYPE(state) {
            	    var n = state.stack.pop();
            	    // ignored by opentype.js
            	    if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }
            	}

            	// INSTCTRL[] INSTCTRL
            	// 0x8D
            	function INSTCTRL(state) {
            	    var s = state.stack.pop();
            	    var v = state.stack.pop();

            	    if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }

            	    switch (s) {
            	        case 1 : state.inhibitGridFit = !!v; return;
            	        case 2 : state.ignoreCvt = !!v; return;
            	        default: throw new Error('invalid INSTCTRL[] selector');
            	    }
            	}

            	// PUSHB[abc] PUSH Bytes
            	// 0xB0-0xB7
            	function PUSHB(n, state) {
            	    var stack = state.stack;
            	    var prog = state.prog;
            	    var ip = state.ip;

            	    if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }

            	    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }

            	    state.ip = ip;
            	}

            	// PUSHW[abc] PUSH Words
            	// 0xB8-0xBF
            	function PUSHW(n, state) {
            	    var ip = state.ip;
            	    var prog = state.prog;
            	    var stack = state.stack;

            	    if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }

            	    for (var i = 0; i < n; i++) {
            	        var w = (prog[++ip] << 8) | prog[++ip];
            	        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
            	        stack.push(w);
            	    }

            	    state.ip = ip;
            	}

            	// MDRP[abcde] Move Direct Relative Point
            	// 0xD0-0xEF
            	// (if indirect is 0)
            	//
            	// and
            	//
            	// MIRP[abcde] Move Indirect Relative Point
            	// 0xE0-0xFF
            	// (if indirect is 1)

            	function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {
            	    var stack = state.stack;
            	    var cvte = indirect && stack.pop();
            	    var pi = stack.pop();
            	    var rp0i = state.rp0;
            	    var rp = state.z0[rp0i];
            	    var p = state.z1[pi];

            	    var md = state.minDis;
            	    var fv = state.fv;
            	    var pv = state.dpv;
            	    var od; // original distance
            	    var d; // moving distance
            	    var sign; // sign of distance
            	    var cv;

            	    d = od = pv.distance(p, rp, true, true);
            	    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0

            	    // TODO consider autoFlip
            	    d = Math.abs(d);

            	    if (indirect) {
            	        cv = state.cvt[cvte];

            	        if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }
            	    }

            	    if (keepD && d < md) { d = md; }

            	    if (ro) { d = state.round(d); }

            	    fv.setRelative(p, rp, sign * d, pv);
            	    fv.touch(p);

            	    if (exports.DEBUG) {
            	        console.log(
            	            state.step,
            	            (indirect ? 'MIRP[' : 'MDRP[') +
            	            (setRp0 ? 'M' : 'm') +
            	            (keepD ? '>' : '_') +
            	            (ro ? 'R' : '_') +
            	            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +
            	            ']',
            	            indirect ?
            	                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :
            	                '',
            	            pi,
            	            '(d =', od, '->', sign * d, ')'
            	        );
            	    }

            	    state.rp1 = state.rp0;
            	    state.rp2 = pi;
            	    if (setRp0) { state.rp0 = pi; }
            	}

            	/*
            	* The instruction table.
            	*/
            	instructionTable = [
            	    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),
            	    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),
            	    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),
            	    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),
            	    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),
            	    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),
            	    /* 0x06 */ SPVTL.bind(undefined, 0),
            	    /* 0x07 */ SPVTL.bind(undefined, 1),
            	    /* 0x08 */ SFVTL.bind(undefined, 0),
            	    /* 0x09 */ SFVTL.bind(undefined, 1),
            	    /* 0x0A */ SPVFS,
            	    /* 0x0B */ SFVFS,
            	    /* 0x0C */ GPV,
            	    /* 0x0D */ GFV,
            	    /* 0x0E */ SFVTPV,
            	    /* 0x0F */ ISECT,
            	    /* 0x10 */ SRP0,
            	    /* 0x11 */ SRP1,
            	    /* 0x12 */ SRP2,
            	    /* 0x13 */ SZP0,
            	    /* 0x14 */ SZP1,
            	    /* 0x15 */ SZP2,
            	    /* 0x16 */ SZPS,
            	    /* 0x17 */ SLOOP,
            	    /* 0x18 */ RTG,
            	    /* 0x19 */ RTHG,
            	    /* 0x1A */ SMD,
            	    /* 0x1B */ ELSE,
            	    /* 0x1C */ JMPR,
            	    /* 0x1D */ SCVTCI,
            	    /* 0x1E */ undefined,   // TODO SSWCI
            	    /* 0x1F */ undefined,   // TODO SSW
            	    /* 0x20 */ DUP,
            	    /* 0x21 */ POP,
            	    /* 0x22 */ CLEAR,
            	    /* 0x23 */ SWAP,
            	    /* 0x24 */ DEPTH,
            	    /* 0x25 */ CINDEX,
            	    /* 0x26 */ MINDEX,
            	    /* 0x27 */ undefined,   // TODO ALIGNPTS
            	    /* 0x28 */ undefined,
            	    /* 0x29 */ undefined,   // TODO UTP
            	    /* 0x2A */ LOOPCALL,
            	    /* 0x2B */ CALL,
            	    /* 0x2C */ FDEF,
            	    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)
            	    /* 0x2E */ MDAP.bind(undefined, 0),
            	    /* 0x2F */ MDAP.bind(undefined, 1),
            	    /* 0x30 */ IUP.bind(undefined, yUnitVector),
            	    /* 0x31 */ IUP.bind(undefined, xUnitVector),
            	    /* 0x32 */ SHP.bind(undefined, 0),
            	    /* 0x33 */ SHP.bind(undefined, 1),
            	    /* 0x34 */ SHC.bind(undefined, 0),
            	    /* 0x35 */ SHC.bind(undefined, 1),
            	    /* 0x36 */ SHZ.bind(undefined, 0),
            	    /* 0x37 */ SHZ.bind(undefined, 1),
            	    /* 0x38 */ SHPIX,
            	    /* 0x39 */ IP,
            	    /* 0x3A */ MSIRP.bind(undefined, 0),
            	    /* 0x3B */ MSIRP.bind(undefined, 1),
            	    /* 0x3C */ ALIGNRP,
            	    /* 0x3D */ RTDG,
            	    /* 0x3E */ MIAP.bind(undefined, 0),
            	    /* 0x3F */ MIAP.bind(undefined, 1),
            	    /* 0x40 */ NPUSHB,
            	    /* 0x41 */ NPUSHW,
            	    /* 0x42 */ WS,
            	    /* 0x43 */ RS,
            	    /* 0x44 */ WCVTP,
            	    /* 0x45 */ RCVT,
            	    /* 0x46 */ GC.bind(undefined, 0),
            	    /* 0x47 */ GC.bind(undefined, 1),
            	    /* 0x48 */ undefined,   // TODO SCFS
            	    /* 0x49 */ MD.bind(undefined, 0),
            	    /* 0x4A */ MD.bind(undefined, 1),
            	    /* 0x4B */ MPPEM,
            	    /* 0x4C */ undefined,   // TODO MPS
            	    /* 0x4D */ FLIPON,
            	    /* 0x4E */ undefined,   // TODO FLIPOFF
            	    /* 0x4F */ undefined,   // TODO DEBUG
            	    /* 0x50 */ LT,
            	    /* 0x51 */ LTEQ,
            	    /* 0x52 */ GT,
            	    /* 0x53 */ GTEQ,
            	    /* 0x54 */ EQ,
            	    /* 0x55 */ NEQ,
            	    /* 0x56 */ ODD,
            	    /* 0x57 */ EVEN,
            	    /* 0x58 */ IF,
            	    /* 0x59 */ EIF,
            	    /* 0x5A */ AND,
            	    /* 0x5B */ OR,
            	    /* 0x5C */ NOT,
            	    /* 0x5D */ DELTAP123.bind(undefined, 1),
            	    /* 0x5E */ SDB,
            	    /* 0x5F */ SDS,
            	    /* 0x60 */ ADD,
            	    /* 0x61 */ SUB,
            	    /* 0x62 */ DIV,
            	    /* 0x63 */ MUL,
            	    /* 0x64 */ ABS,
            	    /* 0x65 */ NEG,
            	    /* 0x66 */ FLOOR,
            	    /* 0x67 */ CEILING,
            	    /* 0x68 */ ROUND.bind(undefined, 0),
            	    /* 0x69 */ ROUND.bind(undefined, 1),
            	    /* 0x6A */ ROUND.bind(undefined, 2),
            	    /* 0x6B */ ROUND.bind(undefined, 3),
            	    /* 0x6C */ undefined,   // TODO NROUND[ab]
            	    /* 0x6D */ undefined,   // TODO NROUND[ab]
            	    /* 0x6E */ undefined,   // TODO NROUND[ab]
            	    /* 0x6F */ undefined,   // TODO NROUND[ab]
            	    /* 0x70 */ WCVTF,
            	    /* 0x71 */ DELTAP123.bind(undefined, 2),
            	    /* 0x72 */ DELTAP123.bind(undefined, 3),
            	    /* 0x73 */ DELTAC123.bind(undefined, 1),
            	    /* 0x74 */ DELTAC123.bind(undefined, 2),
            	    /* 0x75 */ DELTAC123.bind(undefined, 3),
            	    /* 0x76 */ SROUND,
            	    /* 0x77 */ S45ROUND,
            	    /* 0x78 */ undefined,   // TODO JROT[]
            	    /* 0x79 */ undefined,   // TODO JROF[]
            	    /* 0x7A */ ROFF,
            	    /* 0x7B */ undefined,
            	    /* 0x7C */ RUTG,
            	    /* 0x7D */ RDTG,
            	    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though
            	    /* 0x7F */ POP, // actually AA, supposed to do only a pop though
            	    /* 0x80 */ undefined,   // TODO FLIPPT
            	    /* 0x81 */ undefined,   // TODO FLIPRGON
            	    /* 0x82 */ undefined,   // TODO FLIPRGOFF
            	    /* 0x83 */ undefined,
            	    /* 0x84 */ undefined,
            	    /* 0x85 */ SCANCTRL,
            	    /* 0x86 */ SDPVTL.bind(undefined, 0),
            	    /* 0x87 */ SDPVTL.bind(undefined, 1),
            	    /* 0x88 */ GETINFO,
            	    /* 0x89 */ undefined,   // TODO IDEF
            	    /* 0x8A */ ROLL,
            	    /* 0x8B */ MAX,
            	    /* 0x8C */ MIN,
            	    /* 0x8D */ SCANTYPE,
            	    /* 0x8E */ INSTCTRL,
            	    /* 0x8F */ undefined,
            	    /* 0x90 */ undefined,
            	    /* 0x91 */ undefined,
            	    /* 0x92 */ undefined,
            	    /* 0x93 */ undefined,
            	    /* 0x94 */ undefined,
            	    /* 0x95 */ undefined,
            	    /* 0x96 */ undefined,
            	    /* 0x97 */ undefined,
            	    /* 0x98 */ undefined,
            	    /* 0x99 */ undefined,
            	    /* 0x9A */ undefined,
            	    /* 0x9B */ undefined,
            	    /* 0x9C */ undefined,
            	    /* 0x9D */ undefined,
            	    /* 0x9E */ undefined,
            	    /* 0x9F */ undefined,
            	    /* 0xA0 */ undefined,
            	    /* 0xA1 */ undefined,
            	    /* 0xA2 */ undefined,
            	    /* 0xA3 */ undefined,
            	    /* 0xA4 */ undefined,
            	    /* 0xA5 */ undefined,
            	    /* 0xA6 */ undefined,
            	    /* 0xA7 */ undefined,
            	    /* 0xA8 */ undefined,
            	    /* 0xA9 */ undefined,
            	    /* 0xAA */ undefined,
            	    /* 0xAB */ undefined,
            	    /* 0xAC */ undefined,
            	    /* 0xAD */ undefined,
            	    /* 0xAE */ undefined,
            	    /* 0xAF */ undefined,
            	    /* 0xB0 */ PUSHB.bind(undefined, 1),
            	    /* 0xB1 */ PUSHB.bind(undefined, 2),
            	    /* 0xB2 */ PUSHB.bind(undefined, 3),
            	    /* 0xB3 */ PUSHB.bind(undefined, 4),
            	    /* 0xB4 */ PUSHB.bind(undefined, 5),
            	    /* 0xB5 */ PUSHB.bind(undefined, 6),
            	    /* 0xB6 */ PUSHB.bind(undefined, 7),
            	    /* 0xB7 */ PUSHB.bind(undefined, 8),
            	    /* 0xB8 */ PUSHW.bind(undefined, 1),
            	    /* 0xB9 */ PUSHW.bind(undefined, 2),
            	    /* 0xBA */ PUSHW.bind(undefined, 3),
            	    /* 0xBB */ PUSHW.bind(undefined, 4),
            	    /* 0xBC */ PUSHW.bind(undefined, 5),
            	    /* 0xBD */ PUSHW.bind(undefined, 6),
            	    /* 0xBE */ PUSHW.bind(undefined, 7),
            	    /* 0xBF */ PUSHW.bind(undefined, 8),
            	    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),
            	    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),
            	    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),
            	    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),
            	    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),
            	    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),
            	    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),
            	    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),
            	    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),
            	    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),
            	    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),
            	    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),
            	    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),
            	    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),
            	    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),
            	    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),
            	    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),
            	    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),
            	    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),
            	    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),
            	    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),
            	    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),
            	    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),
            	    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),
            	    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),
            	    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),
            	    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),
            	    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),
            	    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),
            	    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),
            	    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),
            	    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),
            	    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),
            	    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),
            	    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),
            	    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),
            	    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),
            	    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),
            	    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),
            	    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),
            	    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),
            	    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),
            	    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),
            	    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),
            	    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),
            	    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),
            	    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),
            	    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),
            	    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),
            	    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),
            	    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),
            	    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),
            	    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),
            	    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),
            	    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),
            	    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),
            	    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),
            	    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),
            	    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),
            	    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),
            	    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),
            	    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),
            	    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),
            	    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)
            	];

            	/*****************************
            	  Mathematical Considerations
            	******************************

            	fv ... refers to freedom vector
            	pv ... refers to projection vector
            	rp ... refers to reference point
            	p  ... refers to to point being operated on
            	d  ... refers to distance

            	SETRELATIVE:
            	============

            	case freedom vector == x-axis:
            	------------------------------

            	                        (pv)
            	                     .-'
            	              rpd .-'
            	               .-*
            	          d .-'90°'
            	         .-'       '
            	      .-'           '
            	   *-'               ' b
            	  rp                  '
            	                       '
            	                        '
            	            p *----------*-------------- (fv)
            	                          pm

            	  rpdx = rpx + d * pv.x
            	  rpdy = rpy + d * pv.y

            	  equation of line b

            	   y - rpdy = pvns * (x- rpdx)

            	   y = p.y

            	   x = rpdx + ( p.y - rpdy ) / pvns


            	case freedom vector == y-axis:
            	------------------------------

            	    * pm
            	    |\
            	    | \
            	    |  \
            	    |   \
            	    |    \
            	    |     \
            	    |      \
            	    |       \
            	    |        \
            	    |         \ b
            	    |          \
            	    |           \
            	    |            \    .-' (pv)
            	    |         90° \.-'
            	    |           .-'* rpd
            	    |        .-'
            	    *     *-'  d
            	    p     rp

            	  rpdx = rpx + d * pv.x
            	  rpdy = rpy + d * pv.y

            	  equation of line b:
            	           pvns ... normal slope to pv

            	   y - rpdy = pvns * (x - rpdx)

            	   x = p.x

            	   y = rpdy +  pvns * (p.x - rpdx)



            	generic case:
            	-------------


            	                              .'(fv)
            	                            .'
            	                          .* pm
            	                        .' !
            	                      .'    .
            	                    .'      !
            	                  .'         . b
            	                .'           !
            	               *              .
            	              p               !
            	                         90°   .    ... (pv)
            	                           ...-*-'''
            	                  ...---'''    rpd
            	         ...---'''   d
            	   *--'''
            	  rp

            	    rpdx = rpx + d * pv.x
            	    rpdy = rpy + d * pv.y

            	 equation of line b:
            	    pvns... normal slope to pv

            	    y - rpdy = pvns * (x - rpdx)

            	 equation of freedom vector line:
            	    fvs ... slope of freedom vector (=fy/fx)

            	    y - py = fvs * (x - px)


            	  on pm both equations are true for same x/y

            	    y - rpdy = pvns * (x - rpdx)

            	    y - py = fvs * (x - px)

            	  form to y and set equal:

            	    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py

            	  expand:

            	    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py

            	  switch:

            	    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy

            	  solve for x:

            	    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy



            	          fvs * px - pvns * rpdx + rpdy - py
            	    x =  -----------------------------------
            	                 fvs - pvns

            	  and:

            	    y = fvs * (x - px) + py



            	INTERPOLATE:
            	============

            	Examples of point interpolation.

            	The weight of the movement of the reference point gets bigger
            	the further the other reference point is away, thus the safest
            	option (that is avoiding 0/0 divisions) is to weight the
            	original distance of the other point by the sum of both distances.

            	If the sum of both distances is 0, then move the point by the
            	arithmetic average of the movement of both reference points.




            	           (+6)
            	    rp1o *---->*rp1
            	         .     .                          (+12)
            	         .     .                  rp2o *---------->* rp2
            	         .     .                       .           .
            	         .     .                       .           .
            	         .    10          20           .           .
            	         |.........|...................|           .
            	               .   .                               .
            	               .   . (+8)                          .
            	                po *------>*p                      .
            	               .           .                       .
            	               .    12     .          24           .
            	               |...........|.......................|
            	                                  36


            	-------



            	           (+10)
            	    rp1o *-------->*rp1
            	         .         .                      (-10)
            	         .         .              rp2 *<---------* rpo2
            	         .         .                   .         .
            	         .         .                   .         .
            	         .    10   .          30       .         .
            	         |.........|.............................|
            	                   .                   .
            	                   . (+5)              .
            	                po *--->* p            .
            	                   .    .              .
            	                   .    .   20         .
            	                   |....|..............|
            	                     5        15


            	-------


            	           (+10)
            	    rp1o *-------->*rp1
            	         .         .
            	         .         .
            	    rp2o *-------->*rp2


            	                               (+10)
            	                          po *-------->* p

            	-------


            	           (+10)
            	    rp1o *-------->*rp1
            	         .         .
            	         .         .(+30)
            	    rp2o *---------------------------->*rp2


            	                                        (+25)
            	                          po *----------------------->* p



            	vim: set ts=4 sw=4 expandtab:
            	*****/

            	/**
            	 * Converts a string into a list of tokens.
            	 */

            	/**
            	 * Create a new token
            	 * @param {string} char a single char
            	 */
            	function Token(char) {
            	    this.char = char;
            	    this.state = {};
            	    this.activeState = null;
            	}

            	/**
            	 * Create a new context range
            	 * @param {number} startIndex range start index
            	 * @param {number} endOffset range end index offset
            	 * @param {string} contextName owner context name
            	 */
            	function ContextRange(startIndex, endOffset, contextName) {
            	    this.contextName = contextName;
            	    this.startIndex = startIndex;
            	    this.endOffset = endOffset;
            	}

            	/**
            	 * Check context start and end
            	 * @param {string} contextName a unique context name
            	 * @param {function} checkStart a predicate function the indicates a context's start
            	 * @param {function} checkEnd a predicate function the indicates a context's end
            	 */
            	function ContextChecker(contextName, checkStart, checkEnd) {
            	    this.contextName = contextName;
            	    this.openRange = null;
            	    this.ranges = [];
            	    this.checkStart = checkStart;
            	    this.checkEnd = checkEnd;
            	}

            	/**
            	 * Create a context params
            	 * @param {array} context a list of items
            	 * @param {number} currentIndex current item index
            	 */
            	function ContextParams(context, currentIndex) {
            	    this.context = context;
            	    this.index = currentIndex;
            	    this.length = context.length;
            	    this.current = context[currentIndex];
            	    this.backtrack = context.slice(0, currentIndex);
            	    this.lookahead = context.slice(currentIndex + 1);
            	}

            	/**
            	 * Create an event instance
            	 * @param {string} eventId event unique id
            	 */
            	function Event(eventId) {
            	    this.eventId = eventId;
            	    this.subscribers = [];
            	}

            	/**
            	 * Initialize a core events and auto subscribe required event handlers
            	 * @param {any} events an object that enlists core events handlers
            	 */
            	function initializeCoreEvents(events) {
            	    var this$1 = this;

            	    var coreEvents = [
            	        'start', 'end', 'next', 'newToken', 'contextStart',
            	        'contextEnd', 'insertToken', 'removeToken', 'removeRange',
            	        'replaceToken', 'replaceRange', 'composeRUD', 'updateContextsRanges'
            	    ];

            	    coreEvents.forEach(function (eventId) {
            	        Object.defineProperty(this$1.events, eventId, {
            	            value: new Event(eventId)
            	        });
            	    });

            	    if (!!events) {
            	        coreEvents.forEach(function (eventId) {
            	            var event = events[eventId];
            	            if (typeof event === 'function') {
            	                this$1.events[eventId].subscribe(event);
            	            }
            	        });
            	    }
            	    var requiresContextUpdate = [
            	        'insertToken', 'removeToken', 'removeRange',
            	        'replaceToken', 'replaceRange', 'composeRUD'
            	    ];
            	    requiresContextUpdate.forEach(function (eventId) {
            	        this$1.events[eventId].subscribe(
            	            this$1.updateContextsRanges
            	        );
            	    });
            	}

            	/**
            	 * Converts a string into a list of tokens
            	 * @param {any} events tokenizer core events
            	 */
            	function Tokenizer(events) {
            	    this.tokens = [];
            	    this.registeredContexts = {};
            	    this.contextCheckers = [];
            	    this.events = {};
            	    this.registeredModifiers = [];

            	    initializeCoreEvents.call(this, events);
            	}

            	/**
            	 * Sets the state of a token, usually called by a state modifier.
            	 * @param {string} key state item key
            	 * @param {any} value state item value
            	 */
            	Token.prototype.setState = function(key, value) {
            	    this.state[key] = value;
            	    this.activeState = { key: key, value: this.state[key] };
            	    return this.activeState;
            	};

            	Token.prototype.getState = function (stateId) {
            	    return this.state[stateId] || null;
            	};

            	/**
            	 * Checks if an index exists in the tokens list.
            	 * @param {number} index token index
            	 */
            	Tokenizer.prototype.inboundIndex = function(index) {
            	    return index >= 0 && index < this.tokens.length;
            	};

            	/**
            	 * Compose and apply a list of operations (replace, update, delete)
            	 * @param {array} RUDs replace, update and delete operations
            	 * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)
            	 */
            	Tokenizer.prototype.composeRUD = function (RUDs) {
            	    var this$1 = this;

            	    var silent = true;
            	    var state = RUDs.map(function (RUD) { return (
            	        this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent))
            	    ); });
            	    var hasFAILObject = function (obj) { return (
            	        typeof obj === 'object' &&
            	        obj.hasOwnProperty('FAIL')
            	    ); };
            	    if (state.every(hasFAILObject)) {
            	        return {
            	            FAIL: "composeRUD: one or more operations hasn't completed successfully",
            	            report: state.filter(hasFAILObject)
            	        };
            	    }
            	    this.dispatch('composeRUD', [state.filter(function (op) { return !hasFAILObject(op); })]);
            	};

            	/**
            	 * Replace a range of tokens with a list of tokens
            	 * @param {number} startIndex range start index
            	 * @param {number} offset range offset
            	 * @param {token} tokens a list of tokens to replace
            	 * @param {boolean} silent dispatch events and update context ranges
            	 */
            	Tokenizer.prototype.replaceRange = function (startIndex, offset, tokens, silent) {
            	    offset = offset !== null ? offset : this.tokens.length;
            	    var isTokenType = tokens.every(function (token) { return token instanceof Token; });
            	    if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {
            	        var replaced = this.tokens.splice.apply(
            	            this.tokens, [startIndex, offset].concat(tokens)
            	        );
            	        if (!silent) { this.dispatch('replaceToken', [startIndex, offset, tokens]); }
            	        return [replaced, tokens];
            	    } else {
            	        return { FAIL: 'replaceRange: invalid tokens or startIndex.' };
            	    }
            	};

            	/**
            	 * Replace a token with another token
            	 * @param {number} index token index
            	 * @param {token} token a token to replace
            	 * @param {boolean} silent dispatch events and update context ranges
            	 */
            	Tokenizer.prototype.replaceToken = function (index, token, silent) {
            	    if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {
            	        var replaced = this.tokens.splice(index, 1, token);
            	        if (!silent) { this.dispatch('replaceToken', [index, token]); }
            	        return [replaced[0], token];
            	    } else {
            	        return { FAIL: 'replaceToken: invalid token or index.' };
            	    }
            	};

            	/**
            	 * Removes a range of tokens
            	 * @param {number} startIndex range start index
            	 * @param {number} offset range offset
            	 * @param {boolean} silent dispatch events and update context ranges
            	 */
            	Tokenizer.prototype.removeRange = function(startIndex, offset, silent) {
            	    offset = !isNaN(offset) ? offset : this.tokens.length;
            	    var tokens = this.tokens.splice(startIndex, offset);
            	    if (!silent) { this.dispatch('removeRange', [tokens, startIndex, offset]); }
            	    return tokens;
            	};

            	/**
            	 * Remove a token at a certain index
            	 * @param {number} index token index
            	 * @param {boolean} silent dispatch events and update context ranges
            	 */
            	Tokenizer.prototype.removeToken = function(index, silent) {
            	    if (!isNaN(index) && this.inboundIndex(index)) {
            	        var token = this.tokens.splice(index, 1);
            	        if (!silent) { this.dispatch('removeToken', [token, index]); }
            	        return token;
            	    } else {
            	        return { FAIL: 'removeToken: invalid token index.' };
            	    }
            	};

            	/**
            	 * Insert a list of tokens at a certain index
            	 * @param {array} tokens a list of tokens to insert
            	 * @param {number} index insert the list of tokens at index
            	 * @param {boolean} silent dispatch events and update context ranges
            	 */
            	Tokenizer.prototype.insertToken = function (tokens, index, silent) {
            	    var tokenType = tokens.every(
            	        function (token) { return token instanceof Token; }
            	    );
            	    if (tokenType) {
            	        this.tokens.splice.apply(
            	            this.tokens, [index, 0].concat(tokens)
            	        );
            	        if (!silent) { this.dispatch('insertToken', [tokens, index]); }
            	        return tokens;
            	    } else {
            	        return { FAIL: 'insertToken: invalid token(s).' };
            	    }
            	};

            	/**
            	 * A state modifier that is called on 'newToken' event
            	 * @param {string} modifierId state modifier id
            	 * @param {function} condition a predicate function that returns true or false
            	 * @param {function} modifier a function to update token state
            	 */
            	Tokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {
            	    this.events.newToken.subscribe(function(token, contextParams) {
            	        var conditionParams = [token, contextParams];
            	        var canApplyModifier = (
            	            condition === null ||
            	            condition.apply(this, conditionParams) === true
            	        );
            	        var modifierParams = [token, contextParams];
            	        if (canApplyModifier) {
            	            var newStateValue = modifier.apply(this, modifierParams);
            	            token.setState(modifierId, newStateValue);
            	        }
            	    });
            	    this.registeredModifiers.push(modifierId);
            	};

            	/**
            	 * Subscribe a handler to an event
            	 * @param {function} eventHandler an event handler function
            	 */
            	Event.prototype.subscribe = function (eventHandler) {
            	    if (typeof eventHandler === 'function') {
            	        return ((this.subscribers.push(eventHandler)) - 1);
            	    } else {
            	        return { FAIL: ("invalid '" + (this.eventId) + "' event handler")};
            	    }
            	};

            	/**
            	 * Unsubscribe an event handler
            	 * @param {string} subsId subscription id
            	 */
            	Event.prototype.unsubscribe = function (subsId) {
            	    this.subscribers.splice(subsId, 1);
            	};

            	/**
            	 * Sets context params current value index
            	 * @param {number} index context params current value index
            	 */
            	ContextParams.prototype.setCurrentIndex = function(index) {
            	    this.index = index;
            	    this.current = this.context[index];
            	    this.backtrack = this.context.slice(0, index);
            	    this.lookahead = this.context.slice(index + 1);
            	};

            	/**
            	 * Get an item at an offset from the current value
            	 * example (current value is 3):
            	 *  1    2   [3]   4    5   |   items values
            	 * -2   -1    0    1    2   |   offset values
            	 * @param {number} offset an offset from current value index
            	 */
            	ContextParams.prototype.get = function (offset) {
            	    switch (true) {
            	        case (offset === 0):
            	            return this.current;
            	        case (offset < 0 && Math.abs(offset) <= this.backtrack.length):
            	            return this.backtrack.slice(offset)[0];
            	        case (offset > 0 && offset <= this.lookahead.length):
            	            return this.lookahead[offset - 1];
            	        default:
            	            return null;
            	    }
            	};

            	/**
            	 * Converts a context range into a string value
            	 * @param {contextRange} range a context range
            	 */
            	Tokenizer.prototype.rangeToText = function (range) {
            	    if (range instanceof ContextRange) {
            	        return (
            	            this.getRangeTokens(range)
            	                .map(function (token) { return token.char; }).join('')
            	        );
            	    }
            	};

            	/**
            	 * Converts all tokens into a string
            	 */
            	Tokenizer.prototype.getText = function () {
            	    return this.tokens.map(function (token) { return token.char; }).join('');
            	};

            	/**
            	 * Get a context by name
            	 * @param {string} contextName context name to get
            	 */
            	Tokenizer.prototype.getContext = function (contextName) {
            	    var context = this.registeredContexts[contextName];
            	    return !!context ? context : null;
            	};

            	/**
            	 * Subscribes a new event handler to an event
            	 * @param {string} eventName event name to subscribe to
            	 * @param {function} eventHandler a function to be invoked on event
            	 */
            	Tokenizer.prototype.on = function(eventName, eventHandler) {
            	    var event = this.events[eventName];
            	    if (!!event) {
            	        return event.subscribe(eventHandler);
            	    } else {
            	        return null;
            	    }
            	};

            	/**
            	 * Dispatches an event
            	 * @param {string} eventName event name
            	 * @param {any} args event handler arguments
            	 */
            	Tokenizer.prototype.dispatch = function(eventName, args) {
            	    var this$1 = this;

            	    var event = this.events[eventName];
            	    if (event instanceof Event) {
            	        event.subscribers.forEach(function (subscriber) {
            	            subscriber.apply(this$1, args || []);
            	        });
            	    }
            	};

            	/**
            	 * Register a new context checker
            	 * @param {string} contextName a unique context name
            	 * @param {function} contextStartCheck a predicate function that returns true on context start
            	 * @param {function} contextEndCheck  a predicate function that returns true on context end
            	 * TODO: call tokenize on registration to update context ranges with the new context.
            	 */
            	Tokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {
            	    if (!!this.getContext(contextName)) { return {
            	        FAIL:
            	        ("context name '" + contextName + "' is already registered.")
            	    }; }
            	    if (typeof contextStartCheck !== 'function') { return {
            	        FAIL:
            	        "missing context start check."
            	    }; }
            	    if (typeof contextEndCheck !== 'function') { return {
            	        FAIL:
            	        "missing context end check."
            	    }; }
            	    var contextCheckers = new ContextChecker(
            	        contextName, contextStartCheck, contextEndCheck
            	    );
            	    this.registeredContexts[contextName] = contextCheckers;
            	    this.contextCheckers.push(contextCheckers);
            	    return contextCheckers;
            	};

            	/**
            	 * Gets a context range tokens
            	 * @param {contextRange} range a context range
            	 */
            	Tokenizer.prototype.getRangeTokens = function(range) {
            	    var endIndex = range.startIndex + range.endOffset;
            	    return [].concat(
            	        this.tokens
            	            .slice(range.startIndex, endIndex)
            	    );
            	};

            	/**
            	 * Gets the ranges of a context
            	 * @param {string} contextName context name
            	 */
            	Tokenizer.prototype.getContextRanges = function(contextName) {
            	    var context = this.getContext(contextName);
            	    if (!!context) {
            	        return context.ranges;
            	    } else {
            	        return { FAIL: ("context checker '" + contextName + "' is not registered.") };
            	    }
            	};

            	/**
            	 * Resets context ranges to run context update
            	 */
            	Tokenizer.prototype.resetContextsRanges = function () {
            	    var registeredContexts = this.registeredContexts;
            	    for (var contextName in registeredContexts) {
            	        if (registeredContexts.hasOwnProperty(contextName)) {
            	            var context = registeredContexts[contextName];
            	            context.ranges = [];
            	        }
            	    }
            	};

            	/**
            	 * Updates context ranges
            	 */
            	Tokenizer.prototype.updateContextsRanges = function () {
            	    var this$1 = this;

            	    this.resetContextsRanges();
            	    var chars = this.tokens.map(function (token) { return token.char; });
            	    for (var i = 0; i < chars.length; i++) {
            	        var contextParams = new ContextParams(chars, i);
            	        this$1.runContextCheck(contextParams);
            	    }
            	    this.dispatch('updateContextsRanges', [this.registeredContexts]);
            	};

            	/**
            	 * Sets the end offset of an open range
            	 * @param {number} offset range end offset
            	 * @param {string} contextName context name
            	 */
            	Tokenizer.prototype.setEndOffset = function (offset, contextName) {
            	    var startIndex = this.getContext(contextName).openRange.startIndex;
            	    var range = new ContextRange(startIndex, offset, contextName);
            	    var ranges = this.getContext(contextName).ranges;
            	    range.rangeId = contextName + "." + (ranges.length);
            	    ranges.push(range);
            	    this.getContext(contextName).openRange = null;
            	    return range;
            	};

            	/**
            	 * Runs a context check on the current context
            	 * @param {contextParams} contextParams current context params
            	 */
            	Tokenizer.prototype.runContextCheck = function(contextParams) {
            	    var this$1 = this;

            	    var index = contextParams.index;
            	    this.contextCheckers.forEach(function (contextChecker) {
            	        var contextName = contextChecker.contextName;
            	        var openRange = this$1.getContext(contextName).openRange;
            	        if (!openRange && contextChecker.checkStart(contextParams)) {
            	            openRange = new ContextRange(index, null, contextName);
            	            this$1.getContext(contextName).openRange = openRange;
            	            this$1.dispatch('contextStart', [contextName, index]);
            	        }
            	        if (!!openRange && contextChecker.checkEnd(contextParams)) {
            	            var offset = (index - openRange.startIndex) + 1;
            	            var range = this$1.setEndOffset(offset, contextName);
            	            this$1.dispatch('contextEnd', [contextName, range]);
            	        }
            	    });
            	};

            	/**
            	 * Converts a text into a list of tokens
            	 * @param {string} text a text to tokenize
            	 */
            	Tokenizer.prototype.tokenize = function (text) {
            	    var this$1 = this;

            	    this.tokens = [];
            	    this.resetContextsRanges();
            	    var chars = Array.from(text);
            	    this.dispatch('start');
            	    for (var i = 0; i < chars.length; i++) {
            	        var char = chars[i];
            	        var contextParams = new ContextParams(chars, i);
            	        this$1.dispatch('next', [contextParams]);
            	        this$1.runContextCheck(contextParams);
            	        var token = new Token(char);
            	        this$1.tokens.push(token);
            	        this$1.dispatch('newToken', [token, contextParams]);
            	    }
            	    this.dispatch('end', [this.tokens]);
            	    return this.tokens;
            	};

            	// ╭─┄┄┄────────────────────────┄─────────────────────────────────────────────╮
            	// ┊ Character Class Assertions ┊ Checks if a char belongs to a certain class ┊
            	// ╰─╾──────────────────────────┄─────────────────────────────────────────────╯
            	// jscs:disable maximumLineLength
            	/**
            	 * Check if a char is Arabic
            	 * @param {string} c a single char
            	 */
            	function isArabicChar(c) {
            	    return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(c);
            	}

            	/**
            	 * Check if a char is an isolated arabic char
            	 * @param {string} c a single char
            	 */
            	function isIsolatedArabicChar(char) {
            	    return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(char);
            	}

            	/**
            	 * Check if a char is an Arabic Tashkeel char
            	 * @param {string} c a single char
            	 */
            	function isTashkeelArabicChar(char) {
            	    return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(char);
            	}

            	/**
            	 * Check if a char is whitespace char
            	 * @param {string} c a single char
            	 */
            	function isWhiteSpace(c) {
            	    return /\s/.test(c);
            	}

            	/**
            	 * Arabic word context checkers
            	 */

            	function arabicWordStartCheck(contextParams) {
            	    var char = contextParams.current;
            	    var prevChar = contextParams.get(-1);
            	    return (
            	        // ? arabic first char
            	        (prevChar === null && isArabicChar(char)) ||
            	        // ? arabic char preceded with a non arabic char
            	        (!isArabicChar(prevChar) && isArabicChar(char))
            	    );
            	}

            	function arabicWordEndCheck(contextParams) {
            	    var nextChar = contextParams.get(1);
            	    return (
            	        // ? last arabic char
            	        (nextChar === null) ||
            	        // ? next char is not arabic
            	        (!isArabicChar(nextChar))
            	    );
            	}
            	var arabicWordCheck = { arabicWordStartCheck: arabicWordStartCheck, arabicWordEndCheck: arabicWordEndCheck };

            	/**
            	 * Arabic sentence context checkers
            	 */

            	function arabicSentenceStartCheck(contextParams) {
            	    var char = contextParams.current;
            	    var prevChar = contextParams.get(-1);
            	    return (
            	        // ? an arabic char preceded with a non arabic char
            	        (isArabicChar(char) || isTashkeelArabicChar(char)) &&
            	        !isArabicChar(prevChar)
            	    );
            	}

            	function arabicSentenceEndCheck(contextParams) {
            	    var nextChar = contextParams.get(1);
            	    switch (true) {
            	        case nextChar === null:
            	            return true;
            	        case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):
            	            var nextIsWhitespace = isWhiteSpace(nextChar);
            	            if (!nextIsWhitespace) { return true; }
            	            if (nextIsWhitespace) {
            	                var arabicCharAhead = false;
            	                arabicCharAhead = (
            	                    contextParams.lookahead.some(
            	                        function (c) { return isArabicChar(c) || isTashkeelArabicChar(c); }
            	                    )
            	                );
            	                if (!arabicCharAhead) { return true; }
            	            }
            	            break;
            	        default:
            	            return false;
            	    }
            	}
            	var arabicSentenceCheck = { arabicSentenceStartCheck: arabicSentenceStartCheck, arabicSentenceEndCheck: arabicSentenceEndCheck };

            	/**
            	 * Apply Arabic presentation forms to a range of tokens
            	 */
            	/**
            	 * Check if a char can be connected to it's preceding char
            	 * @param {ContextParams} charContextParams context params of a char
            	 */
            	function willConnectPrev(charContextParams) {
            	    var backtrack = [].concat(charContextParams.backtrack);
            	    for (var i = backtrack.length - 1; i >= 0; i--) {
            	        var prevChar = backtrack[i];
            	        var isolated = isIsolatedArabicChar(prevChar);
            	        var tashkeel = isTashkeelArabicChar(prevChar);
            	        if (!isolated && !tashkeel) { return true; }
            	        if (isolated) { return false; }
            	    }
            	    return false;
            	}

            	/**
            	 * Check if a char can be connected to it's proceeding char
            	 * @param {ContextParams} charContextParams context params of a char
            	 */
            	function willConnectNext(charContextParams) {
            	    if (isIsolatedArabicChar(charContextParams.current)) { return false; }
            	    for (var i = 0; i < charContextParams.lookahead.length; i++) {
            	        var nextChar = charContextParams.lookahead[i];
            	        var tashkeel = isTashkeelArabicChar(nextChar);
            	        if (!tashkeel) { return true; }
            	    }
            	    return false;
            	}

            	/**
            	 * Apply arabic presentation forms to a list of tokens
            	 * @param {ContextRange} range a range of tokens
            	 */
            	function arabicPresentationForms(range) {
            	    var features = this.features.arab;
            	    var rangeTokens = this.tokenizer.getRangeTokens(range);
            	    if (rangeTokens.length === 1) { return; }
            	    var getSubstitutionIndex = function (substitution) { return (
            	        substitution.length === 1 &&
            	        substitution[0].id === 12 &&
            	        substitution[0].substitution
            	    ); };
            	    var applyForm = function (tag, token, params) {
            	        if (!features.hasOwnProperty(tag)) { return; }
            	        var substitution = features[tag].lookup(params) || null;
            	        var substIndex = getSubstitutionIndex(substitution)[0];
            	        if (substIndex >= 0) {
            	            return token.setState(tag, substIndex);
            	        }
            	    };
            	    var tokensParams = new ContextParams(rangeTokens, 0);
            	    var charContextParams = new ContextParams(rangeTokens.map(function (t){ return t.char; }), 0);
            	    rangeTokens.forEach(function (token, i) {
            	        if (isTashkeelArabicChar(token.char)) { return; }
            	        tokensParams.setCurrentIndex(i);
            	        charContextParams.setCurrentIndex(i);
            	        var CONNECT = 0; // 2 bits 00 (10: can connect next) (01: can connect prev)
            	        if (willConnectPrev(charContextParams)) { CONNECT |= 1; }
            	        if (willConnectNext(charContextParams)) { CONNECT |= 2; }
            	        switch (CONNECT) {
            	            case 0: // isolated * original form
            	                return;
            	            case 1: // fina
            	                applyForm('fina', token, tokensParams);
            	                break;
            	            case 2: // init
            	                applyForm('init', token, tokensParams);
            	                break;
            	            case 3: // medi
            	                applyForm('medi', token, tokensParams);
            	                break;
            	        }
            	    });
            	}

            	/**
            	 * Apply Arabic required ligatures feature to a range of tokens
            	 */

            	/**
            	 * Apply Arabic required ligatures to a context range
            	 * @param {ContextRange} range a range of tokens
            	 */
            	function arabicRequiredLigatures(range) {
            	    var features = this.features.arab;
            	    if (!features.hasOwnProperty('rlig')) { return; }
            	    var tokens = this.tokenizer.getRangeTokens(range);
            	    for (var i = 0; i < tokens.length; i++) {
            	        var lookupParams = new ContextParams(tokens, i);
            	        var substitution = features.rlig.lookup(lookupParams) || null;
            	        var chainingContext = (
            	            substitution.length === 1 &&
            	            substitution[0].id === 63 &&
            	            substitution[0].substitution
            	        );
            	        var ligature = (
            	            substitution.length === 1 &&
            	            substitution[0].id === 41 &&
            	            substitution[0].substitution[0]
            	        );
            	        var token = tokens[i];
            	        if (!!ligature) {
            	            token.setState('rlig', [ligature.ligGlyph]);
            	            for (var c = 0; c < ligature.components.length; c++) {
            	                var component = ligature.components[c];
            	                var lookaheadToken = lookupParams.get(c + 1);
            	                if (lookaheadToken.activeState.value === component) {
            	                    lookaheadToken.state.deleted = true;
            	                }
            	            }
            	        } else if (chainingContext) {
            	            var substIndex = (
            	                chainingContext &&
            	                chainingContext.length === 1 &&
            	                chainingContext[0].id === 12 &&
            	                chainingContext[0].substitution
            	            );
            	            if (!!substIndex && substIndex >= 0) { token.setState('rlig', substIndex); }
            	        }
            	    }
            	}

            	/**
            	 * Infer bidirectional properties for a given text and apply
            	 * the corresponding layout rules.
            	 */

            	/**
            	 * Create Bidi. features
            	 * @param {string} baseDir text base direction. value either 'ltr' or 'rtl'
            	 */
            	function Bidi(baseDir) {
            	    this.baseDir = baseDir || 'ltr';
            	    this.tokenizer = new Tokenizer();
            	    this.features = [];
            	}

            	/**
            	 * Sets Bidi text
            	 * @param {string} text a text input
            	 */
            	Bidi.prototype.setText = function (text) {
            	    this.text = text;
            	};

            	/**
            	 * Store essential context checks:
            	 * arabic word check for applying gsub features
            	 * arabic sentence check for adjusting arabic layout
            	 */
            	Bidi.prototype.contextChecks = ({
            	    arabicWordCheck: arabicWordCheck,
            	    arabicSentenceCheck: arabicSentenceCheck
            	});

            	/**
            	 * Register arabic word check
            	 */
            	function registerArabicWordCheck() {
            	    var checks = this.contextChecks.arabicWordCheck;
            	    return this.tokenizer.registerContextChecker(
            	        'arabicWord',
            	        checks.arabicWordStartCheck,
            	        checks.arabicWordEndCheck
            	    );
            	}

            	/**
            	 * Register arabic sentence check
            	 */
            	function registerArabicSentenceCheck() {
            	    var checks = this.contextChecks.arabicSentenceCheck;
            	    return this.tokenizer.registerContextChecker(
            	        'arabicSentence',
            	        checks.arabicSentenceStartCheck,
            	        checks.arabicSentenceEndCheck
            	    );
            	}

            	/**
            	 * Perform pre tokenization procedure then
            	 * tokenize text input
            	 */
            	function tokenizeText() {
            	    registerArabicWordCheck.call(this);
            	    registerArabicSentenceCheck.call(this);
            	    return this.tokenizer.tokenize(this.text);
            	}

            	/**
            	 * Reverse arabic sentence layout
            	 * TODO: check base dir before applying adjustments - priority low
            	 */
            	function reverseArabicSentences() {
            	    var this$1 = this;

            	    var ranges = this.tokenizer.getContextRanges('arabicSentence');
            	    ranges.forEach(function (range) {
            	        var rangeTokens = this$1.tokenizer.getRangeTokens(range);
            	        this$1.tokenizer.replaceRange(
            	            range.startIndex,
            	            range.endOffset,
            	            rangeTokens.reverse()
            	        );
            	    });
            	}

            	/**
            	 * Subscribe arabic presentation form features
            	 * @param {feature} feature a feature to apply
            	 */
            	Bidi.prototype.subscribeArabicForms = function(feature) {
            	    var this$1 = this;

            	    this.tokenizer.events.contextEnd.subscribe(
            	        function (contextName, range) {
            	            if (contextName === 'arabicWord') {
            	                return arabicPresentationForms.call(
            	                    this$1.tokenizer, range, feature
            	                );
            	            }
            	        }
            	    );
            	};

            	/**
            	 * Apply Gsub features
            	 * @param {feature} features a list of features
            	 */
            	Bidi.prototype.applyFeatures = function (features) {
            	    var this$1 = this;

            	    for (var i = 0; i < features.length; i++) {
            	        var feature = features[i];
            	        if (feature) {
            	            var script = feature.script;
            	            if (!this$1.features[script]) {
            	                this$1.features[script] = {};
            	            }
            	            this$1.features[script][feature.tag] = feature;
            	        }
            	    }
            	};

            	/**
            	 * Register a state modifier
            	 * @param {string} modifierId state modifier id
            	 * @param {function} condition a predicate function that returns true or false
            	 * @param {function} modifier a modifier function to set token state
            	 */
            	Bidi.prototype.registerModifier = function (modifierId, condition, modifier) {
            	    this.tokenizer.registerModifier(modifierId, condition, modifier);
            	};

            	/**
            	 * Check if 'glyphIndex' is registered
            	 */
            	function checkGlyphIndexStatus() {
            	    if (this.tokenizer.registeredModifiers.indexOf('glyphIndex') === -1) {
            	        throw new Error(
            	            'glyphIndex modifier is required to apply ' +
            	            'arabic presentation features.'
            	        );
            	    }
            	}

            	/**
            	 * Apply arabic presentation forms features
            	 */
            	function applyArabicPresentationForms() {
            	    var this$1 = this;

            	    if (!this.features.hasOwnProperty('arab')) { return; }
            	    checkGlyphIndexStatus.call(this);
            	    var ranges = this.tokenizer.getContextRanges('arabicWord');
            	    ranges.forEach(function (range) {
            	        arabicPresentationForms.call(this$1, range);
            	    });
            	}

            	/**
            	 * Apply required arabic ligatures
            	 */
            	function applyArabicRequireLigatures() {
            	    var this$1 = this;

            	    if (!this.features.hasOwnProperty('arab')) { return; }
            	    if (!this.features.arab.hasOwnProperty('rlig')) { return; }
            	    checkGlyphIndexStatus.call(this);
            	    var ranges = this.tokenizer.getContextRanges('arabicWord');
            	    ranges.forEach(function (range) {
            	        arabicRequiredLigatures.call(this$1, range);
            	    });
            	}

            	/**
            	 * process text input
            	 * @param {string} text an input text
            	 */
            	Bidi.prototype.processText = function(text) {
            	    if (!this.text || this.text !== text) {
            	        this.setText(text);
            	        tokenizeText.call(this);
            	        applyArabicPresentationForms.call(this);
            	        applyArabicRequireLigatures.call(this);
            	        reverseArabicSentences.call(this);
            	    }
            	};

            	/**
            	 * Process a string of text to identify and adjust
            	 * bidirectional text entities.
            	 * @param {string} text input text
            	 */
            	Bidi.prototype.getBidiText = function (text) {
            	    this.processText(text);
            	    return this.tokenizer.getText();
            	};

            	/**
            	 * Get the current state index of each token
            	 * @param {text} text an input text
            	 */
            	Bidi.prototype.getTextGlyphs = function (text) {
            	    var this$1 = this;

            	    this.processText(text);
            	    var indexes = [];
            	    for (var i = 0; i < this.tokenizer.tokens.length; i++) {
            	        var token = this$1.tokenizer.tokens[i];
            	        if (token.state.deleted) { continue; }
            	        var index = token.activeState.value;
            	        indexes.push(Array.isArray(index) ? index[0] : index);
            	    }
            	    return indexes;
            	};

            	/**
            	 * Query a feature by some of it's properties to lookup a glyph substitution.
            	 */

            	// DEFAULT TEXT BASE DIRECTION
            	var BASE_DIR = 'ltr';

            	/**
            	 * Create feature query instance
            	 * @param {Font} font opentype font instance
            	 * @param {string} baseDir text base direction
            	 */
            	function FeatureQuery(font, baseDir) {
            	    this.font = font;
            	    this.features = {};
            	    BASE_DIR = !!baseDir ? baseDir : BASE_DIR;
            	}

            	/**
            	 * Create a new feature lookup
            	 * @param {string} tag feature tag
            	 * @param {feature} feature reference to feature at gsub table
            	 * @param {FeatureLookups} feature lookups associated with this feature
            	 * @param {string} script gsub script tag
            	 */
            	function Feature(tag, feature, featureLookups, script) {
            	    this.tag = tag;
            	    this.featureRef = feature;
            	    this.lookups = featureLookups.lookups;
            	    this.script = script;
            	}

            	/**
            	 * Create a coverage table lookup
            	 * @param {any} coverageTable gsub coverage table
            	 */
            	function Coverage$1(coverageTable) {
            	    this.table = coverageTable;
            	}

            	/**
            	 * Create a ligature set lookup
            	 * @param {any} ligatureSets gsub ligature set
            	 */
            	function LigatureSets(ligatureSets) {
            	    this.ligatureSets = ligatureSets;
            	}

            	/**
            	 * Lookup a glyph ligature
            	 * @param {ContextParams} contextParams context params to lookup
            	 * @param {number} ligSetIndex ligature set index at ligature sets
            	 */
            	LigatureSets.prototype.lookup = function (contextParams, ligSetIndex) {
            	    var ligatureSet = this.ligatureSets[ligSetIndex];
            	    var matchComponents = function (components, indexes) {
            	        if (components.length > indexes.length) { return null; }
            	        for (var c = 0; c < components.length; c++) {
            	            var component = components[c];
            	            var index = indexes[c];
            	            if (component !== index) { return false; }
            	        }
            	        return true;
            	    };
            	    for (var s = 0; s < ligatureSet.length; s++) {
            	        var ligSetItem = ligatureSet[s];
            	        var lookaheadIndexes = contextParams.lookahead.map(
            	            function (token) { return token.activeState.value; }
            	        );
            	        if (BASE_DIR === 'rtl') { lookaheadIndexes.reverse(); }
            	        var componentsMatch = matchComponents(
            	            ligSetItem.components, lookaheadIndexes
            	        );
            	        if (componentsMatch) { return ligSetItem; }
            	    }
            	    return null;
            	};

            	/**
            	 * Create a feature substitution
            	 * @param {any} lookups a reference to gsub lookups
            	 * @param {Lookuptable} lookupTable a feature lookup table
            	 * @param {any} subtable substitution table
            	 */
            	function Substitution$1(lookups, lookupTable, subtable) {
            	    this.lookups = lookups;
            	    this.subtable = subtable;
            	    this.lookupTable = lookupTable;
            	    if (subtable.hasOwnProperty('coverage')) {
            	        this.coverage = new Coverage$1(
            	            subtable.coverage
            	        );
            	    }
            	    if (subtable.hasOwnProperty('inputCoverage')) {
            	        this.inputCoverage = subtable.inputCoverage.map(
            	            function (table) { return new Coverage$1(table); }
            	        );
            	    }
            	    if (subtable.hasOwnProperty('backtrackCoverage')) {
            	        this.backtrackCoverage = subtable.backtrackCoverage.map(
            	            function (table) { return new Coverage$1(table); }
            	        );
            	    }
            	    if (subtable.hasOwnProperty('lookaheadCoverage')) {
            	        this.lookaheadCoverage = subtable.lookaheadCoverage.map(
            	            function (table) { return new Coverage$1(table); }
            	        );
            	    }
            	    if (subtable.hasOwnProperty('ligatureSets')) {
            	        this.ligatureSets = new LigatureSets(subtable.ligatureSets);
            	    }
            	}

            	/**
            	 * Create a lookup table lookup
            	 * @param {number} index table index at gsub lookups
            	 * @param {any} lookups a reference to gsub lookups
            	 */
            	function LookupTable(index, lookups) {
            	    this.index = index;
            	    this.subtables = lookups[index].subtables.map(
            	        function (subtable) { return new Substitution$1(
            	            lookups, lookups[index], subtable
            	        ); }
            	    );
            	}

            	function FeatureLookups(lookups, lookupListIndexes) {
            	    this.lookups = lookupListIndexes.map(
            	        function (index) { return new LookupTable(index, lookups); }
            	    );
            	}

            	/**
            	 * Lookup a lookup table subtables
            	 * @param {ContextParams} contextParams context params to lookup
            	 */
            	LookupTable.prototype.lookup = function (contextParams) {
            	    var this$1 = this;

            	    var substitutions = [];
            	    for (var i = 0; i < this.subtables.length; i++) {
            	        var subsTable = this$1.subtables[i];
            	        var substitution = subsTable.lookup(contextParams);
            	        if (substitution !== null || substitution.length) {
            	            substitutions = substitutions.concat(substitution);
            	        }
            	    }
            	    return substitutions;
            	};

            	/**
            	 * Handle a single substitution - format 2
            	 * @param {ContextParams} contextParams context params to lookup
            	 */
            	function singleSubstitutionFormat2(contextParams) {
            	    var glyphIndex = contextParams.current.activeState.value;
            	    glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;
            	    var substituteIndex = this.coverage.lookup(glyphIndex);
            	    if (substituteIndex === -1) { return []; }
            	    return [this.subtable.substitute[substituteIndex]];
            	}

            	/**
            	 * Lookup a list of coverage tables
            	 * @param {any} coverageList a list of coverage tables
            	 * @param {any} contextParams context params to lookup
            	 */
            	function lookupCoverageList(coverageList, contextParams) {
            	    var lookupList = [];
            	    for (var i = 0; i < coverageList.length; i++) {
            	        var coverage = coverageList[i];
            	        var glyphIndex = contextParams.current.activeState.value;
            	        glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;
            	        var lookupIndex = coverage.lookup(glyphIndex);
            	        if (lookupIndex !== -1) {
            	            lookupList.push(lookupIndex);
            	        }
            	    }
            	    if (lookupList.length !== coverageList.length) { return -1; }
            	    return lookupList;
            	}

            	/**
            	 * Handle chaining context substitution - format 3
            	 * @param {any} contextParams context params to lookup
            	 */
            	function chainingSubstitutionFormat3(contextParams) {
            	    var this$1 = this;

            	    var lookupsCount = (
            	        this.inputCoverage.length +
            	        this.lookaheadCoverage.length +
            	        this.backtrackCoverage.length
            	    );
            	    if (contextParams.context.length < lookupsCount) { return []; }
            	    // INPUT LOOKUP //
            	    var inputLookups = lookupCoverageList(
            	        this.inputCoverage, contextParams
            	    );
            	    if (inputLookups === -1) { return []; }
            	    // LOOKAHEAD LOOKUP //
            	    var lookaheadOffset = this.inputCoverage.length - 1;
            	    if (contextParams.lookahead.length < this.lookaheadCoverage.length) { return []; }
            	    var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);
            	    while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {
            	        lookaheadContext.shift();
            	    }
            	    var lookaheadParams = new ContextParams(lookaheadContext, 0);
            	    var lookaheadLookups = lookupCoverageList(
            	        this.lookaheadCoverage, lookaheadParams
            	    );
            	    // BACKTRACK LOOKUP //
            	    var backtrackContext = [].concat(contextParams.backtrack);
            	    backtrackContext.reverse();
            	    while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {
            	        backtrackContext.shift();
            	    }
            	    if (backtrackContext.length < this.backtrackCoverage.length) { return []; }
            	    var backtrackParams = new ContextParams(backtrackContext, 0);
            	    var backtrackLookups = lookupCoverageList(
            	        this.backtrackCoverage, backtrackParams
            	    );
            	    var contextRulesMatch = (
            	        inputLookups.length === this.inputCoverage.length &&
            	        lookaheadLookups.length === this.lookaheadCoverage.length &&
            	        backtrackLookups.length === this.backtrackCoverage.length
            	    );
            	    var substitutions = [];
            	    if (contextRulesMatch) {
            	        var lookupRecords = this.subtable.lookupRecords;
            	        for (var i = 0; i < lookupRecords.length; i++) {
            	            var lookupRecord = lookupRecords[i];
            	            for (var j = 0; j < inputLookups.length; j++) {
            	                var inputContext = new ContextParams([contextParams.get(j)], 0);
            	                var lookupIndex = lookupRecord.lookupListIndex;
            	                var lookupTable = new LookupTable(lookupIndex, this$1.lookups);
            	                var lookup = lookupTable.lookup(inputContext);
            	                substitutions = substitutions.concat(lookup);
            	            }
            	        }
            	    }
            	    return substitutions;
            	}

            	/**
            	 * Handle ligature substitution - format 1
            	 * @param {any} contextParams context params to lookup
            	 */
            	function ligatureSubstitutionFormat1(contextParams) {
            	    // COVERAGE LOOKUP //
            	    var glyphIndex = contextParams.current.activeState.value;
            	    var ligSetIndex = this.coverage.lookup(glyphIndex);
            	    if (ligSetIndex === -1) { return []; }
            	    // COMPONENTS LOOKUP * note that components is logically ordered
            	    var ligGlyphs = this.ligatureSets.lookup(contextParams, ligSetIndex);
            	    return ligGlyphs ? [ligGlyphs] : [];
            	}

            	/**
            	 * [ LOOKUP TYPES ]
            	 * -------------------------------
            	 * Single                        1;
            	 * Multiple                      2;
            	 * Alternate                     3;
            	 * Ligature                      4;
            	 * Context                       5;
            	 * ChainingContext               6;
            	 * ExtensionSubstitution         7;
            	 * ReverseChainingContext        8;
            	 * -------------------------------
            	 * @param {any} contextParams context params to lookup
            	 */
            	Substitution$1.prototype.lookup = function (contextParams) {
            	    var substitutions = [];
            	    var lookupType = this.lookupTable.lookupType;
            	    var substFormat = this.subtable.substFormat;
            	    if (lookupType === 1 && substFormat === 2) {
            	        var substitution = singleSubstitutionFormat2.call(this, contextParams);
            	        if (substitution.length > 0) {
            	            substitutions.push({ id: 12, substitution: substitution });
            	        }
            	    }
            	    if (lookupType === 6 && substFormat === 3) {
            	        var substitution$1 = chainingSubstitutionFormat3.call(this, contextParams);
            	        if (substitution$1.length > 0) {
            	            substitutions.push({ id: 63, substitution: substitution$1 });
            	        }
            	    }
            	    if (lookupType === 4 && substFormat === 1) {
            	        var substitution$2 = ligatureSubstitutionFormat1.call(this, contextParams);
            	        if (substitution$2.length > 0) {
            	            substitutions.push({ id: 41, substitution: substitution$2 });
            	        }
            	    }
            	    return substitutions;
            	};

            	/**
            	 * Lookup a coverage table
            	 * @param {number} glyphIndex to lookup
            	 */
            	Coverage$1.prototype.lookup = function (glyphIndex) {
            	    if (!glyphIndex) { return -1; }
            	    switch (this.table.format) {
            	        case 1:
            	            return this.table.glyphs.indexOf(glyphIndex);

            	        case 2:
            	            var ranges = this.table.ranges;
            	            for (var i = 0; i < ranges.length; i++) {
            	                var range = ranges[i];
            	                if (glyphIndex >= range.start && glyphIndex <= range.end) {
            	                    var offset = glyphIndex - range.start;
            	                    return range.index + offset;
            	                }
            	            }
            	            break;
            	        default:
            	            return -1; // not found
            	    }
            	    return -1;
            	};

            	/**
            	 * Lookup a feature for a substitution or more
            	 * @param {any} contextParams context params to lookup
            	 */
            	Feature.prototype.lookup = function(contextParams) {
            	    var this$1 = this;

            	    var lookups = [];
            	    for (var i = 0; i < this.lookups.length; i++) {
            	        var lookupTable = this$1.lookups[i];
            	        var lookup = lookupTable.lookup(contextParams);
            	        if (lookup !== null || lookup.length) {
            	            lookups = lookups.concat(lookup);
            	        }
            	    }
            	    return lookups;
            	};

            	/**
            	 * Get feature indexes of a specific script
            	 * @param {string} scriptTag script tag
            	 */
            	FeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {
            	    if (!scriptTag) { return []; }
            	    var tables = this.font.tables;
            	    if (!tables.gsub) { return []; }
            	    var scripts = this.font.tables.gsub.scripts;
            	    for (var i = 0; i < scripts.length; i++) {
            	        var script = scripts[i];
            	        if (script.tag === scriptTag) {
            	            var defaultLangSys = script.script.defaultLangSys;
            	            return defaultLangSys.featureIndexes;
            	        } else {
            	            var langSysRecords = script.langSysRecords;
            	            if (!!langSysRecords) {
            	                for (var j = 0; j < langSysRecords.length; j++) {
            	                    var langSysRecord = langSysRecords[j];
            	                    if (langSysRecord.tag === scriptTag) {
            	                        var langSys = langSysRecord.langSys;
            	                        return langSys.featureIndexes;
            	                    }
            	                }
            	            }
            	        }
            	    }
            	    return [];
            	};

            	/**
            	 * Map a feature tag to a gsub feature
            	 * @param {any} features gsub features
            	 * @param {*} scriptTag script tag
            	 */
            	FeatureQuery.prototype.mapTagsToFeatures = function (features, scriptTag) {
            	    var this$1 = this;

            	    var tags = {};
            	    for (var i = 0; i < features.length; i++) {
            	        var feature = features[i].feature;
            	        var tag = features[i].tag;
            	        var lookups = this$1.font.tables.gsub.lookups;
            	        var featureLookups = new FeatureLookups(lookups, feature.lookupListIndexes);
            	        tags[tag] = new Feature(tag, feature, featureLookups, scriptTag);
            	    }
            	    this.features[scriptTag].tags = tags;
            	};

            	/**
            	 * Get features of a specific script
            	 * @param {string} scriptTag script tag
            	 */
            	FeatureQuery.prototype.getScriptFeatures = function (scriptTag) {
            	    var features = this.features[scriptTag];
            	    if (this.features.hasOwnProperty(scriptTag)) { return features; }
            	    var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);
            	    if (!featuresIndexes) { return null; }
            	    var gsub = this.font.tables.gsub;
            	    features = featuresIndexes.map(function (index) { return gsub.features[index]; });
            	    this.features[scriptTag] = features;
            	    this.mapTagsToFeatures(features, scriptTag);
            	    return features;
            	};

            	/**
            	 * Query a feature by it's properties
            	 * @param {any} query an object that describes the properties of a query
            	 */
            	FeatureQuery.prototype.getFeature = function (query) {
            	    if (!this.font) { return { FAIL: "No font was found"}; }
            	    if (!this.features.hasOwnProperty(query.script)) {
            	        this.getScriptFeatures(query.script);
            	    }
            	    return this.features[query.script].tags[query.tag] || null;
            	};

            	// The Font object

            	/**
            	 * @typedef FontOptions
            	 * @type Object
            	 * @property {Boolean} empty - whether to create a new empty font
            	 * @property {string} familyName
            	 * @property {string} styleName
            	 * @property {string=} fullName
            	 * @property {string=} postScriptName
            	 * @property {string=} designer
            	 * @property {string=} designerURL
            	 * @property {string=} manufacturer
            	 * @property {string=} manufacturerURL
            	 * @property {string=} license
            	 * @property {string=} licenseURL
            	 * @property {string=} version
            	 * @property {string=} description
            	 * @property {string=} copyright
            	 * @property {string=} trademark
            	 * @property {Number} unitsPerEm
            	 * @property {Number} ascender
            	 * @property {Number} descender
            	 * @property {Number} createdTimestamp
            	 * @property {string=} weightClass
            	 * @property {string=} widthClass
            	 * @property {string=} fsSelection
            	 */

            	/**
            	 * A Font represents a loaded OpenType font file.
            	 * It contains a set of glyphs and methods to draw text on a drawing context,
            	 * or to get a path representing the text.
            	 * @exports opentype.Font
            	 * @class
            	 * @param {FontOptions}
            	 * @constructor
            	 */
            	function Font(options) {
            	    options = options || {};

            	    if (!options.empty) {
            	        // Check that we've provided the minimum set of names.
            	        checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');
            	        checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');
            	        checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');
            	        checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');
            	        checkArgument(options.descender, 'When creating a new Font object, descender is required.');
            	        checkArgument(options.descender < 0, 'Descender should be negative (e.g. -512).');

            	        // OS X will complain if the names are empty, so we put a single space everywhere by default.
            	        this.names = {
            	            fontFamily: {en: options.familyName || ' '},
            	            fontSubfamily: {en: options.styleName || ' '},
            	            fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},
            	            // postScriptName may not contain any whitespace
            	            postScriptName: {en: options.postScriptName || (options.familyName + options.styleName).replace(/\s/g, '')},
            	            designer: {en: options.designer || ' '},
            	            designerURL: {en: options.designerURL || ' '},
            	            manufacturer: {en: options.manufacturer || ' '},
            	            manufacturerURL: {en: options.manufacturerURL || ' '},
            	            license: {en: options.license || ' '},
            	            licenseURL: {en: options.licenseURL || ' '},
            	            version: {en: options.version || 'Version 0.1'},
            	            description: {en: options.description || ' '},
            	            copyright: {en: options.copyright || ' '},
            	            trademark: {en: options.trademark || ' '}
            	        };
            	        this.unitsPerEm = options.unitsPerEm || 1000;
            	        this.ascender = options.ascender;
            	        this.descender = options.descender;
            	        this.createdTimestamp = options.createdTimestamp;
            	        this.tables = { os2: {
            	            usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
            	            usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
            	            fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR
            	        } };
            	    }

            	    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.
            	    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
            	    this.encoding = new DefaultEncoding(this);
            	    this.position = new Position(this);
            	    this.substitution = new Substitution(this);
            	    this.tables = this.tables || {};

            	    Object.defineProperty(this, 'hinting', {
            	        get: function() {
            	            if (this._hinting) { return this._hinting; }
            	            if (this.outlinesFormat === 'truetype') {
            	                return (this._hinting = new Hinting(this));
            	            }
            	        }
            	    });
            	}

            	/**
            	 * Check if the font has a glyph for the given character.
            	 * @param  {string}
            	 * @return {Boolean}
            	 */
            	Font.prototype.hasChar = function(c) {
            	    return this.encoding.charToGlyphIndex(c) !== null;
            	};

            	/**
            	 * Convert the given character to a single glyph index.
            	 * Note that this function assumes that there is a one-to-one mapping between
            	 * the given character and a glyph; for complex scripts this might not be the case.
            	 * @param  {string}
            	 * @return {Number}
            	 */
            	Font.prototype.charToGlyphIndex = function(s) {
            	    return this.encoding.charToGlyphIndex(s);
            	};

            	/**
            	 * Convert the given character to a single Glyph object.
            	 * Note that this function assumes that there is a one-to-one mapping between
            	 * the given character and a glyph; for complex scripts this might not be the case.
            	 * @param  {string}
            	 * @return {opentype.Glyph}
            	 */
            	Font.prototype.charToGlyph = function(c) {
            	    var glyphIndex = this.charToGlyphIndex(c);
            	    var glyph = this.glyphs.get(glyphIndex);
            	    if (!glyph) {
            	        // .notdef
            	        glyph = this.glyphs.get(0);
            	    }

            	    return glyph;
            	};

            	/**
            	 * Convert the given text to a list of Glyph objects.
            	 * Note that there is no strict one-to-one mapping between characters and
            	 * glyphs, so the list of returned glyphs can be larger or smaller than the
            	 * length of the given string.
            	 * @param  {string}
            	 * @param  {GlyphRenderOptions} [options]
            	 * @return {opentype.Glyph[]}
            	 */
            	Font.prototype.stringToGlyphs = function(s, options) {
            	    var this$1 = this;

            	    options = options || this.defaultRenderOptions;

            	    var bidi = new Bidi();

            	    // Create and register 'glyphIndex' state modifier
            	    var charToGlyphIndexMod = function (token) { return this$1.charToGlyphIndex(token.char); };
            	    bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod);

            	    var arabFeatureQuery = new FeatureQuery(this);
            	    var arabFeatures = ['init', 'medi', 'fina', 'rlig'];
            	    bidi.applyFeatures(
            	        arabFeatures.map(function (tag) {
            	            var query = { tag: tag, script: 'arab' };
            	            var feature = arabFeatureQuery.getFeature(query);
            	            if (!!feature) { return feature; }
            	        })
            	    );
            	    var indexes = bidi.getTextGlyphs(s);

            	    var length = indexes.length;

            	    // Apply substitutions on glyph indexes
            	    if (options.features) {
            	        var script = options.script || this.substitution.getDefaultScriptName();
            	        var manyToOne = [];
            	        if (options.features.liga) { manyToOne = manyToOne.concat(this.substitution.getFeature('liga', script, options.language)); }
            	        if (options.features.rlig) { manyToOne = manyToOne.concat(this.substitution.getFeature('rlig', script, options.language)); }
            	        for (var i = 0; i < length; i += 1) {
            	            for (var j = 0; j < manyToOne.length; j++) {
            	                var ligature = manyToOne[j];
            	                var components = ligature.sub;
            	                var compCount = components.length;
            	                var k = 0;
            	                while (k < compCount && components[k] === indexes[i + k]) { k++; }
            	                if (k === compCount) {
            	                    indexes.splice(i, compCount, ligature.by);
            	                    length = length - compCount + 1;
            	                }
            	            }
            	        }
            	    }

            	    // convert glyph indexes to glyph objects
            	    var glyphs = new Array(length);
            	    var notdef = this.glyphs.get(0);
            	    for (var i$1 = 0; i$1 < length; i$1 += 1) {
            	        glyphs[i$1] = this$1.glyphs.get(indexes[i$1]) || notdef;
            	    }
            	    return glyphs;
            	};

            	/**
            	 * @param  {string}
            	 * @return {Number}
            	 */
            	Font.prototype.nameToGlyphIndex = function(name) {
            	    return this.glyphNames.nameToGlyphIndex(name);
            	};

            	/**
            	 * @param  {string}
            	 * @return {opentype.Glyph}
            	 */
            	Font.prototype.nameToGlyph = function(name) {
            	    var glyphIndex = this.nameToGlyphIndex(name);
            	    var glyph = this.glyphs.get(glyphIndex);
            	    if (!glyph) {
            	        // .notdef
            	        glyph = this.glyphs.get(0);
            	    }

            	    return glyph;
            	};

            	/**
            	 * @param  {Number}
            	 * @return {String}
            	 */
            	Font.prototype.glyphIndexToName = function(gid) {
            	    if (!this.glyphNames.glyphIndexToName) {
            	        return '';
            	    }

            	    return this.glyphNames.glyphIndexToName(gid);
            	};

            	/**
            	 * Retrieve the value of the kerning pair between the left glyph (or its index)
            	 * and the right glyph (or its index). If no kerning pair is found, return 0.
            	 * The kerning value gets added to the advance width when calculating the spacing
            	 * between glyphs.
            	 * For GPOS kerning, this method uses the default script and language, which covers
            	 * most use cases. To have greater control, use font.position.getKerningValue .
            	 * @param  {opentype.Glyph} leftGlyph
            	 * @param  {opentype.Glyph} rightGlyph
            	 * @return {Number}
            	 */
            	Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
            	    leftGlyph = leftGlyph.index || leftGlyph;
            	    rightGlyph = rightGlyph.index || rightGlyph;
            	    var gposKerning = this.position.defaultKerningTables;
            	    if (gposKerning) {
            	        return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);
            	    }
            	    // "kern" table
            	    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;
            	};

            	/**
            	 * @typedef GlyphRenderOptions
            	 * @type Object
            	 * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.
            	 *                               See https://www.microsoft.com/typography/otspec/scripttags.htm
            	 * @property {string} [language='dflt'] - language system used to determine which features to apply.
            	 *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx
            	 * @property {boolean} [kerning=true] - whether to include kerning values
            	 * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.
            	 *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm
            	 */
            	Font.prototype.defaultRenderOptions = {
            	    kerning: true,
            	    features: {
            	        liga: true,
            	        rlig: true
            	    }
            	};

            	/**
            	 * Helper function that invokes the given callback for each glyph in the given text.
            	 * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text
            	 * @param {string} text - The text to apply.
            	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
            	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
            	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
            	 * @param  {GlyphRenderOptions=} options
            	 * @param  {Function} callback
            	 */
            	Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
            	    var this$1 = this;

            	    x = x !== undefined ? x : 0;
            	    y = y !== undefined ? y : 0;
            	    fontSize = fontSize !== undefined ? fontSize : 72;
            	    options = options || this.defaultRenderOptions;
            	    var fontScale = 1 / this.unitsPerEm * fontSize;
            	    var glyphs = this.stringToGlyphs(text, options);
            	    var kerningLookups;
            	    if (options.kerning) {
            	        var script = options.script || this.position.getDefaultScriptName();
            	        kerningLookups = this.position.getKerningTables(script, options.language);
            	    }
            	    for (var i = 0; i < glyphs.length; i += 1) {
            	        var glyph = glyphs[i];
            	        callback.call(this$1, glyph, x, y, fontSize, options);
            	        if (glyph.advanceWidth) {
            	            x += glyph.advanceWidth * fontScale;
            	        }

            	        if (options.kerning && i < glyphs.length - 1) {
            	            // We should apply position adjustment lookups in a more generic way.
            	            // Here we only use the xAdvance value.
            	            var kerningValue = kerningLookups ?
            	                  this$1.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) :
            	                  this$1.getKerningValue(glyph, glyphs[i + 1]);
            	            x += kerningValue * fontScale;
            	        }

            	        if (options.letterSpacing) {
            	            x += options.letterSpacing * fontSize;
            	        } else if (options.tracking) {
            	            x += (options.tracking / 1000) * fontSize;
            	        }
            	    }
            	    return x;
            	};

            	/**
            	 * Create a Path object that represents the given text.
            	 * @param  {string} text - The text to create.
            	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
            	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
            	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
            	 * @param  {GlyphRenderOptions=} options
            	 * @return {opentype.Path}
            	 */
            	Font.prototype.getPath = function(text, x, y, fontSize, options) {
            	    var fullPath = new Path();
            	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
            	        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
            	        fullPath.extend(glyphPath);
            	    });
            	    return fullPath;
            	};

            	/**
            	 * Create an array of Path objects that represent the glyphs of a given text.
            	 * @param  {string} text - The text to create.
            	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
            	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
            	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
            	 * @param  {GlyphRenderOptions=} options
            	 * @return {opentype.Path[]}
            	 */
            	Font.prototype.getPaths = function(text, x, y, fontSize, options) {
            	    var glyphPaths = [];
            	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
            	        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
            	        glyphPaths.push(glyphPath);
            	    });

            	    return glyphPaths;
            	};

            	/**
            	 * Returns the advance width of a text.
            	 *
            	 * This is something different than Path.getBoundingBox() as for example a
            	 * suffixed whitespace increases the advanceWidth but not the bounding box
            	 * or an overhanging letter like a calligraphic 'f' might have a quite larger
            	 * bounding box than its advance width.
            	 *
            	 * This corresponds to canvas2dContext.measureText(text).width
            	 *
            	 * @param  {string} text - The text to create.
            	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
            	 * @param  {GlyphRenderOptions=} options
            	 * @return advance width
            	 */
            	Font.prototype.getAdvanceWidth = function(text, fontSize, options) {
            	    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});
            	};

            	/**
            	 * Draw the text on the given drawing context.
            	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
            	 * @param  {string} text - The text to create.
            	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
            	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
            	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
            	 * @param  {GlyphRenderOptions=} options
            	 */
            	Font.prototype.draw = function(ctx, text, x, y, fontSize, options) {
            	    this.getPath(text, x, y, fontSize, options).draw(ctx);
            	};

            	/**
            	 * Draw the points of all glyphs in the text.
            	 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
            	 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
            	 * @param {string} text - The text to create.
            	 * @param {number} [x=0] - Horizontal position of the beginning of the text.
            	 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
            	 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
            	 * @param {GlyphRenderOptions=} options
            	 */
            	Font.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
            	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
            	        glyph.drawPoints(ctx, gX, gY, gFontSize);
            	    });
            	};

            	/**
            	 * Draw lines indicating important font measurements for all glyphs in the text.
            	 * Black lines indicate the origin of the coordinate system (point 0,0).
            	 * Blue lines indicate the glyph bounding box.
            	 * Green line indicates the advance width of the glyph.
            	 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
            	 * @param {string} text - The text to create.
            	 * @param {number} [x=0] - Horizontal position of the beginning of the text.
            	 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
            	 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
            	 * @param {GlyphRenderOptions=} options
            	 */
            	Font.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
            	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
            	        glyph.drawMetrics(ctx, gX, gY, gFontSize);
            	    });
            	};

            	/**
            	 * @param  {string}
            	 * @return {string}
            	 */
            	Font.prototype.getEnglishName = function(name) {
            	    var translations = this.names[name];
            	    if (translations) {
            	        return translations.en;
            	    }
            	};

            	/**
            	 * Validate
            	 */
            	Font.prototype.validate = function() {
            	    var _this = this;

            	    function assert(predicate, message) {
            	    }

            	    function assertNamePresent(name) {
            	        var englishName = _this.getEnglishName(name);
            	        assert(englishName && englishName.trim().length > 0);
            	    }

            	    // Identification information
            	    assertNamePresent('fontFamily');
            	    assertNamePresent('weightName');
            	    assertNamePresent('manufacturer');
            	    assertNamePresent('copyright');
            	    assertNamePresent('version');

            	    // Dimension information
            	    assert(this.unitsPerEm > 0);
            	};

            	/**
            	 * Convert the font object to a SFNT data structure.
            	 * This structure contains all the necessary tables and metadata to create a binary OTF file.
            	 * @return {opentype.Table}
            	 */
            	Font.prototype.toTables = function() {
            	    return sfnt.fontToTable(this);
            	};
            	/**
            	 * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.
            	 */
            	Font.prototype.toBuffer = function() {
            	    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');
            	    return this.toArrayBuffer();
            	};
            	/**
            	 * Converts a `opentype.Font` into an `ArrayBuffer`
            	 * @return {ArrayBuffer}
            	 */
            	Font.prototype.toArrayBuffer = function() {
            	    var sfntTable = this.toTables();
            	    var bytes = sfntTable.encode();
            	    var buffer = new ArrayBuffer(bytes.length);
            	    var intArray = new Uint8Array(buffer);
            	    for (var i = 0; i < bytes.length; i++) {
            	        intArray[i] = bytes[i];
            	    }

            	    return buffer;
            	};

            	/**
            	 * Initiate a download of the OpenType font.
            	 */
            	Font.prototype.download = function(fileName) {
            	    var familyName = this.getEnglishName('fontFamily');
            	    var styleName = this.getEnglishName('fontSubfamily');
            	    fileName = fileName || familyName.replace(/\s/g, '') + '-' + styleName + '.otf';
            	    var arrayBuffer = this.toArrayBuffer();

            	    if (isBrowser()) {
            	        window.URL = window.URL || window.webkitURL;

            	        if (window.URL) {
            	            var dataView = new DataView(arrayBuffer);
            	            var blob = new Blob([dataView], {type: 'font/opentype'});

            	            var link = document.createElement('a');
            	            link.href = window.URL.createObjectURL(blob);
            	            link.download = fileName;

            	            var event = document.createEvent('MouseEvents');
            	            event.initEvent('click', true, false);
            	            link.dispatchEvent(event);
            	        } else {
            	            console.warn('Font file could not be downloaded. Try using a different browser.');
            	        }
            	    } else {
            	        var fs = require$$0;
            	        var buffer = arrayBufferToNodeBuffer(arrayBuffer);
            	        fs.writeFileSync(fileName, buffer);
            	    }
            	};
            	/**
            	 * @private
            	 */
            	Font.prototype.fsSelectionValues = {
            	    ITALIC:              0x001, //1
            	    UNDERSCORE:          0x002, //2
            	    NEGATIVE:            0x004, //4
            	    OUTLINED:            0x008, //8
            	    STRIKEOUT:           0x010, //16
            	    BOLD:                0x020, //32
            	    REGULAR:             0x040, //64
            	    USER_TYPO_METRICS:   0x080, //128
            	    WWS:                 0x100, //256
            	    OBLIQUE:             0x200  //512
            	};

            	/**
            	 * @private
            	 */
            	Font.prototype.usWidthClasses = {
            	    ULTRA_CONDENSED: 1,
            	    EXTRA_CONDENSED: 2,
            	    CONDENSED: 3,
            	    SEMI_CONDENSED: 4,
            	    MEDIUM: 5,
            	    SEMI_EXPANDED: 6,
            	    EXPANDED: 7,
            	    EXTRA_EXPANDED: 8,
            	    ULTRA_EXPANDED: 9
            	};

            	/**
            	 * @private
            	 */
            	Font.prototype.usWeightClasses = {
            	    THIN: 100,
            	    EXTRA_LIGHT: 200,
            	    LIGHT: 300,
            	    NORMAL: 400,
            	    MEDIUM: 500,
            	    SEMI_BOLD: 600,
            	    BOLD: 700,
            	    EXTRA_BOLD: 800,
            	    BLACK:    900
            	};

            	// The `fvar` table stores font variation axes and instances.

            	function addName(name, names) {
            	    var nameString = JSON.stringify(name);
            	    var nameID = 256;
            	    for (var nameKey in names) {
            	        var n = parseInt(nameKey);
            	        if (!n || n < 256) {
            	            continue;
            	        }

            	        if (JSON.stringify(names[nameKey]) === nameString) {
            	            return n;
            	        }

            	        if (nameID <= n) {
            	            nameID = n + 1;
            	        }
            	    }

            	    names[nameID] = name;
            	    return nameID;
            	}

            	function makeFvarAxis(n, axis, names) {
            	    var nameID = addName(axis.name, names);
            	    return [
            	        {name: 'tag_' + n, type: 'TAG', value: axis.tag},
            	        {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},
            	        {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},
            	        {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},
            	        {name: 'flags_' + n, type: 'USHORT', value: 0},
            	        {name: 'nameID_' + n, type: 'USHORT', value: nameID}
            	    ];
            	}

            	function parseFvarAxis(data, start, names) {
            	    var axis = {};
            	    var p = new parse.Parser(data, start);
            	    axis.tag = p.parseTag();
            	    axis.minValue = p.parseFixed();
            	    axis.defaultValue = p.parseFixed();
            	    axis.maxValue = p.parseFixed();
            	    p.skip('uShort', 1);  // reserved for flags; no values defined
            	    axis.name = names[p.parseUShort()] || {};
            	    return axis;
            	}

            	function makeFvarInstance(n, inst, axes, names) {
            	    var nameID = addName(inst.name, names);
            	    var fields = [
            	        {name: 'nameID_' + n, type: 'USHORT', value: nameID},
            	        {name: 'flags_' + n, type: 'USHORT', value: 0}
            	    ];

            	    for (var i = 0; i < axes.length; ++i) {
            	        var axisTag = axes[i].tag;
            	        fields.push({
            	            name: 'axis_' + n + ' ' + axisTag,
            	            type: 'FIXED',
            	            value: inst.coordinates[axisTag] << 16
            	        });
            	    }

            	    return fields;
            	}

            	function parseFvarInstance(data, start, axes, names) {
            	    var inst = {};
            	    var p = new parse.Parser(data, start);
            	    inst.name = names[p.parseUShort()] || {};
            	    p.skip('uShort', 1);  // reserved for flags; no values defined

            	    inst.coordinates = {};
            	    for (var i = 0; i < axes.length; ++i) {
            	        inst.coordinates[axes[i].tag] = p.parseFixed();
            	    }

            	    return inst;
            	}

            	function makeFvarTable(fvar, names) {
            	    var result = new table.Table('fvar', [
            	        {name: 'version', type: 'ULONG', value: 0x10000},
            	        {name: 'offsetToData', type: 'USHORT', value: 0},
            	        {name: 'countSizePairs', type: 'USHORT', value: 2},
            	        {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},
            	        {name: 'axisSize', type: 'USHORT', value: 20},
            	        {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},
            	        {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}
            	    ]);
            	    result.offsetToData = result.sizeOf();

            	    for (var i = 0; i < fvar.axes.length; i++) {
            	        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));
            	    }

            	    for (var j = 0; j < fvar.instances.length; j++) {
            	        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));
            	    }

            	    return result;
            	}

            	function parseFvarTable(data, start, names) {
            	    var p = new parse.Parser(data, start);
            	    var tableVersion = p.parseULong();
            	    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');
            	    var offsetToData = p.parseOffset16();
            	    // Skip countSizePairs.
            	    p.skip('uShort', 1);
            	    var axisCount = p.parseUShort();
            	    var axisSize = p.parseUShort();
            	    var instanceCount = p.parseUShort();
            	    var instanceSize = p.parseUShort();

            	    var axes = [];
            	    for (var i = 0; i < axisCount; i++) {
            	        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));
            	    }

            	    var instances = [];
            	    var instanceStart = start + offsetToData + axisCount * axisSize;
            	    for (var j = 0; j < instanceCount; j++) {
            	        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));
            	    }

            	    return {axes: axes, instances: instances};
            	}

            	var fvar = { make: makeFvarTable, parse: parseFvarTable };

            	// The `GPOS` table contains kerning pairs, among other things.

            	var subtableParsers$1 = new Array(10);         // subtableParsers[0] is unused

            	// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable
            	// this = Parser instance
            	subtableParsers$1[1] = function parseLookup1() {
            	    var start = this.offset + this.relativeOffset;
            	    var posformat = this.parseUShort();
            	    if (posformat === 1) {
            	        return {
            	            posFormat: 1,
            	            coverage: this.parsePointer(Parser.coverage),
            	            value: this.parseValueRecord()
            	        };
            	    } else if (posformat === 2) {
            	        return {
            	            posFormat: 2,
            	            coverage: this.parsePointer(Parser.coverage),
            	            values: this.parseValueRecordList()
            	        };
            	    }
            	    check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 1 format must be 1 or 2.');
            	};

            	// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable
            	subtableParsers$1[2] = function parseLookup2() {
            	    var start = this.offset + this.relativeOffset;
            	    var posFormat = this.parseUShort();
            	    check.assert(posFormat === 1 || posFormat === 2, '0x' + start.toString(16) + ': GPOS lookup type 2 format must be 1 or 2.');
            	    var coverage = this.parsePointer(Parser.coverage);
            	    var valueFormat1 = this.parseUShort();
            	    var valueFormat2 = this.parseUShort();
            	    if (posFormat === 1) {
            	        // Adjustments for Glyph Pairs
            	        return {
            	            posFormat: posFormat,
            	            coverage: coverage,
            	            valueFormat1: valueFormat1,
            	            valueFormat2: valueFormat2,
            	            pairSets: this.parseList(Parser.pointer(Parser.list(function() {
            	                return {        // pairValueRecord
            	                    secondGlyph: this.parseUShort(),
            	                    value1: this.parseValueRecord(valueFormat1),
            	                    value2: this.parseValueRecord(valueFormat2)
            	                };
            	            })))
            	        };
            	    } else if (posFormat === 2) {
            	        var classDef1 = this.parsePointer(Parser.classDef);
            	        var classDef2 = this.parsePointer(Parser.classDef);
            	        var class1Count = this.parseUShort();
            	        var class2Count = this.parseUShort();
            	        return {
            	            // Class Pair Adjustment
            	            posFormat: posFormat,
            	            coverage: coverage,
            	            valueFormat1: valueFormat1,
            	            valueFormat2: valueFormat2,
            	            classDef1: classDef1,
            	            classDef2: classDef2,
            	            class1Count: class1Count,
            	            class2Count: class2Count,
            	            classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {
            	                return {
            	                    value1: this.parseValueRecord(valueFormat1),
            	                    value2: this.parseValueRecord(valueFormat2)
            	                };
            	            }))
            	        };
            	    }
            	};

            	subtableParsers$1[3] = function parseLookup3() { return { error: 'GPOS Lookup 3 not supported' }; };
            	subtableParsers$1[4] = function parseLookup4() { return { error: 'GPOS Lookup 4 not supported' }; };
            	subtableParsers$1[5] = function parseLookup5() { return { error: 'GPOS Lookup 5 not supported' }; };
            	subtableParsers$1[6] = function parseLookup6() { return { error: 'GPOS Lookup 6 not supported' }; };
            	subtableParsers$1[7] = function parseLookup7() { return { error: 'GPOS Lookup 7 not supported' }; };
            	subtableParsers$1[8] = function parseLookup8() { return { error: 'GPOS Lookup 8 not supported' }; };
            	subtableParsers$1[9] = function parseLookup9() { return { error: 'GPOS Lookup 9 not supported' }; };

            	// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos
            	function parseGposTable(data, start) {
            	    start = start || 0;
            	    var p = new Parser(data, start);
            	    var tableVersion = p.parseVersion(1);
            	    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GPOS table version ' + tableVersion);

            	    if (tableVersion === 1) {
            	        return {
            	            version: tableVersion,
            	            scripts: p.parseScriptList(),
            	            features: p.parseFeatureList(),
            	            lookups: p.parseLookupList(subtableParsers$1)
            	        };
            	    } else {
            	        return {
            	            version: tableVersion,
            	            scripts: p.parseScriptList(),
            	            features: p.parseFeatureList(),
            	            lookups: p.parseLookupList(subtableParsers$1),
            	            variations: p.parseFeatureVariationsList()
            	        };
            	    }

            	}

            	// GPOS Writing //////////////////////////////////////////////
            	// NOT SUPPORTED
            	var subtableMakers$1 = new Array(10);

            	function makeGposTable(gpos) {
            	    return new table.Table('GPOS', [
            	        {name: 'version', type: 'ULONG', value: 0x10000},
            	        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gpos.scripts)},
            	        {name: 'features', type: 'TABLE', value: new table.FeatureList(gpos.features)},
            	        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gpos.lookups, subtableMakers$1)}
            	    ]);
            	}

            	var gpos = { parse: parseGposTable, make: makeGposTable };

            	// The `kern` table contains kerning pairs.

            	function parseWindowsKernTable(p) {
            	    var pairs = {};
            	    // Skip nTables.
            	    p.skip('uShort');
            	    var subtableVersion = p.parseUShort();
            	    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');
            	    // Skip subtableLength, subtableCoverage
            	    p.skip('uShort', 2);
            	    var nPairs = p.parseUShort();
            	    // Skip searchRange, entrySelector, rangeShift.
            	    p.skip('uShort', 3);
            	    for (var i = 0; i < nPairs; i += 1) {
            	        var leftIndex = p.parseUShort();
            	        var rightIndex = p.parseUShort();
            	        var value = p.parseShort();
            	        pairs[leftIndex + ',' + rightIndex] = value;
            	    }
            	    return pairs;
            	}

            	function parseMacKernTable(p) {
            	    var pairs = {};
            	    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.
            	    // Skip the rest.
            	    p.skip('uShort');
            	    var nTables = p.parseULong();
            	    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');
            	    if (nTables > 1) {
            	        console.warn('Only the first kern subtable is supported.');
            	    }
            	    p.skip('uLong');
            	    var coverage = p.parseUShort();
            	    var subtableVersion = coverage & 0xFF;
            	    p.skip('uShort');
            	    if (subtableVersion === 0) {
            	        var nPairs = p.parseUShort();
            	        // Skip searchRange, entrySelector, rangeShift.
            	        p.skip('uShort', 3);
            	        for (var i = 0; i < nPairs; i += 1) {
            	            var leftIndex = p.parseUShort();
            	            var rightIndex = p.parseUShort();
            	            var value = p.parseShort();
            	            pairs[leftIndex + ',' + rightIndex] = value;
            	        }
            	    }
            	    return pairs;
            	}

            	// Parse the `kern` table which contains kerning pairs.
            	function parseKernTable(data, start) {
            	    var p = new parse.Parser(data, start);
            	    var tableVersion = p.parseUShort();
            	    if (tableVersion === 0) {
            	        return parseWindowsKernTable(p);
            	    } else if (tableVersion === 1) {
            	        return parseMacKernTable(p);
            	    } else {
            	        throw new Error('Unsupported kern table version (' + tableVersion + ').');
            	    }
            	}

            	var kern = { parse: parseKernTable };

            	// The `loca` table stores the offsets to the locations of the glyphs in the font.

            	// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,
            	// relative to the beginning of the glyphData table.
            	// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)
            	// The loca table has two versions: a short version where offsets are stored as uShorts, and a long
            	// version where offsets are stored as uLongs. The `head` table specifies which version to use
            	// (under indexToLocFormat).
            	function parseLocaTable(data, start, numGlyphs, shortVersion) {
            	    var p = new parse.Parser(data, start);
            	    var parseFn = shortVersion ? p.parseUShort : p.parseULong;
            	    // There is an extra entry after the last index element to compute the length of the last glyph.
            	    // That's why we use numGlyphs + 1.
            	    var glyphOffsets = [];
            	    for (var i = 0; i < numGlyphs + 1; i += 1) {
            	        var glyphOffset = parseFn.call(p);
            	        if (shortVersion) {
            	            // The short table version stores the actual offset divided by 2.
            	            glyphOffset *= 2;
            	        }

            	        glyphOffsets.push(glyphOffset);
            	    }

            	    return glyphOffsets;
            	}

            	var loca = { parse: parseLocaTable };

            	// opentype.js

            	/**
            	 * The opentype library.
            	 * @namespace opentype
            	 */

            	// File loaders /////////////////////////////////////////////////////////
            	/**
            	 * Loads a font from a file. The callback throws an error message as the first parameter if it fails
            	 * and the font as an ArrayBuffer in the second parameter if it succeeds.
            	 * @param  {string} path - The path of the file
            	 * @param  {Function} callback - The function to call when the font load completes
            	 */
            	function loadFromFile(path, callback) {
            	    var fs = require$$0;
            	    fs.readFile(path, function(err, buffer) {
            	        if (err) {
            	            return callback(err.message);
            	        }

            	        callback(null, nodeBufferToArrayBuffer(buffer));
            	    });
            	}
            	/**
            	 * Loads a font from a URL. The callback throws an error message as the first parameter if it fails
            	 * and the font as an ArrayBuffer in the second parameter if it succeeds.
            	 * @param  {string} url - The URL of the font file.
            	 * @param  {Function} callback - The function to call when the font load completes
            	 */
            	function loadFromUrl(url, callback) {
            	    var request = new XMLHttpRequest();
            	    request.open('get', url, true);
            	    request.responseType = 'arraybuffer';
            	    request.onload = function() {
            	        if (request.response) {
            	            return callback(null, request.response);
            	        } else {
            	            return callback('Font could not be loaded: ' + request.statusText);
            	        }
            	    };

            	    request.onerror = function () {
            	        callback('Font could not be loaded');
            	    };

            	    request.send();
            	}

            	// Table Directory Entries //////////////////////////////////////////////
            	/**
            	 * Parses OpenType table entries.
            	 * @param  {DataView}
            	 * @param  {Number}
            	 * @return {Object[]}
            	 */
            	function parseOpenTypeTableEntries(data, numTables) {
            	    var tableEntries = [];
            	    var p = 12;
            	    for (var i = 0; i < numTables; i += 1) {
            	        var tag = parse.getTag(data, p);
            	        var checksum = parse.getULong(data, p + 4);
            	        var offset = parse.getULong(data, p + 8);
            	        var length = parse.getULong(data, p + 12);
            	        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});
            	        p += 16;
            	    }

            	    return tableEntries;
            	}

            	/**
            	 * Parses WOFF table entries.
            	 * @param  {DataView}
            	 * @param  {Number}
            	 * @return {Object[]}
            	 */
            	function parseWOFFTableEntries(data, numTables) {
            	    var tableEntries = [];
            	    var p = 44; // offset to the first table directory entry.
            	    for (var i = 0; i < numTables; i += 1) {
            	        var tag = parse.getTag(data, p);
            	        var offset = parse.getULong(data, p + 4);
            	        var compLength = parse.getULong(data, p + 8);
            	        var origLength = parse.getULong(data, p + 12);
            	        var compression = (void 0);
            	        if (compLength < origLength) {
            	            compression = 'WOFF';
            	        } else {
            	            compression = false;
            	        }

            	        tableEntries.push({tag: tag, offset: offset, compression: compression,
            	            compressedLength: compLength, length: origLength});
            	        p += 20;
            	    }

            	    return tableEntries;
            	}

            	/**
            	 * @typedef TableData
            	 * @type Object
            	 * @property {DataView} data - The DataView
            	 * @property {number} offset - The data offset.
            	 */

            	/**
            	 * @param  {DataView}
            	 * @param  {Object}
            	 * @return {TableData}
            	 */
            	function uncompressTable(data, tableEntry) {
            	    if (tableEntry.compression === 'WOFF') {
            	        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
            	        var outBuffer = new Uint8Array(tableEntry.length);
            	        tinyInflate(inBuffer, outBuffer);
            	        if (outBuffer.byteLength !== tableEntry.length) {
            	            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\'t match recorded length');
            	        }

            	        var view = new DataView(outBuffer.buffer, 0);
            	        return {data: view, offset: 0};
            	    } else {
            	        return {data: data, offset: tableEntry.offset};
            	    }
            	}

            	// Public API ///////////////////////////////////////////////////////////

            	/**
            	 * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
            	 * Throws an error if the font could not be parsed.
            	 * @param  {ArrayBuffer}
            	 * @return {opentype.Font}
            	 */
            	function parseBuffer(buffer) {
            	    var indexToLocFormat;
            	    var ltagTable;

            	    // Since the constructor can also be called to create new fonts from scratch, we indicate this
            	    // should be an empty font that we'll fill with our own data.
            	    var font = new Font({empty: true});

            	    // OpenType fonts use big endian byte ordering.
            	    // We can't rely on typed array view types, because they operate with the endianness of the host computer.
            	    // Instead we use DataViews where we can specify endianness.
            	    var data = new DataView(buffer, 0);
            	    var numTables;
            	    var tableEntries = [];
            	    var signature = parse.getTag(data, 0);
            	    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {
            	        font.outlinesFormat = 'truetype';
            	        numTables = parse.getUShort(data, 4);
            	        tableEntries = parseOpenTypeTableEntries(data, numTables);
            	    } else if (signature === 'OTTO') {
            	        font.outlinesFormat = 'cff';
            	        numTables = parse.getUShort(data, 4);
            	        tableEntries = parseOpenTypeTableEntries(data, numTables);
            	    } else if (signature === 'wOFF') {
            	        var flavor = parse.getTag(data, 4);
            	        if (flavor === String.fromCharCode(0, 1, 0, 0)) {
            	            font.outlinesFormat = 'truetype';
            	        } else if (flavor === 'OTTO') {
            	            font.outlinesFormat = 'cff';
            	        } else {
            	            throw new Error('Unsupported OpenType flavor ' + signature);
            	        }

            	        numTables = parse.getUShort(data, 12);
            	        tableEntries = parseWOFFTableEntries(data, numTables);
            	    } else {
            	        throw new Error('Unsupported OpenType signature ' + signature);
            	    }

            	    var cffTableEntry;
            	    var fvarTableEntry;
            	    var glyfTableEntry;
            	    var gposTableEntry;
            	    var gsubTableEntry;
            	    var hmtxTableEntry;
            	    var kernTableEntry;
            	    var locaTableEntry;
            	    var nameTableEntry;
            	    var metaTableEntry;
            	    var p;

            	    for (var i = 0; i < numTables; i += 1) {
            	        var tableEntry = tableEntries[i];
            	        var table = (void 0);
            	        switch (tableEntry.tag) {
            	            case 'cmap':
            	                table = uncompressTable(data, tableEntry);
            	                font.tables.cmap = cmap.parse(table.data, table.offset);
            	                font.encoding = new CmapEncoding(font.tables.cmap);
            	                break;
            	            case 'cvt ' :
            	                table = uncompressTable(data, tableEntry);
            	                p = new parse.Parser(table.data, table.offset);
            	                font.tables.cvt = p.parseShortList(tableEntry.length / 2);
            	                break;
            	            case 'fvar':
            	                fvarTableEntry = tableEntry;
            	                break;
            	            case 'fpgm' :
            	                table = uncompressTable(data, tableEntry);
            	                p = new parse.Parser(table.data, table.offset);
            	                font.tables.fpgm = p.parseByteList(tableEntry.length);
            	                break;
            	            case 'head':
            	                table = uncompressTable(data, tableEntry);
            	                font.tables.head = head.parse(table.data, table.offset);
            	                font.unitsPerEm = font.tables.head.unitsPerEm;
            	                indexToLocFormat = font.tables.head.indexToLocFormat;
            	                break;
            	            case 'hhea':
            	                table = uncompressTable(data, tableEntry);
            	                font.tables.hhea = hhea.parse(table.data, table.offset);
            	                font.ascender = font.tables.hhea.ascender;
            	                font.descender = font.tables.hhea.descender;
            	                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
            	                break;
            	            case 'hmtx':
            	                hmtxTableEntry = tableEntry;
            	                break;
            	            case 'ltag':
            	                table = uncompressTable(data, tableEntry);
            	                ltagTable = ltag.parse(table.data, table.offset);
            	                break;
            	            case 'maxp':
            	                table = uncompressTable(data, tableEntry);
            	                font.tables.maxp = maxp.parse(table.data, table.offset);
            	                font.numGlyphs = font.tables.maxp.numGlyphs;
            	                break;
            	            case 'name':
            	                nameTableEntry = tableEntry;
            	                break;
            	            case 'OS/2':
            	                table = uncompressTable(data, tableEntry);
            	                font.tables.os2 = os2.parse(table.data, table.offset);
            	                break;
            	            case 'post':
            	                table = uncompressTable(data, tableEntry);
            	                font.tables.post = post.parse(table.data, table.offset);
            	                font.glyphNames = new GlyphNames(font.tables.post);
            	                break;
            	            case 'prep' :
            	                table = uncompressTable(data, tableEntry);
            	                p = new parse.Parser(table.data, table.offset);
            	                font.tables.prep = p.parseByteList(tableEntry.length);
            	                break;
            	            case 'glyf':
            	                glyfTableEntry = tableEntry;
            	                break;
            	            case 'loca':
            	                locaTableEntry = tableEntry;
            	                break;
            	            case 'CFF ':
            	                cffTableEntry = tableEntry;
            	                break;
            	            case 'kern':
            	                kernTableEntry = tableEntry;
            	                break;
            	            case 'GPOS':
            	                gposTableEntry = tableEntry;
            	                break;
            	            case 'GSUB':
            	                gsubTableEntry = tableEntry;
            	                break;
            	            case 'meta':
            	                metaTableEntry = tableEntry;
            	                break;
            	        }
            	    }

            	    var nameTable = uncompressTable(data, nameTableEntry);
            	    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);
            	    font.names = font.tables.name;

            	    if (glyfTableEntry && locaTableEntry) {
            	        var shortVersion = indexToLocFormat === 0;
            	        var locaTable = uncompressTable(data, locaTableEntry);
            	        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
            	        var glyfTable = uncompressTable(data, glyfTableEntry);
            	        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font);
            	    } else if (cffTableEntry) {
            	        var cffTable = uncompressTable(data, cffTableEntry);
            	        cff.parse(cffTable.data, cffTable.offset, font);
            	    } else {
            	        throw new Error('Font doesn\'t contain TrueType or CFF outlines.');
            	    }

            	    var hmtxTable = uncompressTable(data, hmtxTableEntry);
            	    hmtx.parse(hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);
            	    addGlyphNames(font);

            	    if (kernTableEntry) {
            	        var kernTable = uncompressTable(data, kernTableEntry);
            	        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);
            	    } else {
            	        font.kerningPairs = {};
            	    }

            	    if (gposTableEntry) {
            	        var gposTable = uncompressTable(data, gposTableEntry);
            	        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);
            	        font.position.init();
            	    }

            	    if (gsubTableEntry) {
            	        var gsubTable = uncompressTable(data, gsubTableEntry);
            	        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);
            	    }

            	    if (fvarTableEntry) {
            	        var fvarTable = uncompressTable(data, fvarTableEntry);
            	        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);
            	    }

            	    if (metaTableEntry) {
            	        var metaTable = uncompressTable(data, metaTableEntry);
            	        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);
            	        font.metas = font.tables.meta;
            	    }

            	    return font;
            	}

            	/**
            	 * Asynchronously load the font from a URL or a filesystem. When done, call the callback
            	 * with two arguments `(err, font)`. The `err` will be null on success,
            	 * the `font` is a Font object.
            	 * We use the node.js callback convention so that
            	 * opentype.js can integrate with frameworks like async.js.
            	 * @alias opentype.load
            	 * @param  {string} url - The URL of the font to load.
            	 * @param  {Function} callback - The callback.
            	 */
            	function load(url, callback) {
            	    var isNode$$1 = typeof window === 'undefined';
            	    var loadFn = isNode$$1 ? loadFromFile : loadFromUrl;
            	    loadFn(url, function(err, arrayBuffer) {
            	        if (err) {
            	            return callback(err);
            	        }
            	        var font;
            	        try {
            	            font = parseBuffer(arrayBuffer);
            	        } catch (e) {
            	            return callback(e, null);
            	        }
            	        return callback(null, font);
            	    });
            	}

            	/**
            	 * Synchronously load the font from a URL or file.
            	 * When done, returns the font object or throws an error.
            	 * @alias opentype.loadSync
            	 * @param  {string} url - The URL of the font to load.
            	 * @return {opentype.Font}
            	 */
            	function loadSync(url) {
            	    var fs = require$$0;
            	    var buffer = fs.readFileSync(url);
            	    return parseBuffer(nodeBufferToArrayBuffer(buffer));
            	}

            	exports.Font = Font;
            	exports.Glyph = Glyph;
            	exports.Path = Path;
            	exports.BoundingBox = BoundingBox;
            	exports._parse = parse;
            	exports.parse = parseBuffer;
            	exports.load = load;
            	exports.loadSync = loadSync;

            	Object.defineProperty(exports, '__esModule', { value: true });

            })));

            });

            var OpenTypeJs = unwrapExports$4(opentype);

            // Hershey simplex one line font.
            // See: http://paulbourke.net/dataformats/hershey/

            const hersheyPaths = {
              '32': [[null]],
              '33': [
                [null, [5, 21, 0], [5, 7, 0]],
                [null, [5, 2, 0], [4, 1, 0], [5, 0, 0], [6, 1, 0], [5, 2, 0]],
                [null],
              ],
              '34': [
                [null, [4, 21, 0], [4, 14, 0]],
                [null, [12, 21, 0], [12, 14, 0]],
                [null],
              ],
              '35': [
                [null, [11, 25, 0], [4, -7, 0]],
                [null, [17, 25, 0], [10, -7, 0]],
                [null, [4, 12, 0], [18, 12, 0]],
                [null, [3, 6, 0], [17, 6, 0]],
                [null],
              ],
              '36': [
                [null, [8, 25, 0], [8, -4, 0]],
                [null, [12, 25, 0], [12, -4, 0]],
                [
                  null,
                  [17, 18, 0],
                  [15, 20, 0],
                  [12, 21, 0],
                  [8, 21, 0],
                  [5, 20, 0],
                  [3, 18, 0],
                  [3, 16, 0],
                  [4, 14, 0],
                  [5, 13, 0],
                  [7, 12, 0],
                  [13, 10, 0],
                  [15, 9, 0],
                  [16, 8, 0],
                  [17, 6, 0],
                  [17, 3, 0],
                  [15, 1, 0],
                  [12, 0, 0],
                  [8, 0, 0],
                  [5, 1, 0],
                  [3, 3, 0],
                ],
                [null],
              ],
              '37': [
                [null, [21, 21, 0], [3, 0, 0]],
                [
                  null,
                  [8, 21, 0],
                  [10, 19, 0],
                  [10, 17, 0],
                  [9, 15, 0],
                  [7, 14, 0],
                  [5, 14, 0],
                  [3, 16, 0],
                  [3, 18, 0],
                  [4, 20, 0],
                  [6, 21, 0],
                  [8, 21, 0],
                  [10, 20, 0],
                  [13, 19, 0],
                  [16, 19, 0],
                  [19, 20, 0],
                  [21, 21, 0],
                ],
                [
                  null,
                  [17, 7, 0],
                  [15, 6, 0],
                  [14, 4, 0],
                  [14, 2, 0],
                  [16, 0, 0],
                  [18, 0, 0],
                  [20, 1, 0],
                  [21, 3, 0],
                  [21, 5, 0],
                  [19, 7, 0],
                  [17, 7, 0],
                ],
                [null],
              ],
              '38': [
                [
                  null,
                  [23, 12, 0],
                  [23, 13, 0],
                  [22, 14, 0],
                  [21, 14, 0],
                  [20, 13, 0],
                  [19, 11, 0],
                  [17, 6, 0],
                  [15, 3, 0],
                  [13, 1, 0],
                  [11, 0, 0],
                  [7, 0, 0],
                  [5, 1, 0],
                  [4, 2, 0],
                  [3, 4, 0],
                  [3, 6, 0],
                  [4, 8, 0],
                  [5, 9, 0],
                  [12, 13, 0],
                  [13, 14, 0],
                  [14, 16, 0],
                  [14, 18, 0],
                  [13, 20, 0],
                  [11, 21, 0],
                  [9, 20, 0],
                  [8, 18, 0],
                  [8, 16, 0],
                  [9, 13, 0],
                  [11, 10, 0],
                  [16, 3, 0],
                  [18, 1, 0],
                  [20, 0, 0],
                  [22, 0, 0],
                  [23, 1, 0],
                  [23, 2, 0],
                ],
                [null],
              ],
              '39': [
                [
                  null,
                  [5, 19, 0],
                  [4, 20, 0],
                  [5, 21, 0],
                  [6, 20, 0],
                  [6, 18, 0],
                  [5, 16, 0],
                  [4, 15, 0],
                ],
                [null],
              ],
              '40': [
                [
                  null,
                  [11, 25, 0],
                  [9, 23, 0],
                  [7, 20, 0],
                  [5, 16, 0],
                  [4, 11, 0],
                  [4, 7, 0],
                  [5, 2, 0],
                  [7, -2, 0],
                  [9, -5, 0],
                  [11, -7, 0],
                ],
                [null],
              ],
              '41': [
                [
                  null,
                  [3, 25, 0],
                  [5, 23, 0],
                  [7, 20, 0],
                  [9, 16, 0],
                  [10, 11, 0],
                  [10, 7, 0],
                  [9, 2, 0],
                  [7, -2, 0],
                  [5, -5, 0],
                  [3, -7, 0],
                ],
                [null],
              ],
              '42': [
                [null, [8, 21, 0], [8, 9, 0]],
                [null, [3, 18, 0], [13, 12, 0]],
                [null, [13, 18, 0], [3, 12, 0]],
                [null],
              ],
              '43': [
                [null, [13, 18, 0], [13, 0, 0]],
                [null, [4, 9, 0], [22, 9, 0]],
                [null],
              ],
              '44': [
                [
                  null,
                  [6, 1, 0],
                  [5, 0, 0],
                  [4, 1, 0],
                  [5, 2, 0],
                  [6, 1, 0],
                  [6, -1, 0],
                  [5, -3, 0],
                  [4, -4, 0],
                ],
                [null],
              ],
              '45': [[null, [4, 9, 0], [22, 9, 0]], [null]],
              '46': [[null, [5, 2, 0], [4, 1, 0], [5, 0, 0], [6, 1, 0], [5, 2, 0]], [null]],
              '47': [[null, [20, 25, 0], [2, -7, 0]], [null]],
              '48': [
                [
                  null,
                  [9, 21, 0],
                  [6, 20, 0],
                  [4, 17, 0],
                  [3, 12, 0],
                  [3, 9, 0],
                  [4, 4, 0],
                  [6, 1, 0],
                  [9, 0, 0],
                  [11, 0, 0],
                  [14, 1, 0],
                  [16, 4, 0],
                  [17, 9, 0],
                  [17, 12, 0],
                  [16, 17, 0],
                  [14, 20, 0],
                  [11, 21, 0],
                  [9, 21, 0],
                ],
                [null],
              ],
              '49': [[null, [6, 17, 0], [8, 18, 0], [11, 21, 0], [11, 0, 0]], [null]],
              '50': [
                [
                  null,
                  [4, 16, 0],
                  [4, 17, 0],
                  [5, 19, 0],
                  [6, 20, 0],
                  [8, 21, 0],
                  [12, 21, 0],
                  [14, 20, 0],
                  [15, 19, 0],
                  [16, 17, 0],
                  [16, 15, 0],
                  [15, 13, 0],
                  [13, 10, 0],
                  [3, 0, 0],
                  [17, 0, 0],
                ],
                [null],
              ],
              '51': [
                [
                  null,
                  [5, 21, 0],
                  [16, 21, 0],
                  [10, 13, 0],
                  [13, 13, 0],
                  [15, 12, 0],
                  [16, 11, 0],
                  [17, 8, 0],
                  [17, 6, 0],
                  [16, 3, 0],
                  [14, 1, 0],
                  [11, 0, 0],
                  [8, 0, 0],
                  [5, 1, 0],
                  [4, 2, 0],
                  [3, 4, 0],
                ],
                [null],
              ],
              '52': [
                [null, [13, 21, 0], [3, 7, 0], [18, 7, 0]],
                [null, [13, 21, 0], [13, 0, 0]],
                [null],
              ],
              '53': [
                [
                  null,
                  [15, 21, 0],
                  [5, 21, 0],
                  [4, 12, 0],
                  [5, 13, 0],
                  [8, 14, 0],
                  [11, 14, 0],
                  [14, 13, 0],
                  [16, 11, 0],
                  [17, 8, 0],
                  [17, 6, 0],
                  [16, 3, 0],
                  [14, 1, 0],
                  [11, 0, 0],
                  [8, 0, 0],
                  [5, 1, 0],
                  [4, 2, 0],
                  [3, 4, 0],
                ],
                [null],
              ],
              '54': [
                [
                  null,
                  [16, 18, 0],
                  [15, 20, 0],
                  [12, 21, 0],
                  [10, 21, 0],
                  [7, 20, 0],
                  [5, 17, 0],
                  [4, 12, 0],
                  [4, 7, 0],
                  [5, 3, 0],
                  [7, 1, 0],
                  [10, 0, 0],
                  [11, 0, 0],
                  [14, 1, 0],
                  [16, 3, 0],
                  [17, 6, 0],
                  [17, 7, 0],
                  [16, 10, 0],
                  [14, 12, 0],
                  [11, 13, 0],
                  [10, 13, 0],
                  [7, 12, 0],
                  [5, 10, 0],
                  [4, 7, 0],
                ],
                [null],
              ],
              '55': [
                [null, [17, 21, 0], [7, 0, 0]],
                [null, [3, 21, 0], [17, 21, 0]],
                [null],
              ],
              '56': [
                [
                  null,
                  [8, 21, 0],
                  [5, 20, 0],
                  [4, 18, 0],
                  [4, 16, 0],
                  [5, 14, 0],
                  [7, 13, 0],
                  [11, 12, 0],
                  [14, 11, 0],
                  [16, 9, 0],
                  [17, 7, 0],
                  [17, 4, 0],
                  [16, 2, 0],
                  [15, 1, 0],
                  [12, 0, 0],
                  [8, 0, 0],
                  [5, 1, 0],
                  [4, 2, 0],
                  [3, 4, 0],
                  [3, 7, 0],
                  [4, 9, 0],
                  [6, 11, 0],
                  [9, 12, 0],
                  [13, 13, 0],
                  [15, 14, 0],
                  [16, 16, 0],
                  [16, 18, 0],
                  [15, 20, 0],
                  [12, 21, 0],
                  [8, 21, 0],
                ],
                [null],
              ],
              '57': [
                [
                  null,
                  [16, 14, 0],
                  [15, 11, 0],
                  [13, 9, 0],
                  [10, 8, 0],
                  [9, 8, 0],
                  [6, 9, 0],
                  [4, 11, 0],
                  [3, 14, 0],
                  [3, 15, 0],
                  [4, 18, 0],
                  [6, 20, 0],
                  [9, 21, 0],
                  [10, 21, 0],
                  [13, 20, 0],
                  [15, 18, 0],
                  [16, 14, 0],
                  [16, 9, 0],
                  [15, 4, 0],
                  [13, 1, 0],
                  [10, 0, 0],
                  [8, 0, 0],
                  [5, 1, 0],
                  [4, 3, 0],
                ],
                [null],
              ],
              '58': [
                [null, [5, 14, 0], [4, 13, 0], [5, 12, 0], [6, 13, 0], [5, 14, 0]],
                [null, [5, 2, 0], [4, 1, 0], [5, 0, 0], [6, 1, 0], [5, 2, 0]],
                [null],
              ],
              '59': [
                [null, [5, 14, 0], [4, 13, 0], [5, 12, 0], [6, 13, 0], [5, 14, 0]],
                [
                  null,
                  [6, 1, 0],
                  [5, 0, 0],
                  [4, 1, 0],
                  [5, 2, 0],
                  [6, 1, 0],
                  [6, -1, 0],
                  [5, -3, 0],
                  [4, -4, 0],
                ],
                [null],
              ],
              '60': [[null, [20, 18, 0], [4, 9, 0], [20, 0, 0]], [null]],
              '61': [
                [null, [4, 12, 0], [22, 12, 0]],
                [null, [4, 6, 0], [22, 6, 0]],
                [null],
              ],
              '62': [[null, [4, 18, 0], [20, 9, 0], [4, 0, 0]], [null]],
              '63': [
                [
                  null,
                  [3, 16, 0],
                  [3, 17, 0],
                  [4, 19, 0],
                  [5, 20, 0],
                  [7, 21, 0],
                  [11, 21, 0],
                  [13, 20, 0],
                  [14, 19, 0],
                  [15, 17, 0],
                  [15, 15, 0],
                  [14, 13, 0],
                  [13, 12, 0],
                  [9, 10, 0],
                  [9, 7, 0],
                ],
                [null, [9, 2, 0], [8, 1, 0], [9, 0, 0], [10, 1, 0], [9, 2, 0]],
                [null],
              ],
              '64': [
                [
                  null,
                  [18, 13, 0],
                  [17, 15, 0],
                  [15, 16, 0],
                  [12, 16, 0],
                  [10, 15, 0],
                  [9, 14, 0],
                  [8, 11, 0],
                  [8, 8, 0],
                  [9, 6, 0],
                  [11, 5, 0],
                  [14, 5, 0],
                  [16, 6, 0],
                  [17, 8, 0],
                ],
                [
                  null,
                  [12, 16, 0],
                  [10, 14, 0],
                  [9, 11, 0],
                  [9, 8, 0],
                  [10, 6, 0],
                  [11, 5, 0],
                ],
                [
                  null,
                  [18, 16, 0],
                  [17, 8, 0],
                  [17, 6, 0],
                  [19, 5, 0],
                  [21, 5, 0],
                  [23, 7, 0],
                  [24, 10, 0],
                  [24, 12, 0],
                  [23, 15, 0],
                  [22, 17, 0],
                  [20, 19, 0],
                  [18, 20, 0],
                  [15, 21, 0],
                  [12, 21, 0],
                  [9, 20, 0],
                  [7, 19, 0],
                  [5, 17, 0],
                  [4, 15, 0],
                  [3, 12, 0],
                  [3, 9, 0],
                  [4, 6, 0],
                  [5, 4, 0],
                  [7, 2, 0],
                  [9, 1, 0],
                  [12, 0, 0],
                  [15, 0, 0],
                  [18, 1, 0],
                  [20, 2, 0],
                  [21, 3, 0],
                ],
                [null, [19, 16, 0], [18, 8, 0], [18, 6, 0], [19, 5, 0]],
              ],
              '65': [
                [null, [9, 21, 0], [1, 0, 0]],
                [null, [9, 21, 0], [17, 0, 0]],
                [null, [4, 7, 0], [14, 7, 0]],
                [null],
              ],
              '66': [
                [null, [4, 21, 0], [4, 0, 0]],
                [
                  null,
                  [4, 21, 0],
                  [13, 21, 0],
                  [16, 20, 0],
                  [17, 19, 0],
                  [18, 17, 0],
                  [18, 15, 0],
                  [17, 13, 0],
                  [16, 12, 0],
                  [13, 11, 0],
                ],
                [
                  null,
                  [4, 11, 0],
                  [13, 11, 0],
                  [16, 10, 0],
                  [17, 9, 0],
                  [18, 7, 0],
                  [18, 4, 0],
                  [17, 2, 0],
                  [16, 1, 0],
                  [13, 0, 0],
                  [4, 0, 0],
                ],
                [null],
              ],
              '67': [
                [
                  null,
                  [18, 16, 0],
                  [17, 18, 0],
                  [15, 20, 0],
                  [13, 21, 0],
                  [9, 21, 0],
                  [7, 20, 0],
                  [5, 18, 0],
                  [4, 16, 0],
                  [3, 13, 0],
                  [3, 8, 0],
                  [4, 5, 0],
                  [5, 3, 0],
                  [7, 1, 0],
                  [9, 0, 0],
                  [13, 0, 0],
                  [15, 1, 0],
                  [17, 3, 0],
                  [18, 5, 0],
                ],
                [null],
              ],
              '68': [
                [null, [4, 21, 0], [4, 0, 0]],
                [
                  null,
                  [4, 21, 0],
                  [11, 21, 0],
                  [14, 20, 0],
                  [16, 18, 0],
                  [17, 16, 0],
                  [18, 13, 0],
                  [18, 8, 0],
                  [17, 5, 0],
                  [16, 3, 0],
                  [14, 1, 0],
                  [11, 0, 0],
                  [4, 0, 0],
                ],
                [null],
              ],
              '69': [
                [null, [4, 21, 0], [4, 0, 0]],
                [null, [4, 21, 0], [17, 21, 0]],
                [null, [4, 11, 0], [12, 11, 0]],
                [null, [4, 0, 0], [17, 0, 0]],
                [null],
              ],
              '70': [
                [null, [4, 21, 0], [4, 0, 0]],
                [null, [4, 21, 0], [17, 21, 0]],
                [null, [4, 11, 0], [12, 11, 0]],
                [null],
              ],
              '71': [
                [
                  null,
                  [18, 16, 0],
                  [17, 18, 0],
                  [15, 20, 0],
                  [13, 21, 0],
                  [9, 21, 0],
                  [7, 20, 0],
                  [5, 18, 0],
                  [4, 16, 0],
                  [3, 13, 0],
                  [3, 8, 0],
                  [4, 5, 0],
                  [5, 3, 0],
                  [7, 1, 0],
                  [9, 0, 0],
                  [13, 0, 0],
                  [15, 1, 0],
                  [17, 3, 0],
                  [18, 5, 0],
                  [18, 8, 0],
                ],
                [null, [13, 8, 0], [18, 8, 0]],
                [null],
              ],
              '72': [
                [null, [4, 21, 0], [4, 0, 0]],
                [null, [18, 21, 0], [18, 0, 0]],
                [null, [4, 11, 0], [18, 11, 0]],
                [null],
              ],
              '73': [[null, [4, 21, 0], [4, 0, 0]], [null]],
              '74': [
                [
                  null,
                  [12, 21, 0],
                  [12, 5, 0],
                  [11, 2, 0],
                  [10, 1, 0],
                  [8, 0, 0],
                  [6, 0, 0],
                  [4, 1, 0],
                  [3, 2, 0],
                  [2, 5, 0],
                  [2, 7, 0],
                ],
                [null],
              ],
              '75': [
                [null, [4, 21, 0], [4, 0, 0]],
                [null, [18, 21, 0], [4, 7, 0]],
                [null, [9, 12, 0], [18, 0, 0]],
                [null],
              ],
              '76': [[null, [4, 21, 0], [4, 0, 0]], [null, [4, 0, 0], [16, 0, 0]], [null]],
              '77': [
                [null, [4, 21, 0], [4, 0, 0]],
                [null, [4, 21, 0], [12, 0, 0]],
                [null, [20, 21, 0], [12, 0, 0]],
                [null, [20, 21, 0], [20, 0, 0]],
                [null],
              ],
              '78': [
                [null, [4, 21, 0], [4, 0, 0]],
                [null, [4, 21, 0], [18, 0, 0]],
                [null, [18, 21, 0], [18, 0, 0]],
                [null],
              ],
              '79': [
                [
                  null,
                  [9, 21, 0],
                  [7, 20, 0],
                  [5, 18, 0],
                  [4, 16, 0],
                  [3, 13, 0],
                  [3, 8, 0],
                  [4, 5, 0],
                  [5, 3, 0],
                  [7, 1, 0],
                  [9, 0, 0],
                  [13, 0, 0],
                  [15, 1, 0],
                  [17, 3, 0],
                  [18, 5, 0],
                  [19, 8, 0],
                  [19, 13, 0],
                  [18, 16, 0],
                  [17, 18, 0],
                  [15, 20, 0],
                  [13, 21, 0],
                  [9, 21, 0],
                ],
                [null],
              ],
              '80': [
                [null, [4, 21, 0], [4, 0, 0]],
                [
                  null,
                  [4, 21, 0],
                  [13, 21, 0],
                  [16, 20, 0],
                  [17, 19, 0],
                  [18, 17, 0],
                  [18, 14, 0],
                  [17, 12, 0],
                  [16, 11, 0],
                  [13, 10, 0],
                  [4, 10, 0],
                ],
                [null],
              ],
              '81': [
                [
                  null,
                  [9, 21, 0],
                  [7, 20, 0],
                  [5, 18, 0],
                  [4, 16, 0],
                  [3, 13, 0],
                  [3, 8, 0],
                  [4, 5, 0],
                  [5, 3, 0],
                  [7, 1, 0],
                  [9, 0, 0],
                  [13, 0, 0],
                  [15, 1, 0],
                  [17, 3, 0],
                  [18, 5, 0],
                  [19, 8, 0],
                  [19, 13, 0],
                  [18, 16, 0],
                  [17, 18, 0],
                  [15, 20, 0],
                  [13, 21, 0],
                  [9, 21, 0],
                ],
                [null, [12, 4, 0], [18, -2, 0]],
                [null],
              ],
              '82': [
                [null, [4, 21, 0], [4, 0, 0]],
                [
                  null,
                  [4, 21, 0],
                  [13, 21, 0],
                  [16, 20, 0],
                  [17, 19, 0],
                  [18, 17, 0],
                  [18, 15, 0],
                  [17, 13, 0],
                  [16, 12, 0],
                  [13, 11, 0],
                  [4, 11, 0],
                ],
                [null, [11, 11, 0], [18, 0, 0]],
                [null],
              ],
              '83': [
                [
                  null,
                  [17, 18, 0],
                  [15, 20, 0],
                  [12, 21, 0],
                  [8, 21, 0],
                  [5, 20, 0],
                  [3, 18, 0],
                  [3, 16, 0],
                  [4, 14, 0],
                  [5, 13, 0],
                  [7, 12, 0],
                  [13, 10, 0],
                  [15, 9, 0],
                  [16, 8, 0],
                  [17, 6, 0],
                  [17, 3, 0],
                  [15, 1, 0],
                  [12, 0, 0],
                  [8, 0, 0],
                  [5, 1, 0],
                  [3, 3, 0],
                ],
                [null],
              ],
              '84': [
                [null, [8, 21, 0], [8, 0, 0]],
                [null, [1, 21, 0], [15, 21, 0]],
                [null],
              ],
              '85': [
                [
                  null,
                  [4, 21, 0],
                  [4, 6, 0],
                  [5, 3, 0],
                  [7, 1, 0],
                  [10, 0, 0],
                  [12, 0, 0],
                  [15, 1, 0],
                  [17, 3, 0],
                  [18, 6, 0],
                  [18, 21, 0],
                ],
                [null],
              ],
              '86': [[null, [1, 21, 0], [9, 0, 0]], [null, [17, 21, 0], [9, 0, 0]], [null]],
              '87': [
                [null, [2, 21, 0], [7, 0, 0]],
                [null, [12, 21, 0], [7, 0, 0]],
                [null, [12, 21, 0], [17, 0, 0]],
                [null, [22, 21, 0], [17, 0, 0]],
                [null],
              ],
              '88': [
                [null, [3, 21, 0], [17, 0, 0]],
                [null, [17, 21, 0], [3, 0, 0]],
                [null],
              ],
              '89': [
                [null, [1, 21, 0], [9, 11, 0], [9, 0, 0]],
                [null, [17, 21, 0], [9, 11, 0]],
                [null],
              ],
              '90': [
                [null, [17, 21, 0], [3, 0, 0]],
                [null, [3, 21, 0], [17, 21, 0]],
                [null, [3, 0, 0], [17, 0, 0]],
                [null],
              ],
              '91': [
                [null, [4, 25, 0], [4, -7, 0]],
                [null, [5, 25, 0], [5, -7, 0]],
                [null, [4, 25, 0], [11, 25, 0]],
                [null, [4, -7, 0], [11, -7, 0]],
                [null],
              ],
              '92': [[null, [0, 21, 0], [14, -3, 0]], [null]],
              '93': [
                [null, [9, 25, 0], [9, -7, 0]],
                [null, [10, 25, 0], [10, -7, 0]],
                [null, [3, 25, 0], [10, 25, 0]],
                [null, [3, -7, 0], [10, -7, 0]],
                [null],
              ],
              '94': [
                [null, [6, 15, 0], [8, 18, 0], [10, 15, 0]],
                [null, [3, 12, 0], [8, 17, 0], [13, 12, 0]],
                [null, [8, 17, 0], [8, 0, 0]],
                [null],
              ],
              '95': [[null, [0, -2, 0], [16, -2, 0]], [null]],
              '96': [
                [
                  null,
                  [6, 21, 0],
                  [5, 20, 0],
                  [4, 18, 0],
                  [4, 16, 0],
                  [5, 15, 0],
                  [6, 16, 0],
                  [5, 17, 0],
                ],
                [null],
              ],
              '97': [
                [null, [15, 14, 0], [15, 0, 0]],
                [
                  null,
                  [15, 11, 0],
                  [13, 13, 0],
                  [11, 14, 0],
                  [8, 14, 0],
                  [6, 13, 0],
                  [4, 11, 0],
                  [3, 8, 0],
                  [3, 6, 0],
                  [4, 3, 0],
                  [6, 1, 0],
                  [8, 0, 0],
                  [11, 0, 0],
                  [13, 1, 0],
                  [15, 3, 0],
                ],
                [null],
              ],
              '98': [
                [null, [4, 21, 0], [4, 0, 0]],
                [
                  null,
                  [4, 11, 0],
                  [6, 13, 0],
                  [8, 14, 0],
                  [11, 14, 0],
                  [13, 13, 0],
                  [15, 11, 0],
                  [16, 8, 0],
                  [16, 6, 0],
                  [15, 3, 0],
                  [13, 1, 0],
                  [11, 0, 0],
                  [8, 0, 0],
                  [6, 1, 0],
                  [4, 3, 0],
                ],
                [null],
              ],
              '99': [
                [
                  null,
                  [15, 11, 0],
                  [13, 13, 0],
                  [11, 14, 0],
                  [8, 14, 0],
                  [6, 13, 0],
                  [4, 11, 0],
                  [3, 8, 0],
                  [3, 6, 0],
                  [4, 3, 0],
                  [6, 1, 0],
                  [8, 0, 0],
                  [11, 0, 0],
                  [13, 1, 0],
                  [15, 3, 0],
                ],
                [null],
              ],
              '100': [
                [null, [15, 21, 0], [15, 0, 0]],
                [
                  null,
                  [15, 11, 0],
                  [13, 13, 0],
                  [11, 14, 0],
                  [8, 14, 0],
                  [6, 13, 0],
                  [4, 11, 0],
                  [3, 8, 0],
                  [3, 6, 0],
                  [4, 3, 0],
                  [6, 1, 0],
                  [8, 0, 0],
                  [11, 0, 0],
                  [13, 1, 0],
                  [15, 3, 0],
                ],
                [null],
              ],
              '101': [
                [
                  null,
                  [3, 8, 0],
                  [15, 8, 0],
                  [15, 10, 0],
                  [14, 12, 0],
                  [13, 13, 0],
                  [11, 14, 0],
                  [8, 14, 0],
                  [6, 13, 0],
                  [4, 11, 0],
                  [3, 8, 0],
                  [3, 6, 0],
                  [4, 3, 0],
                  [6, 1, 0],
                  [8, 0, 0],
                  [11, 0, 0],
                  [13, 1, 0],
                  [15, 3, 0],
                ],
                [null],
              ],
              '102': [
                [null, [10, 21, 0], [8, 21, 0], [6, 20, 0], [5, 17, 0], [5, 0, 0]],
                [null, [2, 14, 0], [9, 14, 0]],
                [null],
              ],
              '103': [
                [
                  null,
                  [15, 14, 0],
                  [15, -2, 0],
                  [14, -5, 0],
                  [13, -6, 0],
                  [11, -7, 0],
                  [8, -7, 0],
                  [6, -6, 0],
                ],
                [
                  null,
                  [15, 11, 0],
                  [13, 13, 0],
                  [11, 14, 0],
                  [8, 14, 0],
                  [6, 13, 0],
                  [4, 11, 0],
                  [3, 8, 0],
                  [3, 6, 0],
                  [4, 3, 0],
                  [6, 1, 0],
                  [8, 0, 0],
                  [11, 0, 0],
                  [13, 1, 0],
                  [15, 3, 0],
                ],
                [null],
              ],
              '104': [
                [null, [4, 21, 0], [4, 0, 0]],
                [
                  null,
                  [4, 10, 0],
                  [7, 13, 0],
                  [9, 14, 0],
                  [12, 14, 0],
                  [14, 13, 0],
                  [15, 10, 0],
                  [15, 0, 0],
                ],
                [null],
              ],
              '105': [
                [null, [3, 21, 0], [4, 20, 0], [5, 21, 0], [4, 22, 0], [3, 21, 0]],
                [null, [4, 14, 0], [4, 0, 0]],
                [null],
              ],
              '106': [
                [null, [5, 21, 0], [6, 20, 0], [7, 21, 0], [6, 22, 0], [5, 21, 0]],
                [null, [6, 14, 0], [6, -3, 0], [5, -6, 0], [3, -7, 0], [1, -7, 0]],
                [null],
              ],
              '107': [
                [null, [4, 21, 0], [4, 0, 0]],
                [null, [14, 14, 0], [4, 4, 0]],
                [null, [8, 8, 0], [15, 0, 0]],
                [null],
              ],
              '108': [[null, [4, 21, 0], [4, 0, 0]], [null]],
              '109': [
                [null, [4, 14, 0], [4, 0, 0]],
                [
                  null,
                  [4, 10, 0],
                  [7, 13, 0],
                  [9, 14, 0],
                  [12, 14, 0],
                  [14, 13, 0],
                  [15, 10, 0],
                  [15, 0, 0],
                ],
                [
                  null,
                  [15, 10, 0],
                  [18, 13, 0],
                  [20, 14, 0],
                  [23, 14, 0],
                  [25, 13, 0],
                  [26, 10, 0],
                  [26, 0, 0],
                ],
                [null],
              ],
              '110': [
                [null, [4, 14, 0], [4, 0, 0]],
                [
                  null,
                  [4, 10, 0],
                  [7, 13, 0],
                  [9, 14, 0],
                  [12, 14, 0],
                  [14, 13, 0],
                  [15, 10, 0],
                  [15, 0, 0],
                ],
                [null],
              ],
              '111': [
                [
                  null,
                  [8, 14, 0],
                  [6, 13, 0],
                  [4, 11, 0],
                  [3, 8, 0],
                  [3, 6, 0],
                  [4, 3, 0],
                  [6, 1, 0],
                  [8, 0, 0],
                  [11, 0, 0],
                  [13, 1, 0],
                  [15, 3, 0],
                  [16, 6, 0],
                  [16, 8, 0],
                  [15, 11, 0],
                  [13, 13, 0],
                  [11, 14, 0],
                  [8, 14, 0],
                ],
                [null],
              ],
              '112': [
                [null, [4, 14, 0], [4, -7, 0]],
                [
                  null,
                  [4, 11, 0],
                  [6, 13, 0],
                  [8, 14, 0],
                  [11, 14, 0],
                  [13, 13, 0],
                  [15, 11, 0],
                  [16, 8, 0],
                  [16, 6, 0],
                  [15, 3, 0],
                  [13, 1, 0],
                  [11, 0, 0],
                  [8, 0, 0],
                  [6, 1, 0],
                  [4, 3, 0],
                ],
                [null],
              ],
              '113': [
                [null, [15, 14, 0], [15, -7, 0]],
                [
                  null,
                  [15, 11, 0],
                  [13, 13, 0],
                  [11, 14, 0],
                  [8, 14, 0],
                  [6, 13, 0],
                  [4, 11, 0],
                  [3, 8, 0],
                  [3, 6, 0],
                  [4, 3, 0],
                  [6, 1, 0],
                  [8, 0, 0],
                  [11, 0, 0],
                  [13, 1, 0],
                  [15, 3, 0],
                ],
                [null],
              ],
              '114': [
                [null, [4, 14, 0], [4, 0, 0]],
                [null, [4, 8, 0], [5, 11, 0], [7, 13, 0], [9, 14, 0], [12, 14, 0]],
                [null],
              ],
              '115': [
                [
                  null,
                  [14, 11, 0],
                  [13, 13, 0],
                  [10, 14, 0],
                  [7, 14, 0],
                  [4, 13, 0],
                  [3, 11, 0],
                  [4, 9, 0],
                  [6, 8, 0],
                  [11, 7, 0],
                  [13, 6, 0],
                  [14, 4, 0],
                  [14, 3, 0],
                  [13, 1, 0],
                  [10, 0, 0],
                  [7, 0, 0],
                  [4, 1, 0],
                  [3, 3, 0],
                ],
                [null],
              ],
              '116': [
                [null, [5, 21, 0], [5, 4, 0], [6, 1, 0], [8, 0, 0], [10, 0, 0]],
                [null, [2, 14, 0], [9, 14, 0]],
                [null],
              ],
              '117': [
                [
                  null,
                  [4, 14, 0],
                  [4, 4, 0],
                  [5, 1, 0],
                  [7, 0, 0],
                  [10, 0, 0],
                  [12, 1, 0],
                  [15, 4, 0],
                ],
                [null, [15, 14, 0], [15, 0, 0]],
                [null],
              ],
              '118': [
                [null, [2, 14, 0], [8, 0, 0]],
                [null, [14, 14, 0], [8, 0, 0]],
                [null],
              ],
              '119': [
                [null, [3, 14, 0], [7, 0, 0]],
                [null, [11, 14, 0], [7, 0, 0]],
                [null, [11, 14, 0], [15, 0, 0]],
                [null, [19, 14, 0], [15, 0, 0]],
                [null],
              ],
              '120': [
                [null, [3, 14, 0], [14, 0, 0]],
                [null, [14, 14, 0], [3, 0, 0]],
                [null],
              ],
              '121': [
                [null, [2, 14, 0], [8, 0, 0]],
                [
                  null,
                  [14, 14, 0],
                  [8, 0, 0],
                  [6, -4, 0],
                  [4, -6, 0],
                  [2, -7, 0],
                  [1, -7, 0],
                ],
                [null],
              ],
              '122': [
                [null, [14, 14, 0], [3, 0, 0]],
                [null, [3, 14, 0], [14, 14, 0]],
                [null, [3, 0, 0], [14, 0, 0]],
                [null],
              ],
              '123': [
                [
                  null,
                  [9, 25, 0],
                  [7, 24, 0],
                  [6, 23, 0],
                  [5, 21, 0],
                  [5, 19, 0],
                  [6, 17, 0],
                  [7, 16, 0],
                  [8, 14, 0],
                  [8, 12, 0],
                  [6, 10, 0],
                ],
                [
                  null,
                  [7, 24, 0],
                  [6, 22, 0],
                  [6, 20, 0],
                  [7, 18, 0],
                  [8, 17, 0],
                  [9, 15, 0],
                  [9, 13, 0],
                  [8, 11, 0],
                  [4, 9, 0],
                  [8, 7, 0],
                  [9, 5, 0],
                  [9, 3, 0],
                  [8, 1, 0],
                  [7, 0, 0],
                  [6, -2, 0],
                  [6, -4, 0],
                  [7, -6, 0],
                ],
                [
                  null,
                  [6, 8, 0],
                  [8, 6, 0],
                  [8, 4, 0],
                  [7, 2, 0],
                  [6, 1, 0],
                  [5, -1, 0],
                  [5, -3, 0],
                  [6, -5, 0],
                  [7, -6, 0],
                  [9, -7, 0],
                ],
                [null],
              ],
              '124': [[null, [4, 25, 0], [4, -7, 0]], [null]],
              '125': [
                [
                  null,
                  [5, 25, 0],
                  [7, 24, 0],
                  [8, 23, 0],
                  [9, 21, 0],
                  [9, 19, 0],
                  [8, 17, 0],
                  [7, 16, 0],
                  [6, 14, 0],
                  [6, 12, 0],
                  [8, 10, 0],
                ],
                [
                  null,
                  [7, 24, 0],
                  [8, 22, 0],
                  [8, 20, 0],
                  [7, 18, 0],
                  [6, 17, 0],
                  [5, 15, 0],
                  [5, 13, 0],
                  [6, 11, 0],
                  [10, 9, 0],
                  [6, 7, 0],
                  [5, 5, 0],
                  [5, 3, 0],
                  [6, 1, 0],
                  [7, 0, 0],
                  [8, -2, 0],
                  [8, -4, 0],
                  [7, -6, 0],
                ],
                [
                  null,
                  [8, 8, 0],
                  [6, 6, 0],
                  [6, 4, 0],
                  [7, 2, 0],
                  [8, 1, 0],
                  [9, -1, 0],
                  [9, -3, 0],
                  [8, -5, 0],
                  [7, -6, 0],
                  [5, -7, 0],
                ],
                [null],
              ],
              '126': [
                [
                  null,
                  [3, 6, 0],
                  [3, 8, 0],
                  [4, 11, 0],
                  [6, 12, 0],
                  [8, 12, 0],
                  [10, 11, 0],
                  [14, 8, 0],
                  [16, 7, 0],
                  [18, 7, 0],
                  [20, 8, 0],
                  [21, 10, 0],
                ],
                [
                  null,
                  [3, 8, 0],
                  [4, 10, 0],
                  [6, 11, 0],
                  [8, 11, 0],
                  [10, 10, 0],
                  [14, 7, 0],
                  [16, 6, 0],
                  [18, 6, 0],
                  [20, 7, 0],
                  [21, 10, 0],
                  [21, 12, 0],
                ],
                [null],
              ],
            };

            const hersheyWidth = {
              '32': 16,
              '33': 10,
              '34': 16,
              '35': 21,
              '36': 20,
              '37': 24,
              '38': 26,
              '39': 10,
              '40': 14,
              '41': 14,
              '42': 16,
              '43': 26,
              '44': 10,
              '45': 26,
              '46': 10,
              '47': 22,
              '48': 20,
              '49': 20,
              '50': 20,
              '51': 20,
              '52': 20,
              '53': 20,
              '54': 20,
              '55': 20,
              '56': 20,
              '57': 20,
              '58': 10,
              '59': 10,
              '60': 24,
              '61': 26,
              '62': 24,
              '63': 18,
              '64': 27,
              '65': 18,
              '66': 21,
              '67': 21,
              '68': 21,
              '69': 19,
              '70': 18,
              '71': 21,
              '72': 22,
              '73': 8,
              '74': 16,
              '75': 21,
              '76': 17,
              '77': 24,
              '78': 22,
              '79': 22,
              '80': 21,
              '81': 22,
              '82': 21,
              '83': 20,
              '84': 16,
              '85': 22,
              '86': 18,
              '87': 24,
              '88': 20,
              '89': 18,
              '90': 20,
              '91': 14,
              '92': 14,
              '93': 14,
              '94': 16,
              '95': 16,
              '96': 10,
              '97': 19,
              '98': 19,
              '99': 18,
              '100': 19,
              '101': 18,
              '102': 12,
              '103': 19,
              '104': 19,
              '105': 8,
              '106': 10,
              '107': 17,
              '108': 8,
              '109': 30,
              '110': 19,
              '111': 19,
              '112': 19,
              '113': 19,
              '114': 13,
              '115': 17,
              '116': 12,
              '117': 19,
              '118': 16,
              '119': 22,
              '120': 17,
              '121': 16,
              '122': 17,
              '123': 14,
              '124': 8,
              '125': 14,
              '126': 24,
            };

            const toPaths = (letters) => {
              let xOffset = 0;
              const mergedPaths = [];
              for (const letter of letters) {
                const code = letter.charCodeAt(0);
                const paths = hersheyPaths[code] || [];
                mergedPaths.push(...translate$2([xOffset, 0, 0], paths));
                xOffset += hersheyWidth[code] || 0;
              }
              return Shape.fromGeometry({ type: 'paths', paths: mergedPaths }).scale(
                1 / 28
              );
            };

            const ofSize$2 = (size) => (text) => toPaths(text).scale(size);

            const Hershey = (size) => ofSize$2(size);
            Hershey.ofSize = ofSize$2;
            Hershey.toPaths = toPaths;

            var commonjsGlobal$3 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global$1 !== 'undefined' ? global$1 : typeof self !== 'undefined' ? self : {};

            function unwrapExports$5 (x) {
            	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
            }

            function createCommonjsModule$6(fn, module) {
            	return module = { exports: {} }, fn(module, module.exports), module.exports;
            }

            var binPacking = createCommonjsModule$6(function (module, exports) {
            (function (global, factory) {
               factory(exports) ;
            }(commonjsGlobal$3, (function (exports) {
            /******************************************************************************

            This is a binary tree based bin packing algorithm that is more complex than
            the simple Packer (packer.js). Instead of starting off with a fixed width and
            height, it starts with the width and height of the first block passed and then
            grows as necessary to accomodate each subsequent block. As it grows it attempts
            to maintain a roughly square ratio by making 'smart' choices about whether to
            grow right or down.

            When growing, the algorithm can only grow to the right OR down. Therefore, if
            the new block is BOTH wider and taller than the current target then it will be
            rejected. This makes it very important to initialize with a sensible starting
            width and height. If you are providing sorted input (largest first) then this
            will not be an issue.

            A potential way to solve this limitation would be to allow growth in BOTH
            directions at once, but this requires maintaining a more complex tree
            with 3 children (down, right and center) and that complexity can be avoided
            by simply chosing a sensible starting block.

            Best results occur when the input blocks are sorted by height, or even better
            when sorted by max(width,height).

            Inputs:
            ------

              blocks: array of any objects that have .w and .h attributes

            Outputs:
            -------

              marks each block that fits with a .fit attribute pointing to a
              node with .x and .y coordinates

            Example:
            -------

              var blocks = [
                { w: 100, h: 100 },
                { w: 100, h: 100 },
                { w:  80, h:  80 },
                { w:  80, h:  80 },
                etc
                etc
              ];

              var packer = new GrowingPacker();
              packer.fit(blocks);

              for(var n = 0 ; n < blocks.length ; n++) {
                var block = blocks[n];
                if (block.fit) {
                  Draw(block.fit.x, block.fit.y, block.w, block.h);
                }
              }


            ******************************************************************************/

            function GrowingPacker() {}

            GrowingPacker.prototype = {

              fit: function fit(blocks) {
                var n,
                    node,
                    block,
                    len = blocks.length;
                var w = len > 0 ? blocks[0].w : 0;
                var h = len > 0 ? blocks[0].h : 0;
                this.root = { x: 0, y: 0, w: w, h: h };
                for (n = 0; n < len; n++) {
                  block = blocks[n];
                  if (node = this.findNode(this.root, block.w, block.h)) block.fit = this.splitNode(node, block.w, block.h);else block.fit = this.growNode(block.w, block.h);
                }
              },

              findNode: function findNode(root, w, h) {
                if (root.used) return this.findNode(root.right, w, h) || this.findNode(root.down, w, h);else if (w <= root.w && h <= root.h) return root;else return null;
              },

              splitNode: function splitNode(node, w, h) {
                node.used = true;
                node.down = { x: node.x, y: node.y + h, w: node.w, h: node.h - h };
                node.right = { x: node.x + w, y: node.y, w: node.w - w, h: h };
                return node;
              },

              growNode: function growNode(w, h) {
                var canGrowDown = w <= this.root.w;
                var canGrowRight = h <= this.root.h;

                var shouldGrowRight = canGrowRight && this.root.h >= this.root.w + w; // attempt to keep square-ish by growing right when height is much greater than width
                var shouldGrowDown = canGrowDown && this.root.w >= this.root.h + h; // attempt to keep square-ish by growing down  when width  is much greater than height

                if (shouldGrowRight) return this.growRight(w, h);else if (shouldGrowDown) return this.growDown(w, h);else if (canGrowRight) return this.growRight(w, h);else if (canGrowDown) return this.growDown(w, h);else return null; // need to ensure sensible root starting size to avoid this happening
              },

              growRight: function growRight(w, h) {
                var node;
                this.root = {
                  used: true,
                  x: 0,
                  y: 0,
                  w: this.root.w + w,
                  h: this.root.h,
                  down: this.root,
                  right: { x: this.root.w, y: 0, w: w, h: this.root.h }
                };
                if (node = this.findNode(this.root, w, h)) return this.splitNode(node, w, h);else return null;
              },

              growDown: function growDown(w, h) {
                var node;
                this.root = {
                  used: true,
                  x: 0,
                  y: 0,
                  w: this.root.w,
                  h: this.root.h + h,
                  down: { x: 0, y: this.root.h, w: this.root.w, h: h },
                  right: this.root
                };
                if (node = this.findNode(this.root, w, h)) return this.splitNode(node, w, h);else return null;
              }

            };

            /******************************************************************************

            This is a very simple binary tree based bin packing algorithm that is initialized
            with a fixed width and height and will fit each block into the first node where
            it fits and then split that node into 2 parts (down and right) to track the
            remaining whitespace.

            Best results occur when the input blocks are sorted by height, or even better
            when sorted by max(width,height).

            Inputs:
            ------

              w:       width of target rectangle
              h:      height of target rectangle
              blocks: array of any objects that have .w and .h attributes

            Outputs:
            -------

              marks each block that fits with a .fit attribute pointing to a
              node with .x and .y coordinates

            Example:
            -------

              var blocks = [
                { w: 100, h: 100 },
                { w: 100, h: 100 },
                { w:  80, h:  80 },
                { w:  80, h:  80 },
                etc
                etc
              ];

              var packer = new Packer(500, 500);
              packer.fit(blocks);

              for(var n = 0 ; n < blocks.length ; n++) {
                var block = blocks[n];
                if (block.fit) {
                  Draw(block.fit.x, block.fit.y, block.w, block.h);
                }
              }


            ******************************************************************************/

            function Packer(w, h) {
              this.init(w, h);
            }

            Packer.prototype = {

              init: function init(w, h) {
                this.root = { x: 0, y: 0, w: w, h: h };
              },

              fit: function fit(blocks) {
                var n, node, block;
                for (n = 0; n < blocks.length; n++) {
                  block = blocks[n];
                  if (node = this.findNode(this.root, block.w, block.h)) block.fit = this.splitNode(node, block.w, block.h);
                }
              },

              findNode: function findNode(root, w, h) {
                if (root.used) return this.findNode(root.right, w, h) || this.findNode(root.down, w, h);else if (w <= root.w && h <= root.h) return root;else return null;
              },

              splitNode: function splitNode(node, w, h) {
                node.used = true;
                node.down = { x: node.x, y: node.y + h, w: node.w, h: node.h - h };
                node.right = { x: node.x + w, y: node.y, w: node.w - w, h: h };
                return node;
              }

            };

            exports.GrowingPacker = GrowingPacker;
            exports.Packer = Packer;

            Object.defineProperty(exports, '__esModule', { value: true });

            })));

            });

            var BinPackingEs = unwrapExports$5(binPacking);

            const { GrowingPacker, Packer } = BinPackingEs;

            const X$b = 0;
            const Y$b = 1;

            const measureSize = (geometry) => {
              const [min, max] = measureBoundingBox$4(geometry);
              const width = max[X$b] - min[X$b];
              const height = max[Y$b] - min[Y$b];
              return [width, height];
            };

            const measureOrigin = (geometry) => {
              const [min] = measureBoundingBox$4(geometry);
              const [x, y] = min;
              return [x, y];
            };

            const measureOffsets = (size, pageMargin) => {
              if (size) {
                const [width, height] = size;

                // Center the output to match pages.
                const xOffset = width / -2;
                const yOffset = height / -2;
                const packer = new Packer(width - pageMargin * 2, height - pageMargin * 2);

                return [xOffset, yOffset, packer];
              } else {
                const packer = new GrowingPacker();
                return [0, 0, packer];
              }
            };

            const pack = (
              { size, itemMargin = 1, pageMargin = 5 },
              ...geometries
            ) => {
              const [xOffset, yOffset, packer] = measureOffsets(size, pageMargin);

              const packedGeometries = [];
              const unpackedGeometries = [];

              const blocks = [];

              for (const geometry of geometries) {
                const [width, height] = measureSize(geometry);
                if (!isFinite(width) || !isFinite(height)) {
                  continue;
                }
                const [w, h] = [width + itemMargin * 2, height + itemMargin * 2];
                blocks.push({ w, h, geometry });
              }

              // Place largest cells first
              blocks.sort((a, b) => 0 - Math.max(a.w, a.h) + Math.max(b.w, b.h));

              packer.fit(blocks);

              let minPoint = [Infinity, Infinity, 0];
              let maxPoint = [-Infinity, -Infinity, 0];

              for (const { geometry, fit } of blocks) {
                if (fit && fit.used) {
                  const [x, y] = measureOrigin(geometry);
                  const xo = 0 + xOffset + (fit.x - x + itemMargin + pageMargin);
                  const yo = 0 + yOffset + (fit.y - y + itemMargin + pageMargin);
                  minPoint = min([fit.x + xOffset, fit.y + yOffset, 0], minPoint);
                  maxPoint = max(
                    [fit.x + xOffset + fit.w, fit.y + yOffset + fit.h, 0],
                    maxPoint
                  );
                  const transformed = toKeptGeometry(translate$4([xo, yo, 0], geometry));
                  packedGeometries.push(transformed);
                } else {
                  unpackedGeometries.push(geometry);
                }
              }

              return [packedGeometries, unpackedGeometries, minPoint, maxPoint];
            };

            const pack$1 = (
              shape,
              { size, pageMargin = 5, itemMargin = 1, perLayout = Infinity, packSize = [] }
            ) => {
              if (perLayout === 0) {
                // Packing was disabled -- do nothing.
                return shape;
              }

              let todo = [];
              for (const leaf of getLeafs(shape.toKeptGeometry())) {
                todo.push(leaf);
              }
              const packedLayers = [];
              while (todo.length > 0) {
                const input = [];
                while (todo.length > 0 && input.length < perLayout) {
                  input.push(todo.shift());
                }
                const [packed, unpacked, minPoint, maxPoint] = pack(
                  { size, pageMargin, itemMargin },
                  ...input
                );
                packSize[0] = minPoint;
                packSize[1] = maxPoint;
                if (packed.length === 0) {
                  break;
                } else {
                  packedLayers.push(
                    taggedItem(
                      {},
                      taggedDisjointAssembly({}, ...packed.map(toDisjointGeometry))
                    )
                  );
                }
                todo.unshift(...unpacked);
              }
              let packedShape = Shape.fromGeometry(taggedLayers({}, ...packedLayers));
              if (size === undefined) {
                packedShape = packedShape.center({
                  centerX: true,
                  centerY: true,
                  centerZ: false,
                });
              }
              return packedShape;
            };

            const packMethod = function (...args) {
              return pack$1(this, ...args);
            };
            Shape.prototype.pack = packMethod;

            const MIN$3 = 0;
            const MAX = 1;
            const X$c = 0;
            const Y$c = 1;

            const getItemNames = (geometry) => {
              const names = new Set();
              const op = (geometry, descend) => {
                if (
                  geometry.type === 'item' &&
                  isNotVoid(geometry) &&
                  geometry.tags &&
                  geometry.tags.some((tag) => tag.startsWith('item/'))
                ) {
                  geometry.tags
                    .filter((tag) => tag.startsWith('item/'))
                    .forEach((tag) => names.add(tag.substring(5)));
                } else {
                  descend();
                }
              };
              visit(geometry, op);
              return [...names].sort();
            };

            const buildLayoutGeometry = ({
              layer,
              packSize,
              pageWidth,
              pageLength,
              margin,
            }) => {
              const itemNames = getItemNames(layer);
              const labelScale = 0.0125 * 5;
              const size = [pageWidth, pageLength];
              const r = (v) => Math.floor(v * 100) / 100;
              const title = `${r(pageWidth)} x ${r(pageLength)} : ${itemNames.join(', ')}`;
              const visualization = Square(
                Math.max(pageWidth, margin),
                Math.max(pageLength, margin)
              )
                .outline()
                .with(
                  Hershey(max$1(pageWidth, pageLength) * labelScale)(title).move(
                    pageWidth / -2,
                    (pageLength * (1 + labelScale)) / 2
                  )
                )
                .color('red')
                .Sketch()
                .toGeometry();
              return taggedLayout(
                { size, margin, title, marks: packSize },
                layer,
                visualization
              );
            };

            const Page = (
              {
                size,
                pageMargin = 5,
                itemMargin = 1,
                itemsPerPage = Infinity,
                pack: pack$1$1 = true,
              },
              ...shapes
            ) => {
              const margin = itemMargin;
              const layers = [];
              for (const shape of shapes) {
                for (const leaf of getLeafs(shape.toDisjointGeometry())) {
                  layers.push(leaf);
                }
              }
              if (!pack$1$1) {
                const layer = taggedLayers({}, ...layers);
                const packSize = measureBoundingBox$4(layer);
                const pageWidth = packSize[MAX][X$c] - packSize[MIN$3][X$c];
                const pageLength = packSize[MAX][Y$c] - packSize[MIN$3][Y$c];
                return Shape.fromGeometry(
                  buildLayoutGeometry({ layer, packSize, pageWidth, pageLength, margin })
                );
              } else if (size) {
                // Content fits to page size.
                const packSize = [];
                const content = pack$1(Shape.fromGeometry(taggedLayers({}, ...layers)), {
                  size,
                  pageMargin,
                  itemMargin,
                  perLayout: itemsPerPage,
                  packSize,
                });
                if (packSize.length === 0) {
                  throw Error('Packing failed');
                }
                const pageWidth = packSize[MAX][X$c] - packSize[MIN$3][X$c];
                const pageLength = packSize[MAX][Y$c] - packSize[MIN$3][Y$c];
                const plans = [];
                for (const layer of content.toDisjointGeometry().content[0].content) {
                  plans.push(
                    buildLayoutGeometry({ layer, packSize, pageWidth, pageLength, margin })
                  );
                }
                return Shape.fromGeometry(taggedLayers({}, ...plans)).canonicalize();
              } else {
                const packSize = [];
                // Page fits to content size.
                const content = pack$1(Shape.fromGeometry(taggedLayers({}, ...layers)), {
                  pageMargin,
                  itemMargin,
                  perLayout: itemsPerPage,
                  packSize,
                });
                if (packSize.length === 0) {
                  throw Error('Packing failed');
                }
                // FIX: Using content.size() loses the margin, which is a problem for repacking.
                // Probably page plans should be generated by pack and count toward the size.
                const pageWidth = packSize[MAX][X$c] - packSize[MIN$3][X$c];
                const pageLength = packSize[MAX][Y$c] - packSize[MIN$3][Y$c];
                if (isFinite(pageWidth) && isFinite(pageLength)) {
                  const plans = [];
                  for (const layer of content.toDisjointGeometry().content[0].content) {
                    const layoutGeometry = buildLayoutGeometry({
                      layer,
                      packSize,
                      pageWidth,
                      pageLength,
                      margin,
                    });
                    Shape.fromGeometry(layoutGeometry).canonicalize();
                    plans.push(layoutGeometry);
                  }
                  return Shape.fromGeometry(taggedLayers({}, ...plans));
                } else {
                  return Empty().canonicalize();
                }
              }
            };

            const PageMethod = function (options = {}) {
              return Page(options, this);
            };
            Shape.prototype.Page = PageMethod;

            const ensurePages = (geometry, depth = 0) => {
              const pages = getLayouts(geometry);
              if (pages.length === 0 && depth === 0) {
                return ensurePages(
                  Page({}, Shape.fromGeometry(geometry)).toDisjointGeometry(),
                  depth + 1
                );
              } else {
                return pages;
              }
            };

            const Z$9 = 2;

            // TODO: Radial distortion rather than just lift?
            const arch = (shape, factor, { resolution = 1 } = {}) => {
              const assembly = [];
              for (const { solid, tags } of getSolids(shape.toKeptGeometry())) {
                const [min, max] = measureBoundingBox$3(solid);
                const maxZ = max[Z$9];
                const minZ = min[Z$9];
                const height = maxZ - minZ;
                const liftAt = (z) => factor * Math.sin(((z - minZ) / height) * Math.PI);
                const lift = ([x, y, z]) => [x + liftAt(z), y, z];
                assembly.push(
                  taggedSolid(
                    { tags },
                    deform(makeWatertight$1(solid), lift, min, max, resolution)
                  )
                );
              }

              return Shape.fromGeometry(taggedAssembly({}, ...assembly));
            };

            const archMethod = function (...args) {
              return arch(this, ...args);
            };
            Shape.prototype.arch = archMethod;

            function unwrapExports$6 (x) {
            	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
            }

            function createCommonjsModule$7(fn, module) {
            	return module = { exports: {} }, fn(module, module.exports), module.exports;
            }

            var constants$2 = createCommonjsModule$7(function (module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.NORM_2D = 1.0 / 47.0;
            exports.NORM_3D = 1.0 / 103.0;
            exports.NORM_4D = 1.0 / 30.0;
            exports.SQUISH_2D = (Math.sqrt(2 + 1) - 1) / 2;
            exports.SQUISH_3D = (Math.sqrt(3 + 1) - 1) / 3;
            exports.SQUISH_4D = (Math.sqrt(4 + 1) - 1) / 4;
            exports.STRETCH_2D = (1 / Math.sqrt(2 + 1) - 1) / 2;
            exports.STRETCH_3D = (1 / Math.sqrt(3 + 1) - 1) / 3;
            exports.STRETCH_4D = (1 / Math.sqrt(4 + 1) - 1) / 4;
            exports.base2D = [
                [1, 1, 0, 1, 0, 1, 0, 0, 0],
                [1, 1, 0, 1, 0, 1, 2, 1, 1]
            ];
            exports.base3D = [
                [0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1],
                [2, 1, 1, 0, 2, 1, 0, 1, 2, 0, 1, 1, 3, 1, 1, 1],
                [1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 2, 1, 1, 0, 2, 1, 0, 1, 2, 0, 1, 1]
            ];
            exports.base4D = [
                [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1],
                [3, 1, 1, 1, 0, 3, 1, 1, 0, 1, 3, 1, 0, 1, 1, 3, 0, 1, 1, 1, 4, 1, 1, 1, 1],
                [
                    1,
                    1,
                    0,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    0,
                    1,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1,
                    2,
                    1,
                    1,
                    0,
                    0,
                    2,
                    1,
                    0,
                    1,
                    0,
                    2,
                    1,
                    0,
                    0,
                    1,
                    2,
                    0,
                    1,
                    1,
                    0,
                    2,
                    0,
                    1,
                    0,
                    1,
                    2,
                    0,
                    0,
                    1,
                    1
                ],
                [
                    3,
                    1,
                    1,
                    1,
                    0,
                    3,
                    1,
                    1,
                    0,
                    1,
                    3,
                    1,
                    0,
                    1,
                    1,
                    3,
                    0,
                    1,
                    1,
                    1,
                    2,
                    1,
                    1,
                    0,
                    0,
                    2,
                    1,
                    0,
                    1,
                    0,
                    2,
                    1,
                    0,
                    0,
                    1,
                    2,
                    0,
                    1,
                    1,
                    0,
                    2,
                    0,
                    1,
                    0,
                    1,
                    2,
                    0,
                    0,
                    1,
                    1
                ]
            ];
            exports.gradients2D = [
                5,
                2,
                2,
                5,
                -5,
                2,
                -2,
                5,
                5,
                -2,
                2,
                -5,
                -5,
                -2,
                -2,
                -5
            ];
            exports.gradients3D = [
                -11,
                4,
                4,
                -4,
                11,
                4,
                -4,
                4,
                11,
                11,
                4,
                4,
                4,
                11,
                4,
                4,
                4,
                11,
                -11,
                -4,
                4,
                -4,
                -11,
                4,
                -4,
                -4,
                11,
                11,
                -4,
                4,
                4,
                -11,
                4,
                4,
                -4,
                11,
                -11,
                4,
                -4,
                -4,
                11,
                -4,
                -4,
                4,
                -11,
                11,
                4,
                -4,
                4,
                11,
                -4,
                4,
                4,
                -11,
                -11,
                -4,
                -4,
                -4,
                -11,
                -4,
                -4,
                -4,
                -11,
                11,
                -4,
                -4,
                4,
                -11,
                -4,
                4,
                -4,
                -11
            ];
            exports.gradients4D = [
                3,
                1,
                1,
                1,
                1,
                3,
                1,
                1,
                1,
                1,
                3,
                1,
                1,
                1,
                1,
                3,
                -3,
                1,
                1,
                1,
                -1,
                3,
                1,
                1,
                -1,
                1,
                3,
                1,
                -1,
                1,
                1,
                3,
                3,
                -1,
                1,
                1,
                1,
                -3,
                1,
                1,
                1,
                -1,
                3,
                1,
                1,
                -1,
                1,
                3,
                -3,
                -1,
                1,
                1,
                -1,
                -3,
                1,
                1,
                -1,
                -1,
                3,
                1,
                -1,
                -1,
                1,
                3,
                3,
                1,
                -1,
                1,
                1,
                3,
                -1,
                1,
                1,
                1,
                -3,
                1,
                1,
                1,
                -1,
                3,
                -3,
                1,
                -1,
                1,
                -1,
                3,
                -1,
                1,
                -1,
                1,
                -3,
                1,
                -1,
                1,
                -1,
                3,
                3,
                -1,
                -1,
                1,
                1,
                -3,
                -1,
                1,
                1,
                -1,
                -3,
                1,
                1,
                -1,
                -1,
                3,
                -3,
                -1,
                -1,
                1,
                -1,
                -3,
                -1,
                1,
                -1,
                -1,
                -3,
                1,
                -1,
                -1,
                -1,
                3,
                3,
                1,
                1,
                -1,
                1,
                3,
                1,
                -1,
                1,
                1,
                3,
                -1,
                1,
                1,
                1,
                -3,
                -3,
                1,
                1,
                -1,
                -1,
                3,
                1,
                -1,
                -1,
                1,
                3,
                -1,
                -1,
                1,
                1,
                -3,
                3,
                -1,
                1,
                -1,
                1,
                -3,
                1,
                -1,
                1,
                -1,
                3,
                -1,
                1,
                -1,
                1,
                -3,
                -3,
                -1,
                1,
                -1,
                -1,
                -3,
                1,
                -1,
                -1,
                -1,
                3,
                -1,
                -1,
                -1,
                1,
                -3,
                3,
                1,
                -1,
                -1,
                1,
                3,
                -1,
                -1,
                1,
                1,
                -3,
                -1,
                1,
                1,
                -1,
                -3,
                -3,
                1,
                -1,
                -1,
                -1,
                3,
                -1,
                -1,
                -1,
                1,
                -3,
                -1,
                -1,
                1,
                -1,
                -3,
                3,
                -1,
                -1,
                -1,
                1,
                -3,
                -1,
                -1,
                1,
                -1,
                -3,
                -1,
                1,
                -1,
                -1,
                -3,
                -3,
                -1,
                -1,
                -1,
                -1,
                -3,
                -1,
                -1,
                -1,
                -1,
                -3,
                -1,
                -1,
                -1,
                -1,
                -3
            ];
            exports.lookupPairs2D = [
                0,
                1,
                1,
                0,
                4,
                1,
                17,
                0,
                20,
                2,
                21,
                2,
                22,
                5,
                23,
                5,
                26,
                4,
                39,
                3,
                42,
                4,
                43,
                3
            ];
            exports.lookupPairs3D = [
                0,
                2,
                1,
                1,
                2,
                2,
                5,
                1,
                6,
                0,
                7,
                0,
                32,
                2,
                34,
                2,
                129,
                1,
                133,
                1,
                160,
                5,
                161,
                5,
                518,
                0,
                519,
                0,
                546,
                4,
                550,
                4,
                645,
                3,
                647,
                3,
                672,
                5,
                673,
                5,
                674,
                4,
                677,
                3,
                678,
                4,
                679,
                3,
                680,
                13,
                681,
                13,
                682,
                12,
                685,
                14,
                686,
                12,
                687,
                14,
                712,
                20,
                714,
                18,
                809,
                21,
                813,
                23,
                840,
                20,
                841,
                21,
                1198,
                19,
                1199,
                22,
                1226,
                18,
                1230,
                19,
                1325,
                23,
                1327,
                22,
                1352,
                15,
                1353,
                17,
                1354,
                15,
                1357,
                17,
                1358,
                16,
                1359,
                16,
                1360,
                11,
                1361,
                10,
                1362,
                11,
                1365,
                10,
                1366,
                9,
                1367,
                9,
                1392,
                11,
                1394,
                11,
                1489,
                10,
                1493,
                10,
                1520,
                8,
                1521,
                8,
                1878,
                9,
                1879,
                9,
                1906,
                7,
                1910,
                7,
                2005,
                6,
                2007,
                6,
                2032,
                8,
                2033,
                8,
                2034,
                7,
                2037,
                6,
                2038,
                7,
                2039,
                6
            ];
            exports.lookupPairs4D = [
                0,
                3,
                1,
                2,
                2,
                3,
                5,
                2,
                6,
                1,
                7,
                1,
                8,
                3,
                9,
                2,
                10,
                3,
                13,
                2,
                16,
                3,
                18,
                3,
                22,
                1,
                23,
                1,
                24,
                3,
                26,
                3,
                33,
                2,
                37,
                2,
                38,
                1,
                39,
                1,
                41,
                2,
                45,
                2,
                54,
                1,
                55,
                1,
                56,
                0,
                57,
                0,
                58,
                0,
                59,
                0,
                60,
                0,
                61,
                0,
                62,
                0,
                63,
                0,
                256,
                3,
                258,
                3,
                264,
                3,
                266,
                3,
                272,
                3,
                274,
                3,
                280,
                3,
                282,
                3,
                2049,
                2,
                2053,
                2,
                2057,
                2,
                2061,
                2,
                2081,
                2,
                2085,
                2,
                2089,
                2,
                2093,
                2,
                2304,
                9,
                2305,
                9,
                2312,
                9,
                2313,
                9,
                16390,
                1,
                16391,
                1,
                16406,
                1,
                16407,
                1,
                16422,
                1,
                16423,
                1,
                16438,
                1,
                16439,
                1,
                16642,
                8,
                16646,
                8,
                16658,
                8,
                16662,
                8,
                18437,
                6,
                18439,
                6,
                18469,
                6,
                18471,
                6,
                18688,
                9,
                18689,
                9,
                18690,
                8,
                18693,
                6,
                18694,
                8,
                18695,
                6,
                18696,
                9,
                18697,
                9,
                18706,
                8,
                18710,
                8,
                18725,
                6,
                18727,
                6,
                131128,
                0,
                131129,
                0,
                131130,
                0,
                131131,
                0,
                131132,
                0,
                131133,
                0,
                131134,
                0,
                131135,
                0,
                131352,
                7,
                131354,
                7,
                131384,
                7,
                131386,
                7,
                133161,
                5,
                133165,
                5,
                133177,
                5,
                133181,
                5,
                133376,
                9,
                133377,
                9,
                133384,
                9,
                133385,
                9,
                133400,
                7,
                133402,
                7,
                133417,
                5,
                133421,
                5,
                133432,
                7,
                133433,
                5,
                133434,
                7,
                133437,
                5,
                147510,
                4,
                147511,
                4,
                147518,
                4,
                147519,
                4,
                147714,
                8,
                147718,
                8,
                147730,
                8,
                147734,
                8,
                147736,
                7,
                147738,
                7,
                147766,
                4,
                147767,
                4,
                147768,
                7,
                147770,
                7,
                147774,
                4,
                147775,
                4,
                149509,
                6,
                149511,
                6,
                149541,
                6,
                149543,
                6,
                149545,
                5,
                149549,
                5,
                149558,
                4,
                149559,
                4,
                149561,
                5,
                149565,
                5,
                149566,
                4,
                149567,
                4,
                149760,
                9,
                149761,
                9,
                149762,
                8,
                149765,
                6,
                149766,
                8,
                149767,
                6,
                149768,
                9,
                149769,
                9,
                149778,
                8,
                149782,
                8,
                149784,
                7,
                149786,
                7,
                149797,
                6,
                149799,
                6,
                149801,
                5,
                149805,
                5,
                149814,
                4,
                149815,
                4,
                149816,
                7,
                149817,
                5,
                149818,
                7,
                149821,
                5,
                149822,
                4,
                149823,
                4,
                149824,
                37,
                149825,
                37,
                149826,
                36,
                149829,
                34,
                149830,
                36,
                149831,
                34,
                149832,
                37,
                149833,
                37,
                149842,
                36,
                149846,
                36,
                149848,
                35,
                149850,
                35,
                149861,
                34,
                149863,
                34,
                149865,
                33,
                149869,
                33,
                149878,
                32,
                149879,
                32,
                149880,
                35,
                149881,
                33,
                149882,
                35,
                149885,
                33,
                149886,
                32,
                149887,
                32,
                150080,
                49,
                150082,
                48,
                150088,
                49,
                150098,
                48,
                150104,
                47,
                150106,
                47,
                151873,
                46,
                151877,
                45,
                151881,
                46,
                151909,
                45,
                151913,
                44,
                151917,
                44,
                152128,
                49,
                152129,
                46,
                152136,
                49,
                152137,
                46,
                166214,
                43,
                166215,
                42,
                166230,
                43,
                166247,
                42,
                166262,
                41,
                166263,
                41,
                166466,
                48,
                166470,
                43,
                166482,
                48,
                166486,
                43,
                168261,
                45,
                168263,
                42,
                168293,
                45,
                168295,
                42,
                168512,
                31,
                168513,
                28,
                168514,
                31,
                168517,
                28,
                168518,
                25,
                168519,
                25,
                280952,
                40,
                280953,
                39,
                280954,
                40,
                280957,
                39,
                280958,
                38,
                280959,
                38,
                281176,
                47,
                281178,
                47,
                281208,
                40,
                281210,
                40,
                282985,
                44,
                282989,
                44,
                283001,
                39,
                283005,
                39,
                283208,
                30,
                283209,
                27,
                283224,
                30,
                283241,
                27,
                283256,
                22,
                283257,
                22,
                297334,
                41,
                297335,
                41,
                297342,
                38,
                297343,
                38,
                297554,
                29,
                297558,
                24,
                297562,
                29,
                297590,
                24,
                297594,
                21,
                297598,
                21,
                299365,
                26,
                299367,
                23,
                299373,
                26,
                299383,
                23,
                299389,
                20,
                299391,
                20,
                299584,
                31,
                299585,
                28,
                299586,
                31,
                299589,
                28,
                299590,
                25,
                299591,
                25,
                299592,
                30,
                299593,
                27,
                299602,
                29,
                299606,
                24,
                299608,
                30,
                299610,
                29,
                299621,
                26,
                299623,
                23,
                299625,
                27,
                299629,
                26,
                299638,
                24,
                299639,
                23,
                299640,
                22,
                299641,
                22,
                299642,
                21,
                299645,
                20,
                299646,
                21,
                299647,
                20,
                299648,
                61,
                299649,
                60,
                299650,
                61,
                299653,
                60,
                299654,
                59,
                299655,
                59,
                299656,
                58,
                299657,
                57,
                299666,
                55,
                299670,
                54,
                299672,
                58,
                299674,
                55,
                299685,
                52,
                299687,
                51,
                299689,
                57,
                299693,
                52,
                299702,
                54,
                299703,
                51,
                299704,
                56,
                299705,
                56,
                299706,
                53,
                299709,
                50,
                299710,
                53,
                299711,
                50,
                299904,
                61,
                299906,
                61,
                299912,
                58,
                299922,
                55,
                299928,
                58,
                299930,
                55,
                301697,
                60,
                301701,
                60,
                301705,
                57,
                301733,
                52,
                301737,
                57,
                301741,
                52,
                301952,
                79,
                301953,
                79,
                301960,
                76,
                301961,
                76,
                316038,
                59,
                316039,
                59,
                316054,
                54,
                316071,
                51,
                316086,
                54,
                316087,
                51,
                316290,
                78,
                316294,
                78,
                316306,
                73,
                316310,
                73,
                318085,
                77,
                318087,
                77,
                318117,
                70,
                318119,
                70,
                318336,
                79,
                318337,
                79,
                318338,
                78,
                318341,
                77,
                318342,
                78,
                318343,
                77,
                430776,
                56,
                430777,
                56,
                430778,
                53,
                430781,
                50,
                430782,
                53,
                430783,
                50,
                431000,
                75,
                431002,
                72,
                431032,
                75,
                431034,
                72,
                432809,
                74,
                432813,
                69,
                432825,
                74,
                432829,
                69,
                433032,
                76,
                433033,
                76,
                433048,
                75,
                433065,
                74,
                433080,
                75,
                433081,
                74,
                447158,
                71,
                447159,
                68,
                447166,
                71,
                447167,
                68,
                447378,
                73,
                447382,
                73,
                447386,
                72,
                447414,
                71,
                447418,
                72,
                447422,
                71,
                449189,
                70,
                449191,
                70,
                449197,
                69,
                449207,
                68,
                449213,
                69,
                449215,
                68,
                449408,
                67,
                449409,
                67,
                449410,
                66,
                449413,
                64,
                449414,
                66,
                449415,
                64,
                449416,
                67,
                449417,
                67,
                449426,
                66,
                449430,
                66,
                449432,
                65,
                449434,
                65,
                449445,
                64,
                449447,
                64,
                449449,
                63,
                449453,
                63,
                449462,
                62,
                449463,
                62,
                449464,
                65,
                449465,
                63,
                449466,
                65,
                449469,
                63,
                449470,
                62,
                449471,
                62,
                449472,
                19,
                449473,
                19,
                449474,
                18,
                449477,
                16,
                449478,
                18,
                449479,
                16,
                449480,
                19,
                449481,
                19,
                449490,
                18,
                449494,
                18,
                449496,
                17,
                449498,
                17,
                449509,
                16,
                449511,
                16,
                449513,
                15,
                449517,
                15,
                449526,
                14,
                449527,
                14,
                449528,
                17,
                449529,
                15,
                449530,
                17,
                449533,
                15,
                449534,
                14,
                449535,
                14,
                449728,
                19,
                449729,
                19,
                449730,
                18,
                449734,
                18,
                449736,
                19,
                449737,
                19,
                449746,
                18,
                449750,
                18,
                449752,
                17,
                449754,
                17,
                449784,
                17,
                449786,
                17,
                451520,
                19,
                451521,
                19,
                451525,
                16,
                451527,
                16,
                451528,
                19,
                451529,
                19,
                451557,
                16,
                451559,
                16,
                451561,
                15,
                451565,
                15,
                451577,
                15,
                451581,
                15,
                451776,
                19,
                451777,
                19,
                451784,
                19,
                451785,
                19,
                465858,
                18,
                465861,
                16,
                465862,
                18,
                465863,
                16,
                465874,
                18,
                465878,
                18,
                465893,
                16,
                465895,
                16,
                465910,
                14,
                465911,
                14,
                465918,
                14,
                465919,
                14,
                466114,
                18,
                466118,
                18,
                466130,
                18,
                466134,
                18,
                467909,
                16,
                467911,
                16,
                467941,
                16,
                467943,
                16,
                468160,
                13,
                468161,
                13,
                468162,
                13,
                468163,
                13,
                468164,
                13,
                468165,
                13,
                468166,
                13,
                468167,
                13,
                580568,
                17,
                580570,
                17,
                580585,
                15,
                580589,
                15,
                580598,
                14,
                580599,
                14,
                580600,
                17,
                580601,
                15,
                580602,
                17,
                580605,
                15,
                580606,
                14,
                580607,
                14,
                580824,
                17,
                580826,
                17,
                580856,
                17,
                580858,
                17,
                582633,
                15,
                582637,
                15,
                582649,
                15,
                582653,
                15,
                582856,
                12,
                582857,
                12,
                582872,
                12,
                582873,
                12,
                582888,
                12,
                582889,
                12,
                582904,
                12,
                582905,
                12,
                596982,
                14,
                596983,
                14,
                596990,
                14,
                596991,
                14,
                597202,
                11,
                597206,
                11,
                597210,
                11,
                597214,
                11,
                597234,
                11,
                597238,
                11,
                597242,
                11,
                597246,
                11,
                599013,
                10,
                599015,
                10,
                599021,
                10,
                599023,
                10,
                599029,
                10,
                599031,
                10,
                599037,
                10,
                599039,
                10,
                599232,
                13,
                599233,
                13,
                599234,
                13,
                599235,
                13,
                599236,
                13,
                599237,
                13,
                599238,
                13,
                599239,
                13,
                599240,
                12,
                599241,
                12,
                599250,
                11,
                599254,
                11,
                599256,
                12,
                599257,
                12,
                599258,
                11,
                599262,
                11,
                599269,
                10,
                599271,
                10,
                599272,
                12,
                599273,
                12,
                599277,
                10,
                599279,
                10,
                599282,
                11,
                599285,
                10,
                599286,
                11,
                599287,
                10,
                599288,
                12,
                599289,
                12,
                599290,
                11,
                599293,
                10,
                599294,
                11,
                599295,
                10
            ];
            exports.p2D = [
                0,
                0,
                1,
                -1,
                0,
                0,
                -1,
                1,
                0,
                2,
                1,
                1,
                1,
                2,
                2,
                0,
                1,
                2,
                0,
                2,
                1,
                0,
                0,
                0
            ];
            exports.p3D = [
                0,
                0,
                1,
                -1,
                0,
                0,
                1,
                0,
                -1,
                0,
                0,
                -1,
                1,
                0,
                0,
                0,
                1,
                -1,
                0,
                0,
                -1,
                0,
                1,
                0,
                0,
                -1,
                1,
                0,
                2,
                1,
                1,
                0,
                1,
                1,
                1,
                -1,
                0,
                2,
                1,
                0,
                1,
                1,
                1,
                -1,
                1,
                0,
                2,
                0,
                1,
                1,
                1,
                -1,
                1,
                1,
                1,
                3,
                2,
                1,
                0,
                3,
                1,
                2,
                0,
                1,
                3,
                2,
                0,
                1,
                3,
                1,
                0,
                2,
                1,
                3,
                0,
                2,
                1,
                3,
                0,
                1,
                2,
                1,
                1,
                1,
                0,
                0,
                2,
                2,
                0,
                0,
                1,
                1,
                0,
                1,
                0,
                2,
                0,
                2,
                0,
                1,
                1,
                0,
                0,
                1,
                2,
                0,
                0,
                2,
                2,
                0,
                0,
                0,
                0,
                1,
                1,
                -1,
                1,
                2,
                0,
                0,
                0,
                0,
                1,
                -1,
                1,
                1,
                2,
                0,
                0,
                0,
                0,
                1,
                1,
                1,
                -1,
                2,
                3,
                1,
                1,
                1,
                2,
                0,
                0,
                2,
                2,
                3,
                1,
                1,
                1,
                2,
                2,
                0,
                0,
                2,
                3,
                1,
                1,
                1,
                2,
                0,
                2,
                0,
                2,
                1,
                1,
                -1,
                1,
                2,
                0,
                0,
                2,
                2,
                1,
                1,
                -1,
                1,
                2,
                2,
                0,
                0,
                2,
                1,
                -1,
                1,
                1,
                2,
                0,
                0,
                2,
                2,
                1,
                -1,
                1,
                1,
                2,
                0,
                2,
                0,
                2,
                1,
                1,
                1,
                -1,
                2,
                2,
                0,
                0,
                2,
                1,
                1,
                1,
                -1,
                2,
                0,
                2,
                0
            ];
            exports.p4D = [
                0,
                0,
                1,
                -1,
                0,
                0,
                0,
                1,
                0,
                -1,
                0,
                0,
                1,
                0,
                0,
                -1,
                0,
                0,
                -1,
                1,
                0,
                0,
                0,
                0,
                1,
                -1,
                0,
                0,
                0,
                1,
                0,
                -1,
                0,
                0,
                -1,
                0,
                1,
                0,
                0,
                0,
                -1,
                1,
                0,
                0,
                0,
                0,
                1,
                -1,
                0,
                0,
                -1,
                0,
                0,
                1,
                0,
                0,
                -1,
                0,
                1,
                0,
                0,
                0,
                -1,
                1,
                0,
                2,
                1,
                1,
                0,
                0,
                1,
                1,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                0,
                2,
                1,
                0,
                1,
                0,
                1,
                1,
                -1,
                1,
                0,
                1,
                1,
                0,
                1,
                -1,
                0,
                2,
                0,
                1,
                1,
                0,
                1,
                -1,
                1,
                1,
                0,
                1,
                0,
                1,
                1,
                -1,
                0,
                2,
                1,
                0,
                0,
                1,
                1,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                1,
                0,
                2,
                0,
                1,
                0,
                1,
                1,
                -1,
                1,
                0,
                1,
                1,
                0,
                1,
                -1,
                1,
                0,
                2,
                0,
                0,
                1,
                1,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                1,
                1,
                1,
                4,
                2,
                1,
                1,
                0,
                4,
                1,
                2,
                1,
                0,
                4,
                1,
                1,
                2,
                0,
                1,
                4,
                2,
                1,
                0,
                1,
                4,
                1,
                2,
                0,
                1,
                4,
                1,
                1,
                0,
                2,
                1,
                4,
                2,
                0,
                1,
                1,
                4,
                1,
                0,
                2,
                1,
                4,
                1,
                0,
                1,
                2,
                1,
                4,
                0,
                2,
                1,
                1,
                4,
                0,
                1,
                2,
                1,
                4,
                0,
                1,
                1,
                2,
                1,
                2,
                1,
                1,
                0,
                0,
                3,
                2,
                1,
                0,
                0,
                3,
                1,
                2,
                0,
                0,
                1,
                2,
                1,
                0,
                1,
                0,
                3,
                2,
                0,
                1,
                0,
                3,
                1,
                0,
                2,
                0,
                1,
                2,
                0,
                1,
                1,
                0,
                3,
                0,
                2,
                1,
                0,
                3,
                0,
                1,
                2,
                0,
                1,
                2,
                1,
                0,
                0,
                1,
                3,
                2,
                0,
                0,
                1,
                3,
                1,
                0,
                0,
                2,
                1,
                2,
                0,
                1,
                0,
                1,
                3,
                0,
                2,
                0,
                1,
                3,
                0,
                1,
                0,
                2,
                1,
                2,
                0,
                0,
                1,
                1,
                3,
                0,
                0,
                2,
                1,
                3,
                0,
                0,
                1,
                2,
                2,
                3,
                1,
                1,
                1,
                0,
                2,
                1,
                1,
                1,
                -1,
                2,
                2,
                0,
                0,
                0,
                2,
                3,
                1,
                1,
                0,
                1,
                2,
                1,
                1,
                -1,
                1,
                2,
                2,
                0,
                0,
                0,
                2,
                3,
                1,
                0,
                1,
                1,
                2,
                1,
                -1,
                1,
                1,
                2,
                2,
                0,
                0,
                0,
                2,
                3,
                1,
                1,
                1,
                0,
                2,
                1,
                1,
                1,
                -1,
                2,
                0,
                2,
                0,
                0,
                2,
                3,
                1,
                1,
                0,
                1,
                2,
                1,
                1,
                -1,
                1,
                2,
                0,
                2,
                0,
                0,
                2,
                3,
                0,
                1,
                1,
                1,
                2,
                -1,
                1,
                1,
                1,
                2,
                0,
                2,
                0,
                0,
                2,
                3,
                1,
                1,
                1,
                0,
                2,
                1,
                1,
                1,
                -1,
                2,
                0,
                0,
                2,
                0,
                2,
                3,
                1,
                0,
                1,
                1,
                2,
                1,
                -1,
                1,
                1,
                2,
                0,
                0,
                2,
                0,
                2,
                3,
                0,
                1,
                1,
                1,
                2,
                -1,
                1,
                1,
                1,
                2,
                0,
                0,
                2,
                0,
                2,
                3,
                1,
                1,
                0,
                1,
                2,
                1,
                1,
                -1,
                1,
                2,
                0,
                0,
                0,
                2,
                2,
                3,
                1,
                0,
                1,
                1,
                2,
                1,
                -1,
                1,
                1,
                2,
                0,
                0,
                0,
                2,
                2,
                3,
                0,
                1,
                1,
                1,
                2,
                -1,
                1,
                1,
                1,
                2,
                0,
                0,
                0,
                2,
                2,
                1,
                1,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                0,
                0,
                0,
                0,
                0,
                2,
                1,
                1,
                -1,
                1,
                0,
                1,
                1,
                0,
                1,
                -1,
                0,
                0,
                0,
                0,
                0,
                2,
                1,
                -1,
                1,
                1,
                0,
                1,
                0,
                1,
                1,
                -1,
                0,
                0,
                0,
                0,
                0,
                2,
                1,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                1,
                0,
                0,
                0,
                0,
                0,
                2,
                1,
                -1,
                1,
                0,
                1,
                1,
                0,
                1,
                -1,
                1,
                0,
                0,
                0,
                0,
                0,
                2,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                1,
                1,
                0,
                0,
                0,
                0,
                0,
                2,
                1,
                1,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                2,
                2,
                0,
                0,
                0,
                2,
                1,
                1,
                -1,
                1,
                0,
                1,
                1,
                0,
                1,
                -1,
                2,
                2,
                0,
                0,
                0,
                2,
                1,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                1,
                2,
                2,
                0,
                0,
                0,
                2,
                1,
                1,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                2,
                0,
                2,
                0,
                0,
                2,
                1,
                -1,
                1,
                1,
                0,
                1,
                0,
                1,
                1,
                -1,
                2,
                0,
                2,
                0,
                0,
                2,
                1,
                -1,
                1,
                0,
                1,
                1,
                0,
                1,
                -1,
                1,
                2,
                0,
                2,
                0,
                0,
                2,
                1,
                1,
                -1,
                1,
                0,
                1,
                1,
                0,
                1,
                -1,
                2,
                0,
                0,
                2,
                0,
                2,
                1,
                -1,
                1,
                1,
                0,
                1,
                0,
                1,
                1,
                -1,
                2,
                0,
                0,
                2,
                0,
                2,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                1,
                1,
                2,
                0,
                0,
                2,
                0,
                2,
                1,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                1,
                2,
                0,
                0,
                0,
                2,
                2,
                1,
                -1,
                1,
                0,
                1,
                1,
                0,
                1,
                -1,
                1,
                2,
                0,
                0,
                0,
                2,
                2,
                1,
                -1,
                0,
                1,
                1,
                1,
                0,
                -1,
                1,
                1,
                2,
                0,
                0,
                0,
                2,
                3,
                1,
                1,
                0,
                0,
                0,
                2,
                2,
                0,
                0,
                0,
                2,
                1,
                1,
                1,
                -1,
                3,
                1,
                0,
                1,
                0,
                0,
                2,
                0,
                2,
                0,
                0,
                2,
                1,
                1,
                1,
                -1,
                3,
                1,
                0,
                0,
                1,
                0,
                2,
                0,
                0,
                2,
                0,
                2,
                1,
                1,
                1,
                -1,
                3,
                1,
                1,
                0,
                0,
                0,
                2,
                2,
                0,
                0,
                0,
                2,
                1,
                1,
                -1,
                1,
                3,
                1,
                0,
                1,
                0,
                0,
                2,
                0,
                2,
                0,
                0,
                2,
                1,
                1,
                -1,
                1,
                3,
                1,
                0,
                0,
                0,
                1,
                2,
                0,
                0,
                0,
                2,
                2,
                1,
                1,
                -1,
                1,
                3,
                1,
                1,
                0,
                0,
                0,
                2,
                2,
                0,
                0,
                0,
                2,
                1,
                -1,
                1,
                1,
                3,
                1,
                0,
                0,
                1,
                0,
                2,
                0,
                0,
                2,
                0,
                2,
                1,
                -1,
                1,
                1,
                3,
                1,
                0,
                0,
                0,
                1,
                2,
                0,
                0,
                0,
                2,
                2,
                1,
                -1,
                1,
                1,
                3,
                1,
                0,
                1,
                0,
                0,
                2,
                0,
                2,
                0,
                0,
                2,
                -1,
                1,
                1,
                1,
                3,
                1,
                0,
                0,
                1,
                0,
                2,
                0,
                0,
                2,
                0,
                2,
                -1,
                1,
                1,
                1,
                3,
                1,
                0,
                0,
                0,
                1,
                2,
                0,
                0,
                0,
                2,
                2,
                -1,
                1,
                1,
                1,
                3,
                3,
                2,
                1,
                0,
                0,
                3,
                1,
                2,
                0,
                0,
                4,
                1,
                1,
                1,
                1,
                3,
                3,
                2,
                0,
                1,
                0,
                3,
                1,
                0,
                2,
                0,
                4,
                1,
                1,
                1,
                1,
                3,
                3,
                0,
                2,
                1,
                0,
                3,
                0,
                1,
                2,
                0,
                4,
                1,
                1,
                1,
                1,
                3,
                3,
                2,
                0,
                0,
                1,
                3,
                1,
                0,
                0,
                2,
                4,
                1,
                1,
                1,
                1,
                3,
                3,
                0,
                2,
                0,
                1,
                3,
                0,
                1,
                0,
                2,
                4,
                1,
                1,
                1,
                1,
                3,
                3,
                0,
                0,
                2,
                1,
                3,
                0,
                0,
                1,
                2,
                4,
                1,
                1,
                1,
                1,
                3,
                3,
                2,
                1,
                0,
                0,
                3,
                1,
                2,
                0,
                0,
                2,
                1,
                1,
                1,
                -1,
                3,
                3,
                2,
                0,
                1,
                0,
                3,
                1,
                0,
                2,
                0,
                2,
                1,
                1,
                1,
                -1,
                3,
                3,
                0,
                2,
                1,
                0,
                3,
                0,
                1,
                2,
                0,
                2,
                1,
                1,
                1,
                -1,
                3,
                3,
                2,
                1,
                0,
                0,
                3,
                1,
                2,
                0,
                0,
                2,
                1,
                1,
                -1,
                1,
                3,
                3,
                2,
                0,
                0,
                1,
                3,
                1,
                0,
                0,
                2,
                2,
                1,
                1,
                -1,
                1,
                3,
                3,
                0,
                2,
                0,
                1,
                3,
                0,
                1,
                0,
                2,
                2,
                1,
                1,
                -1,
                1,
                3,
                3,
                2,
                0,
                1,
                0,
                3,
                1,
                0,
                2,
                0,
                2,
                1,
                -1,
                1,
                1,
                3,
                3,
                2,
                0,
                0,
                1,
                3,
                1,
                0,
                0,
                2,
                2,
                1,
                -1,
                1,
                1,
                3,
                3,
                0,
                0,
                2,
                1,
                3,
                0,
                0,
                1,
                2,
                2,
                1,
                -1,
                1,
                1,
                3,
                3,
                0,
                2,
                1,
                0,
                3,
                0,
                1,
                2,
                0,
                2,
                -1,
                1,
                1,
                1,
                3,
                3,
                0,
                2,
                0,
                1,
                3,
                0,
                1,
                0,
                2,
                2,
                -1,
                1,
                1,
                1,
                3,
                3,
                0,
                0,
                2,
                1,
                3,
                0,
                0,
                1,
                2,
                2,
                -1,
                1,
                1,
                1
            ];
            });

            unwrapExports$6(constants$2);
            var constants_1$2 = constants$2.NORM_2D;
            var constants_2$1 = constants$2.NORM_3D;
            var constants_3$1 = constants$2.NORM_4D;
            var constants_4$1 = constants$2.SQUISH_2D;
            var constants_5$1 = constants$2.SQUISH_3D;
            var constants_6$1 = constants$2.SQUISH_4D;
            var constants_7$1 = constants$2.STRETCH_2D;
            var constants_8$1 = constants$2.STRETCH_3D;
            var constants_9$1 = constants$2.STRETCH_4D;
            var constants_10$1 = constants$2.base2D;
            var constants_11$1 = constants$2.base3D;
            var constants_12$1 = constants$2.base4D;
            var constants_13$1 = constants$2.gradients2D;
            var constants_14$1 = constants$2.gradients3D;
            var constants_15$1 = constants$2.gradients4D;
            var constants_16$1 = constants$2.lookupPairs2D;
            var constants_17$1 = constants$2.lookupPairs3D;
            var constants_18$1 = constants$2.lookupPairs4D;
            var constants_19$1 = constants$2.p2D;
            var constants_20$1 = constants$2.p3D;
            var constants_21$1 = constants$2.p4D;

            var lib$2 = createCommonjsModule$7(function (module, exports) {
            Object.defineProperty(exports, "__esModule", { value: true });

            function contribution2D(multiplier, xsb, ysb) {
                return {
                    dx: -xsb - multiplier * constants$2.SQUISH_2D,
                    dy: -ysb - multiplier * constants$2.SQUISH_2D,
                    xsb: xsb,
                    ysb: ysb
                };
            }
            function contribution3D(multiplier, xsb, ysb, zsb) {
                return {
                    dx: -xsb - multiplier * constants$2.SQUISH_3D,
                    dy: -ysb - multiplier * constants$2.SQUISH_3D,
                    dz: -zsb - multiplier * constants$2.SQUISH_3D,
                    xsb: xsb,
                    ysb: ysb,
                    zsb: zsb
                };
            }
            function contribution4D(multiplier, xsb, ysb, zsb, wsb) {
                return {
                    dx: -xsb - multiplier * constants$2.SQUISH_4D,
                    dy: -ysb - multiplier * constants$2.SQUISH_4D,
                    dz: -zsb - multiplier * constants$2.SQUISH_4D,
                    dw: -wsb - multiplier * constants$2.SQUISH_4D,
                    xsb: xsb,
                    ysb: ysb,
                    zsb: zsb,
                    wsb: wsb
                };
            }
            function makeNoise2D(clientSeed) {
                var contributions = [];
                for (var i = 0; i < constants$2.p2D.length; i += 4) {
                    var baseSet = constants$2.base2D[constants$2.p2D[i]];
                    var previous = null;
                    var current = null;
                    for (var k = 0; k < baseSet.length; k += 3) {
                        current = contribution2D(baseSet[k], baseSet[k + 1], baseSet[k + 2]);
                        if (previous === null)
                            contributions[i / 4] = current;
                        else
                            previous.next = current;
                        previous = current;
                    }
                    current.next = contribution2D(constants$2.p2D[i + 1], constants$2.p2D[i + 2], constants$2.p2D[i + 3]);
                }
                var lookup = [];
                for (var i = 0; i < constants$2.lookupPairs2D.length; i += 2) {
                    lookup[constants$2.lookupPairs2D[i]] = contributions[constants$2.lookupPairs2D[i + 1]];
                }
                var perm = new Uint8Array(256);
                var perm2D = new Uint8Array(256);
                var source = new Uint8Array(256);
                for (var i = 0; i < 256; i++)
                    source[i] = i;
                var seed = new Uint32Array(1);
                seed[0] = clientSeed;
                seed = shuffleSeed(shuffleSeed(shuffleSeed(seed)));
                for (var i = 255; i >= 0; i--) {
                    seed = shuffleSeed(seed);
                    var r = new Uint32Array(1);
                    r[0] = (seed[0] + 31) % (i + 1);
                    if (r[0] < 0)
                        r[0] += i + 1;
                    perm[i] = source[r[0]];
                    perm2D[i] = perm[i] & 0x0e;
                    source[r[0]] = source[i];
                }
                return function (x, y) {
                    var stretchOffset = (x + y) * constants$2.STRETCH_2D;
                    var xs = x + stretchOffset;
                    var ys = y + stretchOffset;
                    var xsb = Math.floor(xs);
                    var ysb = Math.floor(ys);
                    var squishOffset = (xsb + ysb) * constants$2.SQUISH_2D;
                    var dx0 = x - (xsb + squishOffset);
                    var dy0 = y - (ysb + squishOffset);
                    var xins = xs - xsb;
                    var yins = ys - ysb;
                    var inSum = xins + yins;
                    var hash = (xins - yins + 1) |
                        (inSum << 1) |
                        ((inSum + yins) << 2) |
                        ((inSum + xins) << 4);
                    var value = 0;
                    for (var c = lookup[hash]; c !== undefined; c = c.next) {
                        var dx = dx0 + c.dx;
                        var dy = dy0 + c.dy;
                        var attn = 2 - dx * dx - dy * dy;
                        if (attn > 0) {
                            var px = xsb + c.xsb;
                            var py = ysb + c.ysb;
                            var indexPartA = perm[px & 0xff];
                            var index = perm2D[(indexPartA + py) & 0xff];
                            var valuePart = constants$2.gradients2D[index] * dx + constants$2.gradients2D[index + 1] * dy;
                            value += attn * attn * attn * attn * valuePart;
                        }
                    }
                    return value * constants$2.NORM_2D;
                };
            }
            exports.makeNoise2D = makeNoise2D;
            function makeNoise3D(clientSeed) {
                var contributions = [];
                for (var i = 0; i < constants$2.p3D.length; i += 9) {
                    var baseSet = constants$2.base3D[constants$2.p3D[i]];
                    var previous = null;
                    var current = null;
                    for (var k = 0; k < baseSet.length; k += 4) {
                        current = contribution3D(baseSet[k], baseSet[k + 1], baseSet[k + 2], baseSet[k + 3]);
                        if (previous === null)
                            contributions[i / 9] = current;
                        else
                            previous.next = current;
                        previous = current;
                    }
                    current.next = contribution3D(constants$2.p3D[i + 1], constants$2.p3D[i + 2], constants$2.p3D[i + 3], constants$2.p3D[i + 4]);
                    current.next.next = contribution3D(constants$2.p3D[i + 5], constants$2.p3D[i + 6], constants$2.p3D[i + 7], constants$2.p3D[i + 8]);
                }
                var lookup = [];
                for (var i = 0; i < constants$2.lookupPairs3D.length; i += 2) {
                    lookup[constants$2.lookupPairs3D[i]] = contributions[constants$2.lookupPairs3D[i + 1]];
                }
                var perm = new Uint8Array(256);
                var perm3D = new Uint8Array(256);
                var source = new Uint8Array(256);
                for (var i = 0; i < 256; i++)
                    source[i] = i;
                var seed = new Uint32Array(1);
                seed[0] = clientSeed;
                seed = shuffleSeed(shuffleSeed(shuffleSeed(seed)));
                for (var i = 255; i >= 0; i--) {
                    seed = shuffleSeed(seed);
                    var r = new Uint32Array(1);
                    r[0] = (seed[0] + 31) % (i + 1);
                    if (r[0] < 0)
                        r[0] += i + 1;
                    perm[i] = source[r[0]];
                    perm3D[i] = (perm[i] % 24) * 3;
                    source[r[0]] = source[i];
                }
                return function (x, y, z) {
                    var stretchOffset = (x + y + z) * constants$2.STRETCH_3D;
                    var xs = x + stretchOffset;
                    var ys = y + stretchOffset;
                    var zs = z + stretchOffset;
                    var xsb = Math.floor(xs);
                    var ysb = Math.floor(ys);
                    var zsb = Math.floor(zs);
                    var squishOffset = (xsb + ysb + zsb) * constants$2.SQUISH_3D;
                    var dx0 = x - (xsb + squishOffset);
                    var dy0 = y - (ysb + squishOffset);
                    var dz0 = z - (zsb + squishOffset);
                    var xins = xs - xsb;
                    var yins = ys - ysb;
                    var zins = zs - zsb;
                    var inSum = xins + yins + zins;
                    var hash = (yins - zins + 1) |
                        ((xins - yins + 1) << 1) |
                        ((xins - zins + 1) << 2) |
                        (inSum << 3) |
                        ((inSum + zins) << 5) |
                        ((inSum + yins) << 7) |
                        ((inSum + xins) << 9);
                    var value = 0;
                    for (var c = lookup[hash]; c !== undefined; c = c.next) {
                        var dx = dx0 + c.dx;
                        var dy = dy0 + c.dy;
                        var dz = dz0 + c.dz;
                        var attn = 2 - dx * dx - dy * dy - dz * dz;
                        if (attn > 0) {
                            var px = xsb + c.xsb;
                            var py = ysb + c.ysb;
                            var pz = zsb + c.zsb;
                            var indexPartA = perm[px & 0xff];
                            var indexPartB = perm[(indexPartA + py) & 0xff];
                            var index = perm3D[(indexPartB + pz) & 0xff];
                            var valuePart = constants$2.gradients3D[index] * dx +
                                constants$2.gradients3D[index + 1] * dy +
                                constants$2.gradients3D[index + 2] * dz;
                            value += attn * attn * attn * attn * valuePart;
                        }
                    }
                    return value * constants$2.NORM_3D;
                };
            }
            exports.makeNoise3D = makeNoise3D;
            function makeNoise4D(clientSeed) {
                var contributions = [];
                for (var i = 0; i < constants$2.p4D.length; i += 16) {
                    var baseSet = constants$2.base4D[constants$2.p4D[i]];
                    var previous = null;
                    var current = null;
                    for (var k = 0; k < baseSet.length; k += 5) {
                        current = contribution4D(baseSet[k], baseSet[k + 1], baseSet[k + 2], baseSet[k + 3], baseSet[k + 4]);
                        if (previous === null)
                            contributions[i / 16] = current;
                        else
                            previous.next = current;
                        previous = current;
                    }
                    current.next = contribution4D(constants$2.p4D[i + 1], constants$2.p4D[i + 2], constants$2.p4D[i + 3], constants$2.p4D[i + 4], constants$2.p4D[i + 5]);
                    current.next.next = contribution4D(constants$2.p4D[i + 6], constants$2.p4D[i + 7], constants$2.p4D[i + 8], constants$2.p4D[i + 9], constants$2.p4D[i + 10]);
                    current.next.next.next = contribution4D(constants$2.p4D[i + 11], constants$2.p4D[i + 12], constants$2.p4D[i + 13], constants$2.p4D[i + 14], constants$2.p4D[i + 15]);
                }
                var lookup = [];
                for (var i = 0; i < constants$2.lookupPairs4D.length; i += 2) {
                    lookup[constants$2.lookupPairs4D[i]] = contributions[constants$2.lookupPairs4D[i + 1]];
                }
                var perm = new Uint8Array(256);
                var perm4D = new Uint8Array(256);
                var source = new Uint8Array(256);
                for (var i = 0; i < 256; i++)
                    source[i] = i;
                var seed = new Uint32Array(1);
                seed[0] = clientSeed;
                seed = shuffleSeed(shuffleSeed(shuffleSeed(seed)));
                for (var i = 255; i >= 0; i--) {
                    seed = shuffleSeed(seed);
                    var r = new Uint32Array(1);
                    r[0] = (seed[0] + 31) % (i + 1);
                    if (r[0] < 0)
                        r[0] += i + 1;
                    perm[i] = source[r[0]];
                    perm4D[i] = perm[i] & 0xfc;
                    source[r[0]] = source[i];
                }
                return function (x, y, z, w) {
                    var stretchOffset = (x + y + z + w) * constants$2.STRETCH_4D;
                    var xs = x + stretchOffset;
                    var ys = y + stretchOffset;
                    var zs = z + stretchOffset;
                    var ws = w + stretchOffset;
                    var xsb = Math.floor(xs);
                    var ysb = Math.floor(ys);
                    var zsb = Math.floor(zs);
                    var wsb = Math.floor(ws);
                    var squishOffset = (xsb + ysb + zsb + wsb) * constants$2.SQUISH_4D;
                    var dx0 = x - (xsb + squishOffset);
                    var dy0 = y - (ysb + squishOffset);
                    var dz0 = z - (zsb + squishOffset);
                    var dw0 = w - (wsb + squishOffset);
                    var xins = xs - xsb;
                    var yins = ys - ysb;
                    var zins = zs - zsb;
                    var wins = ws - wsb;
                    var inSum = xins + yins + zins + wins;
                    var hash = (zins - wins + 1) |
                        ((yins - zins + 1) << 1) |
                        ((yins - wins + 1) << 2) |
                        ((xins - yins + 1) << 3) |
                        ((xins - zins + 1) << 4) |
                        ((xins - wins + 1) << 5) |
                        (inSum << 6) |
                        ((inSum + wins) << 8) |
                        ((inSum + zins) << 11) |
                        ((inSum + yins) << 14) |
                        ((inSum + xins) << 17);
                    var value = 0;
                    for (var c = lookup[hash]; c !== undefined; c = c.next) {
                        var dx = dx0 + c.dx;
                        var dy = dy0 + c.dy;
                        var dz = dz0 + c.dz;
                        var dw = dw0 + c.dw;
                        var attn = 2 - dx * dx - dy * dy - dz * dz - dw * dw;
                        if (attn > 0) {
                            var px = xsb + c.xsb;
                            var py = ysb + c.ysb;
                            var pz = zsb + c.zsb;
                            var pw = wsb + c.wsb;
                            var indexPartA = perm[px & 0xff];
                            var indexPartB = perm[(indexPartA + py) & 0xff];
                            var indexPartC = perm[(indexPartB + pz) & 0xff];
                            var index = perm4D[(indexPartC + pw) & 0xff];
                            var valuePart = constants$2.gradients4D[index] * dx +
                                constants$2.gradients4D[index + 1] * dy +
                                constants$2.gradients4D[index + 2] * dz +
                                constants$2.gradients4D[index + 3] * dw;
                            value += attn * attn * attn * attn * valuePart;
                        }
                    }
                    return value * constants$2.NORM_4D;
                };
            }
            exports.makeNoise4D = makeNoise4D;
            function shuffleSeed(seed) {
                var newSeed = new Uint32Array(1);
                newSeed[0] = seed[0] * 1664525 + 1013904223;
                return newSeed;
            }
            });

            var OpenSimplexNoise$1 = unwrapExports$6(lib$2);
            var lib_1$1 = lib$2.makeNoise2D;
            var lib_2$1 = lib$2.makeNoise3D;
            var lib_3$1 = lib$2.makeNoise4D;

            const X$d = 0;
            const Y$d = 1;
            const Z$1$6 = 2;

            const crumple = (
              shape,
              amount = 0.1,
              { resolution = 1, seed = 1 } = {}
            ) => {
              const scale = amount / 2;

              const noiseX = OpenSimplexNoise$1.makeNoise3D(seed + 0);
              const noiseY = OpenSimplexNoise$1.makeNoise3D(seed + 1);
              const noiseZ = OpenSimplexNoise$1.makeNoise3D(seed + 2);

              const perturb = (point) => [
                point[X$d] + noiseX(...point) * scale,
                point[Y$d] + noiseY(...point) * scale,
                point[Z$1$6] + noiseZ(...point) * scale,
              ];

              const assembly = [];
              for (const { solid, tags } of getSolids(shape.toKeptGeometry())) {
                const [min, max] = measureBoundingBox$3(solid);
                assembly.push(
                  taggedSolid(
                    { tags },
                    deform(makeWatertight$1(solid), perturb, min, max, resolution)
                  )
                );
              }

              return Shape.fromGeometry(taggedAssembly({}, ...assembly));
            };

            const crumpleMethod = function (...args) {
              return crumple(this, ...args);
            };
            Shape.prototype.crumple = crumpleMethod;

            const Z$2$2 = 0;

            const skew = (shape, factor, { resolution = 1 } = {}) => {
              const assembly = [];
              for (const { solid, tags } of getSolids(shape.toKeptGeometry())) {
                const [min, max] = measureBoundingBox$3(solid);
                const maxZ = max[Z$2$2];
                const minZ = min[Z$2$2];
                const height = maxZ - minZ;
                const shiftAt = (z) => 1 - ((z - minZ) / height) * (1 - factor);
                const shift = ([x, y, z]) => [x + shiftAt(z), y + shiftAt(z), z];
                assembly.push(
                  taggedSolid(
                    { tags },
                    deform(makeWatertight$1(solid), shift, min, max, resolution)
                  )
                );
              }

              return Shape.fromGeometry(taggedAssembly({}, ...assembly));
            };

            const skewMethod = function (...args) {
              return skew(this, ...args);
            };
            Shape.prototype.skew = skewMethod;

            const Z$3$1 = 2;

            const scaleXY = (factor, [x, y, z]) => [...scale$1(factor, [x, y]), z];

            // TODO: Support different factors for x and y.
            const taper = (shape, factor, { resolution = 1 } = {}) => {
              const assembly = [];
              for (const { solid, tags } of getSolids(shape.toKeptGeometry())) {
                const [min, max] = measureBoundingBox$3(solid);
                const maxZ = max[Z$3$1];
                const minZ = min[Z$3$1];
                const height = maxZ - minZ;
                const widthAt = (z) => 1 - ((z - minZ) / height) * (1 - factor);
                const squeeze = ([x, y, z]) => scaleXY(widthAt(z), [x, y, z]);
                assembly.push(
                  taggedSolid(
                    { tags },
                    deform(makeWatertight$1(solid), squeeze, min, max, resolution)
                  )
                );
              }

              return Shape.fromGeometry(taggedAssembly({}, ...assembly));
            };

            const taperMethod = function (...args) {
              return taper(this, ...args);
            };
            Shape.prototype.taper = taperMethod;

            const Z$4$1 = 2;

            const twist = (shape, angle = 0, { resolution = 1 } = {}) => {
              const assembly = [];
              for (const { solid, tags } of getSolids(shape.toKeptGeometry())) {
                const [min, max] = measureBoundingBox$3(solid);
                const height = max[Z$4$1] - min[Z$4$1];
                const radians = (angle / height) * (Math.PI / 180);
                const rotate = (point) => rotateZ(point, radians * (point[Z$4$1] - min[Z$4$1]));
                assembly.push(
                  taggedSolid(
                    { tags },
                    deform(makeWatertight$1(solid), rotate, min, max, resolution)
                  )
                );
              }

              return Shape.fromGeometry(taggedAssembly({}, ...assembly));
            };

            const twistMethod = function (...args) {
              return twist(this, ...args);
            };
            Shape.prototype.twist = twistMethod;

            const X$e = 0;
            const Y$e = 1;
            const Z$a = 2;

            /** Checks for equality, ignoring z. */
            const equalsXY = ([aX, aY], [bX, bY]) => equals([aX, aY, 0], [bX, bY, 0]);

            /** Checks for equality, ignoring x and y */
            const equalsZ = ([, , aZ], [, , bZ]) => equals([0, 0, aZ], [0, 0, bZ]);

            const toGcode = async (
              geometry,
              {
                origin = [0, 0, 0],
                topZ = 0,
                maxFeedRate = 800,
                minCutZ = -1,
                cutDepth = 0.1,
                jumpHeight = 1,
                spindleRpm = 0,
                laserPower = 0,
                feedRate = 300,
                toolType,
              } = {}
            ) => {
              const tool = {};

              const jumpZ = topZ + jumpHeight;

              const codes = [];
              const _ = undefined;
              let position = [0, 0, 0];

              const emit = (code) => codes.push(code);

              // Runs each axis at maximum velocity until matches, so may make dog-legs.
              const rapid = (
                x = position[X$e],
                y = position[Y$e],
                z = position[Z$a],
                f = feedRate
              ) => {
                emit(`G0 X${x.toFixed(3)} Y${y.toFixed(3)} Z${z.toFixed(3)}`);
                position = [x, y, z];
              };

              // Straight motion at set speed.
              const cut = (
                x = position[X$e],
                y = position[Y$e],
                z = position[Z$a],
                f = feedRate
              ) => {
                setSpeed(tool.cutSpeed);
                emit(
                  `G1 X${x.toFixed(3)} Y${y.toFixed(3)} Z${z.toFixed(3)} F${f.toFixed(3)}`
                );
                position = [x, y, z];
              };

              const setSpeed = (value) => {
                if (value !== undefined && tool.speed !== value) {
                  emit(`S${value.toFixed(3)}`);
                  tool.speed = value;
                }
              };

              const enableLaserMode = () => {
                if (tool.laserMode !== true) {
                  emit('$32=1');
                  tool.laserMode = true;
                }
              };

              const disableLaserMode = () => {
                if (tool.laserMode !== true) {
                  emit('$32=0');
                  tool.laserMode = false;
                }
              };

              const toolWarmup = () => {
                switch (toolType) {
                  case 'spindle':
                    tool.isSpindle = true;
                    tool.jumpSpeed = spindleRpm;
                    tool.cutSpeed = spindleRpm;
                    disableLaserMode();
                    raise();
                    emit('M3');
                    break;
                  case 'constantLaser':
                    tool.isConstantLaser = true;
                    tool.jumpSpeed = 0;
                    tool.cutSpeed = laserPower;
                    enableLaserMode();
                    emit('M3');
                    break;
                  case 'dynamicLaser':
                    tool.isDynamicLaser = true;
                    tool.jumpSpeed = laserPower;
                    tool.cutSpeed = laserPower;
                    enableLaserMode();
                    emit('M4');
                    break;
                  default:
                    throw Error('No toolType set.');
                }
              };

              const toolShutdown = () => {
                emit('M5');
              };

              const raise = () => {
                rapid(_, _, jumpZ); // up
              };

              const jump = (x, y) => {
                setSpeed(tool.jumpSpeed);
                raise();
                rapid(x, y, jumpZ); // across
                rapid(x, y, topZ); // down
              };

              const park = () => {
                jump(0, 0);
              };

              const useMetric = () => emit('G21');

              useMetric();
              toolWarmup();

              for (const { tags = [], paths } of getNonVoidPaths(
                toKeptGeometry(geometry)
              )) {
                for (const tag of tags) {
                  if (tag.startsWith('toolpath/')) {
                    const [, attribute, value] = tag.split('/');
                    switch (attribute) {
                      case 'feed_rate':
                        feedRate = Number(value);
                        break;
                      case 'laser_power':
                        laserPower = Number(value);
                        break;
                      case 'spindle_rpm':
                        spindleRpm = Number(value);
                        break;
                    }
                  }
                }
                for (const path of paths) {
                  for (const [start, end] of getEdges(path)) {
                    if (start[Z$a] < minCutZ) {
                      throw Error(`Attempting to cut below minCutZ`);
                    }
                    if (!equalsXY(start, position)) {
                      // We assume that we can plunge or raise vertically without issue.
                      // This avoids raising before plunging.
                      // FIX: This whole approach is essentially wrong, and needs to consider if the tool can plunge or not.
                      jump(...start);
                    }
                    if (!equalsZ(start, position)) {
                      cut(...start); // cut down
                    }
                    cut(...end); // cut across
                  }
                }
              }

              toolShutdown();
              park();

              codes.push(``);
              return new TextEncoder('utf8').encode(codes.join('\n'));
            };

            const prepareGcode = (shape, name, options = {}) => {
              let index = 0;
              const entries = [];
              for (const entry of ensurePages(shape.toKeptGeometry())) {
                const op = toGcode(entry, options);
                addPending(op);
                entries.push({
                  data: op,
                  filename: `${name}_${index++}.gcode`,
                  // CHECK: Is this a reasonable mime type?
                  type: 'application/x-gcode',
                });
              }
              return entries;
            };

            const downloadGcodeMethod = function (...args) {
              const entries = prepareGcode(this, ...args);
              emit$1({ download: { entries } });
              return this;
            };
            Shape.prototype.downloadGcode = downloadGcodeMethod;

            const writeGcode = (shape, name, options = {}) => {
              for (const { data, filename } of prepareGcode(shape, name, options)) {
                addPending(writeFile({ doSerialize: false }, `output/${filename}`, data));
              }
              return shape;
            };

            const writeGcodeMethod = function (...args) {
              return writeGcode(this, ...args);
            };
            Shape.prototype.writeGcode = writeGcodeMethod;

            const toFillColor = (rgb) =>
              `${(rgb[0] / 255).toFixed(9)} ${(rgb[1] / 255).toFixed(9)} ${(
    rgb[2] / 255
  ).toFixed(9)} rg`;
            const toStrokeColor = (rgb) =>
              `${(rgb[0] / 255).toFixed(9)} ${(rgb[1] / 255).toFixed(9)} ${(
    rgb[2] / 255
  ).toFixed(9)} RG`;

            const black = [0, 0, 0];

            // Not entirely sure how conformant this is, but it seems to work for simple
            // cases.

            // Width and height are in post-script points.
            const header = ({
              scale = 1,
              width = 210,
              height = 297,
              trim = 5,
              lineWidth = 0.096,
            }) => {
              const mediaX1 = 0 * scale;
              const mediaY1 = 0 * scale;
              const mediaX2 = width * scale;
              const mediaY2 = height * scale;
              const trimX1 = trim * scale;
              const trimY1 = trim * scale;
              const trimX2 = (width - trim) * scale;
              const trimY2 = (height - trim) * scale;
              return [
                `%PDF-1.5`,
                `1 0 obj << /Pages 2 0 R /Type /Catalog >> endobj`,
                `2 0 obj << /Count 1 /Kids [ 3 0 R ] /Type /Pages >> endobj`,
                `3 0 obj <<`,
                `  /Contents 4 0 R`,
                `  /MediaBox [ ${mediaX1.toFixed(9)} ${mediaY1.toFixed(
      9
    )} ${mediaX2.toFixed(9)} ${mediaY2.toFixed(9)} ]`,
                `  /TrimBox [ ${trimX1.toFixed(9)} ${trimY1.toFixed(9)} ${trimX2.toFixed(
      9
    )} ${trimY2.toFixed(9)} ]`,
                `  /Parent 2 0 R`,
                `  /Type /Page`,
                `>>`,
                `endobj`,
                `4 0 obj << >>`,
                `stream`,
                `${lineWidth.toFixed(9)} w`,
              ];
            };

            const footer = [
              `endstream`,
              `endobj`,
              `trailer << /Root 1 0 R /Size 4 >>`,
              `%%EOF`,
            ];

            const toPdf = async (
              geometry,
              { lineWidth = 0.096, size = [210, 297] } = {}
            ) => {
              const normalize = createNormalize3();
              // This is the size of a post-script point in mm.
              const pointSize = 0.352777778;
              const scale = 1 / pointSize;
              const [width, height] = size;
              const lines = [];
              const matrix = multiply$1(
                fromTranslation([(width * scale) / 2, (height * scale) / 2, 0]),
                fromScaling([scale, scale, scale])
              );
              const keptGeometry = toKeptGeometry(transform$8(matrix, await geometry));
              for (const { tags, surface, z0Surface } of getAnyNonVoidSurfaces(
                keptGeometry
              )) {
                lines.push(toFillColor(toRgbFromTags(tags, black)));
                lines.push(toStrokeColor(toRgbFromTags(tags, black)));
                for (const path of outlineSurface(surface || z0Surface, normalize)) {
                  let nth = path[0] === null ? 1 : 0;
                  if (nth >= path.length) {
                    continue;
                  }
                  const [x1, y1] = path[nth];
                  lines.push(`${x1.toFixed(9)} ${y1.toFixed(9)} m`); // move-to.
                  for (nth++; nth < path.length; nth++) {
                    const [x2, y2] = path[nth];
                    lines.push(`${x2.toFixed(9)} ${y2.toFixed(9)} l`); // line-to.
                  }
                  lines.push(`h`); // Surface paths are always closed.
                }
                lines.push(`f`); // Surface paths are always filled.
              }
              for (const { tags, paths } of getNonVoidPaths(keptGeometry)) {
                lines.push(toStrokeColor(toRgbFromTags(tags, black)));
                for (const path of paths) {
                  let nth = path[0] === null ? 1 : 0;
                  if (nth >= path.length) {
                    continue;
                  }
                  const [x1, y1] = path[nth];
                  lines.push(`${x1.toFixed(9)} ${y1.toFixed(9)} m`); // move-to.
                  for (nth++; nth < path.length; nth++) {
                    const [x2, y2] = path[nth];
                    lines.push(`${x2.toFixed(9)} ${y2.toFixed(9)} l`); // line-to.
                  }
                  if (path[0] !== null) {
                    // A leading null indicates an open path.
                    lines.push(`h`); // close path.
                  }
                  lines.push(`S`); // stroke.
                }
              }

              const output = []
                .concat(header({ scale, width, height, lineWidth }), lines, footer)
                .join('\n');
              return new TextEncoder('utf8').encode(output);
            };

            const preparePdf = (shape, name, { lineWidth = 0.096 } = {}) => {
              let index = 0;
              const entries = [];
              for (const entry of ensurePages(shape.toKeptGeometry())) {
                const { size } = entry.layout;
                const op = toPdf(entry, { lineWidth, size });
                addPending(op);
                entries.push({
                  data: op,
                  filename: `${name}_${index++}.pdf`,
                  type: 'application/pdf',
                });
              }
              return entries;
            };

            const downloadPdfMethod = function (...args) {
              emit$1({ download: { entries: preparePdf(this, ...args) } });
              return this;
            };
            Shape.prototype.downloadPdf = downloadPdfMethod;
            Shape.prototype.pdf = downloadPdfMethod;

            const writePdf = (shape, name, { lineWidth = 0.096 } = {}) => {
              for (const { data, filename } of preparePdf(shape, name, { lineWidth })) {
                addPending(writeFile({ doSerialize: false }, `output/${filename}`, data));
              }
              return writePdf;
            };

            const writePdfMethod = function (...args) {
              return writePdf(this, ...args);
            };
            Shape.prototype.writePdf = writePdfMethod;

            const Plan = (
              { plan, marks = [], planes = [], tags = [], visualization, content },
              context
            ) => {
              let visualizationGeometry =
                visualization === undefined
                  ? taggedAssembly({})
                  : visualization.toKeptGeometry();
              let contentGeometry =
                content === undefined ? [] : content.map((shape) => shape.toKeptGeometry());
              const shape = Shape.fromGeometry(
                {
                  type: 'plan',
                  plan,
                  marks,
                  planes,
                  tags,
                  content: contentGeometry,
                  visualization: visualizationGeometry,
                },
                context
              );
              return shape;
            };

            const dp2 = (number) => Math.round(number * 100) / 100;

            const Apothem = (apothem = 1, sides = 32, center = [0, 0, 0]) => {
              const radius = Polygon.toRadiusFromApothem(apothem, sides);
              return Plan({
                plan: { apothem },
                marks: [center],
                visualization: Circle.ofRadius(radius)
                  .outline()
                  .add(Path([0, 0, 0], [0, radius, 0]))
                  .add(Hershey(radius / 10)(`A${dp2(apothem)}`).moveY(radius / 2))
                  .color('red'),
              });
            };

            Plan.Apothem = Apothem;

            const Diameter = (diameter = 1, center = [0, 0, 0]) => {
              const radius = diameter / 2;
              return Plan({
                plan: { diameter },
                marks: [center],
                visualization: Circle.ofDiameter(diameter)
                  .outline()
                  .add(Path([0, -radius, 0], [0, +radius, 0]))
                  .add(Hershey(radius / 10)(`D${dp2(diameter)}`))
                  .color('red'),
              });
            };
            Plan.Diameter = Diameter;

            const Label = (label, mark = [0, 0, 0]) =>
              Plan({ plan: { label }, marks: [mark] });
            Plan.Label = Label;

            const withLabelMethod = function (...args) {
              return this.with(Plan.Label(...args));
            };
            Shape.prototype.withLabel = withLabelMethod;

            const Length = (length) => {
              return Plan({
                plan: { length },
                visualization: Path([0, 0, 0], [0, length, 0])
                  .add(Hershey(length / 10)(`L${dp2(length)}`).moveY(length / 2))
                  .color('red'),
              });
            };
            Plan.Length = Length;

            // Radius

            const Radius = (radius = 1, center = [0, 0, 0]) =>
              Plan({
                plan: { radius },
                marks: [center],
                visualization: Circle.ofRadius(radius)
                  .outline()
                  .add(Path([0, 0, 0], [0, radius, 0]))
                  .add(Hershey(radius / 10)(`R${dp2(radius)}`).moveY(radius / 2))
                  .color('red'),
              });
            Plan.Radius = Radius;

            const prepareSvg = (shape, name, options = {}) => {
              let index = 0;
              const entries = [];
              for (const entry of ensurePages(shape.toKeptGeometry())) {
                const op = toSvg(entry, options);
                addPending(op);
                entries.push({
                  data: op,
                  filename: `${name}_${index++}.svg`,
                  type: 'image/svg+xml',
                });
              }
              return entries;
            };

            const downloadSvgMethod = function (...args) {
              const entries = prepareSvg(this, ...args);
              emit$1({ download: { entries } });
              return this;
            };
            Shape.prototype.downloadSvg = downloadSvgMethod;

            const writeSvg = (shape, name, options = {}) => {
              for (const { data, filename } of prepareSvg(shape, name, {})) {
                addPending(writeFile({ doSerialize: false }, `output/${filename}`, data));
              }
              return shape;
            };

            const writeSvgMethod = function (...args) {
              return writeSvg(this, ...args);
            };
            Shape.prototype.writeSvg = writeSvgMethod;

            const fromSolidToTriangles = (solid, triangles) => {
              for (const surface of makeWatertight$1(solid)) {
                for (const triangle of toTriangles({}, surface)) {
                  triangles.push(triangle);
                }
              }
            };

            const convertToFacets = (options, polygons) =>
              polygons
                .map(convertToFacet)
                .filter((facet) => facet !== undefined)
                .join('\n');

            const toStlVector = (vector) => `${vector[0]} ${vector[1]} ${vector[2]}`;

            const toStlVertex = (vertex) => `vertex ${toStlVector(vertex)}`;

            const convertToFacet = (polygon) => {
              const plane = toPlane(polygon);
              if (plane !== undefined) {
                return (
                  `facet normal ${toStlVector(toPlane(polygon))}\n` +
                  `outer loop\n` +
                  `${toStlVertex(polygon[0])}\n` +
                  `${toStlVertex(polygon[1])}\n` +
                  `${toStlVertex(polygon[2])}\n` +
                  `endloop\n` +
                  `endfacet`
                );
              }
            };

            const toStl = async (geometry, options = {}) => {
              const keptGeometry = toDisjointGeometry(await geometry);
              const triangles = [];
              for (const { solid } of getNonVoidSolids(keptGeometry)) {
                fromSolidToTriangles(solid, triangles);
              }
              const output = `solid JSxCAD\n${convertToFacets(
    options,
    canonicalize$4(triangles)
  )}\nendsolid JSxCAD\n`;
              return new TextEncoder('utf8').encode(output);
            };

            /**
             *
             * # Write STL
             *
             * ::: illustration { "view": { "position": [5, 5, 5] } }
             * ```
             * await Cube().writeStl('cube.stl');
             * await readStl({ path: 'cube.stl' });
             * ```
             * :::
             *
             **/

            const prepareStl = (shape, name, options = {}) => {
              // CHECK: Should this be limited to Page plans?
              let index = 0;
              const entries = [];
              for (const entry of ensurePages(shape.toKeptGeometry())) {
                const op = toStl(entry, options);
                addPending(op);
                entries.push({
                  data: op,
                  filename: `${name}_${index++}.stl`,
                  type: 'application/sla',
                });
              }
              return entries;
            };

            const downloadStlMethod = function (...args) {
              const entries = prepareStl(this, ...args);
              emit$1({ download: { entries } });
              return this;
            };
            Shape.prototype.downloadStl = downloadStlMethod;

            const writeStl = (shape, name, options = {}) => {
              for (const { data, filename } of prepareStl(shape, name, {})) {
                addPending(writeFile({ doSerialize: false }, `output/${filename}`, data));
              }
              return shape;
            };

            const method$3 = function (...args) {
              return writeStl(this, ...args);
            };
            Shape.prototype.writeStl = method$3;

            /**
             *
             * # Connector
             *
             * Returns a connector plan.
             * See connect().
             *
             * ::: illustration { "view": { "position": [60, -60, 60], "target": [0, 0, 0] } }
             * ```
             * Cube(10).with(Connector('top').move(5))
             * ```
             * :::
             * ::: illustration { "view": { "position": [60, -60, 60], "target": [0, 0, 0] } }
             * ```
             * Cube(10).Connector('top').moveZ(5).connect(Sphere(5).Connector('bottom').flip().moveZ(-5))
             * ```
             * :::
             **/

            const shapeToConnect = Symbol('shapeToConnect');

            // A connector is an oriented reference point.
            //
            // The orientation expresses the direction of facing orthogonal to that axis.
            // The joint may have a zero length (origin and end are equal), but axis must not equal origin.
            // Note: axis must be further than end from origin.

            const Connector = (
              connector,
              {
                plane = [0, 0, 1, 0],
                center = [0, 0, 0],
                right = [1, 0, 0],
                start = [0, 0, 0],
                end = [0, 0, 0],
                shape,
                visualization,
              } = {}
            ) => {
              const plan = Plan(
                // Geometry
                {
                  plan: { connector },
                  marks: [center, right, start, end],
                  planes: [plane],
                  tags: [`connector/${connector}`],
                  visualization,
                },
                // Context
                {
                  [shapeToConnect]: shape,
                }
              );
              return plan;
            };

            Plan.Connector = Connector;

            const ConnectorMethod = function (connector, options) {
              return Connector(connector, { ...options, [shapeToConnect]: this });
            };
            Shape.prototype.Connector = ConnectorMethod;

            Connector.signature =
              'Connector(id:string, { plane:Plane, center:Point, right:Point, start:Point, end:Point, shape:Shape, visualization:Shape }) -> Shape';

            // Associates an existing connector with a shape.
            const toConnectorMethod = function (connector, options) {
              return Shape.fromGeometry(connector.toKeptGeometry(), {
                ...options,
                [shapeToConnect]: this,
              });
            };
            Shape.prototype.toConnector = toConnectorMethod;

            /**
             *
             * # connectors
             *
             * Returns the set of connectors in an assembly by tag.
             * Note that connectors inside Items are not visible.
             * See connect().
             *
             * ::: illustration { "view": { "position": [60, -60, 60], "target": [0, 0, 0] } }
             * ```
             * Cube(10).with(Connector('top').moveZ(5))
             *         .connectors()['top']
             *         .connect(Prism(10, 10).with(Connector('bottom').flip().moveZ(-5))
             *                               .connectors()['bottom']);
             * ```
             * :::
             **/

            const connectors = (shape) => {
              const connectors = [];
              const walk = (geometry, descend) => {
                if (geometry.item) ; else if (geometry.plan && geometry.plan.connector) {
                  connectors.push(
                    Shape.fromGeometry(geometry, { [shapeToConnect]: shape })
                  );
                } else {
                  descend();
                }
              };
              visit(shape.toKeptGeometry(), walk);
              return connectors;
            };

            const connectorsMethod = function () {
              return connectors(this);
            };
            Shape.prototype.connectors = connectorsMethod;

            /**
             *
             * # connector
             *
             * Returns a connector from an assembly.
             * See connect().
             *
             * ::: illustration { "view": { "position": [60, -60, 60], "target": [0, 0, 0] } }
             * ```
             * Prism(10, 10).with(Connector('top').moveZ(5))
             *              .connector('top')
             *              .connect(Cube(10).with(Connector('bottom').flip().moveZ(-5))
             *                               .connector('bottom'));
             * ```
             * :::
             **/

            const connector = (shape, id) => {
              for (const connector of connectors(shape)) {
                if (connector.toGeometry().plan.connector === id) {
                  return connector;
                }
              }
            };

            const connectorMethod = function (id) {
              return connector(this, id);
            };
            Shape.prototype.connector = connectorMethod;

            // FIX:
            // This will produce the average position, but that's probably not what we
            // want, since it will include interior points produced by breaking up
            // convexity.
            const toPosition = (surface) => {
              let sum = [0, 0, 0];
              let count = 0;
              for (const path of surface) {
                for (const point of path) {
                  sum = add(sum, point);
                  count += 1;
                }
              }
              const position = scale(1 / count, sum);
              return position;
            };

            const faceConnector = (shape, id, scoreOrientation, scorePosition) => {
              let bestSurface;
              let bestPosition;
              let bestOrientationScore = -Infinity;
              let bestPositionScore = -Infinity;

              // FIX: This may be sensitive to noise.
              const geometry = shape.toKeptGeometry();
              for (const { solid } of getSolids(geometry)) {
                for (const surface of solid) {
                  const orientationScore = scoreOrientation(surface);
                  if (orientationScore > bestOrientationScore) {
                    bestSurface = surface;
                    bestOrientationScore = orientationScore;
                    bestPosition = toPosition(surface);
                    bestPositionScore = scorePosition(bestPosition);
                  } else if (orientationScore === bestOrientationScore) {
                    const position = toPosition(surface);
                    const positionScore = scorePosition(position);
                    if (positionScore > bestPositionScore) {
                      bestSurface = surface;
                      bestPosition = position;
                      bestPositionScore = positionScore;
                    }
                  }
                }
              }

              // FIX: We should have a consistent rule for deciding the rotational position of the connector.
              const plane = toPlane$2(bestSurface);
              return shape.toConnector(
                Connector(id, {
                  plane,
                  center: bestPosition,
                  right: add(bestPosition, orthogonal(plane)),
                })
              );
            };

            const toConnector = (shape, surface, id) => {
              const center = toPosition(surface);
              // FIX: Adding y + 1 is not always correct.
              const plane = toPlane$2(surface);
              return Connector(id, { plane, center, right: orthogonal(plane) });
            };

            const withConnector = (shape, surface, id) => {
              return shape.toConnector(toConnector(shape, surface, id));
            };

            const Y$f = 1;

            const back = (shape) =>
              shape.connector('back') ||
              faceConnector(
                shape,
                'back',
                (surface) => dot(toPlane$2(surface), [0, 1, 0, 0]),
                (point) => point[Y$f]
              );

            const backMethod = function () {
              return back(this);
            };
            Shape.prototype.back = backMethod;

            back.signature = 'back(shape:Shape) -> Shape';
            backMethod.signature = 'Shape -> back() -> Shape';

            const Z$b = 2;

            const bottom = (shape) =>
              shape.connector('bottom') ||
              faceConnector(
                shape,
                'bottom',
                (surface) => dot(toPlane$2(surface), [0, 0, -1, 0]),
                (point) => -point[Z$b]
              );

            const bottomMethod = function () {
              return bottom(this);
            };
            Shape.prototype.bottom = bottomMethod;

            bottom.signature = 'bottom(shape:Shape) -> Shape';
            bottomMethod.signature = 'Shape -> bottom() -> Shape';

            // Ideally this would be a plane of infinite extent.
            // Unfortunately this makes things like interpolation tricky,
            // so we approximate it with a very large polygon instead.

            const Z$1$7 = (z = 0) => {
              const size = 1e5;
              const min = -size;
              const max = size;
              // FIX: Why aren't we createing the connector directly?
              const sheet = Shape.fromPathToSurface([
                [max, min, z],
                [max, max, z],
                [min, max, z],
                [min, min, z],
              ]);
              return toConnector(sheet, sheet.toGeometry().surface, 'top');
            };

            /**
             *
             * # Chop
             *
             * Remove the parts of a shape above surface, defaulting to Z(0).
             *
             * ::: illustration { "view": { "position": [60, -60, 60], "target": [0, 0, 0] } }
             * ```
             * Cube(10).with(Cube(10).moveX(10).chop(Z(0)));
             * ```
             * :::
             * ::: illustration { "view": { "position": [60, -60, 60], "target": [0, 0, 0] } }
             * ```
             * Cube(10).with(Cube(10).moveX(10).chop(Z(0).flip()));
             * ```
             * :::
             *
             **/

            const toPlane$3 = (connector) => {
              for (const entry of getPlans(connector.toKeptGeometry())) {
                if (entry.plan && entry.plan.connector) {
                  return entry.planes[0];
                }
              }
            };

            const toSurface = (plane) => {
              const max = +1e5;
              const min = -1e5;
              const [, from] = toXYPlaneTransforms(plane);
              const path = [
                [max, max, 0],
                [min, max, 0],
                [min, min, 0],
                [max, min, 0],
              ];
              const polygon = transform$1(from, path);
              return [polygon];
            };

            const chop = (shape, connector = Z$1$7()) => {
              const cuts = [];
              const planeSurface = toSurface(toPlane$3(connector));
              for (const { solid, tags } of getSolids(shape.toKeptGeometry())) {
                const cutResult = cut$1(solid, planeSurface);
                cuts.push(Shape.fromGeometry({ type: 'solid', solid: cutResult, tags }));
              }
              for (const { surface, z0Surface, tags } of getAnySurfaces(
                shape.toKeptGeometry()
              )) {
                const cutSurface = surface || z0Surface;
                const cutResult = cut(planeSurface, cutSurface);
                cuts.push(
                  Shape.fromGeometry({ type: 'surface', surface: cutResult, tags })
                );
              }

              return Assembly(...cuts);
            };

            const chopMethod = function (surface) {
              return chop(this, surface);
            };
            Shape.prototype.chop = chopMethod;

            const Z$2$3 = 2;

            const findFlatTransforms = (shape) => {
              let bestDepth = Infinity;
              let bestTo;
              let bestFrom;
              let bestSurface;

              const assay = (surface) => {
                const plane = toPlane$2(surface);
                if (plane !== undefined) {
                  const [to, from] = toXYPlaneTransforms(plane);
                  const flatShape = shape.transform(to);
                  const [min, max] = flatShape.measureBoundingBox();
                  const depth = max[Z$2$3] - min[Z$2$3];
                  if (depth < bestDepth) {
                    bestDepth = depth;
                    bestTo = to;
                    bestFrom = from;
                    bestSurface = surface;
                  }
                }
              };

              const geometry = shape.toKeptGeometry();
              for (const { solid } of getSolids(geometry)) {
                for (const surface of solid) {
                  assay(surface);
                }
              }
              for (const { surface } of getSurfaces(geometry)) {
                assay(surface);
              }
              for (const { z0Surface } of getZ0Surfaces(geometry)) {
                assay(z0Surface);
              }

              return [bestTo, bestFrom, bestSurface];
            };

            const flat = (shape) => {
              const [, , bestSurface] = findFlatTransforms(shape);
              return withConnector(shape, bestSurface, 'flat');
            };

            const flatMethod = function () {
              return flat(this);
            };
            Shape.prototype.flat = flatMethod;

            flat.signature = 'flat(shape:Shape) -> Connector';
            flatMethod.signature = 'Shape -> flat() -> Connector';

            // Perform an operation on the shape in its best flat orientation,
            // returning the result in the original orientation.

            const inFlat = (shape, op) => {
              const [to, from] = findFlatTransforms(shape);
              return op(shape.transform(to)).transform(from);
            };

            const inFlatMethod = function (op = (_) => _) {
              return inFlat(this, op);
            };
            Shape.prototype.inFlat = inFlatMethod;

            const Y$1$7 = 1;

            const front = (shape) =>
              shape.connector('front') ||
              faceConnector(
                shape,
                'front',
                (surface) => dot(toPlane$2(surface), [0, -1, 0, 0]),
                (point) => -point[Y$1$7]
              );

            const frontMethod = function () {
              return front(this);
            };
            Shape.prototype.front = frontMethod;

            front.signature = 'front(shape:Shape) -> Shape';
            frontMethod.signature = 'Shape -> front() -> Shape';

            const X$f = 0;

            const left = (shape) =>
              shape.connector('left') ||
              faceConnector(
                shape,
                'left',
                (surface) => dot(toPlane$2(surface), [-1, 0, 0, 0]),
                (point) => -point[X$f]
              );

            const leftMethod = function () {
              return left(this);
            };
            Shape.prototype.left = leftMethod;

            left.signature = 'left(shape:Shape) -> Shape';
            leftMethod.signature = 'Shape -> left() -> Shape';

            const on$3 = (above, below, op = (_) => _) =>
              above.bottom().to(below.top().op(op));

            const onMethod = function (below, op) {
              return on$3(this, below, op);
            };

            Shape.prototype.on = onMethod;

            const X$1$7 = 0;

            const right = (shape) =>
              shape.connector('right') ||
              faceConnector(
                shape,
                'right',
                (surface) => dot(toPlane$2(surface), [1, 0, 0, 0]),
                (point) => point[X$1$7]
              );

            const rightMethod = function () {
              return right(this);
            };
            Shape.prototype.right = rightMethod;

            right.signature = 'right(shape:Shape) -> Shape';
            rightMethod.signature = 'Shape -> right() -> Shape';

            const Z$3$2 = 2;

            const top = (shape) =>
              shape.connector('top') ||
              faceConnector(
                shape,
                'top',
                (surface) => dot(toPlane$2(surface), [0, 0, 1, 0]),
                (point) => point[Z$3$2]
              );

            const topMethod = function () {
              return top(this);
            };
            Shape.prototype.top = topMethod;

            top.signature = 'top(shape:Shape) -> Shape';
            topMethod.signature = 'Shape -> top() -> Shape';

            /**
             *
             * # Unfold
             *
             **/

            // FIX: Does not handle convex solids.
            const unfold = (shape) => {
              const faces = shape.faces((f) => f);
              log$2(`Face count is ${faces.length}`);
              const faceByEdge = new Map();

              for (const face of faces) {
                for (const edge of face.faceEdges()) {
                  faceByEdge.set(edge, face);
                }
              }

              const reverseEdge = (edge) => {
                const [a, b] = edge.split(':');
                const reversedEdge = `${b}:${a}`;
                return reversedEdge;
              };

              const seen = new Set();
              const queue = [];

              const enqueueNeighbors = (face) => {
                for (const edge of face.faceEdges()) {
                  const redge = reverseEdge(edge);
                  const neighbor = faceByEdge.get(redge);
                  if (neighbor === undefined || seen.has(neighbor)) continue;
                  seen.add(neighbor);
                  queue.push({
                    face: neighbor,
                    to: `face/edge:${edge}`,
                    from: `face/edge:${redge}`,
                  });
                }
              };

              let root = faces[0];
              enqueueNeighbors(root);

              while (queue.length > 0) {
                const { face, from, to } = queue.shift();
                seen.add(face);
                const fromConnector = face.connector(from);
                const toConnector = root.connector(to);
                if (fromConnector === undefined) {
                  log$2('bad from');
                  continue;
                }
                if (toConnector === undefined) {
                  log$2('bad to');
                  continue;
                }
                root = fromConnector.to(toConnector);
                if (root === undefined) break;
                enqueueNeighbors(face);
              }

              return root;
            };

            const method$4 = function (...args) {
              return unfold(this);
            };
            Shape.prototype.unfold = method$4;

            // Ideally this would be a plane of infinite extent.
            // Unfortunately this makes things like interpolation tricky,
            // so we approximate it with a very large polygon instead.

            const X$2$2 = (x = 0) => {
              const size = 1e5;
              const min = -size;
              const max = size;
              const sheet = Shape.fromPathToSurface([
                [x, max, min],
                [x, max, max],
                [x, min, max],
                [x, min, min],
              ]);
              return toConnector(sheet, sheet.toGeometry().surface, 'top');
            };

            // Ideally this would be a plane of infinite extent.
            // Unfortunately this makes things like interpolation tricky,
            // so we approximate it with a very large polygon instead.

            const Y$2$2 = (y = 0) => {
              const size = 1e5;
              const min = -size;
              const max = size;
              const sheet = Shape.fromPathToSurface([
                [max, y, min],
                [max, y, max],
                [min, y, max],
                [min, y, min],
              ]);
              return toConnector(sheet, sheet.toGeometry().surface, 'top');
            };

            /**
             *
             * # Connect
             *
             * Connects two connectors.
             *
             * ::: illustration { "view": { "position": [60, -60, 0], "target": [0, 0, 0] } }
             * ```
             * Cube(10).Connector('top').moveZ(5)
             *         .connect(Sphere(10).Connector('bottom').flip().moveZ(-9))
             * ```
             * :::
             **/

            const toShape = (connector) => connector.getContext(shapeToConnect);

            const dropConnector = (shape, ...connectors) => {
              if (shape !== undefined) {
                return Shape.fromGeometry(
                  drop(
                    connectors.map((connector) => `connector/${connector}`),
                    shape.toGeometry()
                  )
                );
              }
            };

            const dropConnectorMethod = function (...connectors) {
              return dropConnector(this, ...connectors);
            };
            Shape.prototype.dropConnector = dropConnectorMethod;

            const CENTER = 0;
            const RIGHT = 1;

            const measureAngle = ([aX, aY], [bX, bY]) => {
              const a2 = Math.atan2(aX, aY);
              const a1 = Math.atan2(bX, bY);
              const sign = a1 > a2 ? 1 : -1;
              const angle = a1 - a2;
              const K = -sign * Math.PI * 2;
              const absoluteAngle =
                Math.abs(K + angle) < Math.abs(angle) ? K + angle : angle;
              return (absoluteAngle * 180) / Math.PI;
            };

            // FIX: Separate the doConnect dispatched interfaces.
            // Connect two shapes at the specified connector.
            const connect = (
              aConnectorShape,
              bConnectorShape,
              { doConnect = false, doAssemble = true } = {}
            ) => {
              const aConnector = toKeptGeometry(aConnectorShape.toGeometry()).content[0];
              const aShape = toShape(aConnectorShape);
              const [aTo] = toXYPlaneTransforms(
                aConnector.planes[0],
                subtract(aConnector.marks[RIGHT], aConnector.marks[CENTER])
              );

              const bConnector = toKeptGeometry(bConnectorShape.flip().toGeometry())
                .content[0];
              const bShape = toShape(bConnectorShape);
              const [bTo, bFrom] = toXYPlaneTransforms(
                bConnector.planes[0],
                subtract(bConnector.marks[RIGHT], bConnector.marks[CENTER])
              );

              // Flatten a.
              const aFlatShape = aShape.transform(aTo);
              const aFlatConnector = aConnectorShape.transform(aTo);
              const aMarks = aFlatConnector.toKeptGeometry().content[0].marks;
              const aFlatOriginShape = aFlatShape.move(...negate(aMarks[CENTER]));
              // const aFlatOriginConnector = aFlatConnector.move(...negate(aMarks[CENTER]));

              // Flatten b's connector.
              const bFlatConnector = toKeptGeometry(
                bConnectorShape.transform(bTo).toGeometry()
              ).content[0];
              const bMarks = bFlatConnector.marks;

              // Rotate into alignment.
              const aOrientation = subtract(aMarks[RIGHT], aMarks[CENTER]);
              const bOrientation = subtract(bMarks[RIGHT], bMarks[CENTER]);
              const angle = measureAngle(aOrientation, bOrientation);
              const aFlatOriginRotatedShape = aFlatOriginShape.rotateZ(-angle);
              // const aFlatOriginRotatedConnector = aFlatOriginConnector.rotateZ(-angle);

              // Move a to the flat position of b.
              const aFlatBShape = aFlatOriginRotatedShape.move(...bMarks[CENTER]);
              // const aFlatBConnector = aFlatOriginRotatedConnector.move(...bMarks[CENTER]);
              // Move a to the oriented position of b.
              const aMovedShape = aFlatBShape.transform(bFrom);
              // const aMovedConnector = aFlatBConnector.transform(bFrom);

              if (doConnect) {
                if (doAssemble) {
                  return dropConnector(aMovedShape, aConnector.plan.connector)
                    .Item()
                    .with(dropConnector(bShape, bConnector.plan.connector))
                    .Item();
                } else {
                  return dropConnector(aMovedShape, aConnector.plan.connector)
                    .Item()
                    .layer(dropConnector(bShape, bConnector.plan.connector))
                    .Item();
                }
              } else {
                return aMovedShape;
              }
            };

            const toMethod = function (connector, options) {
              return connect(this, connector, options);
            };
            Shape.prototype.to = toMethod;

            const fromMethod = function (connector, options) {
              return connect(connector, this, options);
            };
            Shape.prototype.from = fromMethod;

            const atMethod = function (connector, options) {
              return connect(this, connector, { ...options, doConnect: false });
            };
            Shape.prototype.at = atMethod;

            const X$g = 0;
            const Y$g = 1;
            const Z$c = 2;
            const RIGHT_ANGLE = Math.PI / -2;

            const isFinite$1 = Number.isFinite;
            const intersect$1 = (a, b, z) => [...intersect(a, b), z];

            const makeToolLine = (start, end, diameter) => {
              const direction = normalize(subtract(end, start));
              // The tool (with given diameter) passes along the outside of the path.
              const toolEdgeOffset = scale(diameter / 2, rotateZ(direction, RIGHT_ANGLE));
              // And in order to get sharp angles with a circular tool we need to cut a bit further.
              const toolStart = add(start, toolEdgeOffset);
              const toolEnd = add(end, toolEdgeOffset);
              const toolLine = fromPoints$2(toolStart, toolEnd);
              return [toolStart, toolEnd, toolLine];
            };

            // FIX: We assume a constant Z here.
            const toolpathEdges = (
              path,
              diameter = 1,
              overcut = true,
              solid = false
            ) => {
              const toolpaths = [];
              let toolpath;
              let lastToolLine;
              const edges = getEdges(path).filter(([start, end]) => !equals(start, end));
              for (const [start, end] of edges) {
                const [toolStart, toolEnd, thisToolLine] = makeToolLine(
                  start,
                  end,
                  diameter
                );
                if (!toolpath) {
                  toolpath = createOpenPath();
                  toolpaths.push(toolpath);
                }
                if (overcut) {
                  if (lastToolLine) {
                    // Move (back) to the intersection point from the overcut.
                    const intersection = intersect$1(thisToolLine, lastToolLine, start[Z$c]);
                    if (isFinite$1(intersection[X$g]) && isFinite$1(intersection[Y$g])) {
                      toolpath.push(intersection);
                    }
                  }
                  toolpath.push(toolStart, toolEnd);
                } else {
                  if (lastToolLine) {
                    // Replace the previous point with the intersection.
                    const intersection = intersect$1(thisToolLine, lastToolLine, start[Z$c]);
                    if (isFinite$1(intersection[X$g]) && isFinite$1(intersection[Y$g])) {
                      toolpath[toolpath.length - 1] = intersection;
                    }
                    toolpath.push(toolEnd);
                  } else {
                    toolpath.push(toolStart, toolEnd);
                  }
                }
                lastToolLine = thisToolLine;
              }
              if (isClosed(path) && !overcut) {
                // Rewrite the start and end to meet at their intersection.
                const [start, end] = edges[0];
                const [, , thisToolLine] = makeToolLine(start, end, diameter);
                const intersection = intersect$1(thisToolLine, lastToolLine, start[Z$c]);
                if (isFinite$1(intersection[X$g]) && isFinite$1(intersection[Y$g])) {
                  toolpath.shift();
                  toolpath[0] = intersection;
                  toolpath[toolpath.length - 1] = intersection;
                }
              }
              return toolpaths;
            };

            const toolpath = (
              geometry,
              diameter = 1,
              overcut = true,
              solid = false
            ) => {
              const toolpaths = [];
              for (const { paths } of getNonVoidPaths(geometry)) {
                for (const path of paths) {
                  toolpaths.push(...toolpathEdges(path, diameter, overcut, solid));
                }
              }
              return toolpaths;
            };

            /**
             *
             * # Chained Hull
             *
             * Builds a convex hull between adjacent pairs in a sequence of shapes.
             *
             * ::: illustration { "view": { "position": [30, 30, 30] } }
             * ```
             * chainHull(Cube(3).move(-5, 5),
             *           Sphere(3).move(5, -5),
             *           Cylinder(3, 10).move(-10, -10))
             *   .move(10, 10)
             * ```
             * :::
             * ::: illustration { "view": { "position": [80, 80, 0] } }
             * ```
             * chainHull(Circle(20).moveZ(-10),
             *           Circle(10),
             *           Circle(20).moveZ(10))
             * ```
             * :::
             *
             **/

            const Z$d = 2;

            const ChainedHull = (...shapes) => {
              const pointsets = shapes.map((shape) => shape.toPoints());
              const chain = [];
              for (let nth = 1; nth < pointsets.length; nth++) {
                const points = [...pointsets[nth - 1], ...pointsets[nth]];
                if (points.every((point) => point[Z$d] === 0)) {
                  chain.push(Shape.fromGeometry(buildConvexSurfaceHull(points)));
                } else {
                  chain.push(Shape.fromGeometry(buildConvexHull(points)));
                }
              }
              return Assembly(...chain);
            };

            const ChainedHullMethod = function (...args) {
              return ChainedHull(this, ...args);
            };
            Shape.prototype.ChainedHull = ChainedHullMethod;

            ChainedHull.signature = 'ChainedHull(...shapes:Shape) -> Shape';

            /**
             *
             * # Hull
             *
             * Builds the convex hull of a set of shapes.
             *
             * ::: illustration { "view": { "position": [30, 30, 30] } }
             * ```
             * hull(Point([0, 0, 10]),
             *      Circle(10))
             * ```
             * :::
             * ::: illustration { "view": { "position": [30, 30, 30] } }
             * ```
             * assemble(Point([0, 0, 10]),
             *          Circle(10))
             *   .hull()
             * ```
             * :::
             * ::: illustration { "view": { "position": [30, 30, 30] } }
             * ```
             * Point([0, 0, 10]).hull(Circle(10))
             * ```
             * :::
             * ::: illustration { "view": { "position": [30, 30, 30] } }
             * ```
             * hull(Circle(4),
             *      Circle(2).move(8));
             * ```
             * :::
             *
             **/

            const Z$1$8 = 2;

            const Hull = (...shapes) => {
              const points = [];
              shapes.forEach((shape) => shape.eachPoint((point) => points.push(point)));
              // FIX: Detect planar hulls properly.
              if (points.every((point) => point[Z$1$8] === 0)) {
                return Shape.fromGeometry(
                  taggedSurface({}, buildConvexSurfaceHull(points))
                );
              } else {
                return Shape.fromGeometry(taggedSolid({}, buildConvexHull(points)));
              }
            };

            const HullMethod = function (...shapes) {
              return Hull(this, ...shapes);
            };
            Shape.prototype.Hull = HullMethod;

            Hull.signature = 'Hull(shape:Shape, ...shapes:Shape) -> Shape';
            HullMethod.signature = 'Shape -> Hull(...shapes:Shape) -> Shape';

            /**
             *
             * # Lathe
             *
             * ::: illustration { "view": { "position": [-80, -80, 80] } }
             * ```
             * ```
             * :::
             *
             **/

            const Loop = (
              shape,
              endDegrees = 360,
              { sides = 32, pitch = 0 } = {}
            ) => {
              const profile = shape.chop(Y$2$2(0));
              const outline = profile.outline();
              const solids = [];
              for (const geometry of getPaths(outline.toKeptGeometry())) {
                for (const path of geometry.paths) {
                  for (
                    let startDegrees = 0;
                    startDegrees < endDegrees;
                    startDegrees += 360
                  ) {
                    solids.push(
                      Shape.fromGeometry(
                        loop(
                          path,
                          (Math.min(360, endDegrees - startDegrees) * Math.PI) / 180,
                          sides,
                          pitch
                        )
                      ).moveX((pitch * startDegrees) / 360)
                    );
                  }
                }
              }
              return Assembly(...solids);
            };

            const LoopMethod = function (...args) {
              return Loop(this, ...args);
            };
            Shape.prototype.Loop = LoopMethod;

            /**
             *
             * # Extrude
             *
             * Generates a solid from a surface by linear extrusion.
             *
             * ```
             * shape.extrude(height, depth, { twist = 0, steps = 1 })
             * ```
             *
             * ::: illustration
             * ```
             * Circle(10).cut(Circle(8))
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 60] } }
             * ```
             * Circle(10).cut(Circle(8)).extrude(10)
             * ```
             * :::
             *
             * ::: illustration { "view": { "position": [40, 40, 60] } }
             * ```
             * Triangle(10).extrude(5, -2)
             * ```
             * :::
             * ::: illustration { "view": { "position": [40, 40, 60] } }
             * ```
             * Triangle(10).extrude(10, 0, { twist: 90, steps: 10 })
             * ```
             * :::
             *
             **/

            const extrude$1 = (shape, height = 1, depth = 0) => {
              if (height < depth) {
                [height, depth] = [depth, height];
              }
              // FIX: Handle extrusion along a vector properly.
              const solids = [];
              const keptGeometry = shape.toKeptGeometry();
              for (const { z0Surface, tags } of getZ0Surfaces(keptGeometry)) {
                if (z0Surface.length > 0) {
                  const solid = alignVertices(extrude(z0Surface, height, depth));
                  solids.push(Shape.fromGeometry({ type: 'solid', solid, tags }));
                }
              }
              for (const { surface, tags } of getSurfaces(keptGeometry)) {
                if (surface.length > 0) {
                  const plane = toPlane$2(surface);
                  if (
                    plane[0] === 0 &&
                    plane[1] === 0 &&
                    plane[2] === 1 &&
                    plane[3] === 0
                  ) {
                    // Detect Z0.
                    // const solid = alignVertices(extrudeAlgorithm(surface, height, depth));
                    const solid = extrude(surface, height, depth);
                    solids.push(Shape.fromGeometry({ type: 'solid', solid, tags }));
                  } else {
                    const [toZ0, fromZ0] = toXYPlaneTransforms(toPlane$2(surface));
                    const z0SolidGeometry = extrude(
                      transform$4(toZ0, surface),
                      height,
                      depth
                    );
                    const solid = alignVertices(transform$5(fromZ0, z0SolidGeometry));
                    solids.push(Shape.fromGeometry({ type: 'solid', solid, tags }));
                  }
                }
              }
              // Keep plans.
              for (const entry of getPlans(keptGeometry)) {
                solids.push(entry);
              }
              return Assembly(...solids);
            };

            const extrudeMethod = function (...args) {
              return extrude$1(this, ...args);
            };
            Shape.prototype.extrude = extrudeMethod;

            extrude$1.signature =
              'extrude(shape:Shape, height:number = 1, depth:number = 1) -> Shape';
            extrudeMethod.signature =
              'Shape -> extrude(height:number = 1, depth:number = 1) -> Shape';

            const outline$1 = (
              shape,
              { includeFaces = true, includeHoles = true } = {}
            ) =>
              Assembly(
                ...outline(
                  shape.toGeometry(),
                  includeFaces,
                  includeHoles
                ).map((outline) => Shape.fromGeometry(outline))
              );

            const outlineMethod = function ({
              includeFaces = true,
              includeHoles = true,
            } = {}) {
              return outline$1(this, { includeFaces, includeHoles });
            };

            const withOutlineMethod = function ({
              includeFaces = true,
              includeHoles = true,
            } = {}) {
              return this.with(outline$1(this, { includeFaces, includeHoles }));
            };

            Shape.prototype.outline = outlineMethod;
            Shape.prototype.withOutline = withOutlineMethod;

            const inline = (shape) => outline$1(shape.flip());

            const inlineMethod = function (options) {
              return inline(this);
            };

            const withInlineMethod = function (options) {
              return this.with(inline(this));
            };

            Shape.prototype.inline = inlineMethod;
            Shape.prototype.withInline = withInlineMethod;

            /**
             *
             * # Interior
             *
             * Generates a surface from the interior of a simple closed path.
             *
             * ::: illustration
             * ```
             * Circle(10)
             * ```
             * :::
             * ::: illustration
             * ```
             * Circle(10)
             *   .outline()
             * ```
             * :::
             * ::: illustration
             * ```
             * Circle(10)
             *   .outline()
             *   .interior()
             * ```
             * :::
             *
             **/

            const interior = (shape) => {
              const surfaces = [];
              for (const { paths } of getPaths(shape.toKeptGeometry())) {
                // FIX: Check paths for coplanarity.
                surfaces.push(
                  Shape.fromPathsToSurface(
                    paths.filter(isClosed).filter((path) => path.length >= 3)
                  )
                );
              }
              return Assembly(...surfaces);
            };

            const interiorMethod = function (...args) {
              return interior(this);
            };
            Shape.prototype.interior = interiorMethod;

            interior.signature = 'interior(shape:Shape) -> Shape';
            interiorMethod.signature = 'Shape -> interior() -> Shape';

            /**
             *
             * # Minkowski (convex)
             *
             * Generates the minkowski sum of a two convex shapes.
             *
             * ::: illustration { "view": { "position": [40, 40, 40] } }
             * ```
             * minkowski(Cube(10),
             *           Sphere(3));
             * ```
             * :::
             *
             **/

            // TODO: Generalize for more operands?
            const minkowski = (a, b) => {
              const aPoints = [];
              const bPoints = [];
              a.eachPoint((point) => aPoints.push(point));
              b.eachPoint((point) => bPoints.push(point));
              return Shape.fromGeometry(buildConvexMinkowskiSum(aPoints, bPoints));
            };

            const minkowskiMethod = function (shape) {
              return minkowski(this, shape);
            };
            Shape.prototype.minkowski = minkowskiMethod;

            minkowski.signature = 'minkowski(a:Shape, b:Shape) -> Shape';

            /**
             *
             * # Section
             *
             * Produces a cross-section of a solid as a surface.
             *
             * ::: illustration { "view": { "position": [40, 40, 60] } }
             * ```
             * difference(Cylinder(10, 10),
             *            Cylinder(8, 10))
             * ```
             * :::
             * ::: illustration
             * ```
             * difference(Sphere(10),
             *            Sphere(8))
             *   .section()
             * ```
             * :::
             * ::: illustration
             * ```
             * difference(Sphere(10),
             *            Sphere(8))
             *   .section()
             *   .outline()
             * ```
             * :::
             *
             **/

            const toPlane$4 = (connector) => {
              for (const entry of getPlans(connector.toKeptGeometry())) {
                if (entry.plan && entry.plan.connector) {
                  return entry.planes[0];
                }
              }
            };

            const toSurface$1 = (plane) => {
              const max = +1e5;
              const min = -1e5;
              const [, from] = toXYPlaneTransforms(plane);
              const path = [
                [max, max, 0],
                [min, max, 0],
                [min, min, 0],
                [max, min, 0],
              ];
              const polygon = transform$1(from, path);
              return [polygon];
            };

            const section$1 = (solidShape, ...connectors) => {
              if (connectors.length === 0) {
                connectors.push(Z$1$7(0));
              }
              const planes = connectors.map(toPlane$4);
              const planeSurfaces = planes.map(toSurface$1);
              const shapes = [];
              const normalize = createNormalize3();
              for (const { solid, tags } of getSolids(solidShape.toKeptGeometry())) {
                const sections = section(solid, planeSurfaces, normalize);
                const surfaces = sections.map((section) => makeConvex$1(section, normalize));
                for (let i = 0; i < surfaces.length; i++) {
                  surfaces[i].plane = planes[i];
                  shapes.push(
                    Shape.fromGeometry({ type: 'surface', surface: surfaces[i], tags })
                  );
                }
              }
              return Layers(...shapes);
            };

            const sectionMethod = function (...args) {
              return section$1(this, ...args);
            };
            Shape.prototype.section = sectionMethod;

            const squash = (shape) => {
              const geometry = shape.toKeptGeometry();
              const result = taggedLayers({});
              for (const { solid, tags } of getSolids(geometry)) {
                const polygons = [];
                for (const surface of solid) {
                  for (const path of surface) {
                    const flat = path.map(([x, y]) => [x, y, 0]);
                    if (toPlane(flat) === undefined) continue;
                    polygons.push(isCounterClockwise(flat) ? flat : flip(flat));
                  }
                }
                result.content.push(
                  union$3(...polygons.map((polygon) => taggedZ0Surface({ tags }, [polygon])))
                );
              }
              for (const { surface, tags } of getSurfaces(geometry)) {
                const polygons = [];
                for (const path of surface) {
                  const flat = path.map(([x, y]) => [x, y, 0]);
                  if (toPlane(flat) === undefined) continue;
                  polygons.push(isCounterClockwise(flat) ? flat : flip(flat));
                }
                result.content.push(taggedZ0Surface({ tags }, polygons));
              }
              for (const { z0Surface, tags } of getZ0Surfaces(geometry)) {
                const polygons = [];
                for (const path of z0Surface) {
                  polygons.push(path);
                }
                result.content.push(taggedZ0Surface({ tags }, polygons));
              }
              for (const { paths, tags } of getPaths(geometry)) {
                const flatPaths = [];
                for (const path of paths) {
                  flatPaths.push(path.map(([x, y]) => [x, y, 0]));
                }
                result.content.push({ type: 'paths', paths: flatPaths, tags });
                result.content.push(taggedPaths({ tags }, flatPaths));
              }
              return Shape.fromGeometry(result);
            };

            const squashMethod = function () {
              return squash(this);
            };
            Shape.prototype.squash = squashMethod;

            /**
             *
             * # Stretch
             *
             **/

            const toPlaneFromConnector = (connector) => {
              for (const entry of getPlans(connector.toKeptGeometry())) {
                if (entry.plan && entry.plan.connector) {
                  return entry.planes[0];
                }
              }
            };

            const toSurface$1$1 = (plane) => {
              const max = +1e5;
              const min = -1e5;
              const [, from] = toXYPlaneTransforms(plane);
              const path = [
                [max, max, 0],
                [min, max, 0],
                [min, min, 0],
                [max, min, 0],
              ];
              const polygon = transform$1(from, path);
              return [polygon];
            };

            const stretch = (shape, length, connector = Z$1$7()) => {
              const normalize = createNormalize3();
              const stretches = [];
              const planeSurface = toSurface$1$1(toPlaneFromConnector(connector));
              for (const { solid, tags } of getSolids(shape.toKeptGeometry())) {
                if (solid.length === 0) {
                  continue;
                }
                const bottom = cutOpen(solid, planeSurface, normalize);
                const [profile] = section(solid, [planeSurface], normalize);
                const top = cutOpen(solid, flip$4(planeSurface), normalize);
                const [toZ0, fromZ0] = toXYPlaneTransforms(toPlane$2(profile));
                const z0SolidGeometry = extrude(
                  transform$4(toZ0, profile),
                  length,
                  0,
                  false
                );
                const middle = transform$5(fromZ0, z0SolidGeometry);
                const topMoved = transform$5(
                  fromTranslation(scale(length, toPlane$2(profile))),
                  top
                );
                stretches.push(
                  Shape.fromGeometry({
                    type: 'solid',
                    solid: alignVertices([...bottom, ...middle, ...topMoved], normalize),
                    tags,
                  })
                );
              }

              return Assembly(...stretches);
            };

            const method$5 = function (...args) {
              return stretch(this, ...args);
            };
            Shape.prototype.stretch = method$5;

            /**
             *
             * # Sweep
             *
             * Sweep a tool profile along a path, to produce a surface.
             *
             **/

            // FIX: This is a weak approximation assuming a 1d profile -- it will need to be redesigned.
            const sweep = (toolpath, tool) => {
              const chains = [];
              for (const { paths } of getPaths(toolpath.toKeptGeometry())) {
                for (const path of paths) {
                  chains.push(
                    ...getEdges(path).map(([start, end]) =>
                      Hull(tool.move(...start), tool.move(...end))
                    )
                  );
                }
              }
              return Assembly(...chains);
            };

            const sweepMethod = function (tool) {
              return sweep(this, tool);
            };

            Shape.prototype.sweep = sweepMethod;
            Shape.prototype.withSweep = function (tool) {
              return this.with(sweep(this, tool));
            };

            const toolpath$1 = (
              shape,
              diameter = 1,
              { overcut = false, solid = true } = {}
            ) =>
              Shape.fromGeometry({
                type: 'paths',
                paths: toolpath(shape.toKeptGeometry(), diameter, overcut, solid),
              });

            const method$1$1 = function (...options) {
              return toolpath$1(this, ...options);
            };

            Shape.prototype.toolpath = method$1$1;
            Shape.prototype.withToolpath = function (...args) {
              return this.with(toolpath$1(this, ...args));
            };

            const X$h = 0;
            const Y$h = 1;
            const Z$2$4 = 2;

            const floor = (value, resolution) =>
              Math.floor(value / resolution) * resolution;
            const ceil = (value, resolution) => Math.ceil(value / resolution) * resolution;

            const floorPoint = ([x, y, z], resolution) => [
              floor(x, resolution),
              floor(y, resolution),
              floor(z, resolution),
            ];
            const ceilPoint = ([x, y, z], resolution) => [
              ceil(x, resolution),
              ceil(y, resolution),
              ceil(z, resolution),
            ];

            const voxels = (shape, resolution = 1) => {
              const offset = resolution / 2;
              const geometry = shape.toDisjointGeometry();
              const normalize = createNormalize3();
              const [boxMin, boxMax] = measureBoundingBox$4(geometry);
              const min = floorPoint(boxMin, resolution);
              const max = ceilPoint(boxMax, resolution);
              const classifiers = [];
              for (const { solid } of getSolids(shape.toDisjointGeometry())) {
                classifiers.push({ bsp: fromSolid$1(solid, normalize) });
              }
              const test = (point) => {
                for (const { bsp } of classifiers) {
                  if (containsPoint(bsp, point)) {
                    return true;
                  }
                }
                return false;
              };
              const polygons = [];
              for (let x = min[X$h] - offset; x <= max[X$h] + offset; x += resolution) {
                for (let y = min[Y$h] - offset; y <= max[Y$h] + offset; y += resolution) {
                  for (let z = min[Z$2$4] - offset; z <= max[Z$2$4] + offset; z += resolution) {
                    const state = test([x, y, z]);
                    if (state !== test([x + resolution, y, z])) {
                      const face = [
                        [x + offset, y - offset, z - offset],
                        [x + offset, y + offset, z - offset],
                        [x + offset, y + offset, z + offset],
                        [x + offset, y - offset, z + offset],
                      ];
                      polygons.push(state ? face : face.reverse());
                    }
                    if (state !== test([x, y + resolution, z])) {
                      const face = [
                        [x - offset, y + offset, z - offset],
                        [x + offset, y + offset, z - offset],
                        [x + offset, y + offset, z + offset],
                        [x - offset, y + offset, z + offset],
                      ];
                      polygons.push(state ? face.reverse() : face);
                    }
                    if (state !== test([x, y, z + resolution])) {
                      const face = [
                        [x - offset, y - offset, z + offset],
                        [x + offset, y - offset, z + offset],
                        [x + offset, y + offset, z + offset],
                        [x - offset, y + offset, z + offset],
                      ];
                      polygons.push(state ? face : face.reverse());
                    }
                  }
                }
              }
              return Shape.fromGeometry(taggedSolid({}, fromPolygons(polygons)));
            };

            const voxelsMethod = function (...args) {
              return voxels(this, ...args);
            };
            Shape.prototype.voxels = voxelsMethod;

            const surfaceCloud = (shape, resolution = 1) => {
              const offset = resolution / 2;
              const geometry = shape.toDisjointGeometry();
              const normalize = createNormalize3();
              const [boxMin, boxMax] = measureBoundingBox$4(geometry);
              const min = floorPoint(boxMin, resolution);
              const max = ceilPoint(boxMax, resolution);
              const classifiers = [];
              for (const { solid } of getSolids(shape.toDisjointGeometry())) {
                classifiers.push({ bsp: fromSolid$1(solid, normalize) });
              }
              const test = (point) => {
                for (const { bsp } of classifiers) {
                  if (containsPoint(bsp, point)) {
                    return true;
                  }
                }
                return false;
              };
              const paths = [];
              for (let x = min[X$h] - offset; x <= max[X$h] + offset; x += resolution) {
                for (let y = min[Y$h] - offset; y <= max[Y$h] + offset; y += resolution) {
                  for (let z = min[Z$2$4] - offset; z <= max[Z$2$4] + offset; z += resolution) {
                    const state = test([x, y, z]);
                    if (state !== test([x + resolution, y, z])) {
                      paths.push([null, [x, y, z], [x + resolution, y, z]]);
                    }
                    if (state !== test([x, y + resolution, z])) {
                      paths.push([null, [x, y, z], [x, y + resolution, z]]);
                    }
                    if (state !== test([x, y, z + resolution])) {
                      paths.push([null, [x, y, z], [x, y, z + resolution]]);
                    }
                  }
                }
              }
              return Shape.fromGeometry(taggedPaths({}, paths));
            };

            const surfaceCloudMethod = function (...args) {
              return surfaceCloud(this, ...args);
            };
            Shape.prototype.surfaceCloud = surfaceCloudMethod;

            const withSurfaceCloudMethod = function (...args) {
              return this.with(surfaceCloud(this, ...args));
            };
            Shape.prototype.withSurfaceCloud = withSurfaceCloudMethod;

            const orderPoints = ([aX, aY, aZ], [bX, bY, bZ]) => {
              const dX = aX - bX;
              if (dX !== 0) {
                return dX;
              }
              const dY = aY - bY;
              if (dY !== 0) {
                return dY;
              }
              const dZ = aZ - bZ;
              return dZ;
            };

            const cloud = (shape, resolution = 1) => {
              const offset = resolution / 2;
              const geometry = shape.toDisjointGeometry();
              const normalize = createNormalize3();
              const [boxMin, boxMax] = measureBoundingBox$4(geometry);
              const min = floorPoint(boxMin, resolution);
              const max = ceilPoint(boxMax, resolution);
              const classifiers = [];
              for (const { solid } of getSolids(shape.toDisjointGeometry())) {
                classifiers.push({ bsp: fromSolid$1(solid, normalize) });
              }
              const test = (point) => {
                for (const { bsp } of classifiers) {
                  if (containsPoint(bsp, point)) {
                    return true;
                  }
                }
                return false;
              };
              const points = [];
              for (let x = min[X$h] - offset; x <= max[X$h] + offset; x += resolution) {
                for (let y = min[Y$h] - offset; y <= max[Y$h] + offset; y += resolution) {
                  for (let z = min[Z$2$4] - offset; z <= max[Z$2$4] + offset; z += resolution) {
                    if (test([x, y, z])) {
                      points.push([x, y, z]);
                    }
                  }
                }
              }
              points.sort(orderPoints);
              return Shape.fromGeometry(taggedPoints({}, points));
            };

            const cloudMethod = function (...args) {
              return cloud(this, ...args);
            };
            Shape.prototype.cloud = cloudMethod;

            // FIX: move this
            const containsPoint$1 = (shape, point) => {
              for (const { solid } of getSolids(shape.toDisjointGeometry())) {
                const bsp = fromSolid$1(solid, createNormalize3());
                if (containsPoint(bsp, point)) {
                  return true;
                }
              }
              return false;
            };

            const containsPointMethod = function (point) {
              return containsPoint$1(this, point);
            };
            Shape.prototype.containsPoint = containsPointMethod;

            const heightCloud = (shape, resolution) => {
              const heights = measureHeights(shape.toDisjointGeometry(), resolution);
              return Shape.fromGeometry(taggedPoints({}, heights));
            };

            const heightCloudMethod = function (resolution) {
              return heightCloud(this, resolution);
            };
            Shape.prototype.heightCloud = heightCloudMethod;

            const ofPoints$1 = (a, b) => fromPoints$2(a, b);
            const meet = (a, b) => intersect(a, b);

            const Line2 = (...args) => ofPoints$1(...args);

            Line2.ofPoints = ofPoints$1;
            Line2.meet = meet;

            // From: http://paulbourke.net/geometry/pointlineplane/

            /*
            //   Calculate the line segment PaPb that is the shortest route between
            //   two lines P1P2 and P3P4. Calculate also the values of mua and mub where
            //      Pa = P1 + mua (P2 - P1)
            //      Pb = P3 + mub (P4 - P3)
            //   Return FALSE if no solution exists.
            int LineLineIntersect(
               XYZ p1,XYZ p2,XYZ p3,XYZ p4,XYZ *pa,XYZ *pb,
               double *mua, double *mub)
            {
               XYZ p13,p43,p21;
               double d1343,d4321,d1321,d4343,d2121;
               double numer,denom;

               p13.x = p1.x - p3.x;
               p13.y = p1.y - p3.y;
               p13.z = p1.z - p3.z;
               p43.x = p4.x - p3.x;
               p43.y = p4.y - p3.y;
               p43.z = p4.z - p3.z;

               if (ABS(p43.x) < EPS && ABS(p43.y) < EPS && ABS(p43.z) < EPS)
                  return(FALSE);

               p21.x = p2.x - p1.x;
               p21.y = p2.y - p1.y;
               p21.z = p2.z - p1.z;

               if (ABS(p21.x) < EPS && ABS(p21.y) < EPS && ABS(p21.z) < EPS)
                  return(FALSE);

               d1343 = p13.x * p43.x + p13.y * p43.y + p13.z * p43.z;
               d4321 = p43.x * p21.x + p43.y * p21.y + p43.z * p21.z;
               d1321 = p13.x * p21.x + p13.y * p21.y + p13.z * p21.z;
               d4343 = p43.x * p43.x + p43.y * p43.y + p43.z * p43.z;
               d2121 = p21.x * p21.x + p21.y * p21.y + p21.z * p21.z;

               denom = d2121 * d4343 - d4321 * d4321;

               if (ABS(denom) < EPS)
                  return(FALSE);

               numer = d1343 * d4321 - d1321 * d4343;

               *mua = numer / denom;
               *mub = (d1343 + d4321 * (*mua)) / d4343;

               pa->x = p1.x + *mua * p21.x;
               pa->y = p1.y + *mua * p21.y;
               pa->z = p1.z + *mua * p21.z;
               pb->x = p3.x + *mub * p43.x;
               pb->y = p3.y + *mub * p43.y;
               pb->z = p3.z + *mub * p43.z;

               return(TRUE);
            }
            */

            const EPSILON$5 = 1e-5;
            const X$i = 0;
            const Y$i = 1;
            const Z$e = 2;

            /**
             * Calculate the line segment PaPb that is the shortest route between
             * two lines P1-P2 and P3-P4.
             *
             * Calculate also the values of mua and mub where
             *   Pa = P1 + mua (P2 - P1)
             *   Pb = P3 + mub (P4 - P3)
             *
             * Return undefined if no solution exists.
             * Otherwise return the shortest connecting line segment.
             */

            const closestSegmentBetweenLines = ([p1, p2], [p3, p4]) => {
              const p13 = [p1[X$i] - p3[X$i], p1[Y$i] - p3[Y$i], p1[Z$e] - p3[Z$e]];
              const p43 = [p4[X$i] - p3[X$i], p4[Y$i] - p3[Y$i], p4[Z$e] - p3[Z$e]];

              if (
                Math.abs(p43[X$i]) < EPSILON$5 &&
                Math.abs(p43[Y$i]) < EPSILON$5 &&
                Math.abs(p43[Z$e]) < EPSILON$5
              ) {
                return [null, null];
              }

              const p21 = [p2[X$i] - p1[X$i], p2[Y$i] - p1[Y$i], p2[Z$e] - p1[Z$e]];

              if (
                Math.abs(p21[X$i]) < EPSILON$5 &&
                Math.abs(p21[Y$i]) < EPSILON$5 &&
                Math.abs(p21[Z$e]) < EPSILON$5
              ) {
                return [null, null];
              }

              const d1343 = p13[X$i] * p43[X$i] + p13[Y$i] * p43[Y$i] + p13[Z$e] * p43[Z$e];
              const d4321 = p43[X$i] * p21[X$i] + p43[Y$i] * p21[Y$i] + p43[Z$e] * p21[Z$e];
              const d1321 = p13[X$i] * p21[X$i] + p13[Y$i] * p21[Y$i] + p13[Z$e] * p21[Z$e];
              const d4343 = p43[X$i] * p43[X$i] + p43[Y$i] * p43[Y$i] + p43[Z$e] * p43[Z$e];
              const d2121 = p21[X$i] * p21[X$i] + p21[Y$i] * p21[Y$i] + p21[Z$e] * p21[Z$e];

              const denominator = d2121 * d4343 - d4321 * d4321;

              if (Math.abs(denominator) < EPSILON$5) {
                return [null, null];
              }

              const numerator = d1343 * d4321 - d1321 * d4343;

              const mua = numerator / denominator;
              const mub = (d1343 + d4321 * mua) / d4343;

              const pa = [p1[X$i] + mua * p21[X$i], p1[Y$i] + mua * p21[Y$i], p1[Z$e] + mua * p21[Z$e]];
              const pb = [p3[X$i] + mub * p43[X$i], p3[Y$i] + mub * p43[Y$i], p3[Z$e] + mub * p43[Z$e]];

              return [pa, pb];
            };

            /**
             *
             * # Shell
             *
             * Converts a solid into a hollow shell of a given thickness.
             *
             * ::: illustration
             * ```
             * Cube(10).shell(1);
             * ```
             * :::
             *
             **/

            const START = 0;
            const END = 1;

            const Shell = (radius = 1, resolution = 3, ...shapes) => {
              const normalize3 = createNormalize3();
              resolution = Math.max(resolution, 3);
              const pieces = [];
              for (const shape of shapes) {
                for (const { solid, tags = [] } of getNonVoidSolids(
                  shape.toDisjointGeometry()
                )) {
                  for (const surface of solid) {
                    for (const polygon of surface) {
                      pieces.push(
                        Hull(
                          ...polygon.map((point) =>
                            Sphere(radius, { resolution }).move(...point)
                          )
                        )
                          .setTags(tags)
                          .toGeometry()
                      );
                    }
                  }
                }
                // FIX: This is more expensive than necessary.
                const surfaces = [];
                for (const { surface, z0Surface } of getAnyNonVoidSurfaces(
                  shape.toDisjointGeometry()
                )) {
                  const thisSurface = surface || z0Surface;
                  const plane = toPlane$2(thisSurface);
                  const rotate90 = fromRotation(Math.PI / -2, plane);
                  const getDirection = (start, end) => normalize(subtract(end, start));
                  const getOffset = ([start, end]) => {
                    const direction = getDirection(start, end);
                    const offset = transform(rotate90, scale(radius, direction));
                    return offset;
                  };
                  const getOuter = (offset, [start, end]) => [
                    add(start, offset),
                    add(end, offset),
                  ];
                  const getInner = (offset, [start, end]) => [
                    subtract(start, offset),
                    subtract(end, offset),
                  ];
                  for (const path of outlineSurface(thisSurface, normalize3)) {
                    const edges = getEdges(path);
                    let last = edges[edges.length - 2];
                    let current = edges[edges.length - 1];
                    let next = edges[0];
                    for (
                      let nth = 0;
                      nth < edges.length;
                      last = current, current = next, next = edges[++nth]
                    ) {
                      const lastOffset = getOffset(last);
                      const currentOffset = getOffset(current);
                      const nextOffset = getOffset(next);
                      const lastOuter = getOuter(lastOffset, last);
                      const lastInner = getInner(lastOffset, last);
                      const currentOuter = getOuter(currentOffset, current);
                      const currentInner = getInner(currentOffset, current);
                      const nextOuter = getOuter(nextOffset, next);
                      const nextInner = getInner(nextOffset, next);
                      // FIX: The projected offsets can cross.
                      const startOuter =
                        closestSegmentBetweenLines(lastOuter, currentOuter)[END] ?? currentOuter[START];
                      const endOuter =
                        closestSegmentBetweenLines(currentOuter, nextOuter)[START] ?? currentOuter[END];
                      const startInner =
                        closestSegmentBetweenLines(lastInner, currentInner)[END] ?? currentInner[START];
                      const endInner =
                        closestSegmentBetweenLines(currentInner, nextInner)[START] ?? currentInner[END];
                      // Build an offset surface.
                      const polygon = [endOuter, endInner, startInner, startOuter];
                      const currentDirection = getDirection(current[0], current[1]);
                      if (dot(currentDirection, getDirection(startOuter, endOuter)) < 0) {
                        // Swap the direction of the outer offset.
                        polygon[0] = startOuter;
                        polygon[3] = endOuter;
                      }
                      if (dot(currentDirection, getDirection(startInner, endInner)) < 0) {
                        // Swap the direction of the inner offset.
                        polygon[1] = startInner;
                        polygon[2] = endInner;
                      }
                      // These need to be distinct surfaces so that they can be unioned.
                      surfaces.push(taggedSurface({}, [polygon]));
                    }
                  }
                  pieces.push(union$3(...surfaces));
                }
              }

              return Shape.fromGeometry(taggedAssembly({}, ...pieces));
            };

            const shellMethod = function (radius, resolution) {
              return Shell(radius, resolution, this);
            };
            Shape.prototype.shell = shellMethod;

            const outerShellMethod = function (radius, resolution) {
              return Shell(radius, resolution, this).cut(this);
            };
            Shape.prototype.outerShell = outerShellMethod;

            const innerShellMethod = function (radius, resolution) {
              return Shell(radius, resolution, this).clip(this);
            };
            Shape.prototype.innerShell = innerShellMethod;

            const grow = (shape, amount = 1, { resolution = 3 } = {}) => {
              const normalize = createNormalize3();
              resolution = Math.max(resolution, 3);
              const pieces = [];
              for (const { solid, tags = [] } of getSolids(shape.toDisjointGeometry())) {
                for (const cloud of toConvexClouds(
                  fromSolid$1(solid, normalize),
                  normalize
                )) {
                  pieces.push(
                    Hull(...cloud.map((point) => Sphere(amount, resolution).move(...point)))
                      .setTags(tags)
                      .toGeometry()
                  );
                }
              }
              return Shape.fromGeometry(taggedLayers({}, ...pieces));
            };

            const growMethod = function (...args) {
              return grow(this, ...args);
            };
            Shape.prototype.grow = growMethod;

            const offset = (shape, radius = 1, resolution = 16) =>
              outline$1(grow(shape, radius, resolution));

            const offsetMethod = function (radius, resolution) {
              return offset(this, radius, resolution);
            };
            Shape.prototype.offset = offsetMethod;

            const shrink = (shape, amount, { resolution = 3 } = {}) => {
              if (amount === 0) {
                return shape;
              } else {
                return shape.cut(Shell(amount, { resolution }, shape));
              }
            };

            const shrinkMethod = function (amount, { resolution = 3 } = {}) {
              return shrink(this, amount, { resolution });
            };
            Shape.prototype.shrink = shrinkMethod;

            const BenchPlane = (
              width = 50,
              {
                cutDepth = 0.3,
                cutHeight = 1000,
                toolDiameter = 3.175,
                axialRate = 0.25,
                millingStyle = 'any',
                sweep = 'cut',
              } = {}
            ) => (length, depth) => {
              let points = [];
              const pointset = [points];
              const toolRadius = toolDiameter / 2;
              const advances = Math.ceil(length / (toolDiameter * axialRate));
              const actualAdvance = length / advances;
              // An extra leveling pass at the end if we ramp.
              const cuts = Math.ceil(depth / Math.min(depth, cutDepth));
              const actualCut = depth / cuts;
              for (let advance = 0; advance < advances; advance++) {
                const x = toolRadius + advance * actualAdvance;
                for (let cut = 0; cut < cuts; cut++) {
                  const startZ = Math.max(0 - actualCut * cut, 0 - depth);
                  const endZ = Math.max(startZ - actualCut, 0 - depth);
                  const startY = 0 + toolRadius;
                  const endY = width - toolRadius;
                  switch (millingStyle) {
                    case 'climb':
                      // Plunge and cut straight.
                      // Jump back for the next pass.
                      points.push(Point(x, startY, endZ), Point(x, endY, endZ));
                      points = [];
                      pointset.push(points);
                      break;
                    case 'conventional':
                      // Plunge and cut straight.
                      // Jump back for the next pass.
                      points.push(Point(x, endY, endZ), Point(x, startY, endZ));
                      points = [];
                      pointset.push(points);
                      break;
                    case 'any':
                      // Cut down sideways in one direction.
                      // Then back in the other.
                      if (cut % 2) {
                        points.push(Point(x, startY, startZ), Point(x, endY, endZ));
                        if (cut + 1 === cuts) {
                          // Come back across the flat to finish the last pass.
                          points.push(Point(x, startY, endZ));
                        }
                      } else {
                        points.push(Point(x, endY, startZ), Point(x, startY, endZ));
                        if (cut + 1 === cuts) {
                          // Come back across the flat to finish the last pass.
                          points.push(Point(x, endY, endZ));
                        }
                      }
                      break;
                    default:
                      throw Error(`Unknown millingStyle: ${millingStyle}`);
                  }
                }
                if (points.length > 0) {
                  // Make sure there's a new toolpath so we jump to it.
                  points = [];
                  pointset.push(points);
                }
              }
              return Assembly(
                ...pointset.map((points) => Toolpath(...points)),
                sweep === 'no'
                  ? undefined
                  : Cube(length, width, cutHeight + cutDepth)
                      .benchTop()
                      .moveZ(-depth)
                      .op((s) => (sweep === 'show' ? s : s.Void()))
              );
            };

            const BenchSaw = (
              width,
              {
                toolDiameter,
                cutDepth,
                axialRate,
                millingStyle = 'any',
                sweep = 'cut',
              } = {}
            ) => (length, depth) =>
              BenchPlane(length, {
                toolDiameter,
                cutDepth,
                axialRate,
                millingStyle,
                sweep,
              })(width, depth).moveX(-width);

            const DrillPress = (
              diameter = 10,
              { toolDiameter = 3.175, cutDepth = 0.3, sides = 16, sweep = 'cut' } = {}
            ) => (depth = 0, x = 0, y = 0) => {
              const radius = diameter / 2;
              const points = [];
              const toolRadius = toolDiameter / 2;
              const cuts = Math.ceil(depth / Math.min(depth, cutDepth));
              const actualCutDepth = depth / cuts;
              const anglePerSide = 360 / sides;
              const rings = Math.ceil((radius - toolRadius) / toolDiameter);
              // At each step we can descend this much to reach the desired level.
              const zPerSegment = actualCutDepth / (sides * rings);
              for (let cut = 0; cut <= cuts; cut++) {
                // We start at the previous cut depth.
                const z = 0 - cut * actualCutDepth;
                for (let ring = 0; ring < rings; ring++) {
                  const cutRadius = radius - toolRadius - toolDiameter * ring;
                  for (let side = 0; side <= sides; side++) {
                    const segment = sides * ring + side;
                    points.push(
                      Point(
                        cutRadius,
                        0,
                        Math.max(z - zPerSegment * segment, 0 - depth)
                      ).rotate(anglePerSide * side)
                    );
                  }
                }
              }
              // Move back to the middle so we don't rub the wall on the way up.
              points.push(Point(0, 0, 0));
              return Assembly(
                Toolpath(...points),
                sweep === 'no'
                  ? undefined
                  : Cylinder.ofDiameter(diameter, depth)
                      .op((s) => (sweep === 'show' ? s : s.Void()))
                      .moveZ(depth / -2)
              ).move(x, y);
            };

            const HoleRouter = (
              depth = 10,
              { toolDiameter = 3.175, cutDepth = 0.3, toolLength = 17, sweep = 'cut' } = {}
            ) => (shape, x = 0, y = 0, z = 0) => {
              const cuts = Math.ceil(depth / Math.min(depth, cutDepth));
              const actualCutDepth = depth / cuts;
              const design = [];
              const sweeps = [];
              for (const surface of shape.surfaces()) {
                // FIX: This assumes a plunging tool.
                const paths = Shape.fromGeometry(
                  taggedPaths(
                    { tags: ['path/Toolpath'] },
                    toolpath(
                      surface.bench(-x, -y, -z).outline().flip().toTransformedGeometry(),
                      toolDiameter,
                      /* overcut= */ false,
                      /* solid= */ true
                    )
                  )
                );
                for (let cut = 0; cut < cuts; cut++) {
                  design.push(paths.moveZ((cut + 1) * -actualCutDepth));
                }
                if (sweep !== 'no') {
                  sweeps.push(
                    paths
                      .sweep(Cylinder.ofDiameter(toolDiameter, depth).moveZ(depth / -2))
                      .op((s) => (sweep === 'show' ? s : s.Void()))
                  );
                }
              }
              return Assembly(...design, ...sweeps);
            };

            const LineRouter = (
              depth = 10,
              { toolDiameter = 3.175, cutDepth = 0.3, toolLength = 17, sweep = 'no' } = {}
            ) => (shape, x = 0, y = 0, z = 0) => {
              const cuts = Math.ceil(depth / Math.min(cutDepth, depth));
              const actualCutDepth = depth / cuts;
              const design = [];
              const sweeps = [];
              for (const { paths } of getNonVoidPaths(
                shape.bench(-x, -y, -z).toDisjointGeometry()
              )) {
                // FIX: This assumes a plunging tool.
                const toolpaths = Shape.fromGeometry(
                  taggedPaths({ tags: ['path/Toolpath'] }, paths)
                );
                for (let cut = 0; cut < cuts; cut++) {
                  design.push(toolpaths.moveZ((cut + 1) * -actualCutDepth));
                }
                if (sweep !== 'no') {
                  // Generally a v bit.
                  sweeps.push(
                    Shape.fromGeometry(taggedPaths({}, paths))
                      .sweep(Cylinder.ofDiameter(toolDiameter, depth).moveZ(depth / -2))
                      .op((s) => (sweep === 'show' ? s : s.Void()))
                  );
                }
              }
              return Assembly(...design, ...sweeps);
            };

            const ProfileRouter = (
              depth = 10,
              { toolDiameter = 3.175, cutDepth = 0.3, toolLength = 17, sweep = 'no' } = {}
            ) => (shape, x = 0, y = 0, z = 0) => {
              const cuts = Math.ceil(depth / Math.min(cutDepth, depth));
              const actualCutDepth = depth / cuts;
              const design = [];
              const sweeps = [];
              for (const surface of shape.surfaces()) {
                // FIX: This assumes a plunging tool.
                const paths = Shape.fromGeometry(
                  taggedPaths(
                    { tags: ['path/Toolpath'] },
                    toolpath(
                      surface.bench(-x, -y, -z).outline().toTransformedGeometry(),
                      toolDiameter,
                      /* overcut= */ false,
                      /* solid= */ true
                    )
                  )
                );
                for (let cut = 0; cut < cuts; cut++) {
                  design.push(paths.moveZ((cut + 1) * -actualCutDepth));
                }
                if (sweep !== 'no') {
                  sweeps.push(
                    paths
                      .sweep(Cylinder.ofDiameter(toolDiameter, depth).moveZ(depth / -2))
                      .op((s) => (sweep === 'show' ? s : s.Void()))
                  );
                }
              }
              return Assembly(...design, ...sweeps);
            };

            const registry = [];

            // FIX: Need to clear out temporary registrations.

            const fromDesignator = (designator) => {
              for (const { parser, constructor } of registry) {
                const spec = parser(designator);
                if (spec !== undefined && spec !== null && spec !== false) {
                  return constructor(spec);
                }
              }
              throw Error('die');
            };

            // Later definitions override earlier definitions.
            const registerDesignator = (parser, constructor) =>
              registry.unshift({ parser, constructor });

            /**
             *
             * # Item
             *
             * Encapsulates a geometry as a discrete item.
             *
             **/

            // Constructs an item from the designator.
            const Item$3 = (designator) => {
              if (typeof designator === 'string') {
                return fromDesignator(designator);
              } else if (designator instanceof Array) {
                return fromDesignator(...designator);
              }
            };

            // Turns the current shape into an item.
            const itemMethod = function (id) {
              const shape = Shape.fromGeometry(
                toKeptGeometry(
                  rewriteTags([`item/${id}`], [], taggedItem({}, this.toGeometry()))
                )
              ).with(Connector('center'));
              // Register the designator for re-use.
              registerDesignator(
                (d) => d === id,
                () => shape
              );
              return shape;
            };

            Shape.prototype.Item = itemMethod;
            Shape.prototype.toItem = itemMethod;

            /**
             *
             * # Bill Of Materials
             *
             **/

            const bom = (shape) => {
              const bom = [];
              visit(shape.toKeptGeometry(), (geometry, descend) => {
                if (geometry.item) {
                  bom.push(
                    geometry.tags
                      .filter((tag) => tag.startsWith('item/'))
                      .map((tag) => tag.substring(5))
                  );
                }
                descend();
              });
              return bom;
            };

            const bomMethod = function (...args) {
              return bom(this);
            };
            Shape.prototype.bom = bomMethod;

            bomMethod.signature = 'Shape -> bom() -> string';

            const fuse = (shape, op = (_) => _) =>
              Shape.fromGeometry(
                rewrite(shape.toKeptGeometry(), (geometry, descend, walk) => {
                  if (geometry.item) {
                    return walk(geometry.item);
                  } else {
                    return descend();
                  }
                })
              );

            const fuseMethod = function (...args) {
              return fuse(this, ...args);
            };
            Shape.prototype.fuse = fuseMethod;

            fuse.signature = 'fuse(shape:Shape, op:function) -> Shapes';
            fuseMethod.signature = 'Shape -> fuse(op:function) -> Shapes';

            const inItems = (shape, op = (_) => _) => {
              const rewritten = rewrite(shape.toKeptGeometry(), (geometry, descend) => {
                if (geometry.item) {
                  // Operate on the interior of the items.
                  const item = op(Shape.fromGeometry(geometry.item));
                  // Reassemble as an item equivalent to the original.
                  return update(geometry, { item: item.toGeometry() });
                } else {
                  return descend();
                }
              });
              return Shape.fromGeometry(rewritten);
            };

            const inItemsMethod = function (...args) {
              return inItems(this, ...args);
            };
            Shape.prototype.inItems = inItemsMethod;

            inItems.signature = 'inItems(shape:Shape, op:function) -> Shapes';
            inItemsMethod.signature = 'Shape -> inItems(op:function) -> Shapes';

            const items = (shape, op = (_) => _) => {
              const items = [];
              for (const item of getItems(shape.toKeptGeometry())) {
                items.push(op(Shape.fromGeometry(item)));
              }
              return items;
            };

            const itemsMethod = function (...args) {
              return items(this, ...args);
            };
            Shape.prototype.items = itemsMethod;

            items.signature = 'items(shape:Shape, op:function) -> Shapes';
            itemsMethod.signature = 'Shape -> items(op:function) -> Shapes';

            const leafs = (shape, op = (_) => _) => {
              const leafs = [];
              for (const leaf of getLeafs(shape.toKeptGeometry())) {
                leafs.push(op(Shape.fromGeometry(leaf)));
              }
              return leafs;
            };

            const leafsMethod = function (...args) {
              return leafs(this, ...args);
            };
            Shape.prototype.leafs = leafsMethod;

            leafs.signature = 'leafs(shape:Shape, op:function) -> Shapes';
            leafsMethod.signature = 'Shape -> leafs(op:function) -> Shapes';

            const toBillOfMaterial = (shape) => {
              const specifications = [];
              for (const { tags } of getItems(shape.toKeptGeometry())) {
                for (const tag of tags) {
                  if (tag.startsWith('item/')) {
                    const specification = tag.substring(5);
                    specifications.push(specification);
                  }
                }
              }
              return specifications;
            };

            const toBillOfMaterialMethod = function (options = {}) {
              return toBillOfMaterial(this);
            };

            Shape.prototype.toBillOfMaterial = toBillOfMaterialMethod;

            const foot = 304.8;
            const inch = 25.4;
            const mm = 1;
            const mil = 0.0254;
            const cm = 10;
            const m$1 = 1000;
            const thou = 0.0254;
            const yard = 914.4;

            // From npm astring 1.4.3 to work around node native module issue.

            // Astring is a tiny and fast JavaScript code generator from an ESTree-compliant AST.
            //
            // Astring was written by David Bonnet and released under an MIT license.
            //
            // The Git repository for Astring is available at:
            // https://github.com/davidbonnet/astring.git
            //
            // Please use the GitHub bug tracker to report issues:
            // https://github.com/davidbonnet/astring/issues

            const { stringify } = JSON;

            /* istanbul ignore if */
            if (!String.prototype.repeat) {
              /* istanbul ignore next */
              throw new Error(
                'String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation'
              );
            }

            /* istanbul ignore if */
            if (!String.prototype.endsWith) {
              /* istanbul ignore next */
              throw new Error(
                'String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation'
              );
            }

            const OPERATOR_PRECEDENCE = {
              '||': 3,
              '&&': 4,
              '|': 5,
              '^': 6,
              '&': 7,
              '==': 8,
              '!=': 8,
              '===': 8,
              '!==': 8,
              '<': 9,
              '>': 9,
              '<=': 9,
              '>=': 9,
              in: 9,
              instanceof: 9,
              '<<': 10,
              '>>': 10,
              '>>>': 10,
              '+': 11,
              '-': 11,
              '*': 12,
              '%': 12,
              '/': 12,
              '**': 13,
            };

            // Enables parenthesis regardless of precedence
            const NEEDS_PARENTHESES = 17;

            const EXPRESSIONS_PRECEDENCE = {
              // Definitions
              ArrayExpression: 20,
              TaggedTemplateExpression: 20,
              ThisExpression: 20,
              Identifier: 20,
              Literal: 18,
              TemplateLiteral: 20,
              Super: 20,
              SequenceExpression: 20,
              // Operations
              MemberExpression: 19,
              CallExpression: 19,
              NewExpression: 19,
              // Other definitions
              ArrowFunctionExpression: NEEDS_PARENTHESES,
              ClassExpression: NEEDS_PARENTHESES,
              FunctionExpression: NEEDS_PARENTHESES,
              ObjectExpression: NEEDS_PARENTHESES,
              // Other operations
              UpdateExpression: 16,
              UnaryExpression: 15,
              BinaryExpression: 14,
              LogicalExpression: 13,
              ConditionalExpression: 4,
              AssignmentExpression: 3,
              AwaitExpression: 2,
              YieldExpression: 2,
              RestElement: 1,
            };

            function formatSequence(state, nodes) {
              /*
              Writes into `state` a sequence of `nodes`.
              */
              const { generator } = state;
              state.write('(');
              if (nodes != null && nodes.length > 0) {
                generator[nodes[0].type](nodes[0], state);
                const { length } = nodes;
                for (let i = 1; i < length; i++) {
                  const param = nodes[i];
                  state.write(', ');
                  generator[param.type](param, state);
                }
              }
              state.write(')');
            }

            function expressionNeedsParenthesis(node, parentNode, isRightHand) {
              const nodePrecedence = EXPRESSIONS_PRECEDENCE[node.type];
              if (nodePrecedence === NEEDS_PARENTHESES) {
                return true;
              }
              const parentNodePrecedence = EXPRESSIONS_PRECEDENCE[parentNode.type];
              if (nodePrecedence !== parentNodePrecedence) {
                // Different node types
                return (
                  (!isRightHand &&
                    nodePrecedence === 15 &&
                    parentNodePrecedence === 14 &&
                    parentNode.operator === '**') ||
                  nodePrecedence < parentNodePrecedence
                );
              }
              if (nodePrecedence !== 13 && nodePrecedence !== 14) {
                // Not a `LogicalExpression` or `BinaryExpression`
                return false;
              }
              if (node.operator === '**' && parentNode.operator === '**') {
                // Exponentiation operator has right-to-left associativity
                return !isRightHand;
              }
              if (isRightHand) {
                // Parenthesis are used if both operators have the same precedence
                return (
                  OPERATOR_PRECEDENCE[node.operator] <=
                  OPERATOR_PRECEDENCE[parentNode.operator]
                );
              }
              return (
                OPERATOR_PRECEDENCE[node.operator] <
                OPERATOR_PRECEDENCE[parentNode.operator]
              );
            }

            function formatBinaryExpressionPart(state, node, parentNode, isRightHand) {
              /*
              Writes into `state` a left-hand or right-hand expression `node`
              from a binary expression applying the provided `operator`.
              The `isRightHand` parameter should be `true` if the `node` is a right-hand argument.
              */
              const { generator } = state;
              if (expressionNeedsParenthesis(node, parentNode, isRightHand)) {
                state.write('(');
                generator[node.type](node, state);
                state.write(')');
              } else {
                generator[node.type](node, state);
              }
            }

            function reindent(state, text, indent, lineEnd) {
              /*
              Writes into `state` the `text` string reindented with the provided `indent`.
              */
              const lines = text.split('\n');
              const end = lines.length - 1;
              state.write(lines[0].trim());
              if (end > 0) {
                state.write(lineEnd);
                for (let i = 1; i < end; i++) {
                  state.write(indent + lines[i].trim() + lineEnd);
                }
                state.write(indent + lines[end].trim());
              }
            }

            function formatComments(state, comments, indent, lineEnd) {
              /*
              Writes into `state` the provided list of `comments`, with the given `indent` and `lineEnd` strings.
              Line comments will end with `"\n"` regardless of the value of `lineEnd`.
              Expects to start on a new unindented line.
              */
              const { length } = comments;
              for (let i = 0; i < length; i++) {
                const comment = comments[i];
                state.write(indent);
                if (comment.type[0] === 'L') {
                  // Line comment
                  state.write('// ' + comment.value.trim() + '\n');
                } else {
                  // Block comment
                  state.write('/*');
                  reindent(state, comment.value, indent, lineEnd);
                  state.write('*/' + lineEnd);
                }
              }
            }

            function hasCallExpression(node) {
              /*
              Returns `true` if the provided `node` contains a call expression and `false` otherwise.
              */
              let currentNode = node;
              while (currentNode != null) {
                const { type } = currentNode;
                if (type[0] === 'C' && type[1] === 'a') {
                  // Is CallExpression
                  return true;
                } else if (type[0] === 'M' && type[1] === 'e' && type[2] === 'm') {
                  // Is MemberExpression
                  currentNode = currentNode.object;
                } else {
                  return false;
                }
              }
            }

            function formatVariableDeclaration(state, node) {
              /*
              Writes into `state` a variable declaration.
              */
              const { generator } = state;
              const { declarations } = node;
              state.write(node.kind + ' ');
              const { length } = declarations;
              if (length > 0) {
                generator.VariableDeclarator(declarations[0], state);
                for (let i = 1; i < length; i++) {
                  state.write(', ');
                  generator.VariableDeclarator(declarations[i], state);
                }
              }
            }

            let ForInStatement,
              FunctionDeclaration,
              RestElement,
              BinaryExpression,
              ArrayExpression,
              BlockStatement;

            const baseGenerator = {
              Program(node, state) {
                const indent = state.indent.repeat(state.indentLevel);
                const { lineEnd, writeComments } = state;
                if (writeComments && node.comments != null) {
                  formatComments(state, node.comments, indent, lineEnd);
                }
                const statements = node.body;
                const { length } = statements;
                for (let i = 0; i < length; i++) {
                  const statement = statements[i];
                  if (writeComments && statement.comments != null) {
                    formatComments(state, statement.comments, indent, lineEnd);
                  }
                  state.write(indent);
                  this[statement.type](statement, state);
                  state.write(lineEnd);
                }
                if (writeComments && node.trailingComments != null) {
                  formatComments(state, node.trailingComments, indent, lineEnd);
                }
              },
              BlockStatement: (BlockStatement = function (node, state) {
                const indent = state.indent.repeat(state.indentLevel++);
                const { lineEnd, writeComments } = state;
                const statementIndent = indent + state.indent;
                state.write('{');
                const statements = node.body;
                if (statements != null && statements.length > 0) {
                  state.write(lineEnd);
                  if (writeComments && node.comments != null) {
                    formatComments(state, node.comments, statementIndent, lineEnd);
                  }
                  const { length } = statements;
                  for (let i = 0; i < length; i++) {
                    const statement = statements[i];
                    if (writeComments && statement.comments != null) {
                      formatComments(state, statement.comments, statementIndent, lineEnd);
                    }
                    state.write(statementIndent);
                    this[statement.type](statement, state);
                    state.write(lineEnd);
                  }
                  state.write(indent);
                } else {
                  if (writeComments && node.comments != null) {
                    state.write(lineEnd);
                    formatComments(state, node.comments, statementIndent, lineEnd);
                    state.write(indent);
                  }
                }
                if (writeComments && node.trailingComments != null) {
                  formatComments(state, node.trailingComments, statementIndent, lineEnd);
                }
                state.write('}');
                state.indentLevel--;
              }),
              ClassBody: BlockStatement,
              EmptyStatement(node, state) {
                state.write(';');
              },
              ExpressionStatement(node, state) {
                const precedence = EXPRESSIONS_PRECEDENCE[node.expression.type];
                if (
                  precedence === NEEDS_PARENTHESES ||
                  (precedence === 3 && node.expression.left.type[0] === 'O')
                ) {
                  // Should always have parentheses or is an AssignmentExpression to an ObjectPattern
                  state.write('(');
                  this[node.expression.type](node.expression, state);
                  state.write(')');
                } else {
                  this[node.expression.type](node.expression, state);
                }
                state.write(';');
              },
              IfStatement(node, state) {
                state.write('if (');
                this[node.test.type](node.test, state);
                state.write(') ');
                this[node.consequent.type](node.consequent, state);
                if (node.alternate != null) {
                  state.write(' else ');
                  this[node.alternate.type](node.alternate, state);
                }
              },
              LabeledStatement(node, state) {
                this[node.label.type](node.label, state);
                state.write(': ');
                this[node.body.type](node.body, state);
              },
              BreakStatement(node, state) {
                state.write('break');
                if (node.label != null) {
                  state.write(' ');
                  this[node.label.type](node.label, state);
                }
                state.write(';');
              },
              ContinueStatement(node, state) {
                state.write('continue');
                if (node.label != null) {
                  state.write(' ');
                  this[node.label.type](node.label, state);
                }
                state.write(';');
              },
              WithStatement(node, state) {
                state.write('with (');
                this[node.object.type](node.object, state);
                state.write(') ');
                this[node.body.type](node.body, state);
              },
              SwitchStatement(node, state) {
                const indent = state.indent.repeat(state.indentLevel++);
                const { lineEnd, writeComments } = state;
                state.indentLevel++;
                const caseIndent = indent + state.indent;
                const statementIndent = caseIndent + state.indent;
                state.write('switch (');
                this[node.discriminant.type](node.discriminant, state);
                state.write(') {' + lineEnd);
                const { cases: occurences } = node;
                const { length: occurencesCount } = occurences;
                for (let i = 0; i < occurencesCount; i++) {
                  const occurence = occurences[i];
                  if (writeComments && occurence.comments != null) {
                    formatComments(state, occurence.comments, caseIndent, lineEnd);
                  }
                  if (occurence.test) {
                    state.write(caseIndent + 'case ');
                    this[occurence.test.type](occurence.test, state);
                    state.write(':' + lineEnd);
                  } else {
                    state.write(caseIndent + 'default:' + lineEnd);
                  }
                  const { consequent } = occurence;
                  const { length: consequentCount } = consequent;
                  for (let i = 0; i < consequentCount; i++) {
                    const statement = consequent[i];
                    if (writeComments && statement.comments != null) {
                      formatComments(state, statement.comments, statementIndent, lineEnd);
                    }
                    state.write(statementIndent);
                    this[statement.type](statement, state);
                    state.write(lineEnd);
                  }
                }
                state.indentLevel -= 2;
                state.write(indent + '}');
              },
              ReturnStatement(node, state) {
                state.write('return');
                if (node.argument) {
                  state.write(' ');
                  this[node.argument.type](node.argument, state);
                }
                state.write(';');
              },
              ThrowStatement(node, state) {
                state.write('throw ');
                this[node.argument.type](node.argument, state);
                state.write(';');
              },
              TryStatement(node, state) {
                state.write('try ');
                this[node.block.type](node.block, state);
                if (node.handler) {
                  const { handler } = node;
                  if (handler.param == null) {
                    state.write(' catch ');
                  } else {
                    state.write(' catch (');
                    this[handler.param.type](handler.param, state);
                    state.write(') ');
                  }
                  this[handler.body.type](handler.body, state);
                }
                if (node.finalizer) {
                  state.write(' finally ');
                  this[node.finalizer.type](node.finalizer, state);
                }
              },
              WhileStatement(node, state) {
                state.write('while (');
                this[node.test.type](node.test, state);
                state.write(') ');
                this[node.body.type](node.body, state);
              },
              DoWhileStatement(node, state) {
                state.write('do ');
                this[node.body.type](node.body, state);
                state.write(' while (');
                this[node.test.type](node.test, state);
                state.write(');');
              },
              ForStatement(node, state) {
                state.write('for (');
                if (node.init != null) {
                  const { init } = node;
                  if (init.type[0] === 'V') {
                    formatVariableDeclaration(state, init);
                  } else {
                    this[init.type](init, state);
                  }
                }
                state.write('; ');
                if (node.test) {
                  this[node.test.type](node.test, state);
                }
                state.write('; ');
                if (node.update) {
                  this[node.update.type](node.update, state);
                }
                state.write(') ');
                this[node.body.type](node.body, state);
              },
              ForInStatement: (ForInStatement = function (node, state) {
                state.write(`for ${node.await ? 'await ' : ''}(`);
                const { left } = node;
                if (left.type[0] === 'V') {
                  formatVariableDeclaration(state, left);
                } else {
                  this[left.type](left, state);
                }
                // Identifying whether node.type is `ForInStatement` or `ForOfStatement`
                state.write(node.type[3] === 'I' ? ' in ' : ' of ');
                this[node.right.type](node.right, state);
                state.write(') ');
                this[node.body.type](node.body, state);
              }),
              ForOfStatement: ForInStatement,
              DebuggerStatement(node, state) {
                state.write('debugger;' + state.lineEnd);
              },
              FunctionDeclaration: (FunctionDeclaration = function (node, state) {
                state.write(
                  (node.async ? 'async ' : '') +
                    (node.generator ? 'function* ' : 'function ') +
                    (node.id ? node.id.name : ''),
                  node
                );
                formatSequence(state, node.params);
                state.write(' ');
                this[node.body.type](node.body, state);
              }),
              FunctionExpression: FunctionDeclaration,
              VariableDeclaration(node, state) {
                formatVariableDeclaration(state, node);
                state.write(';');
              },
              VariableDeclarator(node, state) {
                this[node.id.type](node.id, state);
                if (node.init != null) {
                  state.write(' = ');
                  this[node.init.type](node.init, state);
                }
              },
              ClassDeclaration(node, state) {
                state.write('class ' + (node.id ? `${node.id.name} ` : ''), node);
                if (node.superClass) {
                  state.write('extends ');
                  this[node.superClass.type](node.superClass, state);
                  state.write(' ');
                }
                this.ClassBody(node.body, state);
              },
              ImportDeclaration(node, state) {
                state.write('import ');
                const { specifiers } = node;
                const { length } = specifiers;
                // NOTE: Once babili is fixed, put this after condition
                // https://github.com/babel/babili/issues/430
                let i = 0;
                if (length > 0) {
                  for (; i < length; ) {
                    if (i > 0) {
                      state.write(', ');
                    }
                    const specifier = specifiers[i];
                    const type = specifier.type[6];
                    if (type === 'D') {
                      // ImportDefaultSpecifier
                      state.write(specifier.local.name, specifier);
                      i++;
                    } else if (type === 'N') {
                      // ImportNamespaceSpecifier
                      state.write('* as ' + specifier.local.name, specifier);
                      i++;
                    } else {
                      // ImportSpecifier
                      break;
                    }
                  }
                  if (i < length) {
                    state.write('{');
                    for (;;) {
                      const specifier = specifiers[i];
                      const { name } = specifier.imported;
                      state.write(name, specifier);
                      if (name !== specifier.local.name) {
                        state.write(' as ' + specifier.local.name);
                      }
                      if (++i < length) {
                        state.write(', ');
                      } else {
                        break;
                      }
                    }
                    state.write('}');
                  }
                  state.write(' from ');
                }
                this.Literal(node.source, state);
                state.write(';');
              },
              ExportDefaultDeclaration(node, state) {
                state.write('export default ');
                this[node.declaration.type](node.declaration, state);
                if (
                  EXPRESSIONS_PRECEDENCE[node.declaration.type] &&
                  node.declaration.type[0] !== 'F'
                ) {
                  // All expression nodes except `FunctionExpression`
                  state.write(';');
                }
              },
              ExportNamedDeclaration(node, state) {
                state.write('export ');
                if (node.declaration) {
                  this[node.declaration.type](node.declaration, state);
                } else {
                  state.write('{');
                  const { specifiers } = node;
                  const { length } = specifiers;
                  if (length > 0) {
                    for (let i = 0; ; ) {
                      const specifier = specifiers[i];
                      const { name } = specifier.local;
                      state.write(name, specifier);
                      if (name !== specifier.exported.name) {
                        state.write(' as ' + specifier.exported.name);
                      }
                      if (++i < length) {
                        state.write(', ');
                      } else {
                        break;
                      }
                    }
                  }
                  state.write('}');
                  if (node.source) {
                    state.write(' from ');
                    this.Literal(node.source, state);
                  }
                  state.write(';');
                }
              },
              ExportAllDeclaration(node, state) {
                state.write('export * from ');
                this.Literal(node.source, state);
                state.write(';');
              },
              MethodDefinition(node, state) {
                if (node.static) {
                  state.write('static ');
                }
                const kind = node.kind[0];
                if (kind === 'g' || kind === 's') {
                  // Getter or setter
                  state.write(node.kind + ' ');
                }
                if (node.value.async) {
                  state.write('async ');
                }
                if (node.value.generator) {
                  state.write('*');
                }
                if (node.computed) {
                  state.write('[');
                  this[node.key.type](node.key, state);
                  state.write(']');
                } else {
                  this[node.key.type](node.key, state);
                }
                formatSequence(state, node.value.params);
                state.write(' ');
                this[node.value.body.type](node.value.body, state);
              },
              ClassExpression(node, state) {
                this.ClassDeclaration(node, state);
              },
              ArrowFunctionExpression(node, state) {
                state.write(node.async ? 'async ' : '', node);
                const { params } = node;
                if (params != null) {
                  // Omit parenthesis if only one named parameter
                  if (params.length === 1 && params[0].type[0] === 'I') {
                    // If params[0].type[0] starts with 'I', it can't be `ImportDeclaration` nor `IfStatement` and thus is `Identifier`
                    state.write(params[0].name, params[0]);
                  } else {
                    formatSequence(state, node.params);
                  }
                }
                state.write(' => ');
                if (node.body.type[0] === 'O') {
                  // Body is an object expression
                  state.write('(');
                  this.ObjectExpression(node.body, state);
                  state.write(')');
                } else {
                  this[node.body.type](node.body, state);
                }
              },
              ThisExpression(node, state) {
                state.write('this', node);
              },
              Super(node, state) {
                state.write('super', node);
              },
              RestElement: (RestElement = function (node, state) {
                state.write('...');
                this[node.argument.type](node.argument, state);
              }),
              SpreadElement: RestElement,
              YieldExpression(node, state) {
                state.write(node.delegate ? 'yield*' : 'yield');
                if (node.argument) {
                  state.write(' ');
                  this[node.argument.type](node.argument, state);
                }
              },
              AwaitExpression(node, state) {
                state.write('await ');
                if (node.argument) {
                  this[node.argument.type](node.argument, state);
                }
              },
              TemplateLiteral(node, state) {
                const { quasis, expressions } = node;
                state.write('`');
                const { length } = expressions;
                for (let i = 0; i < length; i++) {
                  const expression = expressions[i];
                  this.TemplateElement(quasis[i], state);
                  state.write('${');
                  this[expression.type](expression, state);
                  state.write('}');
                }
                state.write(quasis[quasis.length - 1].value.raw);
                state.write('`');
              },
              TemplateElement(node, state) {
                state.write(node.value.raw);
              },
              TaggedTemplateExpression(node, state) {
                this[node.tag.type](node.tag, state);
                this[node.quasi.type](node.quasi, state);
              },
              ArrayExpression: (ArrayExpression = function (node, state) {
                state.write('[');
                if (node.elements.length > 0) {
                  const { elements } = node;
                  const { length } = elements;
                  for (let i = 0; ; ) {
                    const element = elements[i];
                    if (element != null) {
                      this[element.type](element, state);
                    }
                    if (++i < length) {
                      state.write(', ');
                    } else {
                      if (element == null) {
                        state.write(', ');
                      }
                      break;
                    }
                  }
                }
                state.write(']');
              }),
              ArrayPattern: ArrayExpression,
              ObjectExpression(node, state) {
                const indent = state.indent.repeat(state.indentLevel++);
                const { lineEnd, writeComments } = state;
                const propertyIndent = indent + state.indent;
                state.write('{');
                if (node.properties.length > 0) {
                  state.write(lineEnd);
                  if (writeComments && node.comments != null) {
                    formatComments(state, node.comments, propertyIndent, lineEnd);
                  }
                  const comma = ',' + lineEnd;
                  const { properties } = node;
                  const { length } = properties;
                  for (let i = 0; ; ) {
                    const property = properties[i];
                    if (writeComments && property.comments != null) {
                      formatComments(state, property.comments, propertyIndent, lineEnd);
                    }
                    state.write(propertyIndent);
                    this[property.type](property, state);
                    if (++i < length) {
                      state.write(comma);
                    } else {
                      break;
                    }
                  }
                  state.write(lineEnd);
                  if (writeComments && node.trailingComments != null) {
                    formatComments(state, node.trailingComments, propertyIndent, lineEnd);
                  }
                  state.write(indent + '}');
                } else if (writeComments) {
                  if (node.comments != null) {
                    state.write(lineEnd);
                    formatComments(state, node.comments, propertyIndent, lineEnd);
                    if (node.trailingComments != null) {
                      formatComments(state, node.trailingComments, propertyIndent, lineEnd);
                    }
                    state.write(indent + '}');
                  } else if (node.trailingComments != null) {
                    state.write(lineEnd);
                    formatComments(state, node.trailingComments, propertyIndent, lineEnd);
                    state.write(indent + '}');
                  } else {
                    state.write('}');
                  }
                } else {
                  state.write('}');
                }
                state.indentLevel--;
              },
              Property(node, state) {
                if (node.method || node.kind[0] !== 'i') {
                  // Either a method or of kind `set` or `get` (not `init`)
                  this.MethodDefinition(node, state);
                } else {
                  if (!node.shorthand) {
                    if (node.computed) {
                      state.write('[');
                      this[node.key.type](node.key, state);
                      state.write(']');
                    } else {
                      this[node.key.type](node.key, state);
                    }
                    state.write(': ');
                  }
                  this[node.value.type](node.value, state);
                }
              },
              ObjectPattern(node, state) {
                state.write('{');
                if (node.properties.length > 0) {
                  const { properties } = node;
                  const { length } = properties;
                  for (let i = 0; ; ) {
                    this[properties[i].type](properties[i], state);
                    if (++i < length) {
                      state.write(', ');
                    } else {
                      break;
                    }
                  }
                }
                state.write('}');
              },
              SequenceExpression(node, state) {
                formatSequence(state, node.expressions);
              },
              UnaryExpression(node, state) {
                if (node.prefix) {
                  state.write(node.operator);
                  if (node.operator.length > 1) {
                    state.write(' ');
                  }
                  if (
                    EXPRESSIONS_PRECEDENCE[node.argument.type] <
                    EXPRESSIONS_PRECEDENCE.UnaryExpression
                  ) {
                    state.write('(');
                    this[node.argument.type](node.argument, state);
                    state.write(')');
                  } else {
                    this[node.argument.type](node.argument, state);
                  }
                } else {
                  // FIXME: This case never occurs
                  this[node.argument.type](node.argument, state);
                  state.write(node.operator);
                }
              },
              UpdateExpression(node, state) {
                // Always applied to identifiers or members, no parenthesis check needed
                if (node.prefix) {
                  state.write(node.operator);
                  this[node.argument.type](node.argument, state);
                } else {
                  this[node.argument.type](node.argument, state);
                  state.write(node.operator);
                }
              },
              AssignmentExpression(node, state) {
                this[node.left.type](node.left, state);
                state.write(' ' + node.operator + ' ');
                this[node.right.type](node.right, state);
              },
              AssignmentPattern(node, state) {
                this[node.left.type](node.left, state);
                state.write(' = ');
                this[node.right.type](node.right, state);
              },
              BinaryExpression: (BinaryExpression = function (node, state) {
                const isIn = node.operator === 'in';
                if (isIn) {
                  // Avoids confusion in `for` loops initializers
                  state.write('(');
                }
                formatBinaryExpressionPart(state, node.left, node, false);
                state.write(' ' + node.operator + ' ');
                formatBinaryExpressionPart(state, node.right, node, true);
                if (isIn) {
                  state.write(')');
                }
              }),
              LogicalExpression: BinaryExpression,
              ConditionalExpression(node, state) {
                if (
                  EXPRESSIONS_PRECEDENCE[node.test.type] >
                  EXPRESSIONS_PRECEDENCE.ConditionalExpression
                ) {
                  this[node.test.type](node.test, state);
                } else {
                  state.write('(');
                  this[node.test.type](node.test, state);
                  state.write(')');
                }
                state.write(' ? ');
                this[node.consequent.type](node.consequent, state);
                state.write(' : ');
                this[node.alternate.type](node.alternate, state);
              },
              NewExpression(node, state) {
                state.write('new ');
                if (
                  EXPRESSIONS_PRECEDENCE[node.callee.type] <
                    EXPRESSIONS_PRECEDENCE.CallExpression ||
                  hasCallExpression(node.callee)
                ) {
                  state.write('(');
                  this[node.callee.type](node.callee, state);
                  state.write(')');
                } else {
                  this[node.callee.type](node.callee, state);
                }
                formatSequence(state, node['arguments']);
              },
              CallExpression(node, state) {
                if (
                  EXPRESSIONS_PRECEDENCE[node.callee.type] <
                  EXPRESSIONS_PRECEDENCE.CallExpression
                ) {
                  state.write('(');
                  this[node.callee.type](node.callee, state);
                  state.write(')');
                } else {
                  this[node.callee.type](node.callee, state);
                }
                formatSequence(state, node['arguments']);
              },
              MemberExpression(node, state) {
                if (
                  EXPRESSIONS_PRECEDENCE[node.object.type] <
                  EXPRESSIONS_PRECEDENCE.MemberExpression
                ) {
                  state.write('(');
                  this[node.object.type](node.object, state);
                  state.write(')');
                } else {
                  this[node.object.type](node.object, state);
                }
                if (node.computed) {
                  state.write('[');
                  this[node.property.type](node.property, state);
                  state.write(']');
                } else {
                  state.write('.');
                  this[node.property.type](node.property, state);
                }
              },
              MetaProperty(node, state) {
                state.write(node.meta.name + '.' + node.property.name, node);
              },
              Identifier(node, state) {
                state.write(node.name, node);
              },
              Literal(node, state) {
                if (node.raw != null) {
                  state.write(node.raw, node);
                } else if (node.regex != null) {
                  this.RegExpLiteral(node, state);
                } else {
                  state.write(stringify(node.value), node);
                }
              },
              RegExpLiteral(node, state) {
                const { regex } = node;
                state.write(`/${regex.pattern}/${regex.flags}`, node);
              },
            };

            const EMPTY_OBJECT = {};

            class State {
              constructor(options) {
                const setup = options == null ? EMPTY_OBJECT : options;
                this.output = '';
                // Functional options
                if (setup.output != null) {
                  this.output = setup.output;
                  this.write = this.writeToStream;
                } else {
                  this.output = '';
                }
                this.generator = setup.generator != null ? setup.generator : baseGenerator;
                // Formating setup
                this.indent = setup.indent != null ? setup.indent : '  ';
                this.lineEnd = setup.lineEnd != null ? setup.lineEnd : '\n';
                this.indentLevel =
                  setup.startingIndentLevel != null ? setup.startingIndentLevel : 0;
                this.writeComments = setup.comments ? setup.comments : false;
                // Source map
                if (setup.sourceMap != null) {
                  this.write =
                    setup.output == null ? this.writeAndMap : this.writeToStreamAndMap;
                  this.sourceMap = setup.sourceMap;
                  this.line = 1;
                  this.column = 0;
                  this.lineEndSize = this.lineEnd.split('\n').length - 1;
                  this.mapping = {
                    original: null,
                    generated: this,
                    name: undefined,
                    source: setup.sourceMap.file || setup.sourceMap._file,
                  };
                }
              }

              write(code) {
                this.output += code;
              }

              writeToStream(code) {
                this.output.write(code);
              }

              writeAndMap(code, node) {
                this.output += code;
                this.map(code, node);
              }

              writeToStreamAndMap(code, node) {
                this.output.write(code);
                this.map(code, node);
              }

              map(code, node) {
                if (node != null && node.loc != null) {
                  const { mapping } = this;
                  mapping.original = node.loc.start;
                  mapping.name = node.name;
                  this.sourceMap.addMapping(mapping);
                }
                if (code.length > 0) {
                  if (this.lineEndSize > 0) {
                    if (code.endsWith(this.lineEnd)) {
                      this.line += this.lineEndSize;
                      this.column = 0;
                    } else if (code[code.length - 1] === '\n') {
                      // Case of inline comment
                      this.line++;
                      this.column = 0;
                    } else {
                      this.column += code.length;
                    }
                  } else {
                    if (code[code.length - 1] === '\n') {
                      // Case of inline comment
                      this.line++;
                      this.column = 0;
                    } else {
                      this.column += code.length;
                    }
                  }
                }
              }

              toString() {
                return this.output;
              }
            }

            function generate(node, options) {
              /*
              Returns a string representing the rendered code of the provided AST `node`.
              The `options` are:

              - `indent`: string to use for indentation (defaults to `␣␣`)
              - `lineEnd`: string to use for line endings (defaults to `\n`)
              - `startingIndentLevel`: indent level to start from (defaults to `0`)
              - `comments`: generate comments if `true` (defaults to `false`)
              - `output`: output stream to write the rendered code to (defaults to `null`)
              - `generator`: custom code generator (defaults to `baseGenerator`)
              */
              const state = new State(options);
              // Travel through the AST node and generate the code
              state.generator[node.type](node, state);
              return state.output;
            }

            function commonjsRequire$1 () {
            	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
            }

            function createCommonjsModule$8(fn, module) {
            	return module = { exports: {} }, fn(module, module.exports), module.exports;
            }

            var object_hash = createCommonjsModule$8(function (module, exports) {
            !function(e){module.exports=e();}(function(){return function o(i,u,a){function s(n,e){if(!u[n]){if(!i[n]){var t="function"==typeof commonjsRequire$1&&commonjsRequire$1;if(!e&&t)return t(n,!0);if(f)return f(n,!0);throw new Error("Cannot find module '"+n+"'")}var r=u[n]={exports:{}};i[n][0].call(r.exports,function(e){var t=i[n][1][e];return s(t||e)},r,r.exports,o,i,u,a);}return u[n].exports}for(var f="function"==typeof commonjsRequire$1&&commonjsRequire$1,e=0;e<a.length;e++)s(a[e]);return s}({1:[function(w,b,m){(function(e,t,f,n,r,o,i,u,a){var s=w("crypto");function c(e,t){return function(e,t){var n;n="passthrough"!==t.algorithm?s.createHash(t.algorithm):new y;void 0===n.write&&(n.write=n.update,n.end=n.update);g(t,n).dispatch(e),n.update||n.end("");if(n.digest)return n.digest("buffer"===t.encoding?void 0:t.encoding);var r=n.read();return "buffer"!==t.encoding?r.toString(t.encoding):r}(e,t=h(e,t))}(m=b.exports=c).sha1=function(e){return c(e)},m.keys=function(e){return c(e,{excludeValues:!0,algorithm:"sha1",encoding:"hex"})},m.MD5=function(e){return c(e,{algorithm:"md5",encoding:"hex"})},m.keysMD5=function(e){return c(e,{algorithm:"md5",encoding:"hex",excludeValues:!0})};var l=s.getHashes?s.getHashes().slice():["sha1","md5"];l.push("passthrough");var d=["buffer","hex","binary","base64"];function h(e,t){t=t||{};var n={};if(n.algorithm=t.algorithm||"sha1",n.encoding=t.encoding||"hex",n.excludeValues=!!t.excludeValues,n.algorithm=n.algorithm.toLowerCase(),n.encoding=n.encoding.toLowerCase(),n.ignoreUnknown=!0===t.ignoreUnknown,n.respectType=!1!==t.respectType,n.respectFunctionNames=!1!==t.respectFunctionNames,n.respectFunctionProperties=!1!==t.respectFunctionProperties,n.unorderedArrays=!0===t.unorderedArrays,n.unorderedSets=!1!==t.unorderedSets,n.unorderedObjects=!1!==t.unorderedObjects,n.replacer=t.replacer||void 0,n.excludeKeys=t.excludeKeys||void 0,void 0===e)throw new Error("Object argument required.");for(var r=0;r<l.length;++r)l[r].toLowerCase()===n.algorithm.toLowerCase()&&(n.algorithm=l[r]);if(-1===l.indexOf(n.algorithm))throw new Error('Algorithm "'+n.algorithm+'"  not supported. supported values: '+l.join(", "));if(-1===d.indexOf(n.encoding)&&"passthrough"!==n.algorithm)throw new Error('Encoding "'+n.encoding+'"  not supported. supported values: '+d.join(", "));return n}function p(e){if("function"==typeof e){return null!=/^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e))}}function g(u,t,a){a=a||[];function s(e){return t.update?t.update(e,"utf8"):t.write(e,"utf8")}return {dispatch:function(e){u.replacer&&(e=u.replacer(e));var t=typeof e;return null===e&&(t="null"),this["_"+t](e)},_object:function(t){var e=Object.prototype.toString.call(t),n=/\[object (.*)\]/i.exec(e);n=(n=n?n[1]:"unknown:["+e+"]").toLowerCase();var r;if(0<=(r=a.indexOf(t)))return this.dispatch("[CIRCULAR:"+r+"]");if(a.push(t),void 0!==f&&f.isBuffer&&f.isBuffer(t))return s("buffer:"),s(t);if("object"===n||"function"===n||"asyncfunction"===n){var o=Object.keys(t);u.unorderedObjects&&(o=o.sort()),!1===u.respectType||p(t)||o.splice(0,0,"prototype","__proto__","constructor"),u.excludeKeys&&(o=o.filter(function(e){return !u.excludeKeys(e)})),s("object:"+o.length+":");var i=this;return o.forEach(function(e){i.dispatch(e),s(":"),u.excludeValues||i.dispatch(t[e]),s(",");})}if(!this["_"+n]){if(u.ignoreUnknown)return s("["+n+"]");throw new Error('Unknown object type "'+n+'"')}this["_"+n](t);},_array:function(e,t){t=void 0!==t?t:!1!==u.unorderedArrays;var n=this;if(s("array:"+e.length+":"),!t||e.length<=1)return e.forEach(function(e){return n.dispatch(e)});var r=[],o=e.map(function(e){var t=new y,n=a.slice();return g(u,t,n).dispatch(e),r=r.concat(n.slice(a.length)),t.read().toString()});return a=a.concat(r),o.sort(),this._array(o,!1)},_date:function(e){return s("date:"+e.toJSON())},_symbol:function(e){return s("symbol:"+e.toString())},_error:function(e){return s("error:"+e.toString())},_boolean:function(e){return s("bool:"+e.toString())},_string:function(e){s("string:"+e.length+":"),s(e.toString());},_function:function(e){s("fn:"),p(e)?this.dispatch("[native]"):this.dispatch(e.toString()),!1!==u.respectFunctionNames&&this.dispatch("function-name:"+String(e.name)),u.respectFunctionProperties&&this._object(e);},_number:function(e){return s("number:"+e.toString())},_xml:function(e){return s("xml:"+e.toString())},_null:function(){return s("Null")},_undefined:function(){return s("Undefined")},_regexp:function(e){return s("regex:"+e.toString())},_uint8array:function(e){return s("uint8array:"),this.dispatch(Array.prototype.slice.call(e))},_uint8clampedarray:function(e){return s("uint8clampedarray:"),this.dispatch(Array.prototype.slice.call(e))},_int8array:function(e){return s("uint8array:"),this.dispatch(Array.prototype.slice.call(e))},_uint16array:function(e){return s("uint16array:"),this.dispatch(Array.prototype.slice.call(e))},_int16array:function(e){return s("uint16array:"),this.dispatch(Array.prototype.slice.call(e))},_uint32array:function(e){return s("uint32array:"),this.dispatch(Array.prototype.slice.call(e))},_int32array:function(e){return s("uint32array:"),this.dispatch(Array.prototype.slice.call(e))},_float32array:function(e){return s("float32array:"),this.dispatch(Array.prototype.slice.call(e))},_float64array:function(e){return s("float64array:"),this.dispatch(Array.prototype.slice.call(e))},_arraybuffer:function(e){return s("arraybuffer:"),this.dispatch(new Uint8Array(e))},_url:function(e){return s("url:"+e.toString())},_map:function(e){s("map:");var t=Array.from(e);return this._array(t,!1!==u.unorderedSets)},_set:function(e){s("set:");var t=Array.from(e);return this._array(t,!1!==u.unorderedSets)},_blob:function(){if(u.ignoreUnknown)return s("[blob]");throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n')},_domwindow:function(){return s("domwindow")},_process:function(){return s("process")},_timer:function(){return s("timer")},_pipe:function(){return s("pipe")},_tcp:function(){return s("tcp")},_udp:function(){return s("udp")},_tty:function(){return s("tty")},_statwatcher:function(){return s("statwatcher")},_securecontext:function(){return s("securecontext")},_connection:function(){return s("connection")},_zlib:function(){return s("zlib")},_context:function(){return s("context")},_nodescript:function(){return s("nodescript")},_httpparser:function(){return s("httpparser")},_dataview:function(){return s("dataview")},_signal:function(){return s("signal")},_fsevent:function(){return s("fsevent")},_tlswrap:function(){return s("tlswrap")}}}function y(){return {buf:"",write:function(e){this.buf+=e;},end:function(e){this.buf+=e;},read:function(){return this.buf}}}m.writeToStream=function(e,t,n){return void 0===n&&(n=t,t={}),g(t=h(e,t),n).dispatch(e)};}).call(this,w("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},w("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/fake_794fcf4d.js","/");},{buffer:3,crypto:5,lYpoI2:10}],2:[function(e,t,f){(function(e,t,n,r,o,i,u,a,s){!function(e){var f="undefined"!=typeof Uint8Array?Uint8Array:Array,n="+".charCodeAt(0),r="/".charCodeAt(0),o="0".charCodeAt(0),i="a".charCodeAt(0),u="A".charCodeAt(0),a="-".charCodeAt(0),s="_".charCodeAt(0);function c(e){var t=e.charCodeAt(0);return t===n||t===a?62:t===r||t===s?63:t<o?-1:t<o+10?t-o+26+26:t<u+26?t-u:t<i+26?t-i+26:void 0}e.toByteArray=function(e){var t,n,r,o,i;if(0<e.length%4)throw new Error("Invalid string. Length must be a multiple of 4");var u=e.length;o="="===e.charAt(u-2)?2:"="===e.charAt(u-1)?1:0,i=new f(3*e.length/4-o),n=0<o?e.length-4:e.length;var a=0;function s(e){i[a++]=e;}for(t=0;t<n;t+=4,0)s((16711680&(r=c(e.charAt(t))<<18|c(e.charAt(t+1))<<12|c(e.charAt(t+2))<<6|c(e.charAt(t+3))))>>16),s((65280&r)>>8),s(255&r);return 2==o?s(255&(r=c(e.charAt(t))<<2|c(e.charAt(t+1))>>4)):1==o&&(s((r=c(e.charAt(t))<<10|c(e.charAt(t+1))<<4|c(e.charAt(t+2))>>2)>>8&255),s(255&r)),i},e.fromByteArray=function(e){var t,n,r,o,i=e.length%3,u="";function a(e){return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e)}for(t=0,r=e.length-i;t<r;t+=3)n=(e[t]<<16)+(e[t+1]<<8)+e[t+2],u+=a((o=n)>>18&63)+a(o>>12&63)+a(o>>6&63)+a(63&o);switch(i){case 1:u+=a((n=e[e.length-1])>>2),u+=a(n<<4&63),u+="==";break;case 2:u+=a((n=(e[e.length-2]<<8)+e[e.length-1])>>10),u+=a(n>>4&63),u+=a(n<<2&63),u+="=";}return u};}(void 0===f?this.base64js={}:f);}).call(this,e("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js","/node_modules/gulp-browserify/node_modules/base64-js/lib");},{buffer:3,lYpoI2:10}],3:[function(O,e,H){(function(e,t,h,n,r,o,i,u,a){var s=O("base64-js"),f=O("ieee754");function h(e,t,n){if(!(this instanceof h))return new h(e,t,n);var r,o,i,u,a,s=typeof e;if("base64"===t&&"string"==s)for(e=(r=e).trim?r.trim():r.replace(/^\s+|\s+$/g,"");e.length%4!=0;)e+="=";if("number"==s)o=x(e);else if("string"==s)o=h.byteLength(e,t);else {if("object"!=s)throw new Error("First argument needs to be a number, array or string.");o=x(e.length);}if(h._useTypedArrays?i=h._augment(new Uint8Array(o)):((i=this).length=o,i._isBuffer=!0),h._useTypedArrays&&"number"==typeof e.byteLength)i._set(e);else if(S(a=e)||h.isBuffer(a)||a&&"object"==typeof a&&"number"==typeof a.length)for(u=0;u<o;u++)h.isBuffer(e)?i[u]=e.readUInt8(u):i[u]=e[u];else if("string"==s)i.write(e,0,t);else if("number"==s&&!h._useTypedArrays&&!n)for(u=0;u<o;u++)i[u]=0;return i}function p(e,t,n,r){return h._charsWritten=T(function(e){for(var t=[],n=0;n<e.length;n++)t.push(255&e.charCodeAt(n));return t}(t),e,n,r)}function g(e,t,n,r){return h._charsWritten=T(function(e){for(var t,n,r,o=[],i=0;i<e.length;i++)t=e.charCodeAt(i),n=t>>8,r=t%256,o.push(r),o.push(n);return o}(t),e,n,r)}function c(e,t,n){var r="";n=Math.min(e.length,n);for(var o=t;o<n;o++)r+=String.fromCharCode(e[o]);return r}function l(e,t,n,r){r||(D("boolean"==typeof n,"missing or invalid endian"),D(null!=t,"missing offset"),D(t+1<e.length,"Trying to read beyond buffer length"));var o,i=e.length;if(!(i<=t))return n?(o=e[t],t+1<i&&(o|=e[t+1]<<8)):(o=e[t]<<8,t+1<i&&(o|=e[t+1])),o}function d(e,t,n,r){r||(D("boolean"==typeof n,"missing or invalid endian"),D(null!=t,"missing offset"),D(t+3<e.length,"Trying to read beyond buffer length"));var o,i=e.length;if(!(i<=t))return n?(t+2<i&&(o=e[t+2]<<16),t+1<i&&(o|=e[t+1]<<8),o|=e[t],t+3<i&&(o+=e[t+3]<<24>>>0)):(t+1<i&&(o=e[t+1]<<16),t+2<i&&(o|=e[t+2]<<8),t+3<i&&(o|=e[t+3]),o+=e[t]<<24>>>0),o}function y(e,t,n,r){if(r||(D("boolean"==typeof n,"missing or invalid endian"),D(null!=t,"missing offset"),D(t+1<e.length,"Trying to read beyond buffer length")),!(e.length<=t)){var o=l(e,t,n,!0);return 32768&o?-1*(65535-o+1):o}}function w(e,t,n,r){if(r||(D("boolean"==typeof n,"missing or invalid endian"),D(null!=t,"missing offset"),D(t+3<e.length,"Trying to read beyond buffer length")),!(e.length<=t)){var o=d(e,t,n,!0);return 2147483648&o?-1*(4294967295-o+1):o}}function b(e,t,n,r){return r||(D("boolean"==typeof n,"missing or invalid endian"),D(t+3<e.length,"Trying to read beyond buffer length")),f.read(e,t,n,23,4)}function m(e,t,n,r){return r||(D("boolean"==typeof n,"missing or invalid endian"),D(t+7<e.length,"Trying to read beyond buffer length")),f.read(e,t,n,52,8)}function v(e,t,n,r,o){o||(D(null!=t,"missing value"),D("boolean"==typeof r,"missing or invalid endian"),D(null!=n,"missing offset"),D(n+1<e.length,"trying to write beyond buffer length"),N(t,65535));var i=e.length;if(!(i<=n))for(var u=0,a=Math.min(i-n,2);u<a;u++)e[n+u]=(t&255<<8*(r?u:1-u))>>>8*(r?u:1-u);}function _(e,t,n,r,o){o||(D(null!=t,"missing value"),D("boolean"==typeof r,"missing or invalid endian"),D(null!=n,"missing offset"),D(n+3<e.length,"trying to write beyond buffer length"),N(t,4294967295));var i=e.length;if(!(i<=n))for(var u=0,a=Math.min(i-n,4);u<a;u++)e[n+u]=t>>>8*(r?u:3-u)&255;}function E(e,t,n,r,o){o||(D(null!=t,"missing value"),D("boolean"==typeof r,"missing or invalid endian"),D(null!=n,"missing offset"),D(n+1<e.length,"Trying to write beyond buffer length"),Y(t,32767,-32768)),e.length<=n||v(e,0<=t?t:65535+t+1,n,r,o);}function I(e,t,n,r,o){o||(D(null!=t,"missing value"),D("boolean"==typeof r,"missing or invalid endian"),D(null!=n,"missing offset"),D(n+3<e.length,"Trying to write beyond buffer length"),Y(t,2147483647,-2147483648)),e.length<=n||_(e,0<=t?t:4294967295+t+1,n,r,o);}function A(e,t,n,r,o){o||(D(null!=t,"missing value"),D("boolean"==typeof r,"missing or invalid endian"),D(null!=n,"missing offset"),D(n+3<e.length,"Trying to write beyond buffer length"),F(t,34028234663852886e22,-34028234663852886e22)),e.length<=n||f.write(e,t,n,r,23,4);}function B(e,t,n,r,o){o||(D(null!=t,"missing value"),D("boolean"==typeof r,"missing or invalid endian"),D(null!=n,"missing offset"),D(n+7<e.length,"Trying to write beyond buffer length"),F(t,17976931348623157e292,-17976931348623157e292)),e.length<=n||f.write(e,t,n,r,52,8);}H.Buffer=h,H.SlowBuffer=h,H.INSPECT_MAX_BYTES=50,h.poolSize=8192,h._useTypedArrays=function(){try{var e=new ArrayBuffer(0),t=new Uint8Array(e);return t.foo=function(){return 42},42===t.foo()&&"function"==typeof t.subarray}catch(e){return !1}}(),h.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"raw":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return !0;default:return !1}},h.isBuffer=function(e){return !(null==e||!e._isBuffer)},h.byteLength=function(e,t){var n;switch(e+="",t||"utf8"){case"hex":n=e.length/2;break;case"utf8":case"utf-8":n=C(e).length;break;case"ascii":case"binary":case"raw":n=e.length;break;case"base64":n=k(e).length;break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":n=2*e.length;break;default:throw new Error("Unknown encoding")}return n},h.concat=function(e,t){if(D(S(e),"Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."),0===e.length)return new h(0);if(1===e.length)return e[0];var n;if("number"!=typeof t)for(n=t=0;n<e.length;n++)t+=e[n].length;var r=new h(t),o=0;for(n=0;n<e.length;n++){var i=e[n];i.copy(r,o),o+=i.length;}return r},h.prototype.write=function(e,t,n,r){if(isFinite(t))isFinite(n)||(r=n,n=void 0);else {var o=r;r=t,t=n,n=o;}t=Number(t)||0;var i,u,a,s,f,c,l,d=this.length-t;switch((!n||d<(n=Number(n)))&&(n=d),r=String(r||"utf8").toLowerCase()){case"hex":i=function(e,t,n,r){n=Number(n)||0;var o=e.length-n;(!r||o<(r=Number(r)))&&(r=o);var i=t.length;D(i%2==0,"Invalid hex string"),i/2<r&&(r=i/2);for(var u=0;u<r;u++){var a=parseInt(t.substr(2*u,2),16);D(!isNaN(a),"Invalid hex string"),e[n+u]=a;}return h._charsWritten=2*u,u}(this,e,t,n);break;case"utf8":case"utf-8":f=this,c=t,l=n,i=h._charsWritten=T(C(e),f,c,l);break;case"ascii":i=p(this,e,t,n);break;case"binary":i=p(this,e,t,n);break;case"base64":u=this,a=t,s=n,i=h._charsWritten=T(k(e),u,a,s);break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":i=g(this,e,t,n);break;default:throw new Error("Unknown encoding")}return i},h.prototype.toString=function(e,t,n){var r,o,i,u,a=this;if(e=String(e||"utf8").toLowerCase(),t=Number(t)||0,(n=void 0!==n?Number(n):n=a.length)===t)return "";switch(e){case"hex":r=function(e,t,n){var r=e.length;(!t||t<0)&&(t=0);(!n||n<0||r<n)&&(n=r);for(var o="",i=t;i<n;i++)o+=j(e[i]);return o}(a,t,n);break;case"utf8":case"utf-8":r=function(e,t,n){var r="",o="";n=Math.min(e.length,n);for(var i=t;i<n;i++)e[i]<=127?(r+=M(o)+String.fromCharCode(e[i]),o=""):o+="%"+e[i].toString(16);return r+M(o)}(a,t,n);break;case"ascii":r=c(a,t,n);break;case"binary":r=c(a,t,n);break;case"base64":o=a,u=n,r=0===(i=t)&&u===o.length?s.fromByteArray(o):s.fromByteArray(o.slice(i,u));break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":r=function(e,t,n){for(var r=e.slice(t,n),o="",i=0;i<r.length;i+=2)o+=String.fromCharCode(r[i]+256*r[i+1]);return o}(a,t,n);break;default:throw new Error("Unknown encoding")}return r},h.prototype.toJSON=function(){return {type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}},h.prototype.copy=function(e,t,n,r){if(n=n||0,r||0===r||(r=this.length),t=t||0,r!==n&&0!==e.length&&0!==this.length){D(n<=r,"sourceEnd < sourceStart"),D(0<=t&&t<e.length,"targetStart out of bounds"),D(0<=n&&n<this.length,"sourceStart out of bounds"),D(0<=r&&r<=this.length,"sourceEnd out of bounds"),r>this.length&&(r=this.length),e.length-t<r-n&&(r=e.length-t+n);var o=r-n;if(o<100||!h._useTypedArrays)for(var i=0;i<o;i++)e[i+t]=this[i+n];else e._set(this.subarray(n,n+o),t);}},h.prototype.slice=function(e,t){var n=this.length;if(e=U(e,n,0),t=U(t,n,n),h._useTypedArrays)return h._augment(this.subarray(e,t));for(var r=t-e,o=new h(r,void 0,!0),i=0;i<r;i++)o[i]=this[i+e];return o},h.prototype.get=function(e){return console.log(".get() is deprecated. Access using array indexes instead."),this.readUInt8(e)},h.prototype.set=function(e,t){return console.log(".set() is deprecated. Access using array indexes instead."),this.writeUInt8(e,t)},h.prototype.readUInt8=function(e,t){if(t||(D(null!=e,"missing offset"),D(e<this.length,"Trying to read beyond buffer length")),!(e>=this.length))return this[e]},h.prototype.readUInt16LE=function(e,t){return l(this,e,!0,t)},h.prototype.readUInt16BE=function(e,t){return l(this,e,!1,t)},h.prototype.readUInt32LE=function(e,t){return d(this,e,!0,t)},h.prototype.readUInt32BE=function(e,t){return d(this,e,!1,t)},h.prototype.readInt8=function(e,t){if(t||(D(null!=e,"missing offset"),D(e<this.length,"Trying to read beyond buffer length")),!(e>=this.length))return 128&this[e]?-1*(255-this[e]+1):this[e]},h.prototype.readInt16LE=function(e,t){return y(this,e,!0,t)},h.prototype.readInt16BE=function(e,t){return y(this,e,!1,t)},h.prototype.readInt32LE=function(e,t){return w(this,e,!0,t)},h.prototype.readInt32BE=function(e,t){return w(this,e,!1,t)},h.prototype.readFloatLE=function(e,t){return b(this,e,!0,t)},h.prototype.readFloatBE=function(e,t){return b(this,e,!1,t)},h.prototype.readDoubleLE=function(e,t){return m(this,e,!0,t)},h.prototype.readDoubleBE=function(e,t){return m(this,e,!1,t)},h.prototype.writeUInt8=function(e,t,n){n||(D(null!=e,"missing value"),D(null!=t,"missing offset"),D(t<this.length,"trying to write beyond buffer length"),N(e,255)),t>=this.length||(this[t]=e);},h.prototype.writeUInt16LE=function(e,t,n){v(this,e,t,!0,n);},h.prototype.writeUInt16BE=function(e,t,n){v(this,e,t,!1,n);},h.prototype.writeUInt32LE=function(e,t,n){_(this,e,t,!0,n);},h.prototype.writeUInt32BE=function(e,t,n){_(this,e,t,!1,n);},h.prototype.writeInt8=function(e,t,n){n||(D(null!=e,"missing value"),D(null!=t,"missing offset"),D(t<this.length,"Trying to write beyond buffer length"),Y(e,127,-128)),t>=this.length||(0<=e?this.writeUInt8(e,t,n):this.writeUInt8(255+e+1,t,n));},h.prototype.writeInt16LE=function(e,t,n){E(this,e,t,!0,n);},h.prototype.writeInt16BE=function(e,t,n){E(this,e,t,!1,n);},h.prototype.writeInt32LE=function(e,t,n){I(this,e,t,!0,n);},h.prototype.writeInt32BE=function(e,t,n){I(this,e,t,!1,n);},h.prototype.writeFloatLE=function(e,t,n){A(this,e,t,!0,n);},h.prototype.writeFloatBE=function(e,t,n){A(this,e,t,!1,n);},h.prototype.writeDoubleLE=function(e,t,n){B(this,e,t,!0,n);},h.prototype.writeDoubleBE=function(e,t,n){B(this,e,t,!1,n);},h.prototype.fill=function(e,t,n){if(e=e||0,t=t||0,n=n||this.length,"string"==typeof e&&(e=e.charCodeAt(0)),D("number"==typeof e&&!isNaN(e),"value is not a number"),D(t<=n,"end < start"),n!==t&&0!==this.length){D(0<=t&&t<this.length,"start out of bounds"),D(0<=n&&n<=this.length,"end out of bounds");for(var r=t;r<n;r++)this[r]=e;}},h.prototype.inspect=function(){for(var e=[],t=this.length,n=0;n<t;n++)if(e[n]=j(this[n]),n===H.INSPECT_MAX_BYTES){e[n+1]="...";break}return "<Buffer "+e.join(" ")+">"},h.prototype.toArrayBuffer=function(){if("undefined"==typeof Uint8Array)throw new Error("Buffer.toArrayBuffer not supported in this browser");if(h._useTypedArrays)return new h(this).buffer;for(var e=new Uint8Array(this.length),t=0,n=e.length;t<n;t+=1)e[t]=this[t];return e.buffer};var L=h.prototype;function U(e,t,n){return "number"!=typeof e?n:t<=(e=~~e)?t:0<=e||0<=(e+=t)?e:0}function x(e){return (e=~~Math.ceil(+e))<0?0:e}function S(e){return (Array.isArray||function(e){return "[object Array]"===Object.prototype.toString.call(e)})(e)}function j(e){return e<16?"0"+e.toString(16):e.toString(16)}function C(e){for(var t=[],n=0;n<e.length;n++){var r=e.charCodeAt(n);if(r<=127)t.push(e.charCodeAt(n));else {var o=n;55296<=r&&r<=57343&&n++;for(var i=encodeURIComponent(e.slice(o,n+1)).substr(1).split("%"),u=0;u<i.length;u++)t.push(parseInt(i[u],16));}}return t}function k(e){return s.toByteArray(e)}function T(e,t,n,r){for(var o=0;o<r&&!(o+n>=t.length||o>=e.length);o++)t[o+n]=e[o];return o}function M(e){try{return decodeURIComponent(e)}catch(e){return String.fromCharCode(65533)}}function N(e,t){D("number"==typeof e,"cannot write a non-number as a number"),D(0<=e,"specified a negative value for writing an unsigned value"),D(e<=t,"value is larger than maximum value for type"),D(Math.floor(e)===e,"value has a fractional component");}function Y(e,t,n){D("number"==typeof e,"cannot write a non-number as a number"),D(e<=t,"value larger than maximum allowed value"),D(n<=e,"value smaller than minimum allowed value"),D(Math.floor(e)===e,"value has a fractional component");}function F(e,t,n){D("number"==typeof e,"cannot write a non-number as a number"),D(e<=t,"value larger than maximum allowed value"),D(n<=e,"value smaller than minimum allowed value");}function D(e,t){if(!e)throw new Error(t||"Failed assertion")}h._augment=function(e){return e._isBuffer=!0,e._get=e.get,e._set=e.set,e.get=L.get,e.set=L.set,e.write=L.write,e.toString=L.toString,e.toLocaleString=L.toString,e.toJSON=L.toJSON,e.copy=L.copy,e.slice=L.slice,e.readUInt8=L.readUInt8,e.readUInt16LE=L.readUInt16LE,e.readUInt16BE=L.readUInt16BE,e.readUInt32LE=L.readUInt32LE,e.readUInt32BE=L.readUInt32BE,e.readInt8=L.readInt8,e.readInt16LE=L.readInt16LE,e.readInt16BE=L.readInt16BE,e.readInt32LE=L.readInt32LE,e.readInt32BE=L.readInt32BE,e.readFloatLE=L.readFloatLE,e.readFloatBE=L.readFloatBE,e.readDoubleLE=L.readDoubleLE,e.readDoubleBE=L.readDoubleBE,e.writeUInt8=L.writeUInt8,e.writeUInt16LE=L.writeUInt16LE,e.writeUInt16BE=L.writeUInt16BE,e.writeUInt32LE=L.writeUInt32LE,e.writeUInt32BE=L.writeUInt32BE,e.writeInt8=L.writeInt8,e.writeInt16LE=L.writeInt16LE,e.writeInt16BE=L.writeInt16BE,e.writeInt32LE=L.writeInt32LE,e.writeInt32BE=L.writeInt32BE,e.writeFloatLE=L.writeFloatLE,e.writeFloatBE=L.writeFloatBE,e.writeDoubleLE=L.writeDoubleLE,e.writeDoubleBE=L.writeDoubleBE,e.fill=L.fill,e.inspect=L.inspect,e.toArrayBuffer=L.toArrayBuffer,e};}).call(this,O("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},O("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/buffer/index.js","/node_modules/gulp-browserify/node_modules/buffer");},{"base64-js":2,buffer:3,ieee754:11,lYpoI2:10}],4:[function(l,d,e){(function(e,t,u,n,r,o,i,a,s){u=l("buffer").Buffer;var f=4,c=new u(f);c.fill(0);d.exports={hash:function(e,t,n,r){return u.isBuffer(e)||(e=new u(e)),function(e,t,n){for(var r=new u(t),o=n?r.writeInt32BE:r.writeInt32LE,i=0;i<e.length;i++)o.call(r,e[i],4*i,!0);return r}(t(function(e,t){if(e.length%f!=0){var n=e.length+(f-e.length%f);e=u.concat([e,c],n);}for(var r=[],o=t?e.readInt32BE:e.readInt32LE,i=0;i<e.length;i+=f)r.push(o.call(e,i));return r}(e,r),8*e.length),n,r)}};}).call(this,l("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},l("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js","/node_modules/gulp-browserify/node_modules/crypto-browserify");},{buffer:3,lYpoI2:10}],5:[function(w,e,b){(function(e,t,a,n,r,o,i,u,s){a=w("buffer").Buffer;var f=w("./sha"),c=w("./sha256"),l=w("./rng"),d={sha1:f,sha256:c,md5:w("./md5")},h=64,p=new a(h);function g(e,r){var o=d[e=e||"sha1"],i=[];return o||y("algorithm:",e,"is not yet supported"),{update:function(e){return a.isBuffer(e)||(e=new a(e)),i.push(e),e.length,this},digest:function(e){var t=a.concat(i),n=r?function(e,t,n){a.isBuffer(t)||(t=new a(t)),a.isBuffer(n)||(n=new a(n)),t.length>h?t=e(t):t.length<h&&(t=a.concat([t,p],h));for(var r=new a(h),o=new a(h),i=0;i<h;i++)r[i]=54^t[i],o[i]=92^t[i];var u=e(a.concat([r,n]));return e(a.concat([o,u]))}(o,r,t):o(t);return i=null,e?n.toString(e):n}}}function y(){var e=[].slice.call(arguments).join(" ");throw new Error([e,"we accept pull requests","http://github.com/dominictarr/crypto-browserify"].join("\n"))}p.fill(0),b.createHash=function(e){return g(e)},b.createHmac=function(e,t){return g(e,t)},b.randomBytes=function(e,t){if(!t||!t.call)return new a(l(e));try{t.call(this,void 0,new a(l(e)));}catch(e){t(e);}},function(e,t){for(var n in e)t(e[n],n);}(["createCredentials","createCipher","createCipheriv","createDecipher","createDecipheriv","createSign","createVerify","createDiffieHellman","pbkdf2"],function(e){b[e]=function(){y("sorry,",e,"is not implemented yet");};});}).call(this,w("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},w("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js","/node_modules/gulp-browserify/node_modules/crypto-browserify");},{"./md5":6,"./rng":7,"./sha":8,"./sha256":9,buffer:3,lYpoI2:10}],6:[function(w,b,e){(function(e,t,n,r,o,i,u,a,s){var f=w("./helpers");function c(e,t){e[t>>5]|=128<<t%32,e[14+(t+64>>>9<<4)]=t;for(var n=1732584193,r=-271733879,o=-1732584194,i=271733878,u=0;u<e.length;u+=16){var a=n,s=r,f=o,c=i;n=d(n,r,o,i,e[u+0],7,-680876936),i=d(i,n,r,o,e[u+1],12,-389564586),o=d(o,i,n,r,e[u+2],17,606105819),r=d(r,o,i,n,e[u+3],22,-1044525330),n=d(n,r,o,i,e[u+4],7,-176418897),i=d(i,n,r,o,e[u+5],12,1200080426),o=d(o,i,n,r,e[u+6],17,-1473231341),r=d(r,o,i,n,e[u+7],22,-45705983),n=d(n,r,o,i,e[u+8],7,1770035416),i=d(i,n,r,o,e[u+9],12,-1958414417),o=d(o,i,n,r,e[u+10],17,-42063),r=d(r,o,i,n,e[u+11],22,-1990404162),n=d(n,r,o,i,e[u+12],7,1804603682),i=d(i,n,r,o,e[u+13],12,-40341101),o=d(o,i,n,r,e[u+14],17,-1502002290),n=h(n,r=d(r,o,i,n,e[u+15],22,1236535329),o,i,e[u+1],5,-165796510),i=h(i,n,r,o,e[u+6],9,-1069501632),o=h(o,i,n,r,e[u+11],14,643717713),r=h(r,o,i,n,e[u+0],20,-373897302),n=h(n,r,o,i,e[u+5],5,-701558691),i=h(i,n,r,o,e[u+10],9,38016083),o=h(o,i,n,r,e[u+15],14,-660478335),r=h(r,o,i,n,e[u+4],20,-405537848),n=h(n,r,o,i,e[u+9],5,568446438),i=h(i,n,r,o,e[u+14],9,-1019803690),o=h(o,i,n,r,e[u+3],14,-187363961),r=h(r,o,i,n,e[u+8],20,1163531501),n=h(n,r,o,i,e[u+13],5,-1444681467),i=h(i,n,r,o,e[u+2],9,-51403784),o=h(o,i,n,r,e[u+7],14,1735328473),n=p(n,r=h(r,o,i,n,e[u+12],20,-1926607734),o,i,e[u+5],4,-378558),i=p(i,n,r,o,e[u+8],11,-2022574463),o=p(o,i,n,r,e[u+11],16,1839030562),r=p(r,o,i,n,e[u+14],23,-35309556),n=p(n,r,o,i,e[u+1],4,-1530992060),i=p(i,n,r,o,e[u+4],11,1272893353),o=p(o,i,n,r,e[u+7],16,-155497632),r=p(r,o,i,n,e[u+10],23,-1094730640),n=p(n,r,o,i,e[u+13],4,681279174),i=p(i,n,r,o,e[u+0],11,-358537222),o=p(o,i,n,r,e[u+3],16,-722521979),r=p(r,o,i,n,e[u+6],23,76029189),n=p(n,r,o,i,e[u+9],4,-640364487),i=p(i,n,r,o,e[u+12],11,-421815835),o=p(o,i,n,r,e[u+15],16,530742520),n=g(n,r=p(r,o,i,n,e[u+2],23,-995338651),o,i,e[u+0],6,-198630844),i=g(i,n,r,o,e[u+7],10,1126891415),o=g(o,i,n,r,e[u+14],15,-1416354905),r=g(r,o,i,n,e[u+5],21,-57434055),n=g(n,r,o,i,e[u+12],6,1700485571),i=g(i,n,r,o,e[u+3],10,-1894986606),o=g(o,i,n,r,e[u+10],15,-1051523),r=g(r,o,i,n,e[u+1],21,-2054922799),n=g(n,r,o,i,e[u+8],6,1873313359),i=g(i,n,r,o,e[u+15],10,-30611744),o=g(o,i,n,r,e[u+6],15,-1560198380),r=g(r,o,i,n,e[u+13],21,1309151649),n=g(n,r,o,i,e[u+4],6,-145523070),i=g(i,n,r,o,e[u+11],10,-1120210379),o=g(o,i,n,r,e[u+2],15,718787259),r=g(r,o,i,n,e[u+9],21,-343485551),n=y(n,a),r=y(r,s),o=y(o,f),i=y(i,c);}return Array(n,r,o,i)}function l(e,t,n,r,o,i){return y((u=y(y(t,e),y(r,i)))<<(a=o)|u>>>32-a,n);var u,a;}function d(e,t,n,r,o,i,u){return l(t&n|~t&r,e,t,o,i,u)}function h(e,t,n,r,o,i,u){return l(t&r|n&~r,e,t,o,i,u)}function p(e,t,n,r,o,i,u){return l(t^n^r,e,t,o,i,u)}function g(e,t,n,r,o,i,u){return l(n^(t|~r),e,t,o,i,u)}function y(e,t){var n=(65535&e)+(65535&t);return (e>>16)+(t>>16)+(n>>16)<<16|65535&n}b.exports=function(e){return f.hash(e,c,16)};}).call(this,w("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},w("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js","/node_modules/gulp-browserify/node_modules/crypto-browserify");},{"./helpers":4,buffer:3,lYpoI2:10}],7:[function(e,l,t){(function(e,t,n,r,o,i,u,a,s){var f;f=function(e){for(var t,n=new Array(e),r=0;r<e;r++)0==(3&r)&&(t=4294967296*Math.random()),n[r]=t>>>((3&r)<<3)&255;return n},l.exports=f;}).call(this,e("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js","/node_modules/gulp-browserify/node_modules/crypto-browserify");},{buffer:3,lYpoI2:10}],8:[function(l,d,e){(function(e,t,n,r,o,i,u,a,s){var f=l("./helpers");function c(e,t){e[t>>5]|=128<<24-t%32,e[15+(t+64>>9<<4)]=t;for(var n,r=Array(80),o=1732584193,i=-271733879,u=-1732584194,a=271733878,s=-1009589776,f=0;f<e.length;f+=16){for(var c=o,l=i,d=u,h=a,p=s,g=0;g<80;g++){r[g]=g<16?e[f+g]:m(r[g-3]^r[g-8]^r[g-14]^r[g-16],1);var y=b(b(m(o,5),w(g,i,u,a)),b(b(s,r[g]),(n=g)<20?1518500249:n<40?1859775393:n<60?-1894007588:-899497514));s=a,a=u,u=m(i,30),i=o,o=y;}o=b(o,c),i=b(i,l),u=b(u,d),a=b(a,h),s=b(s,p);}return Array(o,i,u,a,s)}function w(e,t,n,r){return e<20?t&n|~t&r:!(e<40)&&e<60?t&n|t&r|n&r:t^n^r}function b(e,t){var n=(65535&e)+(65535&t);return (e>>16)+(t>>16)+(n>>16)<<16|65535&n}function m(e,t){return e<<t|e>>>32-t}d.exports=function(e){return f.hash(e,c,20,!0)};}).call(this,l("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},l("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js","/node_modules/gulp-browserify/node_modules/crypto-browserify");},{"./helpers":4,buffer:3,lYpoI2:10}],9:[function(l,d,e){(function(e,t,n,r,o,i,u,a,s){function B(e,t){var n=(65535&e)+(65535&t);return (e>>16)+(t>>16)+(n>>16)<<16|65535&n}function L(e,t){return e>>>t|e<<32-t}function U(e,t){return e>>>t}function f(e,t){var n,r,o,i,u,a,s,f,c,l,d,h,p,g,y,w,b,m,v=new Array(1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298),_=new Array(1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225),E=new Array(64);e[t>>5]|=128<<24-t%32,e[15+(t+64>>9<<4)]=t;for(var I=0;I<e.length;I+=16){n=_[0],r=_[1],o=_[2],i=_[3],u=_[4],a=_[5],s=_[6],f=_[7];for(var A=0;A<64;A++)E[A]=A<16?e[A+I]:B(B(B((m=E[A-2],L(m,17)^L(m,19)^U(m,10)),E[A-7]),(b=E[A-15],L(b,7)^L(b,18)^U(b,3))),E[A-16]),c=B(B(B(B(f,L(w=u,6)^L(w,11)^L(w,25)),(y=u)&a^~y&s),v[A]),E[A]),l=B(L(g=n,2)^L(g,13)^L(g,22),(d=n)&(h=r)^d&(p=o)^h&p),f=s,s=a,a=u,u=B(i,c),i=o,o=r,r=n,n=B(c,l);_[0]=B(n,_[0]),_[1]=B(r,_[1]),_[2]=B(o,_[2]),_[3]=B(i,_[3]),_[4]=B(u,_[4]),_[5]=B(a,_[5]),_[6]=B(s,_[6]),_[7]=B(f,_[7]);}return _}var c=l("./helpers");d.exports=function(e){return c.hash(e,f,32,!0)};}).call(this,l("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},l("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js","/node_modules/gulp-browserify/node_modules/crypto-browserify");},{"./helpers":4,buffer:3,lYpoI2:10}],10:[function(e,c,t){(function(e,t,n,r,o,i,u,a,s){function f(){}(e=c.exports={}).nextTick=function(){var e="undefined"!=typeof window&&window.setImmediate,t="undefined"!=typeof window&&window.postMessage&&window.addEventListener;if(e)return function(e){return window.setImmediate(e)};if(t){var n=[];return window.addEventListener("message",function(e){var t=e.source;t!==window&&null!==t||"process-tick"!==e.data||(e.stopPropagation(),0<n.length&&n.shift()());},!0),function(e){n.push(e),window.postMessage("process-tick","*");}}return function(e){setTimeout(e,0);}}(),e.title="browser",e.browser=!0,e.env={},e.argv=[],e.on=f,e.addListener=f,e.once=f,e.off=f,e.removeListener=f,e.removeAllListeners=f,e.emit=f,e.binding=function(e){throw new Error("process.binding is not supported")},e.cwd=function(){return "/"},e.chdir=function(e){throw new Error("process.chdir is not supported")};}).call(this,e("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/process/browser.js","/node_modules/gulp-browserify/node_modules/process");},{buffer:3,lYpoI2:10}],11:[function(e,t,f){(function(e,t,n,r,o,i,u,a,s){f.read=function(e,t,n,r,o){var i,u,a=8*o-r-1,s=(1<<a)-1,f=s>>1,c=-7,l=n?o-1:0,d=n?-1:1,h=e[t+l];for(l+=d,i=h&(1<<-c)-1,h>>=-c,c+=a;0<c;i=256*i+e[t+l],l+=d,c-=8);for(u=i&(1<<-c)-1,i>>=-c,c+=r;0<c;u=256*u+e[t+l],l+=d,c-=8);if(0===i)i=1-f;else {if(i===s)return u?NaN:1/0*(h?-1:1);u+=Math.pow(2,r),i-=f;}return (h?-1:1)*u*Math.pow(2,i-r)},f.write=function(e,t,n,r,o,i){var u,a,s,f=8*i-o-1,c=(1<<f)-1,l=c>>1,d=23===o?Math.pow(2,-24)-Math.pow(2,-77):0,h=r?0:i-1,p=r?1:-1,g=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(a=isNaN(t)?1:0,u=c):(u=Math.floor(Math.log(t)/Math.LN2),t*(s=Math.pow(2,-u))<1&&(u--,s*=2),2<=(t+=1<=u+l?d/s:d*Math.pow(2,1-l))*s&&(u++,s/=2),c<=u+l?(a=0,u=c):1<=u+l?(a=(t*s-1)*Math.pow(2,o),u+=l):(a=t*Math.pow(2,l-1)*Math.pow(2,o),u=0));8<=o;e[n+h]=255&a,h+=p,a/=256,o-=8);for(u=u<<o|a,f+=o;0<f;e[n+h]=255&u,h+=p,u/=256,f-=8);e[n+h-p]|=128*g;};}).call(this,e("lYpoI2"),"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},e("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/ieee754/index.js","/node_modules/ieee754");},{buffer:3,lYpoI2:10}]},{},[1])(1)});
            });

            // Reserved word lists for various dialects of the language

            var reservedWords = {
              3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
              5: "class enum extends super const export import",
              6: "enum",
              strict: "implements interface let package private protected public static yield",
              strictBind: "eval arguments"
            };

            // And the keywords

            var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

            var keywords = {
              5: ecma5AndLessKeywords,
              "5module": ecma5AndLessKeywords + " export import",
              6: ecma5AndLessKeywords + " const class extends export import super"
            };

            var keywordRelationalOperator = /^in(stanceof)?$/;

            // ## Character categories

            // Big ugly regular expressions that match characters in the
            // whitespace, identifier, and identifier-start categories. These
            // are only applied when a character is found to actually have a
            // code point above 128.
            // Generated by `bin/generate-identifier-regex.js`.
            var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
            var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

            var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
            var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

            nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

            // These are a run-length and offset encoded representation of the
            // >0xffff code points that are a valid part of identifiers. The
            // offset starts at 0x10000, and each pair of numbers represents an
            // offset to the next range, and then a size of the range. They were
            // generated by bin/generate-identifier-regex.js

            // eslint-disable-next-line comma-spacing
            var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938];

            // eslint-disable-next-line comma-spacing
            var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];

            // This has a complexity linear to the value of the code. The
            // assumption is that looking up astral identifier characters is
            // rare.
            function isInAstralSet(code, set) {
              var pos = 0x10000;
              for (var i = 0; i < set.length; i += 2) {
                pos += set[i];
                if (pos > code) { return false }
                pos += set[i + 1];
                if (pos >= code) { return true }
              }
            }

            // Test whether a given character code starts an identifier.

            function isIdentifierStart(code, astral) {
              if (code < 65) { return code === 36 }
              if (code < 91) { return true }
              if (code < 97) { return code === 95 }
              if (code < 123) { return true }
              if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
              if (astral === false) { return false }
              return isInAstralSet(code, astralIdentifierStartCodes)
            }

            // Test whether a given character is part of an identifier.

            function isIdentifierChar(code, astral) {
              if (code < 48) { return code === 36 }
              if (code < 58) { return true }
              if (code < 65) { return false }
              if (code < 91) { return true }
              if (code < 97) { return code === 95 }
              if (code < 123) { return true }
              if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
              if (astral === false) { return false }
              return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
            }

            // ## Token types

            // The assignment of fine-grained, information-carrying type objects
            // allows the tokenizer to store the information it has about a
            // token in a way that is very cheap for the parser to look up.

            // All token type variables start with an underscore, to make them
            // easy to recognize.

            // The `beforeExpr` property is used to disambiguate between regular
            // expressions and divisions. It is set on all token types that can
            // be followed by an expression (thus, a slash after them would be a
            // regular expression).
            //
            // The `startsExpr` property is used to check if the token ends a
            // `yield` expression. It is set on all token types that either can
            // directly start an expression (like a quotation mark) or can
            // continue an expression (like the body of a string).
            //
            // `isLoop` marks a keyword as starting a loop, which is important
            // to know when parsing a label, in order to allow or disallow
            // continue jumps to that label.

            var TokenType = function TokenType(label, conf) {
              if ( conf === void 0 ) conf = {};

              this.label = label;
              this.keyword = conf.keyword;
              this.beforeExpr = !!conf.beforeExpr;
              this.startsExpr = !!conf.startsExpr;
              this.isLoop = !!conf.isLoop;
              this.isAssign = !!conf.isAssign;
              this.prefix = !!conf.prefix;
              this.postfix = !!conf.postfix;
              this.binop = conf.binop || null;
              this.updateContext = null;
            };

            function binop(name, prec) {
              return new TokenType(name, {beforeExpr: true, binop: prec})
            }
            var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

            // Map keyword names to token types.

            var keywords$1 = {};

            // Succinct definitions of keyword token types
            function kw(name, options) {
              if ( options === void 0 ) options = {};

              options.keyword = name;
              return keywords$1[name] = new TokenType(name, options)
            }

            var types = {
              num: new TokenType("num", startsExpr),
              regexp: new TokenType("regexp", startsExpr),
              string: new TokenType("string", startsExpr),
              name: new TokenType("name", startsExpr),
              eof: new TokenType("eof"),

              // Punctuation token types.
              bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
              bracketR: new TokenType("]"),
              braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
              braceR: new TokenType("}"),
              parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
              parenR: new TokenType(")"),
              comma: new TokenType(",", beforeExpr),
              semi: new TokenType(";", beforeExpr),
              colon: new TokenType(":", beforeExpr),
              dot: new TokenType("."),
              question: new TokenType("?", beforeExpr),
              questionDot: new TokenType("?."),
              arrow: new TokenType("=>", beforeExpr),
              template: new TokenType("template"),
              invalidTemplate: new TokenType("invalidTemplate"),
              ellipsis: new TokenType("...", beforeExpr),
              backQuote: new TokenType("`", startsExpr),
              dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

              // Operators. These carry several kinds of properties to help the
              // parser use them properly (the presence of these properties is
              // what categorizes them as operators).
              //
              // `binop`, when present, specifies that this operator is a binary
              // operator, and will refer to its precedence.
              //
              // `prefix` and `postfix` mark the operator as a prefix or postfix
              // unary operator.
              //
              // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
              // binary operators with a very low precedence, that should result
              // in AssignmentExpression nodes.

              eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
              assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
              incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
              prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
              logicalOR: binop("||", 1),
              logicalAND: binop("&&", 2),
              bitwiseOR: binop("|", 3),
              bitwiseXOR: binop("^", 4),
              bitwiseAND: binop("&", 5),
              equality: binop("==/!=/===/!==", 6),
              relational: binop("</>/<=/>=", 7),
              bitShift: binop("<</>>/>>>", 8),
              plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
              modulo: binop("%", 10),
              star: binop("*", 10),
              slash: binop("/", 10),
              starstar: new TokenType("**", {beforeExpr: true}),
              coalesce: binop("??", 1),

              // Keyword token types.
              _break: kw("break"),
              _case: kw("case", beforeExpr),
              _catch: kw("catch"),
              _continue: kw("continue"),
              _debugger: kw("debugger"),
              _default: kw("default", beforeExpr),
              _do: kw("do", {isLoop: true, beforeExpr: true}),
              _else: kw("else", beforeExpr),
              _finally: kw("finally"),
              _for: kw("for", {isLoop: true}),
              _function: kw("function", startsExpr),
              _if: kw("if"),
              _return: kw("return", beforeExpr),
              _switch: kw("switch"),
              _throw: kw("throw", beforeExpr),
              _try: kw("try"),
              _var: kw("var"),
              _const: kw("const"),
              _while: kw("while", {isLoop: true}),
              _with: kw("with"),
              _new: kw("new", {beforeExpr: true, startsExpr: true}),
              _this: kw("this", startsExpr),
              _super: kw("super", startsExpr),
              _class: kw("class", startsExpr),
              _extends: kw("extends", beforeExpr),
              _export: kw("export"),
              _import: kw("import", startsExpr),
              _null: kw("null", startsExpr),
              _true: kw("true", startsExpr),
              _false: kw("false", startsExpr),
              _in: kw("in", {beforeExpr: true, binop: 7}),
              _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
              _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
              _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
              _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
            };

            // Matches a whole line break (where CRLF is considered a single
            // line break). Used to count lines.

            var lineBreak = /\r\n?|\n|\u2028|\u2029/;
            var lineBreakG = new RegExp(lineBreak.source, "g");

            function isNewLine(code, ecma2019String) {
              return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
            }

            var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

            var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

            var ref = Object.prototype;
            var hasOwnProperty$2 = ref.hasOwnProperty;
            var toString$2 = ref.toString;

            // Checks if an object has a property.

            function has(obj, propName) {
              return hasOwnProperty$2.call(obj, propName)
            }

            var isArray$3 = Array.isArray || (function (obj) { return (
              toString$2.call(obj) === "[object Array]"
            ); });

            function wordsRegexp(words) {
              return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
            }

            // These are used when `options.locations` is on, for the
            // `startLoc` and `endLoc` properties.

            var Position = function Position(line, col) {
              this.line = line;
              this.column = col;
            };

            Position.prototype.offset = function offset (n) {
              return new Position(this.line, this.column + n)
            };

            var SourceLocation = function SourceLocation(p, start, end) {
              this.start = start;
              this.end = end;
              if (p.sourceFile !== null) { this.source = p.sourceFile; }
            };

            // The `getLineInfo` function is mostly useful when the
            // `locations` option is off (for performance reasons) and you
            // want to find the line/column position for a given character
            // offset. `input` should be the code string that the offset refers
            // into.

            function getLineInfo(input, offset) {
              for (var line = 1, cur = 0;;) {
                lineBreakG.lastIndex = cur;
                var match = lineBreakG.exec(input);
                if (match && match.index < offset) {
                  ++line;
                  cur = match.index + match[0].length;
                } else {
                  return new Position(line, offset - cur)
                }
              }
            }

            // A second optional argument can be given to further configure
            // the parser process. These options are recognized:

            var defaultOptions = {
              // `ecmaVersion` indicates the ECMAScript version to parse. Must be
              // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
              // (2019). This influences support for strict mode, the set of
              // reserved words, and support for new syntax features. The default
              // is 10.
              ecmaVersion: 10,
              // `sourceType` indicates the mode the code should be parsed in.
              // Can be either `"script"` or `"module"`. This influences global
              // strict mode and parsing of `import` and `export` declarations.
              sourceType: "script",
              // `onInsertedSemicolon` can be a callback that will be called
              // when a semicolon is automatically inserted. It will be passed
              // the position of the comma as an offset, and if `locations` is
              // enabled, it is given the location as a `{line, column}` object
              // as second argument.
              onInsertedSemicolon: null,
              // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
              // trailing commas.
              onTrailingComma: null,
              // By default, reserved words are only enforced if ecmaVersion >= 5.
              // Set `allowReserved` to a boolean value to explicitly turn this on
              // an off. When this option has the value "never", reserved words
              // and keywords can also not be used as property names.
              allowReserved: null,
              // When enabled, a return at the top level is not considered an
              // error.
              allowReturnOutsideFunction: false,
              // When enabled, import/export statements are not constrained to
              // appearing at the top of the program.
              allowImportExportEverywhere: false,
              // When enabled, await identifiers are allowed to appear at the top-level scope,
              // but they are still not allowed in non-async functions.
              allowAwaitOutsideFunction: false,
              // When enabled, hashbang directive in the beginning of file
              // is allowed and treated as a line comment.
              allowHashBang: false,
              // When `locations` is on, `loc` properties holding objects with
              // `start` and `end` properties in `{line, column}` form (with
              // line being 1-based and column 0-based) will be attached to the
              // nodes.
              locations: false,
              // A function can be passed as `onToken` option, which will
              // cause Acorn to call that function with object in the same
              // format as tokens returned from `tokenizer().getToken()`. Note
              // that you are not allowed to call the parser from the
              // callback—that will corrupt its internal state.
              onToken: null,
              // A function can be passed as `onComment` option, which will
              // cause Acorn to call that function with `(block, text, start,
              // end)` parameters whenever a comment is skipped. `block` is a
              // boolean indicating whether this is a block (`/* */`) comment,
              // `text` is the content of the comment, and `start` and `end` are
              // character offsets that denote the start and end of the comment.
              // When the `locations` option is on, two more parameters are
              // passed, the full `{line, column}` locations of the start and
              // end of the comments. Note that you are not allowed to call the
              // parser from the callback—that will corrupt its internal state.
              onComment: null,
              // Nodes have their start and end characters offsets recorded in
              // `start` and `end` properties (directly on the node, rather than
              // the `loc` object, which holds line/column data. To also add a
              // [semi-standardized][range] `range` property holding a `[start,
              // end]` array with the same numbers, set the `ranges` option to
              // `true`.
              //
              // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
              ranges: false,
              // It is possible to parse multiple files into a single AST by
              // passing the tree produced by parsing the first file as
              // `program` option in subsequent parses. This will add the
              // toplevel forms of the parsed file to the `Program` (top) node
              // of an existing parse tree.
              program: null,
              // When `locations` is on, you can pass this to record the source
              // file in every node's `loc` object.
              sourceFile: null,
              // This value, if given, is stored in every node, whether
              // `locations` is on or off.
              directSourceFile: null,
              // When enabled, parenthesized expressions are represented by
              // (non-standard) ParenthesizedExpression nodes
              preserveParens: false
            };

            // Interpret and default an options object

            function getOptions(opts) {
              var options = {};

              for (var opt in defaultOptions)
                { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

              if (options.ecmaVersion >= 2015)
                { options.ecmaVersion -= 2009; }

              if (options.allowReserved == null)
                { options.allowReserved = options.ecmaVersion < 5; }

              if (isArray$3(options.onToken)) {
                var tokens = options.onToken;
                options.onToken = function (token) { return tokens.push(token); };
              }
              if (isArray$3(options.onComment))
                { options.onComment = pushComment(options, options.onComment); }

              return options
            }

            function pushComment(options, array) {
              return function(block, text, start, end, startLoc, endLoc) {
                var comment = {
                  type: block ? "Block" : "Line",
                  value: text,
                  start: start,
                  end: end
                };
                if (options.locations)
                  { comment.loc = new SourceLocation(this, startLoc, endLoc); }
                if (options.ranges)
                  { comment.range = [start, end]; }
                array.push(comment);
              }
            }

            // Each scope gets a bitset that may contain these flags
            var
                SCOPE_TOP = 1,
                SCOPE_FUNCTION = 2,
                SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
                SCOPE_ASYNC = 4,
                SCOPE_GENERATOR = 8,
                SCOPE_ARROW = 16,
                SCOPE_SIMPLE_CATCH = 32,
                SCOPE_SUPER = 64,
                SCOPE_DIRECT_SUPER = 128;

            function functionFlags(async, generator) {
              return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
            }

            // Used in checkLVal and declareName to determine the type of a binding
            var
                BIND_NONE = 0, // Not a binding
                BIND_VAR = 1, // Var-style binding
                BIND_LEXICAL = 2, // Let- or const-style binding
                BIND_FUNCTION = 3, // Function declaration
                BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
                BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

            var Parser = function Parser(options, input, startPos) {
              this.options = options = getOptions(options);
              this.sourceFile = options.sourceFile;
              this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
              var reserved = "";
              if (options.allowReserved !== true) {
                for (var v = options.ecmaVersion;; v--)
                  { if (reserved = reservedWords[v]) { break } }
                if (options.sourceType === "module") { reserved += " await"; }
              }
              this.reservedWords = wordsRegexp(reserved);
              var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
              this.reservedWordsStrict = wordsRegexp(reservedStrict);
              this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
              this.input = String(input);

              // Used to signal to callers of `readWord1` whether the word
              // contained any escape sequences. This is needed because words with
              // escape sequences must not be interpreted as keywords.
              this.containsEsc = false;

              // Set up token state

              // The current position of the tokenizer in the input.
              if (startPos) {
                this.pos = startPos;
                this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
                this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
              } else {
                this.pos = this.lineStart = 0;
                this.curLine = 1;
              }

              // Properties of the current token:
              // Its type
              this.type = types.eof;
              // For tokens that include more information than their type, the value
              this.value = null;
              // Its start and end offset
              this.start = this.end = this.pos;
              // And, if locations are used, the {line, column} object
              // corresponding to those offsets
              this.startLoc = this.endLoc = this.curPosition();

              // Position information for the previous token
              this.lastTokEndLoc = this.lastTokStartLoc = null;
              this.lastTokStart = this.lastTokEnd = this.pos;

              // The context stack is used to superficially track syntactic
              // context to predict whether a regular expression is allowed in a
              // given position.
              this.context = this.initialContext();
              this.exprAllowed = true;

              // Figure out if it's a module code.
              this.inModule = options.sourceType === "module";
              this.strict = this.inModule || this.strictDirective(this.pos);

              // Used to signify the start of a potential arrow function
              this.potentialArrowAt = -1;

              // Positions to delayed-check that yield/await does not exist in default parameters.
              this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
              // Labels in scope.
              this.labels = [];
              // Thus-far undefined exports.
              this.undefinedExports = {};

              // If enabled, skip leading hashbang line.
              if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
                { this.skipLineComment(2); }

              // Scope tracking for duplicate variable names (see scope.js)
              this.scopeStack = [];
              this.enterScope(SCOPE_TOP);

              // For RegExp validation
              this.regexpState = null;
            };

            var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

            Parser.prototype.parse = function parse () {
              var node = this.options.program || this.startNode();
              this.nextToken();
              return this.parseTopLevel(node)
            };

            prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
            prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
            prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
            prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
            prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
            prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

            // Switch to a getter for 7.0.0.
            Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

            Parser.extend = function extend () {
                var plugins = [], len = arguments.length;
                while ( len-- ) plugins[ len ] = arguments[ len ];

              var cls = this;
              for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
              return cls
            };

            Parser.parse = function parse (input, options) {
              return new this(options, input).parse()
            };

            Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
              var parser = new this(options, input, pos);
              parser.nextToken();
              return parser.parseExpression()
            };

            Parser.tokenizer = function tokenizer (input, options) {
              return new this(options, input)
            };

            Object.defineProperties( Parser.prototype, prototypeAccessors );

            var pp = Parser.prototype;

            // ## Parser utilities

            var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
            pp.strictDirective = function(start) {
              for (;;) {
                // Try to find string literal.
                skipWhiteSpace.lastIndex = start;
                start += skipWhiteSpace.exec(this.input)[0].length;
                var match = literal.exec(this.input.slice(start));
                if (!match) { return false }
                if ((match[1] || match[2]) === "use strict") {
                  skipWhiteSpace.lastIndex = start + match[0].length;
                  var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
                  var next = this.input.charAt(end);
                  return next === ";" || next === "}" ||
                    (lineBreak.test(spaceAfter[0]) &&
                     !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
                }
                start += match[0].length;

                // Skip semicolon, if any.
                skipWhiteSpace.lastIndex = start;
                start += skipWhiteSpace.exec(this.input)[0].length;
                if (this.input[start] === ";")
                  { start++; }
              }
            };

            // Predicate that tests whether the next token is of the given
            // type, and if yes, consumes it as a side effect.

            pp.eat = function(type) {
              if (this.type === type) {
                this.next();
                return true
              } else {
                return false
              }
            };

            // Tests whether parsed token is a contextual keyword.

            pp.isContextual = function(name) {
              return this.type === types.name && this.value === name && !this.containsEsc
            };

            // Consumes contextual keyword if possible.

            pp.eatContextual = function(name) {
              if (!this.isContextual(name)) { return false }
              this.next();
              return true
            };

            // Asserts that following token is given contextual keyword.

            pp.expectContextual = function(name) {
              if (!this.eatContextual(name)) { this.unexpected(); }
            };

            // Test whether a semicolon can be inserted at the current position.

            pp.canInsertSemicolon = function() {
              return this.type === types.eof ||
                this.type === types.braceR ||
                lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
            };

            pp.insertSemicolon = function() {
              if (this.canInsertSemicolon()) {
                if (this.options.onInsertedSemicolon)
                  { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
                return true
              }
            };

            // Consume a semicolon, or, failing that, see if we are allowed to
            // pretend that there is a semicolon at this position.

            pp.semicolon = function() {
              if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
            };

            pp.afterTrailingComma = function(tokType, notNext) {
              if (this.type === tokType) {
                if (this.options.onTrailingComma)
                  { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
                if (!notNext)
                  { this.next(); }
                return true
              }
            };

            // Expect a token of a given type. If found, consume it, otherwise,
            // raise an unexpected token error.

            pp.expect = function(type) {
              this.eat(type) || this.unexpected();
            };

            // Raise an unexpected token error.

            pp.unexpected = function(pos) {
              this.raise(pos != null ? pos : this.start, "Unexpected token");
            };

            function DestructuringErrors() {
              this.shorthandAssign =
              this.trailingComma =
              this.parenthesizedAssign =
              this.parenthesizedBind =
              this.doubleProto =
                -1;
            }

            pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
              if (!refDestructuringErrors) { return }
              if (refDestructuringErrors.trailingComma > -1)
                { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
              var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
              if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
            };

            pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
              if (!refDestructuringErrors) { return false }
              var shorthandAssign = refDestructuringErrors.shorthandAssign;
              var doubleProto = refDestructuringErrors.doubleProto;
              if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
              if (shorthandAssign >= 0)
                { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
              if (doubleProto >= 0)
                { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
            };

            pp.checkYieldAwaitInDefaultParams = function() {
              if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
                { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
              if (this.awaitPos)
                { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
            };

            pp.isSimpleAssignTarget = function(expr) {
              if (expr.type === "ParenthesizedExpression")
                { return this.isSimpleAssignTarget(expr.expression) }
              return expr.type === "Identifier" || expr.type === "MemberExpression"
            };

            var pp$1 = Parser.prototype;

            // ### Statement parsing

            // Parse a program. Initializes the parser, reads any number of
            // statements, and wraps them in a Program node.  Optionally takes a
            // `program` argument.  If present, the statements will be appended
            // to its body instead of creating a new node.

            pp$1.parseTopLevel = function(node) {
              var exports = {};
              if (!node.body) { node.body = []; }
              while (this.type !== types.eof) {
                var stmt = this.parseStatement(null, true, exports);
                node.body.push(stmt);
              }
              if (this.inModule)
                { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
                  {
                    var name = list[i];

                    this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
                  } }
              this.adaptDirectivePrologue(node.body);
              this.next();
              node.sourceType = this.options.sourceType;
              return this.finishNode(node, "Program")
            };

            var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

            pp$1.isLet = function(context) {
              if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
              skipWhiteSpace.lastIndex = this.pos;
              var skip = skipWhiteSpace.exec(this.input);
              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
              // For ambiguous cases, determine if a LexicalDeclaration (or only a
              // Statement) is allowed here. If context is not empty then only a Statement
              // is allowed. However, `let [` is an explicit negative lookahead for
              // ExpressionStatement, so special-case it first.
              if (nextCh === 91) { return true } // '['
              if (context) { return false }

              if (nextCh === 123) { return true } // '{'
              if (isIdentifierStart(nextCh, true)) {
                var pos = next + 1;
                while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
                var ident = this.input.slice(next, pos);
                if (!keywordRelationalOperator.test(ident)) { return true }
              }
              return false
            };

            // check 'async [no LineTerminator here] function'
            // - 'async /*foo*/ function' is OK.
            // - 'async /*\n*/ function' is invalid.
            pp$1.isAsyncFunction = function() {
              if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
                { return false }

              skipWhiteSpace.lastIndex = this.pos;
              var skip = skipWhiteSpace.exec(this.input);
              var next = this.pos + skip[0].length;
              return !lineBreak.test(this.input.slice(this.pos, next)) &&
                this.input.slice(next, next + 8) === "function" &&
                (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
            };

            // Parse a single statement.
            //
            // If expecting a statement and finding a slash operator, parse a
            // regular expression literal. This is to handle cases like
            // `if (foo) /blah/.exec(foo)`, where looking at the previous token
            // does not help.

            pp$1.parseStatement = function(context, topLevel, exports) {
              var starttype = this.type, node = this.startNode(), kind;

              if (this.isLet(context)) {
                starttype = types._var;
                kind = "let";
              }

              // Most types of statements are recognized by the keyword they
              // start with. Many are trivial to parse, some require a bit of
              // complexity.

              switch (starttype) {
              case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
              case types._debugger: return this.parseDebuggerStatement(node)
              case types._do: return this.parseDoStatement(node)
              case types._for: return this.parseForStatement(node)
              case types._function:
                // Function as sole body of either an if statement or a labeled statement
                // works, but not when it is part of a labeled statement that is the sole
                // body of an if statement.
                if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
                return this.parseFunctionStatement(node, false, !context)
              case types._class:
                if (context) { this.unexpected(); }
                return this.parseClass(node, true)
              case types._if: return this.parseIfStatement(node)
              case types._return: return this.parseReturnStatement(node)
              case types._switch: return this.parseSwitchStatement(node)
              case types._throw: return this.parseThrowStatement(node)
              case types._try: return this.parseTryStatement(node)
              case types._const: case types._var:
                kind = kind || this.value;
                if (context && kind !== "var") { this.unexpected(); }
                return this.parseVarStatement(node, kind)
              case types._while: return this.parseWhileStatement(node)
              case types._with: return this.parseWithStatement(node)
              case types.braceL: return this.parseBlock(true, node)
              case types.semi: return this.parseEmptyStatement(node)
              case types._export:
              case types._import:
                if (this.options.ecmaVersion > 10 && starttype === types._import) {
                  skipWhiteSpace.lastIndex = this.pos;
                  var skip = skipWhiteSpace.exec(this.input);
                  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
                  if (nextCh === 40 || nextCh === 46) // '(' or '.'
                    { return this.parseExpressionStatement(node, this.parseExpression()) }
                }

                if (!this.options.allowImportExportEverywhere) {
                  if (!topLevel)
                    { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
                  if (!this.inModule)
                    { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
                }
                return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

                // If the statement does not start with a statement keyword or a
                // brace, it's an ExpressionStatement or LabeledStatement. We
                // simply start parsing an expression, and afterwards, if the
                // next token is a colon and the expression was a simple
                // Identifier node, we switch to interpreting it as a label.
              default:
                if (this.isAsyncFunction()) {
                  if (context) { this.unexpected(); }
                  this.next();
                  return this.parseFunctionStatement(node, true, !context)
                }

                var maybeName = this.value, expr = this.parseExpression();
                if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
                  { return this.parseLabeledStatement(node, maybeName, expr, context) }
                else { return this.parseExpressionStatement(node, expr) }
              }
            };

            pp$1.parseBreakContinueStatement = function(node, keyword) {
              var isBreak = keyword === "break";
              this.next();
              if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
              else if (this.type !== types.name) { this.unexpected(); }
              else {
                node.label = this.parseIdent();
                this.semicolon();
              }

              // Verify that there is an actual destination to break or
              // continue to.
              var i = 0;
              for (; i < this.labels.length; ++i) {
                var lab = this.labels[i];
                if (node.label == null || lab.name === node.label.name) {
                  if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
                  if (node.label && isBreak) { break }
                }
              }
              if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
              return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
            };

            pp$1.parseDebuggerStatement = function(node) {
              this.next();
              this.semicolon();
              return this.finishNode(node, "DebuggerStatement")
            };

            pp$1.parseDoStatement = function(node) {
              this.next();
              this.labels.push(loopLabel);
              node.body = this.parseStatement("do");
              this.labels.pop();
              this.expect(types._while);
              node.test = this.parseParenExpression();
              if (this.options.ecmaVersion >= 6)
                { this.eat(types.semi); }
              else
                { this.semicolon(); }
              return this.finishNode(node, "DoWhileStatement")
            };

            // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
            // loop is non-trivial. Basically, we have to parse the init `var`
            // statement or expression, disallowing the `in` operator (see
            // the second parameter to `parseExpression`), and then check
            // whether the next token is `in` or `of`. When there is no init
            // part (semicolon immediately after the opening parenthesis), it
            // is a regular `for` loop.

            pp$1.parseForStatement = function(node) {
              this.next();
              var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
              this.labels.push(loopLabel);
              this.enterScope(0);
              this.expect(types.parenL);
              if (this.type === types.semi) {
                if (awaitAt > -1) { this.unexpected(awaitAt); }
                return this.parseFor(node, null)
              }
              var isLet = this.isLet();
              if (this.type === types._var || this.type === types._const || isLet) {
                var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
                this.next();
                this.parseVar(init$1, true, kind);
                this.finishNode(init$1, "VariableDeclaration");
                if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
                  if (this.options.ecmaVersion >= 9) {
                    if (this.type === types._in) {
                      if (awaitAt > -1) { this.unexpected(awaitAt); }
                    } else { node.await = awaitAt > -1; }
                  }
                  return this.parseForIn(node, init$1)
                }
                if (awaitAt > -1) { this.unexpected(awaitAt); }
                return this.parseFor(node, init$1)
              }
              var refDestructuringErrors = new DestructuringErrors;
              var init = this.parseExpression(true, refDestructuringErrors);
              if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
                if (this.options.ecmaVersion >= 9) {
                  if (this.type === types._in) {
                    if (awaitAt > -1) { this.unexpected(awaitAt); }
                  } else { node.await = awaitAt > -1; }
                }
                this.toAssignable(init, false, refDestructuringErrors);
                this.checkLVal(init);
                return this.parseForIn(node, init)
              } else {
                this.checkExpressionErrors(refDestructuringErrors, true);
              }
              if (awaitAt > -1) { this.unexpected(awaitAt); }
              return this.parseFor(node, init)
            };

            pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
              this.next();
              return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
            };

            pp$1.parseIfStatement = function(node) {
              this.next();
              node.test = this.parseParenExpression();
              // allow function declarations in branches, but only in non-strict mode
              node.consequent = this.parseStatement("if");
              node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
              return this.finishNode(node, "IfStatement")
            };

            pp$1.parseReturnStatement = function(node) {
              if (!this.inFunction && !this.options.allowReturnOutsideFunction)
                { this.raise(this.start, "'return' outside of function"); }
              this.next();

              // In `return` (and `break`/`continue`), the keywords with
              // optional arguments, we eagerly look for a semicolon or the
              // possibility to insert one.

              if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
              else { node.argument = this.parseExpression(); this.semicolon(); }
              return this.finishNode(node, "ReturnStatement")
            };

            pp$1.parseSwitchStatement = function(node) {
              this.next();
              node.discriminant = this.parseParenExpression();
              node.cases = [];
              this.expect(types.braceL);
              this.labels.push(switchLabel);
              this.enterScope(0);

              // Statements under must be grouped (by label) in SwitchCase
              // nodes. `cur` is used to keep the node that we are currently
              // adding statements to.

              var cur;
              for (var sawDefault = false; this.type !== types.braceR;) {
                if (this.type === types._case || this.type === types._default) {
                  var isCase = this.type === types._case;
                  if (cur) { this.finishNode(cur, "SwitchCase"); }
                  node.cases.push(cur = this.startNode());
                  cur.consequent = [];
                  this.next();
                  if (isCase) {
                    cur.test = this.parseExpression();
                  } else {
                    if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
                    sawDefault = true;
                    cur.test = null;
                  }
                  this.expect(types.colon);
                } else {
                  if (!cur) { this.unexpected(); }
                  cur.consequent.push(this.parseStatement(null));
                }
              }
              this.exitScope();
              if (cur) { this.finishNode(cur, "SwitchCase"); }
              this.next(); // Closing brace
              this.labels.pop();
              return this.finishNode(node, "SwitchStatement")
            };

            pp$1.parseThrowStatement = function(node) {
              this.next();
              if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
                { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
              node.argument = this.parseExpression();
              this.semicolon();
              return this.finishNode(node, "ThrowStatement")
            };

            // Reused empty array added for node fields that are always empty.

            var empty$1 = [];

            pp$1.parseTryStatement = function(node) {
              this.next();
              node.block = this.parseBlock();
              node.handler = null;
              if (this.type === types._catch) {
                var clause = this.startNode();
                this.next();
                if (this.eat(types.parenL)) {
                  clause.param = this.parseBindingAtom();
                  var simple = clause.param.type === "Identifier";
                  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
                  this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
                  this.expect(types.parenR);
                } else {
                  if (this.options.ecmaVersion < 10) { this.unexpected(); }
                  clause.param = null;
                  this.enterScope(0);
                }
                clause.body = this.parseBlock(false);
                this.exitScope();
                node.handler = this.finishNode(clause, "CatchClause");
              }
              node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
              if (!node.handler && !node.finalizer)
                { this.raise(node.start, "Missing catch or finally clause"); }
              return this.finishNode(node, "TryStatement")
            };

            pp$1.parseVarStatement = function(node, kind) {
              this.next();
              this.parseVar(node, false, kind);
              this.semicolon();
              return this.finishNode(node, "VariableDeclaration")
            };

            pp$1.parseWhileStatement = function(node) {
              this.next();
              node.test = this.parseParenExpression();
              this.labels.push(loopLabel);
              node.body = this.parseStatement("while");
              this.labels.pop();
              return this.finishNode(node, "WhileStatement")
            };

            pp$1.parseWithStatement = function(node) {
              if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
              this.next();
              node.object = this.parseParenExpression();
              node.body = this.parseStatement("with");
              return this.finishNode(node, "WithStatement")
            };

            pp$1.parseEmptyStatement = function(node) {
              this.next();
              return this.finishNode(node, "EmptyStatement")
            };

            pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
              for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
                {
                var label = list[i$1];

                if (label.name === maybeName)
                  { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
              } }
              var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
              for (var i = this.labels.length - 1; i >= 0; i--) {
                var label$1 = this.labels[i];
                if (label$1.statementStart === node.start) {
                  // Update information about previous labels on this node
                  label$1.statementStart = this.start;
                  label$1.kind = kind;
                } else { break }
              }
              this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
              node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
              this.labels.pop();
              node.label = expr;
              return this.finishNode(node, "LabeledStatement")
            };

            pp$1.parseExpressionStatement = function(node, expr) {
              node.expression = expr;
              this.semicolon();
              return this.finishNode(node, "ExpressionStatement")
            };

            // Parse a semicolon-enclosed block of statements, handling `"use
            // strict"` declarations when `allowStrict` is true (used for
            // function bodies).

            pp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {
              if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
              if ( node === void 0 ) node = this.startNode();

              node.body = [];
              this.expect(types.braceL);
              if (createNewLexicalScope) { this.enterScope(0); }
              while (this.type !== types.braceR) {
                var stmt = this.parseStatement(null);
                node.body.push(stmt);
              }
              if (exitStrict) { this.strict = false; }
              this.next();
              if (createNewLexicalScope) { this.exitScope(); }
              return this.finishNode(node, "BlockStatement")
            };

            // Parse a regular `for` loop. The disambiguation code in
            // `parseStatement` will already have parsed the init statement or
            // expression.

            pp$1.parseFor = function(node, init) {
              node.init = init;
              this.expect(types.semi);
              node.test = this.type === types.semi ? null : this.parseExpression();
              this.expect(types.semi);
              node.update = this.type === types.parenR ? null : this.parseExpression();
              this.expect(types.parenR);
              node.body = this.parseStatement("for");
              this.exitScope();
              this.labels.pop();
              return this.finishNode(node, "ForStatement")
            };

            // Parse a `for`/`in` and `for`/`of` loop, which are almost
            // same from parser's perspective.

            pp$1.parseForIn = function(node, init) {
              var isForIn = this.type === types._in;
              this.next();

              if (
                init.type === "VariableDeclaration" &&
                init.declarations[0].init != null &&
                (
                  !isForIn ||
                  this.options.ecmaVersion < 8 ||
                  this.strict ||
                  init.kind !== "var" ||
                  init.declarations[0].id.type !== "Identifier"
                )
              ) {
                this.raise(
                  init.start,
                  ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
                );
              } else if (init.type === "AssignmentPattern") {
                this.raise(init.start, "Invalid left-hand side in for-loop");
              }
              node.left = init;
              node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
              this.expect(types.parenR);
              node.body = this.parseStatement("for");
              this.exitScope();
              this.labels.pop();
              return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
            };

            // Parse a list of variable declarations.

            pp$1.parseVar = function(node, isFor, kind) {
              node.declarations = [];
              node.kind = kind;
              for (;;) {
                var decl = this.startNode();
                this.parseVarId(decl, kind);
                if (this.eat(types.eq)) {
                  decl.init = this.parseMaybeAssign(isFor);
                } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
                  this.unexpected();
                } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
                  this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
                } else {
                  decl.init = null;
                }
                node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
                if (!this.eat(types.comma)) { break }
              }
              return node
            };

            pp$1.parseVarId = function(decl, kind) {
              decl.id = this.parseBindingAtom();
              this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
            };

            var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

            // Parse a function declaration or literal (depending on the
            // `statement & FUNC_STATEMENT`).

            // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
            pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
              this.initFunction(node);
              if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
                if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
                  { this.unexpected(); }
                node.generator = this.eat(types.star);
              }
              if (this.options.ecmaVersion >= 8)
                { node.async = !!isAsync; }

              if (statement & FUNC_STATEMENT) {
                node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
                if (node.id && !(statement & FUNC_HANGING_STATEMENT))
                  // If it is a regular function declaration in sloppy mode, then it is
                  // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
                  // mode depends on properties of the current scope (see
                  // treatFunctionsAsVar).
                  { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
              }

              var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
              this.yieldPos = 0;
              this.awaitPos = 0;
              this.awaitIdentPos = 0;
              this.enterScope(functionFlags(node.async, node.generator));

              if (!(statement & FUNC_STATEMENT))
                { node.id = this.type === types.name ? this.parseIdent() : null; }

              this.parseFunctionParams(node);
              this.parseFunctionBody(node, allowExpressionBody, false);

              this.yieldPos = oldYieldPos;
              this.awaitPos = oldAwaitPos;
              this.awaitIdentPos = oldAwaitIdentPos;
              return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
            };

            pp$1.parseFunctionParams = function(node) {
              this.expect(types.parenL);
              node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
              this.checkYieldAwaitInDefaultParams();
            };

            // Parse a class declaration or literal (depending on the
            // `isStatement` parameter).

            pp$1.parseClass = function(node, isStatement) {
              this.next();

              // ecma-262 14.6 Class Definitions
              // A class definition is always strict mode code.
              var oldStrict = this.strict;
              this.strict = true;

              this.parseClassId(node, isStatement);
              this.parseClassSuper(node);
              var classBody = this.startNode();
              var hadConstructor = false;
              classBody.body = [];
              this.expect(types.braceL);
              while (this.type !== types.braceR) {
                var element = this.parseClassElement(node.superClass !== null);
                if (element) {
                  classBody.body.push(element);
                  if (element.type === "MethodDefinition" && element.kind === "constructor") {
                    if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
                    hadConstructor = true;
                  }
                }
              }
              this.strict = oldStrict;
              this.next();
              node.body = this.finishNode(classBody, "ClassBody");
              return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
            };

            pp$1.parseClassElement = function(constructorAllowsSuper) {
              var this$1 = this;

              if (this.eat(types.semi)) { return null }

              var method = this.startNode();
              var tryContextual = function (k, noLineBreak) {
                if ( noLineBreak === void 0 ) noLineBreak = false;

                var start = this$1.start, startLoc = this$1.startLoc;
                if (!this$1.eatContextual(k)) { return false }
                if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
                if (method.key) { this$1.unexpected(); }
                method.computed = false;
                method.key = this$1.startNodeAt(start, startLoc);
                method.key.name = k;
                this$1.finishNode(method.key, "Identifier");
                return false
              };

              method.kind = "method";
              method.static = tryContextual("static");
              var isGenerator = this.eat(types.star);
              var isAsync = false;
              if (!isGenerator) {
                if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
                  isAsync = true;
                  isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
                } else if (tryContextual("get")) {
                  method.kind = "get";
                } else if (tryContextual("set")) {
                  method.kind = "set";
                }
              }
              if (!method.key) { this.parsePropertyName(method); }
              var key = method.key;
              var allowsDirectSuper = false;
              if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
                  key.type === "Literal" && key.value === "constructor")) {
                if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
                if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
                if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
                method.kind = "constructor";
                allowsDirectSuper = constructorAllowsSuper;
              } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
                this.raise(key.start, "Classes may not have a static property named prototype");
              }
              this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
              if (method.kind === "get" && method.value.params.length !== 0)
                { this.raiseRecoverable(method.value.start, "getter should have no params"); }
              if (method.kind === "set" && method.value.params.length !== 1)
                { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
              if (method.kind === "set" && method.value.params[0].type === "RestElement")
                { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
              return method
            };

            pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
              method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
              return this.finishNode(method, "MethodDefinition")
            };

            pp$1.parseClassId = function(node, isStatement) {
              if (this.type === types.name) {
                node.id = this.parseIdent();
                if (isStatement)
                  { this.checkLVal(node.id, BIND_LEXICAL, false); }
              } else {
                if (isStatement === true)
                  { this.unexpected(); }
                node.id = null;
              }
            };

            pp$1.parseClassSuper = function(node) {
              node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
            };

            // Parses module export declaration.

            pp$1.parseExport = function(node, exports) {
              this.next();
              // export * from '...'
              if (this.eat(types.star)) {
                if (this.options.ecmaVersion >= 11) {
                  if (this.eatContextual("as")) {
                    node.exported = this.parseIdent(true);
                    this.checkExport(exports, node.exported.name, this.lastTokStart);
                  } else {
                    node.exported = null;
                  }
                }
                this.expectContextual("from");
                if (this.type !== types.string) { this.unexpected(); }
                node.source = this.parseExprAtom();
                this.semicolon();
                return this.finishNode(node, "ExportAllDeclaration")
              }
              if (this.eat(types._default)) { // export default ...
                this.checkExport(exports, "default", this.lastTokStart);
                var isAsync;
                if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
                  var fNode = this.startNode();
                  this.next();
                  if (isAsync) { this.next(); }
                  node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
                } else if (this.type === types._class) {
                  var cNode = this.startNode();
                  node.declaration = this.parseClass(cNode, "nullableID");
                } else {
                  node.declaration = this.parseMaybeAssign();
                  this.semicolon();
                }
                return this.finishNode(node, "ExportDefaultDeclaration")
              }
              // export var|const|let|function|class ...
              if (this.shouldParseExportStatement()) {
                node.declaration = this.parseStatement(null);
                if (node.declaration.type === "VariableDeclaration")
                  { this.checkVariableExport(exports, node.declaration.declarations); }
                else
                  { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
                node.specifiers = [];
                node.source = null;
              } else { // export { x, y as z } [from '...']
                node.declaration = null;
                node.specifiers = this.parseExportSpecifiers(exports);
                if (this.eatContextual("from")) {
                  if (this.type !== types.string) { this.unexpected(); }
                  node.source = this.parseExprAtom();
                } else {
                  for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
                    // check for keywords used as local names
                    var spec = list[i];

                    this.checkUnreserved(spec.local);
                    // check if export is defined
                    this.checkLocalExport(spec.local);
                  }

                  node.source = null;
                }
                this.semicolon();
              }
              return this.finishNode(node, "ExportNamedDeclaration")
            };

            pp$1.checkExport = function(exports, name, pos) {
              if (!exports) { return }
              if (has(exports, name))
                { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
              exports[name] = true;
            };

            pp$1.checkPatternExport = function(exports, pat) {
              var type = pat.type;
              if (type === "Identifier")
                { this.checkExport(exports, pat.name, pat.start); }
              else if (type === "ObjectPattern")
                { for (var i = 0, list = pat.properties; i < list.length; i += 1)
                  {
                    var prop = list[i];

                    this.checkPatternExport(exports, prop);
                  } }
              else if (type === "ArrayPattern")
                { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
                  var elt = list$1[i$1];

                    if (elt) { this.checkPatternExport(exports, elt); }
                } }
              else if (type === "Property")
                { this.checkPatternExport(exports, pat.value); }
              else if (type === "AssignmentPattern")
                { this.checkPatternExport(exports, pat.left); }
              else if (type === "RestElement")
                { this.checkPatternExport(exports, pat.argument); }
              else if (type === "ParenthesizedExpression")
                { this.checkPatternExport(exports, pat.expression); }
            };

            pp$1.checkVariableExport = function(exports, decls) {
              if (!exports) { return }
              for (var i = 0, list = decls; i < list.length; i += 1)
                {
                var decl = list[i];

                this.checkPatternExport(exports, decl.id);
              }
            };

            pp$1.shouldParseExportStatement = function() {
              return this.type.keyword === "var" ||
                this.type.keyword === "const" ||
                this.type.keyword === "class" ||
                this.type.keyword === "function" ||
                this.isLet() ||
                this.isAsyncFunction()
            };

            // Parses a comma-separated list of module exports.

            pp$1.parseExportSpecifiers = function(exports) {
              var nodes = [], first = true;
              // export { x, y as z } [from '...']
              this.expect(types.braceL);
              while (!this.eat(types.braceR)) {
                if (!first) {
                  this.expect(types.comma);
                  if (this.afterTrailingComma(types.braceR)) { break }
                } else { first = false; }

                var node = this.startNode();
                node.local = this.parseIdent(true);
                node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
                this.checkExport(exports, node.exported.name, node.exported.start);
                nodes.push(this.finishNode(node, "ExportSpecifier"));
              }
              return nodes
            };

            // Parses import declaration.

            pp$1.parseImport = function(node) {
              this.next();
              // import '...'
              if (this.type === types.string) {
                node.specifiers = empty$1;
                node.source = this.parseExprAtom();
              } else {
                node.specifiers = this.parseImportSpecifiers();
                this.expectContextual("from");
                node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
              }
              this.semicolon();
              return this.finishNode(node, "ImportDeclaration")
            };

            // Parses a comma-separated list of module imports.

            pp$1.parseImportSpecifiers = function() {
              var nodes = [], first = true;
              if (this.type === types.name) {
                // import defaultObj, { x, y as z } from '...'
                var node = this.startNode();
                node.local = this.parseIdent();
                this.checkLVal(node.local, BIND_LEXICAL);
                nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
                if (!this.eat(types.comma)) { return nodes }
              }
              if (this.type === types.star) {
                var node$1 = this.startNode();
                this.next();
                this.expectContextual("as");
                node$1.local = this.parseIdent();
                this.checkLVal(node$1.local, BIND_LEXICAL);
                nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
                return nodes
              }
              this.expect(types.braceL);
              while (!this.eat(types.braceR)) {
                if (!first) {
                  this.expect(types.comma);
                  if (this.afterTrailingComma(types.braceR)) { break }
                } else { first = false; }

                var node$2 = this.startNode();
                node$2.imported = this.parseIdent(true);
                if (this.eatContextual("as")) {
                  node$2.local = this.parseIdent();
                } else {
                  this.checkUnreserved(node$2.imported);
                  node$2.local = node$2.imported;
                }
                this.checkLVal(node$2.local, BIND_LEXICAL);
                nodes.push(this.finishNode(node$2, "ImportSpecifier"));
              }
              return nodes
            };

            // Set `ExpressionStatement#directive` property for directive prologues.
            pp$1.adaptDirectivePrologue = function(statements) {
              for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
                statements[i].directive = statements[i].expression.raw.slice(1, -1);
              }
            };
            pp$1.isDirectiveCandidate = function(statement) {
              return (
                statement.type === "ExpressionStatement" &&
                statement.expression.type === "Literal" &&
                typeof statement.expression.value === "string" &&
                // Reject parenthesized strings.
                (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
              )
            };

            var pp$2 = Parser.prototype;

            // Convert existing expression atom to assignable pattern
            // if possible.

            pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
              if (this.options.ecmaVersion >= 6 && node) {
                switch (node.type) {
                case "Identifier":
                  if (this.inAsync && node.name === "await")
                    { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
                  break

                case "ObjectPattern":
                case "ArrayPattern":
                case "RestElement":
                  break

                case "ObjectExpression":
                  node.type = "ObjectPattern";
                  if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
                  for (var i = 0, list = node.properties; i < list.length; i += 1) {
                    var prop = list[i];

                  this.toAssignable(prop, isBinding);
                    // Early error:
                    //   AssignmentRestProperty[Yield, Await] :
                    //     `...` DestructuringAssignmentTarget[Yield, Await]
                    //
                    //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
                    if (
                      prop.type === "RestElement" &&
                      (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
                    ) {
                      this.raise(prop.argument.start, "Unexpected token");
                    }
                  }
                  break

                case "Property":
                  // AssignmentProperty has type === "Property"
                  if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
                  this.toAssignable(node.value, isBinding);
                  break

                case "ArrayExpression":
                  node.type = "ArrayPattern";
                  if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
                  this.toAssignableList(node.elements, isBinding);
                  break

                case "SpreadElement":
                  node.type = "RestElement";
                  this.toAssignable(node.argument, isBinding);
                  if (node.argument.type === "AssignmentPattern")
                    { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
                  break

                case "AssignmentExpression":
                  if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
                  node.type = "AssignmentPattern";
                  delete node.operator;
                  this.toAssignable(node.left, isBinding);
                  // falls through to AssignmentPattern

                case "AssignmentPattern":
                  break

                case "ParenthesizedExpression":
                  this.toAssignable(node.expression, isBinding, refDestructuringErrors);
                  break

                case "ChainExpression":
                  this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
                  break

                case "MemberExpression":
                  if (!isBinding) { break }

                default:
                  this.raise(node.start, "Assigning to rvalue");
                }
              } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
              return node
            };

            // Convert list of expression atoms to binding list.

            pp$2.toAssignableList = function(exprList, isBinding) {
              var end = exprList.length;
              for (var i = 0; i < end; i++) {
                var elt = exprList[i];
                if (elt) { this.toAssignable(elt, isBinding); }
              }
              if (end) {
                var last = exprList[end - 1];
                if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
                  { this.unexpected(last.argument.start); }
              }
              return exprList
            };

            // Parses spread element.

            pp$2.parseSpread = function(refDestructuringErrors) {
              var node = this.startNode();
              this.next();
              node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
              return this.finishNode(node, "SpreadElement")
            };

            pp$2.parseRestBinding = function() {
              var node = this.startNode();
              this.next();

              // RestElement inside of a function parameter must be an identifier
              if (this.options.ecmaVersion === 6 && this.type !== types.name)
                { this.unexpected(); }

              node.argument = this.parseBindingAtom();

              return this.finishNode(node, "RestElement")
            };

            // Parses lvalue (assignable) atom.

            pp$2.parseBindingAtom = function() {
              if (this.options.ecmaVersion >= 6) {
                switch (this.type) {
                case types.bracketL:
                  var node = this.startNode();
                  this.next();
                  node.elements = this.parseBindingList(types.bracketR, true, true);
                  return this.finishNode(node, "ArrayPattern")

                case types.braceL:
                  return this.parseObj(true)
                }
              }
              return this.parseIdent()
            };

            pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
              var elts = [], first = true;
              while (!this.eat(close)) {
                if (first) { first = false; }
                else { this.expect(types.comma); }
                if (allowEmpty && this.type === types.comma) {
                  elts.push(null);
                } else if (allowTrailingComma && this.afterTrailingComma(close)) {
                  break
                } else if (this.type === types.ellipsis) {
                  var rest = this.parseRestBinding();
                  this.parseBindingListItem(rest);
                  elts.push(rest);
                  if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
                  this.expect(close);
                  break
                } else {
                  var elem = this.parseMaybeDefault(this.start, this.startLoc);
                  this.parseBindingListItem(elem);
                  elts.push(elem);
                }
              }
              return elts
            };

            pp$2.parseBindingListItem = function(param) {
              return param
            };

            // Parses assignment pattern around given atom if possible.

            pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
              left = left || this.parseBindingAtom();
              if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
              var node = this.startNodeAt(startPos, startLoc);
              node.left = left;
              node.right = this.parseMaybeAssign();
              return this.finishNode(node, "AssignmentPattern")
            };

            // Verify that a node is an lval — something that can be assigned
            // to.
            // bindingType can be either:
            // 'var' indicating that the lval creates a 'var' binding
            // 'let' indicating that the lval creates a lexical ('let' or 'const') binding
            // 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

            pp$2.checkLVal = function(expr, bindingType, checkClashes) {
              if ( bindingType === void 0 ) bindingType = BIND_NONE;

              switch (expr.type) {
              case "Identifier":
                if (bindingType === BIND_LEXICAL && expr.name === "let")
                  { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
                if (this.strict && this.reservedWordsStrictBind.test(expr.name))
                  { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
                if (checkClashes) {
                  if (has(checkClashes, expr.name))
                    { this.raiseRecoverable(expr.start, "Argument name clash"); }
                  checkClashes[expr.name] = true;
                }
                if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
                break

              case "ChainExpression":
                this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
                break

              case "MemberExpression":
                if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
                break

              case "ObjectPattern":
                for (var i = 0, list = expr.properties; i < list.length; i += 1)
                  {
                var prop = list[i];

                this.checkLVal(prop, bindingType, checkClashes);
              }
                break

              case "Property":
                // AssignmentProperty has type === "Property"
                this.checkLVal(expr.value, bindingType, checkClashes);
                break

              case "ArrayPattern":
                for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
                  var elem = list$1[i$1];

                if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
                }
                break

              case "AssignmentPattern":
                this.checkLVal(expr.left, bindingType, checkClashes);
                break

              case "RestElement":
                this.checkLVal(expr.argument, bindingType, checkClashes);
                break

              case "ParenthesizedExpression":
                this.checkLVal(expr.expression, bindingType, checkClashes);
                break

              default:
                this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
              }
            };

            // A recursive descent parser operates by defining functions for all

            var pp$3 = Parser.prototype;

            // Check if property name clashes with already added.
            // Object/class getters and setters are not allowed to clash —
            // either with each other or with an init property — and in
            // strict mode, init properties are also not allowed to be repeated.

            pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
              if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
                { return }
              if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
                { return }
              var key = prop.key;
              var name;
              switch (key.type) {
              case "Identifier": name = key.name; break
              case "Literal": name = String(key.value); break
              default: return
              }
              var kind = prop.kind;
              if (this.options.ecmaVersion >= 6) {
                if (name === "__proto__" && kind === "init") {
                  if (propHash.proto) {
                    if (refDestructuringErrors) {
                      if (refDestructuringErrors.doubleProto < 0)
                        { refDestructuringErrors.doubleProto = key.start; }
                      // Backwards-compat kludge. Can be removed in version 6.0
                    } else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
                  }
                  propHash.proto = true;
                }
                return
              }
              name = "$" + name;
              var other = propHash[name];
              if (other) {
                var redefinition;
                if (kind === "init") {
                  redefinition = this.strict && other.init || other.get || other.set;
                } else {
                  redefinition = other.init || other[kind];
                }
                if (redefinition)
                  { this.raiseRecoverable(key.start, "Redefinition of property"); }
              } else {
                other = propHash[name] = {
                  init: false,
                  get: false,
                  set: false
                };
              }
              other[kind] = true;
            };

            // ### Expression parsing

            // These nest, from the most general expression type at the top to
            // 'atomic', nondivisible expression types at the bottom. Most of
            // the functions will simply let the function(s) below them parse,
            // and, *if* the syntactic construct they handle is present, wrap
            // the AST node that the inner parser gave them in another node.

            // Parse a full expression. The optional arguments are used to
            // forbid the `in` operator (in for loops initalization expressions)
            // and provide reference for storing '=' operator inside shorthand
            // property assignment in contexts where both object expression
            // and object pattern might appear (so it's possible to raise
            // delayed syntax error at correct position).

            pp$3.parseExpression = function(noIn, refDestructuringErrors) {
              var startPos = this.start, startLoc = this.startLoc;
              var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
              if (this.type === types.comma) {
                var node = this.startNodeAt(startPos, startLoc);
                node.expressions = [expr];
                while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
                return this.finishNode(node, "SequenceExpression")
              }
              return expr
            };

            // Parse an assignment expression. This includes applications of
            // operators like `+=`.

            pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
              if (this.isContextual("yield")) {
                if (this.inGenerator) { return this.parseYield(noIn) }
                // The tokenizer will assume an expression is allowed after
                // `yield`, but this isn't that kind of yield
                else { this.exprAllowed = false; }
              }

              var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
              if (refDestructuringErrors) {
                oldParenAssign = refDestructuringErrors.parenthesizedAssign;
                oldTrailingComma = refDestructuringErrors.trailingComma;
                refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
              } else {
                refDestructuringErrors = new DestructuringErrors;
                ownDestructuringErrors = true;
              }

              var startPos = this.start, startLoc = this.startLoc;
              if (this.type === types.parenL || this.type === types.name)
                { this.potentialArrowAt = this.start; }
              var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
              if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
              if (this.type.isAssign) {
                var node = this.startNodeAt(startPos, startLoc);
                node.operator = this.value;
                node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
                if (!ownDestructuringErrors) {
                  refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
                }
                if (refDestructuringErrors.shorthandAssign >= node.left.start)
                  { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
                this.checkLVal(left);
                this.next();
                node.right = this.parseMaybeAssign(noIn);
                return this.finishNode(node, "AssignmentExpression")
              } else {
                if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
              }
              if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
              if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
              return left
            };

            // Parse a ternary conditional (`?:`) operator.

            pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
              var startPos = this.start, startLoc = this.startLoc;
              var expr = this.parseExprOps(noIn, refDestructuringErrors);
              if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
              if (this.eat(types.question)) {
                var node = this.startNodeAt(startPos, startLoc);
                node.test = expr;
                node.consequent = this.parseMaybeAssign();
                this.expect(types.colon);
                node.alternate = this.parseMaybeAssign(noIn);
                return this.finishNode(node, "ConditionalExpression")
              }
              return expr
            };

            // Start the precedence parser.

            pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
              var startPos = this.start, startLoc = this.startLoc;
              var expr = this.parseMaybeUnary(refDestructuringErrors, false);
              if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
              return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
            };

            // Parse binary operators with the operator precedence parsing
            // algorithm. `left` is the left-hand side of the operator.
            // `minPrec` provides context that allows the function to stop and
            // defer further parser to one of its callers when it encounters an
            // operator that has a lower precedence than the set it is parsing.

            pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
              var prec = this.type.binop;
              if (prec != null && (!noIn || this.type !== types._in)) {
                if (prec > minPrec) {
                  var logical = this.type === types.logicalOR || this.type === types.logicalAND;
                  var coalesce = this.type === types.coalesce;
                  if (coalesce) {
                    // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
                    // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
                    prec = types.logicalAND.binop;
                  }
                  var op = this.value;
                  this.next();
                  var startPos = this.start, startLoc = this.startLoc;
                  var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
                  var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
                  if ((logical && this.type === types.coalesce) || (coalesce && (this.type === types.logicalOR || this.type === types.logicalAND))) {
                    this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
                  }
                  return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
                }
              }
              return left
            };

            pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
              var node = this.startNodeAt(startPos, startLoc);
              node.left = left;
              node.operator = op;
              node.right = right;
              return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
            };

            // Parse unary operators, both prefix and postfix.

            pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
              var startPos = this.start, startLoc = this.startLoc, expr;
              if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
                expr = this.parseAwait();
                sawUnary = true;
              } else if (this.type.prefix) {
                var node = this.startNode(), update = this.type === types.incDec;
                node.operator = this.value;
                node.prefix = true;
                this.next();
                node.argument = this.parseMaybeUnary(null, true);
                this.checkExpressionErrors(refDestructuringErrors, true);
                if (update) { this.checkLVal(node.argument); }
                else if (this.strict && node.operator === "delete" &&
                         node.argument.type === "Identifier")
                  { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
                else { sawUnary = true; }
                expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
              } else {
                expr = this.parseExprSubscripts(refDestructuringErrors);
                if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
                while (this.type.postfix && !this.canInsertSemicolon()) {
                  var node$1 = this.startNodeAt(startPos, startLoc);
                  node$1.operator = this.value;
                  node$1.prefix = false;
                  node$1.argument = expr;
                  this.checkLVal(expr);
                  this.next();
                  expr = this.finishNode(node$1, "UpdateExpression");
                }
              }

              if (!sawUnary && this.eat(types.starstar))
                { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
              else
                { return expr }
            };

            // Parse call, dot, and `[]`-subscript expressions.

            pp$3.parseExprSubscripts = function(refDestructuringErrors) {
              var startPos = this.start, startLoc = this.startLoc;
              var expr = this.parseExprAtom(refDestructuringErrors);
              if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
                { return expr }
              var result = this.parseSubscripts(expr, startPos, startLoc);
              if (refDestructuringErrors && result.type === "MemberExpression") {
                if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
                if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
              }
              return result
            };

            pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
              var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
                  this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
                  this.potentialArrowAt === base.start;
              var optionalChained = false;

              while (true) {
                var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);

                if (element.optional) { optionalChained = true; }
                if (element === base || element.type === "ArrowFunctionExpression") {
                  if (optionalChained) {
                    var chainNode = this.startNodeAt(startPos, startLoc);
                    chainNode.expression = element;
                    element = this.finishNode(chainNode, "ChainExpression");
                  }
                  return element
                }

                base = element;
              }
            };

            pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {
              var optionalSupported = this.options.ecmaVersion >= 11;
              var optional = optionalSupported && this.eat(types.questionDot);
              if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

              var computed = this.eat(types.bracketL);
              if (computed || (optional && this.type !== types.parenL && this.type !== types.backQuote) || this.eat(types.dot)) {
                var node = this.startNodeAt(startPos, startLoc);
                node.object = base;
                node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
                node.computed = !!computed;
                if (computed) { this.expect(types.bracketR); }
                if (optionalSupported) {
                  node.optional = optional;
                }
                base = this.finishNode(node, "MemberExpression");
              } else if (!noCalls && this.eat(types.parenL)) {
                var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
                this.yieldPos = 0;
                this.awaitPos = 0;
                this.awaitIdentPos = 0;
                var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
                if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {
                  this.checkPatternErrors(refDestructuringErrors, false);
                  this.checkYieldAwaitInDefaultParams();
                  if (this.awaitIdentPos > 0)
                    { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
                  this.yieldPos = oldYieldPos;
                  this.awaitPos = oldAwaitPos;
                  this.awaitIdentPos = oldAwaitIdentPos;
                  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
                }
                this.checkExpressionErrors(refDestructuringErrors, true);
                this.yieldPos = oldYieldPos || this.yieldPos;
                this.awaitPos = oldAwaitPos || this.awaitPos;
                this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
                var node$1 = this.startNodeAt(startPos, startLoc);
                node$1.callee = base;
                node$1.arguments = exprList;
                if (optionalSupported) {
                  node$1.optional = optional;
                }
                base = this.finishNode(node$1, "CallExpression");
              } else if (this.type === types.backQuote) {
                if (optional || optionalChained) {
                  this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
                }
                var node$2 = this.startNodeAt(startPos, startLoc);
                node$2.tag = base;
                node$2.quasi = this.parseTemplate({isTagged: true});
                base = this.finishNode(node$2, "TaggedTemplateExpression");
              }
              return base
            };

            // Parse an atomic expression — either a single token that is an
            // expression, an expression started by a keyword like `function` or
            // `new`, or an expression wrapped in punctuation like `()`, `[]`,
            // or `{}`.

            pp$3.parseExprAtom = function(refDestructuringErrors) {
              // If a division operator appears in an expression position, the
              // tokenizer got confused, and we force it to read a regexp instead.
              if (this.type === types.slash) { this.readRegexp(); }

              var node, canBeArrow = this.potentialArrowAt === this.start;
              switch (this.type) {
              case types._super:
                if (!this.allowSuper)
                  { this.raise(this.start, "'super' keyword outside a method"); }
                node = this.startNode();
                this.next();
                if (this.type === types.parenL && !this.allowDirectSuper)
                  { this.raise(node.start, "super() call outside constructor of a subclass"); }
                // The `super` keyword can appear at below:
                // SuperProperty:
                //     super [ Expression ]
                //     super . IdentifierName
                // SuperCall:
                //     super ( Arguments )
                if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
                  { this.unexpected(); }
                return this.finishNode(node, "Super")

              case types._this:
                node = this.startNode();
                this.next();
                return this.finishNode(node, "ThisExpression")

              case types.name:
                var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
                var id = this.parseIdent(false);
                if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
                  { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
                if (canBeArrow && !this.canInsertSemicolon()) {
                  if (this.eat(types.arrow))
                    { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
                  if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
                    id = this.parseIdent(false);
                    if (this.canInsertSemicolon() || !this.eat(types.arrow))
                      { this.unexpected(); }
                    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
                  }
                }
                return id

              case types.regexp:
                var value = this.value;
                node = this.parseLiteral(value.value);
                node.regex = {pattern: value.pattern, flags: value.flags};
                return node

              case types.num: case types.string:
                return this.parseLiteral(this.value)

              case types._null: case types._true: case types._false:
                node = this.startNode();
                node.value = this.type === types._null ? null : this.type === types._true;
                node.raw = this.type.keyword;
                this.next();
                return this.finishNode(node, "Literal")

              case types.parenL:
                var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
                if (refDestructuringErrors) {
                  if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
                    { refDestructuringErrors.parenthesizedAssign = start; }
                  if (refDestructuringErrors.parenthesizedBind < 0)
                    { refDestructuringErrors.parenthesizedBind = start; }
                }
                return expr

              case types.bracketL:
                node = this.startNode();
                this.next();
                node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
                return this.finishNode(node, "ArrayExpression")

              case types.braceL:
                return this.parseObj(false, refDestructuringErrors)

              case types._function:
                node = this.startNode();
                this.next();
                return this.parseFunction(node, 0)

              case types._class:
                return this.parseClass(this.startNode(), false)

              case types._new:
                return this.parseNew()

              case types.backQuote:
                return this.parseTemplate()

              case types._import:
                if (this.options.ecmaVersion >= 11) {
                  return this.parseExprImport()
                } else {
                  return this.unexpected()
                }

              default:
                this.unexpected();
              }
            };

            pp$3.parseExprImport = function() {
              var node = this.startNode();

              // Consume `import` as an identifier for `import.meta`.
              // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
              if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
              var meta = this.parseIdent(true);

              switch (this.type) {
              case types.parenL:
                return this.parseDynamicImport(node)
              case types.dot:
                node.meta = meta;
                return this.parseImportMeta(node)
              default:
                this.unexpected();
              }
            };

            pp$3.parseDynamicImport = function(node) {
              this.next(); // skip `(`

              // Parse node.source.
              node.source = this.parseMaybeAssign();

              // Verify ending.
              if (!this.eat(types.parenR)) {
                var errorPos = this.start;
                if (this.eat(types.comma) && this.eat(types.parenR)) {
                  this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
                } else {
                  this.unexpected(errorPos);
                }
              }

              return this.finishNode(node, "ImportExpression")
            };

            pp$3.parseImportMeta = function(node) {
              this.next(); // skip `.`

              var containsEsc = this.containsEsc;
              node.property = this.parseIdent(true);

              if (node.property.name !== "meta")
                { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
              if (containsEsc)
                { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
              if (this.options.sourceType !== "module")
                { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

              return this.finishNode(node, "MetaProperty")
            };

            pp$3.parseLiteral = function(value) {
              var node = this.startNode();
              node.value = value;
              node.raw = this.input.slice(this.start, this.end);
              if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }
              this.next();
              return this.finishNode(node, "Literal")
            };

            pp$3.parseParenExpression = function() {
              this.expect(types.parenL);
              var val = this.parseExpression();
              this.expect(types.parenR);
              return val
            };

            pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
              var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
              if (this.options.ecmaVersion >= 6) {
                this.next();

                var innerStartPos = this.start, innerStartLoc = this.startLoc;
                var exprList = [], first = true, lastIsComma = false;
                var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
                this.yieldPos = 0;
                this.awaitPos = 0;
                // Do not save awaitIdentPos to allow checking awaits nested in parameters
                while (this.type !== types.parenR) {
                  first ? first = false : this.expect(types.comma);
                  if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
                    lastIsComma = true;
                    break
                  } else if (this.type === types.ellipsis) {
                    spreadStart = this.start;
                    exprList.push(this.parseParenItem(this.parseRestBinding()));
                    if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
                    break
                  } else {
                    exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
                  }
                }
                var innerEndPos = this.start, innerEndLoc = this.startLoc;
                this.expect(types.parenR);

                if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
                  this.checkPatternErrors(refDestructuringErrors, false);
                  this.checkYieldAwaitInDefaultParams();
                  this.yieldPos = oldYieldPos;
                  this.awaitPos = oldAwaitPos;
                  return this.parseParenArrowList(startPos, startLoc, exprList)
                }

                if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
                if (spreadStart) { this.unexpected(spreadStart); }
                this.checkExpressionErrors(refDestructuringErrors, true);
                this.yieldPos = oldYieldPos || this.yieldPos;
                this.awaitPos = oldAwaitPos || this.awaitPos;

                if (exprList.length > 1) {
                  val = this.startNodeAt(innerStartPos, innerStartLoc);
                  val.expressions = exprList;
                  this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
                } else {
                  val = exprList[0];
                }
              } else {
                val = this.parseParenExpression();
              }

              if (this.options.preserveParens) {
                var par = this.startNodeAt(startPos, startLoc);
                par.expression = val;
                return this.finishNode(par, "ParenthesizedExpression")
              } else {
                return val
              }
            };

            pp$3.parseParenItem = function(item) {
              return item
            };

            pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
            };

            // New's precedence is slightly tricky. It must allow its argument to
            // be a `[]` or dot subscript expression, but not a call — at least,
            // not without wrapping it in parentheses. Thus, it uses the noCalls
            // argument to parseSubscripts to prevent it from consuming the
            // argument list.

            var empty$1$1 = [];

            pp$3.parseNew = function() {
              if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
              var node = this.startNode();
              var meta = this.parseIdent(true);
              if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
                node.meta = meta;
                var containsEsc = this.containsEsc;
                node.property = this.parseIdent(true);
                if (node.property.name !== "target")
                  { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
                if (containsEsc)
                  { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
                if (!this.inNonArrowFunction())
                  { this.raiseRecoverable(node.start, "'new.target' can only be used in functions"); }
                return this.finishNode(node, "MetaProperty")
              }
              var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
              node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
              if (isImport && node.callee.type === "ImportExpression") {
                this.raise(startPos, "Cannot use new with import()");
              }
              if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
              else { node.arguments = empty$1$1; }
              return this.finishNode(node, "NewExpression")
            };

            // Parse template expression.

            pp$3.parseTemplateElement = function(ref) {
              var isTagged = ref.isTagged;

              var elem = this.startNode();
              if (this.type === types.invalidTemplate) {
                if (!isTagged) {
                  this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
                }
                elem.value = {
                  raw: this.value,
                  cooked: null
                };
              } else {
                elem.value = {
                  raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
                  cooked: this.value
                };
              }
              this.next();
              elem.tail = this.type === types.backQuote;
              return this.finishNode(elem, "TemplateElement")
            };

            pp$3.parseTemplate = function(ref) {
              if ( ref === void 0 ) ref = {};
              var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

              var node = this.startNode();
              this.next();
              node.expressions = [];
              var curElt = this.parseTemplateElement({isTagged: isTagged});
              node.quasis = [curElt];
              while (!curElt.tail) {
                if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
                this.expect(types.dollarBraceL);
                node.expressions.push(this.parseExpression());
                this.expect(types.braceR);
                node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
              }
              this.next();
              return this.finishNode(node, "TemplateLiteral")
            };

            pp$3.isAsyncProp = function(prop) {
              return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
                (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
                !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
            };

            // Parse an object literal or binding pattern.

            pp$3.parseObj = function(isPattern, refDestructuringErrors) {
              var node = this.startNode(), first = true, propHash = {};
              node.properties = [];
              this.next();
              while (!this.eat(types.braceR)) {
                if (!first) {
                  this.expect(types.comma);
                  if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }
                } else { first = false; }

                var prop = this.parseProperty(isPattern, refDestructuringErrors);
                if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
                node.properties.push(prop);
              }
              return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
            };

            pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
              var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
              if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
                if (isPattern) {
                  prop.argument = this.parseIdent(false);
                  if (this.type === types.comma) {
                    this.raise(this.start, "Comma is not permitted after the rest element");
                  }
                  return this.finishNode(prop, "RestElement")
                }
                // To disallow parenthesized identifier via `this.toAssignable()`.
                if (this.type === types.parenL && refDestructuringErrors) {
                  if (refDestructuringErrors.parenthesizedAssign < 0) {
                    refDestructuringErrors.parenthesizedAssign = this.start;
                  }
                  if (refDestructuringErrors.parenthesizedBind < 0) {
                    refDestructuringErrors.parenthesizedBind = this.start;
                  }
                }
                // Parse argument.
                prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
                // To disallow trailing comma via `this.toAssignable()`.
                if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
                  refDestructuringErrors.trailingComma = this.start;
                }
                // Finish
                return this.finishNode(prop, "SpreadElement")
              }
              if (this.options.ecmaVersion >= 6) {
                prop.method = false;
                prop.shorthand = false;
                if (isPattern || refDestructuringErrors) {
                  startPos = this.start;
                  startLoc = this.startLoc;
                }
                if (!isPattern)
                  { isGenerator = this.eat(types.star); }
              }
              var containsEsc = this.containsEsc;
              this.parsePropertyName(prop);
              if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
                isAsync = true;
                isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
                this.parsePropertyName(prop, refDestructuringErrors);
              } else {
                isAsync = false;
              }
              this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
              return this.finishNode(prop, "Property")
            };

            pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
              if ((isGenerator || isAsync) && this.type === types.colon)
                { this.unexpected(); }

              if (this.eat(types.colon)) {
                prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
                prop.kind = "init";
              } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
                if (isPattern) { this.unexpected(); }
                prop.kind = "init";
                prop.method = true;
                prop.value = this.parseMethod(isGenerator, isAsync);
              } else if (!isPattern && !containsEsc &&
                         this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
                         (prop.key.name === "get" || prop.key.name === "set") &&
                         (this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq)) {
                if (isGenerator || isAsync) { this.unexpected(); }
                prop.kind = prop.key.name;
                this.parsePropertyName(prop);
                prop.value = this.parseMethod(false);
                var paramCount = prop.kind === "get" ? 0 : 1;
                if (prop.value.params.length !== paramCount) {
                  var start = prop.value.start;
                  if (prop.kind === "get")
                    { this.raiseRecoverable(start, "getter should have no params"); }
                  else
                    { this.raiseRecoverable(start, "setter should have exactly one param"); }
                } else {
                  if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
                    { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
                }
              } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
                if (isGenerator || isAsync) { this.unexpected(); }
                this.checkUnreserved(prop.key);
                if (prop.key.name === "await" && !this.awaitIdentPos)
                  { this.awaitIdentPos = startPos; }
                prop.kind = "init";
                if (isPattern) {
                  prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
                } else if (this.type === types.eq && refDestructuringErrors) {
                  if (refDestructuringErrors.shorthandAssign < 0)
                    { refDestructuringErrors.shorthandAssign = this.start; }
                  prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
                } else {
                  prop.value = prop.key;
                }
                prop.shorthand = true;
              } else { this.unexpected(); }
            };

            pp$3.parsePropertyName = function(prop) {
              if (this.options.ecmaVersion >= 6) {
                if (this.eat(types.bracketL)) {
                  prop.computed = true;
                  prop.key = this.parseMaybeAssign();
                  this.expect(types.bracketR);
                  return prop.key
                } else {
                  prop.computed = false;
                }
              }
              return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
            };

            // Initialize empty function node.

            pp$3.initFunction = function(node) {
              node.id = null;
              if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
              if (this.options.ecmaVersion >= 8) { node.async = false; }
            };

            // Parse object or class method.

            pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
              var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

              this.initFunction(node);
              if (this.options.ecmaVersion >= 6)
                { node.generator = isGenerator; }
              if (this.options.ecmaVersion >= 8)
                { node.async = !!isAsync; }

              this.yieldPos = 0;
              this.awaitPos = 0;
              this.awaitIdentPos = 0;
              this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

              this.expect(types.parenL);
              node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
              this.checkYieldAwaitInDefaultParams();
              this.parseFunctionBody(node, false, true);

              this.yieldPos = oldYieldPos;
              this.awaitPos = oldAwaitPos;
              this.awaitIdentPos = oldAwaitIdentPos;
              return this.finishNode(node, "FunctionExpression")
            };

            // Parse arrow function expression with given parameters.

            pp$3.parseArrowExpression = function(node, params, isAsync) {
              var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

              this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
              this.initFunction(node);
              if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

              this.yieldPos = 0;
              this.awaitPos = 0;
              this.awaitIdentPos = 0;

              node.params = this.toAssignableList(params, true);
              this.parseFunctionBody(node, true, false);

              this.yieldPos = oldYieldPos;
              this.awaitPos = oldAwaitPos;
              this.awaitIdentPos = oldAwaitIdentPos;
              return this.finishNode(node, "ArrowFunctionExpression")
            };

            // Parse function body and check parameters.

            pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
              var isExpression = isArrowFunction && this.type !== types.braceL;
              var oldStrict = this.strict, useStrict = false;

              if (isExpression) {
                node.body = this.parseMaybeAssign();
                node.expression = true;
                this.checkParams(node, false);
              } else {
                var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
                if (!oldStrict || nonSimple) {
                  useStrict = this.strictDirective(this.end);
                  // If this is a strict mode function, verify that argument names
                  // are not repeated, and it does not try to bind the words `eval`
                  // or `arguments`.
                  if (useStrict && nonSimple)
                    { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
                }
                // Start a new scope with regard to labels and the `inFunction`
                // flag (restore them to their old value afterwards).
                var oldLabels = this.labels;
                this.labels = [];
                if (useStrict) { this.strict = true; }

                // Add the params to varDeclaredNames to ensure that an error is thrown
                // if a let/const declaration in the function clashes with one of the params.
                this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
                // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
                if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
                node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
                node.expression = false;
                this.adaptDirectivePrologue(node.body.body);
                this.labels = oldLabels;
              }
              this.exitScope();
            };

            pp$3.isSimpleParamList = function(params) {
              for (var i = 0, list = params; i < list.length; i += 1)
                {
                var param = list[i];

                if (param.type !== "Identifier") { return false
              } }
              return true
            };

            // Checks function params for various disallowed patterns such as using "eval"
            // or "arguments" and duplicate parameters.

            pp$3.checkParams = function(node, allowDuplicates) {
              var nameHash = {};
              for (var i = 0, list = node.params; i < list.length; i += 1)
                {
                var param = list[i];

                this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
              }
            };

            // Parses a comma-separated list of expressions, and returns them as
            // an array. `close` is the token type that ends the list, and
            // `allowEmpty` can be turned on to allow subsequent commas with
            // nothing in between them to be parsed as `null` (which is needed
            // for array literals).

            pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
              var elts = [], first = true;
              while (!this.eat(close)) {
                if (!first) {
                  this.expect(types.comma);
                  if (allowTrailingComma && this.afterTrailingComma(close)) { break }
                } else { first = false; }

                var elt = (void 0);
                if (allowEmpty && this.type === types.comma)
                  { elt = null; }
                else if (this.type === types.ellipsis) {
                  elt = this.parseSpread(refDestructuringErrors);
                  if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
                    { refDestructuringErrors.trailingComma = this.start; }
                } else {
                  elt = this.parseMaybeAssign(false, refDestructuringErrors);
                }
                elts.push(elt);
              }
              return elts
            };

            pp$3.checkUnreserved = function(ref) {
              var start = ref.start;
              var end = ref.end;
              var name = ref.name;

              if (this.inGenerator && name === "yield")
                { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
              if (this.inAsync && name === "await")
                { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
              if (this.keywords.test(name))
                { this.raise(start, ("Unexpected keyword '" + name + "'")); }
              if (this.options.ecmaVersion < 6 &&
                this.input.slice(start, end).indexOf("\\") !== -1) { return }
              var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
              if (re.test(name)) {
                if (!this.inAsync && name === "await")
                  { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
                this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
              }
            };

            // Parse the next token as an identifier. If `liberal` is true (used
            // when parsing properties), it will also convert keywords into
            // identifiers.

            pp$3.parseIdent = function(liberal, isBinding) {
              var node = this.startNode();
              if (this.type === types.name) {
                node.name = this.value;
              } else if (this.type.keyword) {
                node.name = this.type.keyword;

                // To fix https://github.com/acornjs/acorn/issues/575
                // `class` and `function` keywords push new context into this.context.
                // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
                // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
                if ((node.name === "class" || node.name === "function") &&
                    (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
                  this.context.pop();
                }
              } else {
                this.unexpected();
              }
              this.next(!!liberal);
              this.finishNode(node, "Identifier");
              if (!liberal) {
                this.checkUnreserved(node);
                if (node.name === "await" && !this.awaitIdentPos)
                  { this.awaitIdentPos = node.start; }
              }
              return node
            };

            // Parses yield expression inside generator.

            pp$3.parseYield = function(noIn) {
              if (!this.yieldPos) { this.yieldPos = this.start; }

              var node = this.startNode();
              this.next();
              if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
                node.delegate = false;
                node.argument = null;
              } else {
                node.delegate = this.eat(types.star);
                node.argument = this.parseMaybeAssign(noIn);
              }
              return this.finishNode(node, "YieldExpression")
            };

            pp$3.parseAwait = function() {
              if (!this.awaitPos) { this.awaitPos = this.start; }

              var node = this.startNode();
              this.next();
              node.argument = this.parseMaybeUnary(null, false);
              return this.finishNode(node, "AwaitExpression")
            };

            var pp$4 = Parser.prototype;

            // This function is used to raise exceptions on parse errors. It
            // takes an offset integer (into the current `input`) to indicate
            // the location of the error, attaches the position to the end
            // of the error message, and then raises a `SyntaxError` with that
            // message.

            pp$4.raise = function(pos, message) {
              var loc = getLineInfo(this.input, pos);
              message += " (" + loc.line + ":" + loc.column + ")";
              var err = new SyntaxError(message);
              err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
              throw err
            };

            pp$4.raiseRecoverable = pp$4.raise;

            pp$4.curPosition = function() {
              if (this.options.locations) {
                return new Position(this.curLine, this.pos - this.lineStart)
              }
            };

            var pp$5 = Parser.prototype;

            var Scope = function Scope(flags) {
              this.flags = flags;
              // A list of var-declared names in the current lexical scope
              this.var = [];
              // A list of lexically-declared names in the current lexical scope
              this.lexical = [];
              // A list of lexically-declared FunctionDeclaration names in the current lexical scope
              this.functions = [];
            };

            // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

            pp$5.enterScope = function(flags) {
              this.scopeStack.push(new Scope(flags));
            };

            pp$5.exitScope = function() {
              this.scopeStack.pop();
            };

            // The spec says:
            // > At the top level of a function, or script, function declarations are
            // > treated like var declarations rather than like lexical declarations.
            pp$5.treatFunctionsAsVarInScope = function(scope) {
              return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
            };

            pp$5.declareName = function(name, bindingType, pos) {
              var redeclared = false;
              if (bindingType === BIND_LEXICAL) {
                var scope = this.currentScope();
                redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
                scope.lexical.push(name);
                if (this.inModule && (scope.flags & SCOPE_TOP))
                  { delete this.undefinedExports[name]; }
              } else if (bindingType === BIND_SIMPLE_CATCH) {
                var scope$1 = this.currentScope();
                scope$1.lexical.push(name);
              } else if (bindingType === BIND_FUNCTION) {
                var scope$2 = this.currentScope();
                if (this.treatFunctionsAsVar)
                  { redeclared = scope$2.lexical.indexOf(name) > -1; }
                else
                  { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
                scope$2.functions.push(name);
              } else {
                for (var i = this.scopeStack.length - 1; i >= 0; --i) {
                  var scope$3 = this.scopeStack[i];
                  if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
                      !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
                    redeclared = true;
                    break
                  }
                  scope$3.var.push(name);
                  if (this.inModule && (scope$3.flags & SCOPE_TOP))
                    { delete this.undefinedExports[name]; }
                  if (scope$3.flags & SCOPE_VAR) { break }
                }
              }
              if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
            };

            pp$5.checkLocalExport = function(id) {
              // scope.functions must be empty as Module code is always strict.
              if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
                  this.scopeStack[0].var.indexOf(id.name) === -1) {
                this.undefinedExports[id.name] = id;
              }
            };

            pp$5.currentScope = function() {
              return this.scopeStack[this.scopeStack.length - 1]
            };

            pp$5.currentVarScope = function() {
              for (var i = this.scopeStack.length - 1;; i--) {
                var scope = this.scopeStack[i];
                if (scope.flags & SCOPE_VAR) { return scope }
              }
            };

            // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
            pp$5.currentThisScope = function() {
              for (var i = this.scopeStack.length - 1;; i--) {
                var scope = this.scopeStack[i];
                if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
              }
            };

            var Node$3 = function Node(parser, pos, loc) {
              this.type = "";
              this.start = pos;
              this.end = 0;
              if (parser.options.locations)
                { this.loc = new SourceLocation(parser, loc); }
              if (parser.options.directSourceFile)
                { this.sourceFile = parser.options.directSourceFile; }
              if (parser.options.ranges)
                { this.range = [pos, 0]; }
            };

            // Start an AST node, attaching a start offset.

            var pp$6 = Parser.prototype;

            pp$6.startNode = function() {
              return new Node$3(this, this.start, this.startLoc)
            };

            pp$6.startNodeAt = function(pos, loc) {
              return new Node$3(this, pos, loc)
            };

            // Finish an AST node, adding `type` and `end` properties.

            function finishNodeAt(node, type, pos, loc) {
              node.type = type;
              node.end = pos;
              if (this.options.locations)
                { node.loc.end = loc; }
              if (this.options.ranges)
                { node.range[1] = pos; }
              return node
            }

            pp$6.finishNode = function(node, type) {
              return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
            };

            // Finish node at given position

            pp$6.finishNodeAt = function(node, type, pos, loc) {
              return finishNodeAt.call(this, node, type, pos, loc)
            };

            // The algorithm used to determine whether a regexp can appear at a

            var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
              this.token = token;
              this.isExpr = !!isExpr;
              this.preserveSpace = !!preserveSpace;
              this.override = override;
              this.generator = !!generator;
            };

            var types$1 = {
              b_stat: new TokContext("{", false),
              b_expr: new TokContext("{", true),
              b_tmpl: new TokContext("${", false),
              p_stat: new TokContext("(", false),
              p_expr: new TokContext("(", true),
              q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
              f_stat: new TokContext("function", false),
              f_expr: new TokContext("function", true),
              f_expr_gen: new TokContext("function", true, false, null, true),
              f_gen: new TokContext("function", false, false, null, true)
            };

            var pp$7 = Parser.prototype;

            pp$7.initialContext = function() {
              return [types$1.b_stat]
            };

            pp$7.braceIsBlock = function(prevType) {
              var parent = this.curContext();
              if (parent === types$1.f_expr || parent === types$1.f_stat)
                { return true }
              if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
                { return !parent.isExpr }

              // The check for `tt.name && exprAllowed` detects whether we are
              // after a `yield` or `of` construct. See the `updateContext` for
              // `tt.name`.
              if (prevType === types._return || prevType === types.name && this.exprAllowed)
                { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
              if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
                { return true }
              if (prevType === types.braceL)
                { return parent === types$1.b_stat }
              if (prevType === types._var || prevType === types._const || prevType === types.name)
                { return false }
              return !this.exprAllowed
            };

            pp$7.inGeneratorContext = function() {
              for (var i = this.context.length - 1; i >= 1; i--) {
                var context = this.context[i];
                if (context.token === "function")
                  { return context.generator }
              }
              return false
            };

            pp$7.updateContext = function(prevType) {
              var update, type = this.type;
              if (type.keyword && prevType === types.dot)
                { this.exprAllowed = false; }
              else if (update = type.updateContext)
                { update.call(this, prevType); }
              else
                { this.exprAllowed = type.beforeExpr; }
            };

            // Token-specific context update code

            types.parenR.updateContext = types.braceR.updateContext = function() {
              if (this.context.length === 1) {
                this.exprAllowed = true;
                return
              }
              var out = this.context.pop();
              if (out === types$1.b_stat && this.curContext().token === "function") {
                out = this.context.pop();
              }
              this.exprAllowed = !out.isExpr;
            };

            types.braceL.updateContext = function(prevType) {
              this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
              this.exprAllowed = true;
            };

            types.dollarBraceL.updateContext = function() {
              this.context.push(types$1.b_tmpl);
              this.exprAllowed = true;
            };

            types.parenL.updateContext = function(prevType) {
              var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
              this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
              this.exprAllowed = true;
            };

            types.incDec.updateContext = function() {
              // tokExprAllowed stays unchanged
            };

            types._function.updateContext = types._class.updateContext = function(prevType) {
              if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
                  !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
                  !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
                { this.context.push(types$1.f_expr); }
              else
                { this.context.push(types$1.f_stat); }
              this.exprAllowed = false;
            };

            types.backQuote.updateContext = function() {
              if (this.curContext() === types$1.q_tmpl)
                { this.context.pop(); }
              else
                { this.context.push(types$1.q_tmpl); }
              this.exprAllowed = false;
            };

            types.star.updateContext = function(prevType) {
              if (prevType === types._function) {
                var index = this.context.length - 1;
                if (this.context[index] === types$1.f_expr)
                  { this.context[index] = types$1.f_expr_gen; }
                else
                  { this.context[index] = types$1.f_gen; }
              }
              this.exprAllowed = true;
            };

            types.name.updateContext = function(prevType) {
              var allowed = false;
              if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
                if (this.value === "of" && !this.exprAllowed ||
                    this.value === "yield" && this.inGeneratorContext())
                  { allowed = true; }
              }
              this.exprAllowed = allowed;
            };

            // This file contains Unicode properties extracted from the ECMAScript
            // specification. The lists are extracted like so:
            // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

            // #table-binary-unicode-properties
            var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
            var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
            var ecma11BinaryProperties = ecma10BinaryProperties;
            var unicodeBinaryProperties = {
              9: ecma9BinaryProperties,
              10: ecma10BinaryProperties,
              11: ecma11BinaryProperties
            };

            // #table-unicode-general-category-values
            var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

            // #table-unicode-script-values
            var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
            var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
            var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
            var unicodeScriptValues = {
              9: ecma9ScriptValues,
              10: ecma10ScriptValues,
              11: ecma11ScriptValues
            };

            var data = {};
            function buildUnicodeData(ecmaVersion) {
              var d = data[ecmaVersion] = {
                binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
                nonBinary: {
                  General_Category: wordsRegexp(unicodeGeneralCategoryValues),
                  Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
                }
              };
              d.nonBinary.Script_Extensions = d.nonBinary.Script;

              d.nonBinary.gc = d.nonBinary.General_Category;
              d.nonBinary.sc = d.nonBinary.Script;
              d.nonBinary.scx = d.nonBinary.Script_Extensions;
            }
            buildUnicodeData(9);
            buildUnicodeData(10);
            buildUnicodeData(11);

            var pp$8 = Parser.prototype;

            var RegExpValidationState = function RegExpValidationState(parser) {
              this.parser = parser;
              this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
              this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
              this.source = "";
              this.flags = "";
              this.start = 0;
              this.switchU = false;
              this.switchN = false;
              this.pos = 0;
              this.lastIntValue = 0;
              this.lastStringValue = "";
              this.lastAssertionIsQuantifiable = false;
              this.numCapturingParens = 0;
              this.maxBackReference = 0;
              this.groupNames = [];
              this.backReferenceNames = [];
            };

            RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
              var unicode = flags.indexOf("u") !== -1;
              this.start = start | 0;
              this.source = pattern + "";
              this.flags = flags;
              this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
              this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
            };

            RegExpValidationState.prototype.raise = function raise (message) {
              this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
            };

            // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
            // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
            RegExpValidationState.prototype.at = function at (i, forceU) {
                if ( forceU === void 0 ) forceU = false;

              var s = this.source;
              var l = s.length;
              if (i >= l) {
                return -1
              }
              var c = s.charCodeAt(i);
              if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
                return c
              }
              var next = s.charCodeAt(i + 1);
              return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
            };

            RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {
                if ( forceU === void 0 ) forceU = false;

              var s = this.source;
              var l = s.length;
              if (i >= l) {
                return l
              }
              var c = s.charCodeAt(i), next;
              if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
                  (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
                return i + 1
              }
              return i + 2
            };

            RegExpValidationState.prototype.current = function current (forceU) {
                if ( forceU === void 0 ) forceU = false;

              return this.at(this.pos, forceU)
            };

            RegExpValidationState.prototype.lookahead = function lookahead (forceU) {
                if ( forceU === void 0 ) forceU = false;

              return this.at(this.nextIndex(this.pos, forceU), forceU)
            };

            RegExpValidationState.prototype.advance = function advance (forceU) {
                if ( forceU === void 0 ) forceU = false;

              this.pos = this.nextIndex(this.pos, forceU);
            };

            RegExpValidationState.prototype.eat = function eat (ch, forceU) {
                if ( forceU === void 0 ) forceU = false;

              if (this.current(forceU) === ch) {
                this.advance(forceU);
                return true
              }
              return false
            };

            function codePointToString(ch) {
              if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
              ch -= 0x10000;
              return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
            }

            /**
             * Validate the flags part of a given RegExpLiteral.
             *
             * @param {RegExpValidationState} state The state to validate RegExp.
             * @returns {void}
             */
            pp$8.validateRegExpFlags = function(state) {
              var validFlags = state.validFlags;
              var flags = state.flags;

              for (var i = 0; i < flags.length; i++) {
                var flag = flags.charAt(i);
                if (validFlags.indexOf(flag) === -1) {
                  this.raise(state.start, "Invalid regular expression flag");
                }
                if (flags.indexOf(flag, i + 1) > -1) {
                  this.raise(state.start, "Duplicate regular expression flag");
                }
              }
            };

            /**
             * Validate the pattern part of a given RegExpLiteral.
             *
             * @param {RegExpValidationState} state The state to validate RegExp.
             * @returns {void}
             */
            pp$8.validateRegExpPattern = function(state) {
              this.regexp_pattern(state);

              // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
              // parsing contains a |GroupName|, reparse with the goal symbol
              // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
              // exception if _P_ did not conform to the grammar, if any elements of _P_
              // were not matched by the parse, or if any Early Error conditions exist.
              if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
                state.switchN = true;
                this.regexp_pattern(state);
              }
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
            pp$8.regexp_pattern = function(state) {
              state.pos = 0;
              state.lastIntValue = 0;
              state.lastStringValue = "";
              state.lastAssertionIsQuantifiable = false;
              state.numCapturingParens = 0;
              state.maxBackReference = 0;
              state.groupNames.length = 0;
              state.backReferenceNames.length = 0;

              this.regexp_disjunction(state);

              if (state.pos !== state.source.length) {
                // Make the same messages as V8.
                if (state.eat(0x29 /* ) */)) {
                  state.raise("Unmatched ')'");
                }
                if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {
                  state.raise("Lone quantifier brackets");
                }
              }
              if (state.maxBackReference > state.numCapturingParens) {
                state.raise("Invalid escape");
              }
              for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
                var name = list[i];

                if (state.groupNames.indexOf(name) === -1) {
                  state.raise("Invalid named capture referenced");
                }
              }
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
            pp$8.regexp_disjunction = function(state) {
              this.regexp_alternative(state);
              while (state.eat(0x7C /* | */)) {
                this.regexp_alternative(state);
              }

              // Make the same message as V8.
              if (this.regexp_eatQuantifier(state, true)) {
                state.raise("Nothing to repeat");
              }
              if (state.eat(0x7B /* { */)) {
                state.raise("Lone quantifier brackets");
              }
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
            pp$8.regexp_alternative = function(state) {
              while (state.pos < state.source.length && this.regexp_eatTerm(state))
                { }
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
            pp$8.regexp_eatTerm = function(state) {
              if (this.regexp_eatAssertion(state)) {
                // Handle `QuantifiableAssertion Quantifier` alternative.
                // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
                // is a QuantifiableAssertion.
                if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
                  // Make the same message as V8.
                  if (state.switchU) {
                    state.raise("Invalid quantifier");
                  }
                }
                return true
              }

              if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
                this.regexp_eatQuantifier(state);
                return true
              }

              return false
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
            pp$8.regexp_eatAssertion = function(state) {
              var start = state.pos;
              state.lastAssertionIsQuantifiable = false;

              // ^, $
              if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
                return true
              }

              // \b \B
              if (state.eat(0x5C /* \ */)) {
                if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
                  return true
                }
                state.pos = start;
              }

              // Lookahead / Lookbehind
              if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
                var lookbehind = false;
                if (this.options.ecmaVersion >= 9) {
                  lookbehind = state.eat(0x3C /* < */);
                }
                if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
                  this.regexp_disjunction(state);
                  if (!state.eat(0x29 /* ) */)) {
                    state.raise("Unterminated group");
                  }
                  state.lastAssertionIsQuantifiable = !lookbehind;
                  return true
                }
              }

              state.pos = start;
              return false
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
            pp$8.regexp_eatQuantifier = function(state, noError) {
              if ( noError === void 0 ) noError = false;

              if (this.regexp_eatQuantifierPrefix(state, noError)) {
                state.eat(0x3F /* ? */);
                return true
              }
              return false
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
            pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
              return (
                state.eat(0x2A /* * */) ||
                state.eat(0x2B /* + */) ||
                state.eat(0x3F /* ? */) ||
                this.regexp_eatBracedQuantifier(state, noError)
              )
            };
            pp$8.regexp_eatBracedQuantifier = function(state, noError) {
              var start = state.pos;
              if (state.eat(0x7B /* { */)) {
                var min = 0, max = -1;
                if (this.regexp_eatDecimalDigits(state)) {
                  min = state.lastIntValue;
                  if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
                    max = state.lastIntValue;
                  }
                  if (state.eat(0x7D /* } */)) {
                    // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
                    if (max !== -1 && max < min && !noError) {
                      state.raise("numbers out of order in {} quantifier");
                    }
                    return true
                  }
                }
                if (state.switchU && !noError) {
                  state.raise("Incomplete quantifier");
                }
                state.pos = start;
              }
              return false
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
            pp$8.regexp_eatAtom = function(state) {
              return (
                this.regexp_eatPatternCharacters(state) ||
                state.eat(0x2E /* . */) ||
                this.regexp_eatReverseSolidusAtomEscape(state) ||
                this.regexp_eatCharacterClass(state) ||
                this.regexp_eatUncapturingGroup(state) ||
                this.regexp_eatCapturingGroup(state)
              )
            };
            pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
              var start = state.pos;
              if (state.eat(0x5C /* \ */)) {
                if (this.regexp_eatAtomEscape(state)) {
                  return true
                }
                state.pos = start;
              }
              return false
            };
            pp$8.regexp_eatUncapturingGroup = function(state) {
              var start = state.pos;
              if (state.eat(0x28 /* ( */)) {
                if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
                  this.regexp_disjunction(state);
                  if (state.eat(0x29 /* ) */)) {
                    return true
                  }
                  state.raise("Unterminated group");
                }
                state.pos = start;
              }
              return false
            };
            pp$8.regexp_eatCapturingGroup = function(state) {
              if (state.eat(0x28 /* ( */)) {
                if (this.options.ecmaVersion >= 9) {
                  this.regexp_groupSpecifier(state);
                } else if (state.current() === 0x3F /* ? */) {
                  state.raise("Invalid group");
                }
                this.regexp_disjunction(state);
                if (state.eat(0x29 /* ) */)) {
                  state.numCapturingParens += 1;
                  return true
                }
                state.raise("Unterminated group");
              }
              return false
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
            pp$8.regexp_eatExtendedAtom = function(state) {
              return (
                state.eat(0x2E /* . */) ||
                this.regexp_eatReverseSolidusAtomEscape(state) ||
                this.regexp_eatCharacterClass(state) ||
                this.regexp_eatUncapturingGroup(state) ||
                this.regexp_eatCapturingGroup(state) ||
                this.regexp_eatInvalidBracedQuantifier(state) ||
                this.regexp_eatExtendedPatternCharacter(state)
              )
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
            pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
              if (this.regexp_eatBracedQuantifier(state, true)) {
                state.raise("Nothing to repeat");
              }
              return false
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
            pp$8.regexp_eatSyntaxCharacter = function(state) {
              var ch = state.current();
              if (isSyntaxCharacter(ch)) {
                state.lastIntValue = ch;
                state.advance();
                return true
              }
              return false
            };
            function isSyntaxCharacter(ch) {
              return (
                ch === 0x24 /* $ */ ||
                ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
                ch === 0x2E /* . */ ||
                ch === 0x3F /* ? */ ||
                ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
                ch >= 0x7B /* { */ && ch <= 0x7D /* } */
              )
            }

            // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
            // But eat eager.
            pp$8.regexp_eatPatternCharacters = function(state) {
              var start = state.pos;
              var ch = 0;
              while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
                state.advance();
              }
              return state.pos !== start
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
            pp$8.regexp_eatExtendedPatternCharacter = function(state) {
              var ch = state.current();
              if (
                ch !== -1 &&
                ch !== 0x24 /* $ */ &&
                !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
                ch !== 0x2E /* . */ &&
                ch !== 0x3F /* ? */ &&
                ch !== 0x5B /* [ */ &&
                ch !== 0x5E /* ^ */ &&
                ch !== 0x7C /* | */
              ) {
                state.advance();
                return true
              }
              return false
            };

            // GroupSpecifier ::
            //   [empty]
            //   `?` GroupName
            pp$8.regexp_groupSpecifier = function(state) {
              if (state.eat(0x3F /* ? */)) {
                if (this.regexp_eatGroupName(state)) {
                  if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
                    state.raise("Duplicate capture group name");
                  }
                  state.groupNames.push(state.lastStringValue);
                  return
                }
                state.raise("Invalid group");
              }
            };

            // GroupName ::
            //   `<` RegExpIdentifierName `>`
            // Note: this updates `state.lastStringValue` property with the eaten name.
            pp$8.regexp_eatGroupName = function(state) {
              state.lastStringValue = "";
              if (state.eat(0x3C /* < */)) {
                if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
                  return true
                }
                state.raise("Invalid capture group name");
              }
              return false
            };

            // RegExpIdentifierName ::
            //   RegExpIdentifierStart
            //   RegExpIdentifierName RegExpIdentifierPart
            // Note: this updates `state.lastStringValue` property with the eaten name.
            pp$8.regexp_eatRegExpIdentifierName = function(state) {
              state.lastStringValue = "";
              if (this.regexp_eatRegExpIdentifierStart(state)) {
                state.lastStringValue += codePointToString(state.lastIntValue);
                while (this.regexp_eatRegExpIdentifierPart(state)) {
                  state.lastStringValue += codePointToString(state.lastIntValue);
                }
                return true
              }
              return false
            };

            // RegExpIdentifierStart ::
            //   UnicodeIDStart
            //   `$`
            //   `_`
            //   `\` RegExpUnicodeEscapeSequence[+U]
            pp$8.regexp_eatRegExpIdentifierStart = function(state) {
              var start = state.pos;
              var forceU = this.options.ecmaVersion >= 11;
              var ch = state.current(forceU);
              state.advance(forceU);

              if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
                ch = state.lastIntValue;
              }
              if (isRegExpIdentifierStart(ch)) {
                state.lastIntValue = ch;
                return true
              }

              state.pos = start;
              return false
            };
            function isRegExpIdentifierStart(ch) {
              return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
            }

            // RegExpIdentifierPart ::
            //   UnicodeIDContinue
            //   `$`
            //   `_`
            //   `\` RegExpUnicodeEscapeSequence[+U]
            //   <ZWNJ>
            //   <ZWJ>
            pp$8.regexp_eatRegExpIdentifierPart = function(state) {
              var start = state.pos;
              var forceU = this.options.ecmaVersion >= 11;
              var ch = state.current(forceU);
              state.advance(forceU);

              if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
                ch = state.lastIntValue;
              }
              if (isRegExpIdentifierPart(ch)) {
                state.lastIntValue = ch;
                return true
              }

              state.pos = start;
              return false
            };
            function isRegExpIdentifierPart(ch) {
              return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
            }

            // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
            pp$8.regexp_eatAtomEscape = function(state) {
              if (
                this.regexp_eatBackReference(state) ||
                this.regexp_eatCharacterClassEscape(state) ||
                this.regexp_eatCharacterEscape(state) ||
                (state.switchN && this.regexp_eatKGroupName(state))
              ) {
                return true
              }
              if (state.switchU) {
                // Make the same message as V8.
                if (state.current() === 0x63 /* c */) {
                  state.raise("Invalid unicode escape");
                }
                state.raise("Invalid escape");
              }
              return false
            };
            pp$8.regexp_eatBackReference = function(state) {
              var start = state.pos;
              if (this.regexp_eatDecimalEscape(state)) {
                var n = state.lastIntValue;
                if (state.switchU) {
                  // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
                  if (n > state.maxBackReference) {
                    state.maxBackReference = n;
                  }
                  return true
                }
                if (n <= state.numCapturingParens) {
                  return true
                }
                state.pos = start;
              }
              return false
            };
            pp$8.regexp_eatKGroupName = function(state) {
              if (state.eat(0x6B /* k */)) {
                if (this.regexp_eatGroupName(state)) {
                  state.backReferenceNames.push(state.lastStringValue);
                  return true
                }
                state.raise("Invalid named reference");
              }
              return false
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
            pp$8.regexp_eatCharacterEscape = function(state) {
              return (
                this.regexp_eatControlEscape(state) ||
                this.regexp_eatCControlLetter(state) ||
                this.regexp_eatZero(state) ||
                this.regexp_eatHexEscapeSequence(state) ||
                this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
                (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
                this.regexp_eatIdentityEscape(state)
              )
            };
            pp$8.regexp_eatCControlLetter = function(state) {
              var start = state.pos;
              if (state.eat(0x63 /* c */)) {
                if (this.regexp_eatControlLetter(state)) {
                  return true
                }
                state.pos = start;
              }
              return false
            };
            pp$8.regexp_eatZero = function(state) {
              if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
                state.lastIntValue = 0;
                state.advance();
                return true
              }
              return false
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
            pp$8.regexp_eatControlEscape = function(state) {
              var ch = state.current();
              if (ch === 0x74 /* t */) {
                state.lastIntValue = 0x09; /* \t */
                state.advance();
                return true
              }
              if (ch === 0x6E /* n */) {
                state.lastIntValue = 0x0A; /* \n */
                state.advance();
                return true
              }
              if (ch === 0x76 /* v */) {
                state.lastIntValue = 0x0B; /* \v */
                state.advance();
                return true
              }
              if (ch === 0x66 /* f */) {
                state.lastIntValue = 0x0C; /* \f */
                state.advance();
                return true
              }
              if (ch === 0x72 /* r */) {
                state.lastIntValue = 0x0D; /* \r */
                state.advance();
                return true
              }
              return false
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
            pp$8.regexp_eatControlLetter = function(state) {
              var ch = state.current();
              if (isControlLetter(ch)) {
                state.lastIntValue = ch % 0x20;
                state.advance();
                return true
              }
              return false
            };
            function isControlLetter(ch) {
              return (
                (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
                (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
              )
            }

            // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
            pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
              if ( forceU === void 0 ) forceU = false;

              var start = state.pos;
              var switchU = forceU || state.switchU;

              if (state.eat(0x75 /* u */)) {
                if (this.regexp_eatFixedHexDigits(state, 4)) {
                  var lead = state.lastIntValue;
                  if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
                    var leadSurrogateEnd = state.pos;
                    if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
                      var trail = state.lastIntValue;
                      if (trail >= 0xDC00 && trail <= 0xDFFF) {
                        state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
                        return true
                      }
                    }
                    state.pos = leadSurrogateEnd;
                    state.lastIntValue = lead;
                  }
                  return true
                }
                if (
                  switchU &&
                  state.eat(0x7B /* { */) &&
                  this.regexp_eatHexDigits(state) &&
                  state.eat(0x7D /* } */) &&
                  isValidUnicode(state.lastIntValue)
                ) {
                  return true
                }
                if (switchU) {
                  state.raise("Invalid unicode escape");
                }
                state.pos = start;
              }

              return false
            };
            function isValidUnicode(ch) {
              return ch >= 0 && ch <= 0x10FFFF
            }

            // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
            pp$8.regexp_eatIdentityEscape = function(state) {
              if (state.switchU) {
                if (this.regexp_eatSyntaxCharacter(state)) {
                  return true
                }
                if (state.eat(0x2F /* / */)) {
                  state.lastIntValue = 0x2F; /* / */
                  return true
                }
                return false
              }

              var ch = state.current();
              if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
                state.lastIntValue = ch;
                state.advance();
                return true
              }

              return false
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
            pp$8.regexp_eatDecimalEscape = function(state) {
              state.lastIntValue = 0;
              var ch = state.current();
              if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
                do {
                  state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
                  state.advance();
                } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
                return true
              }
              return false
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
            pp$8.regexp_eatCharacterClassEscape = function(state) {
              var ch = state.current();

              if (isCharacterClassEscape(ch)) {
                state.lastIntValue = -1;
                state.advance();
                return true
              }

              if (
                state.switchU &&
                this.options.ecmaVersion >= 9 &&
                (ch === 0x50 /* P */ || ch === 0x70 /* p */)
              ) {
                state.lastIntValue = -1;
                state.advance();
                if (
                  state.eat(0x7B /* { */) &&
                  this.regexp_eatUnicodePropertyValueExpression(state) &&
                  state.eat(0x7D /* } */)
                ) {
                  return true
                }
                state.raise("Invalid property name");
              }

              return false
            };
            function isCharacterClassEscape(ch) {
              return (
                ch === 0x64 /* d */ ||
                ch === 0x44 /* D */ ||
                ch === 0x73 /* s */ ||
                ch === 0x53 /* S */ ||
                ch === 0x77 /* w */ ||
                ch === 0x57 /* W */
              )
            }

            // UnicodePropertyValueExpression ::
            //   UnicodePropertyName `=` UnicodePropertyValue
            //   LoneUnicodePropertyNameOrValue
            pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
              var start = state.pos;

              // UnicodePropertyName `=` UnicodePropertyValue
              if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
                var name = state.lastStringValue;
                if (this.regexp_eatUnicodePropertyValue(state)) {
                  var value = state.lastStringValue;
                  this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
                  return true
                }
              }
              state.pos = start;

              // LoneUnicodePropertyNameOrValue
              if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
                var nameOrValue = state.lastStringValue;
                this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
                return true
              }
              return false
            };
            pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
              if (!has(state.unicodeProperties.nonBinary, name))
                { state.raise("Invalid property name"); }
              if (!state.unicodeProperties.nonBinary[name].test(value))
                { state.raise("Invalid property value"); }
            };
            pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
              if (!state.unicodeProperties.binary.test(nameOrValue))
                { state.raise("Invalid property name"); }
            };

            // UnicodePropertyName ::
            //   UnicodePropertyNameCharacters
            pp$8.regexp_eatUnicodePropertyName = function(state) {
              var ch = 0;
              state.lastStringValue = "";
              while (isUnicodePropertyNameCharacter(ch = state.current())) {
                state.lastStringValue += codePointToString(ch);
                state.advance();
              }
              return state.lastStringValue !== ""
            };
            function isUnicodePropertyNameCharacter(ch) {
              return isControlLetter(ch) || ch === 0x5F /* _ */
            }

            // UnicodePropertyValue ::
            //   UnicodePropertyValueCharacters
            pp$8.regexp_eatUnicodePropertyValue = function(state) {
              var ch = 0;
              state.lastStringValue = "";
              while (isUnicodePropertyValueCharacter(ch = state.current())) {
                state.lastStringValue += codePointToString(ch);
                state.advance();
              }
              return state.lastStringValue !== ""
            };
            function isUnicodePropertyValueCharacter(ch) {
              return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
            }

            // LoneUnicodePropertyNameOrValue ::
            //   UnicodePropertyValueCharacters
            pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
              return this.regexp_eatUnicodePropertyValue(state)
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
            pp$8.regexp_eatCharacterClass = function(state) {
              if (state.eat(0x5B /* [ */)) {
                state.eat(0x5E /* ^ */);
                this.regexp_classRanges(state);
                if (state.eat(0x5D /* ] */)) {
                  return true
                }
                // Unreachable since it threw "unterminated regular expression" error before.
                state.raise("Unterminated character class");
              }
              return false
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
            // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
            // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
            pp$8.regexp_classRanges = function(state) {
              while (this.regexp_eatClassAtom(state)) {
                var left = state.lastIntValue;
                if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
                  var right = state.lastIntValue;
                  if (state.switchU && (left === -1 || right === -1)) {
                    state.raise("Invalid character class");
                  }
                  if (left !== -1 && right !== -1 && left > right) {
                    state.raise("Range out of order in character class");
                  }
                }
              }
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
            // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
            pp$8.regexp_eatClassAtom = function(state) {
              var start = state.pos;

              if (state.eat(0x5C /* \ */)) {
                if (this.regexp_eatClassEscape(state)) {
                  return true
                }
                if (state.switchU) {
                  // Make the same message as V8.
                  var ch$1 = state.current();
                  if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
                    state.raise("Invalid class escape");
                  }
                  state.raise("Invalid escape");
                }
                state.pos = start;
              }

              var ch = state.current();
              if (ch !== 0x5D /* ] */) {
                state.lastIntValue = ch;
                state.advance();
                return true
              }

              return false
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
            pp$8.regexp_eatClassEscape = function(state) {
              var start = state.pos;

              if (state.eat(0x62 /* b */)) {
                state.lastIntValue = 0x08; /* <BS> */
                return true
              }

              if (state.switchU && state.eat(0x2D /* - */)) {
                state.lastIntValue = 0x2D; /* - */
                return true
              }

              if (!state.switchU && state.eat(0x63 /* c */)) {
                if (this.regexp_eatClassControlLetter(state)) {
                  return true
                }
                state.pos = start;
              }

              return (
                this.regexp_eatCharacterClassEscape(state) ||
                this.regexp_eatCharacterEscape(state)
              )
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
            pp$8.regexp_eatClassControlLetter = function(state) {
              var ch = state.current();
              if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
                state.lastIntValue = ch % 0x20;
                state.advance();
                return true
              }
              return false
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
            pp$8.regexp_eatHexEscapeSequence = function(state) {
              var start = state.pos;
              if (state.eat(0x78 /* x */)) {
                if (this.regexp_eatFixedHexDigits(state, 2)) {
                  return true
                }
                if (state.switchU) {
                  state.raise("Invalid escape");
                }
                state.pos = start;
              }
              return false
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
            pp$8.regexp_eatDecimalDigits = function(state) {
              var start = state.pos;
              var ch = 0;
              state.lastIntValue = 0;
              while (isDecimalDigit(ch = state.current())) {
                state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
                state.advance();
              }
              return state.pos !== start
            };
            function isDecimalDigit(ch) {
              return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
            }

            // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
            pp$8.regexp_eatHexDigits = function(state) {
              var start = state.pos;
              var ch = 0;
              state.lastIntValue = 0;
              while (isHexDigit(ch = state.current())) {
                state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
                state.advance();
              }
              return state.pos !== start
            };
            function isHexDigit(ch) {
              return (
                (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
                (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
                (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
              )
            }
            function hexToInt(ch) {
              if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
                return 10 + (ch - 0x41 /* A */)
              }
              if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
                return 10 + (ch - 0x61 /* a */)
              }
              return ch - 0x30 /* 0 */
            }

            // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
            // Allows only 0-377(octal) i.e. 0-255(decimal).
            pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
              if (this.regexp_eatOctalDigit(state)) {
                var n1 = state.lastIntValue;
                if (this.regexp_eatOctalDigit(state)) {
                  var n2 = state.lastIntValue;
                  if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
                    state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
                  } else {
                    state.lastIntValue = n1 * 8 + n2;
                  }
                } else {
                  state.lastIntValue = n1;
                }
                return true
              }
              return false
            };

            // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
            pp$8.regexp_eatOctalDigit = function(state) {
              var ch = state.current();
              if (isOctalDigit(ch)) {
                state.lastIntValue = ch - 0x30; /* 0 */
                state.advance();
                return true
              }
              state.lastIntValue = 0;
              return false
            };
            function isOctalDigit(ch) {
              return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
            }

            // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
            // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
            // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
            pp$8.regexp_eatFixedHexDigits = function(state, length) {
              var start = state.pos;
              state.lastIntValue = 0;
              for (var i = 0; i < length; ++i) {
                var ch = state.current();
                if (!isHexDigit(ch)) {
                  state.pos = start;
                  return false
                }
                state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
                state.advance();
              }
              return true
            };

            // Object type used to represent tokens. Note that normally, tokens
            // simply exist as properties on the parser object. This is only
            // used for the onToken callback and the external tokenizer.

            var Token = function Token(p) {
              this.type = p.type;
              this.value = p.value;
              this.start = p.start;
              this.end = p.end;
              if (p.options.locations)
                { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
              if (p.options.ranges)
                { this.range = [p.start, p.end]; }
            };

            // ## Tokenizer

            var pp$9 = Parser.prototype;

            // Move to the next token

            pp$9.next = function(ignoreEscapeSequenceInKeyword) {
              if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
                { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
              if (this.options.onToken)
                { this.options.onToken(new Token(this)); }

              this.lastTokEnd = this.end;
              this.lastTokStart = this.start;
              this.lastTokEndLoc = this.endLoc;
              this.lastTokStartLoc = this.startLoc;
              this.nextToken();
            };

            pp$9.getToken = function() {
              this.next();
              return new Token(this)
            };

            // If we're in an ES6 environment, make parsers iterable
            if (typeof Symbol !== "undefined")
              { pp$9[Symbol.iterator] = function() {
                var this$1 = this;

                return {
                  next: function () {
                    var token = this$1.getToken();
                    return {
                      done: token.type === types.eof,
                      value: token
                    }
                  }
                }
              }; }

            // Toggle strict mode. Re-reads the next number or string to please
            // pedantic tests (`"use strict"; 010;` should fail).

            pp$9.curContext = function() {
              return this.context[this.context.length - 1]
            };

            // Read a single token, updating the parser object's token-related
            // properties.

            pp$9.nextToken = function() {
              var curContext = this.curContext();
              if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

              this.start = this.pos;
              if (this.options.locations) { this.startLoc = this.curPosition(); }
              if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

              if (curContext.override) { return curContext.override(this) }
              else { this.readToken(this.fullCharCodeAtPos()); }
            };

            pp$9.readToken = function(code) {
              // Identifier or keyword. '\uXXXX' sequences are allowed in
              // identifiers, so '\' also dispatches to that.
              if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
                { return this.readWord() }

              return this.getTokenFromCode(code)
            };

            pp$9.fullCharCodeAtPos = function() {
              var code = this.input.charCodeAt(this.pos);
              if (code <= 0xd7ff || code >= 0xe000) { return code }
              var next = this.input.charCodeAt(this.pos + 1);
              return (code << 10) + next - 0x35fdc00
            };

            pp$9.skipBlockComment = function() {
              var startLoc = this.options.onComment && this.curPosition();
              var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
              if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
              this.pos = end + 2;
              if (this.options.locations) {
                lineBreakG.lastIndex = start;
                var match;
                while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
                  ++this.curLine;
                  this.lineStart = match.index + match[0].length;
                }
              }
              if (this.options.onComment)
                { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                                       startLoc, this.curPosition()); }
            };

            pp$9.skipLineComment = function(startSkip) {
              var start = this.pos;
              var startLoc = this.options.onComment && this.curPosition();
              var ch = this.input.charCodeAt(this.pos += startSkip);
              while (this.pos < this.input.length && !isNewLine(ch)) {
                ch = this.input.charCodeAt(++this.pos);
              }
              if (this.options.onComment)
                { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                                       startLoc, this.curPosition()); }
            };

            // Called at the start of the parse and after every token. Skips
            // whitespace and comments, and.

            pp$9.skipSpace = function() {
              loop: while (this.pos < this.input.length) {
                var ch = this.input.charCodeAt(this.pos);
                switch (ch) {
                case 32: case 160: // ' '
                  ++this.pos;
                  break
                case 13:
                  if (this.input.charCodeAt(this.pos + 1) === 10) {
                    ++this.pos;
                  }
                case 10: case 8232: case 8233:
                  ++this.pos;
                  if (this.options.locations) {
                    ++this.curLine;
                    this.lineStart = this.pos;
                  }
                  break
                case 47: // '/'
                  switch (this.input.charCodeAt(this.pos + 1)) {
                  case 42: // '*'
                    this.skipBlockComment();
                    break
                  case 47:
                    this.skipLineComment(2);
                    break
                  default:
                    break loop
                  }
                  break
                default:
                  if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                    ++this.pos;
                  } else {
                    break loop
                  }
                }
              }
            };

            // Called at the end of every token. Sets `end`, `val`, and
            // maintains `context` and `exprAllowed`, and skips the space after
            // the token, so that the next one's `start` will point at the
            // right position.

            pp$9.finishToken = function(type, val) {
              this.end = this.pos;
              if (this.options.locations) { this.endLoc = this.curPosition(); }
              var prevType = this.type;
              this.type = type;
              this.value = val;

              this.updateContext(prevType);
            };

            // ### Token reading

            // This is the function that is called to fetch the next token. It
            // is somewhat obscure, because it works in character codes rather
            // than characters, and because operator parsing has been inlined
            // into it.
            //
            // All in the name of speed.
            //
            pp$9.readToken_dot = function() {
              var next = this.input.charCodeAt(this.pos + 1);
              if (next >= 48 && next <= 57) { return this.readNumber(true) }
              var next2 = this.input.charCodeAt(this.pos + 2);
              if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
                this.pos += 3;
                return this.finishToken(types.ellipsis)
              } else {
                ++this.pos;
                return this.finishToken(types.dot)
              }
            };

            pp$9.readToken_slash = function() { // '/'
              var next = this.input.charCodeAt(this.pos + 1);
              if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
              if (next === 61) { return this.finishOp(types.assign, 2) }
              return this.finishOp(types.slash, 1)
            };

            pp$9.readToken_mult_modulo_exp = function(code) { // '%*'
              var next = this.input.charCodeAt(this.pos + 1);
              var size = 1;
              var tokentype = code === 42 ? types.star : types.modulo;

              // exponentiation operator ** and **=
              if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
                ++size;
                tokentype = types.starstar;
                next = this.input.charCodeAt(this.pos + 2);
              }

              if (next === 61) { return this.finishOp(types.assign, size + 1) }
              return this.finishOp(tokentype, size)
            };

            pp$9.readToken_pipe_amp = function(code) { // '|&'
              var next = this.input.charCodeAt(this.pos + 1);
              if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
              if (next === 61) { return this.finishOp(types.assign, 2) }
              return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
            };

            pp$9.readToken_caret = function() { // '^'
              var next = this.input.charCodeAt(this.pos + 1);
              if (next === 61) { return this.finishOp(types.assign, 2) }
              return this.finishOp(types.bitwiseXOR, 1)
            };

            pp$9.readToken_plus_min = function(code) { // '+-'
              var next = this.input.charCodeAt(this.pos + 1);
              if (next === code) {
                if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
                    (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
                  // A `-->` line comment
                  this.skipLineComment(3);
                  this.skipSpace();
                  return this.nextToken()
                }
                return this.finishOp(types.incDec, 2)
              }
              if (next === 61) { return this.finishOp(types.assign, 2) }
              return this.finishOp(types.plusMin, 1)
            };

            pp$9.readToken_lt_gt = function(code) { // '<>'
              var next = this.input.charCodeAt(this.pos + 1);
              var size = 1;
              if (next === code) {
                size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
                if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
                return this.finishOp(types.bitShift, size)
              }
              if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
                  this.input.charCodeAt(this.pos + 3) === 45) {
                // `<!--`, an XML-style comment that should be interpreted as a line comment
                this.skipLineComment(4);
                this.skipSpace();
                return this.nextToken()
              }
              if (next === 61) { size = 2; }
              return this.finishOp(types.relational, size)
            };

            pp$9.readToken_eq_excl = function(code) { // '=!'
              var next = this.input.charCodeAt(this.pos + 1);
              if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
              if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
                this.pos += 2;
                return this.finishToken(types.arrow)
              }
              return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
            };

            pp$9.readToken_question = function() { // '?'
              if (this.options.ecmaVersion >= 11) {
                var next = this.input.charCodeAt(this.pos + 1);
                if (next === 46) {
                  var next2 = this.input.charCodeAt(this.pos + 2);
                  if (next2 < 48 || next2 > 57) { return this.finishOp(types.questionDot, 2) }
                }
                if (next === 63) { return this.finishOp(types.coalesce, 2) }
              }
              return this.finishOp(types.question, 1)
            };

            pp$9.getTokenFromCode = function(code) {
              switch (code) {
              // The interpretation of a dot depends on whether it is followed
              // by a digit or another two dots.
              case 46: // '.'
                return this.readToken_dot()

              // Punctuation tokens.
              case 40: ++this.pos; return this.finishToken(types.parenL)
              case 41: ++this.pos; return this.finishToken(types.parenR)
              case 59: ++this.pos; return this.finishToken(types.semi)
              case 44: ++this.pos; return this.finishToken(types.comma)
              case 91: ++this.pos; return this.finishToken(types.bracketL)
              case 93: ++this.pos; return this.finishToken(types.bracketR)
              case 123: ++this.pos; return this.finishToken(types.braceL)
              case 125: ++this.pos; return this.finishToken(types.braceR)
              case 58: ++this.pos; return this.finishToken(types.colon)

              case 96: // '`'
                if (this.options.ecmaVersion < 6) { break }
                ++this.pos;
                return this.finishToken(types.backQuote)

              case 48: // '0'
                var next = this.input.charCodeAt(this.pos + 1);
                if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
                if (this.options.ecmaVersion >= 6) {
                  if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
                  if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
                }

              // Anything else beginning with a digit is an integer, octal
              // number, or float.
              case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
                return this.readNumber(false)

              // Quotes produce strings.
              case 34: case 39: // '"', "'"
                return this.readString(code)

              // Operators are parsed inline in tiny state machines. '=' (61) is
              // often referred to. `finishOp` simply skips the amount of
              // characters it is given as second argument, and returns a token
              // of the type given by its first argument.

              case 47: // '/'
                return this.readToken_slash()

              case 37: case 42: // '%*'
                return this.readToken_mult_modulo_exp(code)

              case 124: case 38: // '|&'
                return this.readToken_pipe_amp(code)

              case 94: // '^'
                return this.readToken_caret()

              case 43: case 45: // '+-'
                return this.readToken_plus_min(code)

              case 60: case 62: // '<>'
                return this.readToken_lt_gt(code)

              case 61: case 33: // '=!'
                return this.readToken_eq_excl(code)

              case 63: // '?'
                return this.readToken_question()

              case 126: // '~'
                return this.finishOp(types.prefix, 1)
              }

              this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
            };

            pp$9.finishOp = function(type, size) {
              var str = this.input.slice(this.pos, this.pos + size);
              this.pos += size;
              return this.finishToken(type, str)
            };

            pp$9.readRegexp = function() {
              var escaped, inClass, start = this.pos;
              for (;;) {
                if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
                var ch = this.input.charAt(this.pos);
                if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
                if (!escaped) {
                  if (ch === "[") { inClass = true; }
                  else if (ch === "]" && inClass) { inClass = false; }
                  else if (ch === "/" && !inClass) { break }
                  escaped = ch === "\\";
                } else { escaped = false; }
                ++this.pos;
              }
              var pattern = this.input.slice(start, this.pos);
              ++this.pos;
              var flagsStart = this.pos;
              var flags = this.readWord1();
              if (this.containsEsc) { this.unexpected(flagsStart); }

              // Validate pattern
              var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
              state.reset(start, pattern, flags);
              this.validateRegExpFlags(state);
              this.validateRegExpPattern(state);

              // Create Literal#value property value.
              var value = null;
              try {
                value = new RegExp(pattern, flags);
              } catch (e) {
                // ESTree requires null if it failed to instantiate RegExp object.
                // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
              }

              return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
            };

            // Read an integer in the given radix. Return null if zero digits
            // were read, the integer value otherwise. When `len` is given, this
            // will return `null` unless the integer has exactly `len` digits.

            pp$9.readInt = function(radix, len) {
              var start = this.pos, total = 0;
              for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
                var code = this.input.charCodeAt(this.pos), val = (void 0);
                if (code >= 97) { val = code - 97 + 10; } // a
                else if (code >= 65) { val = code - 65 + 10; } // A
                else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
                else { val = Infinity; }
                if (val >= radix) { break }
                ++this.pos;
                total = total * radix + val;
              }
              if (this.pos === start || len != null && this.pos - start !== len) { return null }

              return total
            };

            pp$9.readRadixNumber = function(radix) {
              var start = this.pos;
              this.pos += 2; // 0x
              var val = this.readInt(radix);
              if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
              if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
                val = typeof BigInt !== "undefined" ? BigInt(this.input.slice(start, this.pos)) : null;
                ++this.pos;
              } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
              return this.finishToken(types.num, val)
            };

            // Read an integer, octal integer, or floating-point number.

            pp$9.readNumber = function(startsWithDot) {
              var start = this.pos;
              if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
              var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
              if (octal && this.strict) { this.raise(start, "Invalid number"); }
              var next = this.input.charCodeAt(this.pos);
              if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
                var str$1 = this.input.slice(start, this.pos);
                var val$1 = typeof BigInt !== "undefined" ? BigInt(str$1) : null;
                ++this.pos;
                if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
                return this.finishToken(types.num, val$1)
              }
              if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
              if (next === 46 && !octal) { // '.'
                ++this.pos;
                this.readInt(10);
                next = this.input.charCodeAt(this.pos);
              }
              if ((next === 69 || next === 101) && !octal) { // 'eE'
                next = this.input.charCodeAt(++this.pos);
                if (next === 43 || next === 45) { ++this.pos; } // '+-'
                if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
              }
              if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

              var str = this.input.slice(start, this.pos);
              var val = octal ? parseInt(str, 8) : parseFloat(str);
              return this.finishToken(types.num, val)
            };

            // Read a string value, interpreting backslash-escapes.

            pp$9.readCodePoint = function() {
              var ch = this.input.charCodeAt(this.pos), code;

              if (ch === 123) { // '{'
                if (this.options.ecmaVersion < 6) { this.unexpected(); }
                var codePos = ++this.pos;
                code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
                ++this.pos;
                if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
              } else {
                code = this.readHexChar(4);
              }
              return code
            };

            function codePointToString$1(code) {
              // UTF-16 Decoding
              if (code <= 0xFFFF) { return String.fromCharCode(code) }
              code -= 0x10000;
              return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
            }

            pp$9.readString = function(quote) {
              var out = "", chunkStart = ++this.pos;
              for (;;) {
                if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
                var ch = this.input.charCodeAt(this.pos);
                if (ch === quote) { break }
                if (ch === 92) { // '\'
                  out += this.input.slice(chunkStart, this.pos);
                  out += this.readEscapedChar(false);
                  chunkStart = this.pos;
                } else {
                  if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
                  ++this.pos;
                }
              }
              out += this.input.slice(chunkStart, this.pos++);
              return this.finishToken(types.string, out)
            };

            // Reads template string tokens.

            var INVALID_TEMPLATE_ESCAPE_ERROR = {};

            pp$9.tryReadTemplateToken = function() {
              this.inTemplateElement = true;
              try {
                this.readTmplToken();
              } catch (err) {
                if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
                  this.readInvalidTemplateToken();
                } else {
                  throw err
                }
              }

              this.inTemplateElement = false;
            };

            pp$9.invalidStringToken = function(position, message) {
              if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
                throw INVALID_TEMPLATE_ESCAPE_ERROR
              } else {
                this.raise(position, message);
              }
            };

            pp$9.readTmplToken = function() {
              var out = "", chunkStart = this.pos;
              for (;;) {
                if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
                var ch = this.input.charCodeAt(this.pos);
                if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
                  if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
                    if (ch === 36) {
                      this.pos += 2;
                      return this.finishToken(types.dollarBraceL)
                    } else {
                      ++this.pos;
                      return this.finishToken(types.backQuote)
                    }
                  }
                  out += this.input.slice(chunkStart, this.pos);
                  return this.finishToken(types.template, out)
                }
                if (ch === 92) { // '\'
                  out += this.input.slice(chunkStart, this.pos);
                  out += this.readEscapedChar(true);
                  chunkStart = this.pos;
                } else if (isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.pos);
                  ++this.pos;
                  switch (ch) {
                  case 13:
                    if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
                  case 10:
                    out += "\n";
                    break
                  default:
                    out += String.fromCharCode(ch);
                    break
                  }
                  if (this.options.locations) {
                    ++this.curLine;
                    this.lineStart = this.pos;
                  }
                  chunkStart = this.pos;
                } else {
                  ++this.pos;
                }
              }
            };

            // Reads a template token to search for the end, without validating any escape sequences
            pp$9.readInvalidTemplateToken = function() {
              for (; this.pos < this.input.length; this.pos++) {
                switch (this.input[this.pos]) {
                case "\\":
                  ++this.pos;
                  break

                case "$":
                  if (this.input[this.pos + 1] !== "{") {
                    break
                  }
                // falls through

                case "`":
                  return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

                // no default
                }
              }
              this.raise(this.start, "Unterminated template");
            };

            // Used to read escaped characters

            pp$9.readEscapedChar = function(inTemplate) {
              var ch = this.input.charCodeAt(++this.pos);
              ++this.pos;
              switch (ch) {
              case 110: return "\n" // 'n' -> '\n'
              case 114: return "\r" // 'r' -> '\r'
              case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
              case 117: return codePointToString$1(this.readCodePoint()) // 'u'
              case 116: return "\t" // 't' -> '\t'
              case 98: return "\b" // 'b' -> '\b'
              case 118: return "\u000b" // 'v' -> '\u000b'
              case 102: return "\f" // 'f' -> '\f'
              case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
              case 10: // ' \n'
                if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
                return ""
              case 56:
              case 57:
                if (inTemplate) {
                  var codePos = this.pos - 1;

                  this.invalidStringToken(
                    codePos,
                    "Invalid escape sequence in template string"
                  );

                  return null
                }
              default:
                if (ch >= 48 && ch <= 55) {
                  var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
                  var octal = parseInt(octalStr, 8);
                  if (octal > 255) {
                    octalStr = octalStr.slice(0, -1);
                    octal = parseInt(octalStr, 8);
                  }
                  this.pos += octalStr.length - 1;
                  ch = this.input.charCodeAt(this.pos);
                  if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                    this.invalidStringToken(
                      this.pos - 1 - octalStr.length,
                      inTemplate
                        ? "Octal literal in template string"
                        : "Octal literal in strict mode"
                    );
                  }
                  return String.fromCharCode(octal)
                }
                if (isNewLine(ch)) {
                  // Unicode new line characters after \ get removed from output in both
                  // template literals and strings
                  return ""
                }
                return String.fromCharCode(ch)
              }
            };

            // Used to read character escape sequences ('\x', '\u', '\U').

            pp$9.readHexChar = function(len) {
              var codePos = this.pos;
              var n = this.readInt(16, len);
              if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
              return n
            };

            // Read an identifier, and return it as a string. Sets `this.containsEsc`
            // to whether the word contained a '\u' escape.
            //
            // Incrementally adds only escaped chars, adding other chunks as-is
            // as a micro-optimization.

            pp$9.readWord1 = function() {
              this.containsEsc = false;
              var word = "", first = true, chunkStart = this.pos;
              var astral = this.options.ecmaVersion >= 6;
              while (this.pos < this.input.length) {
                var ch = this.fullCharCodeAtPos();
                if (isIdentifierChar(ch, astral)) {
                  this.pos += ch <= 0xffff ? 1 : 2;
                } else if (ch === 92) { // "\"
                  this.containsEsc = true;
                  word += this.input.slice(chunkStart, this.pos);
                  var escStart = this.pos;
                  if (this.input.charCodeAt(++this.pos) !== 117) // "u"
                    { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
                  ++this.pos;
                  var esc = this.readCodePoint();
                  if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
                    { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
                  word += codePointToString$1(esc);
                  chunkStart = this.pos;
                } else {
                  break
                }
                first = false;
              }
              return word + this.input.slice(chunkStart, this.pos)
            };

            // Read an identifier or keyword token. Will check for reserved
            // words when necessary.

            pp$9.readWord = function() {
              var word = this.readWord1();
              var type = types.name;
              if (this.keywords.test(word)) {
                type = keywords$1[word];
              }
              return this.finishToken(type, word)
            };

            // Acorn is a tiny, fast JavaScript parser written in JavaScript.

            var version$3 = "7.3.1";

            Parser.acorn = {
              Parser: Parser,
              version: version$3,
              defaultOptions: defaultOptions,
              Position: Position,
              SourceLocation: SourceLocation,
              getLineInfo: getLineInfo,
              Node: Node$3,
              TokenType: TokenType,
              tokTypes: types,
              keywordTypes: keywords$1,
              TokContext: TokContext,
              tokContexts: types$1,
              isIdentifierChar: isIdentifierChar,
              isIdentifierStart: isIdentifierStart,
              Token: Token,
              isNewLine: isNewLine,
              lineBreak: lineBreak,
              lineBreakG: lineBreakG,
              nonASCIIwhitespace: nonASCIIwhitespace
            };

            // The main exported interface (under `self.acorn` when in the
            // browser) is a `parse` function that takes a code string and
            // returns an abstract syntax tree as specified by [Mozilla parser
            // API][api].
            //
            // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

            function parse$2(input, options) {
              return Parser.parse(input, options)
            }

            // AST walker module for Mozilla Parser API compatible trees

            // A recursive walk is one where your functions override the default
            // walkers. They can modify and replace the state parameter that's
            // threaded through the walk, and can opt how and whether to walk
            // their child nodes (by calling their third argument on these
            // nodes).
            function recursive(node, state, funcs, baseVisitor, override) {
              var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor
              ;(function c(node, st, override) {
                visitor[override || node.type](node, st, c);
              })(node, state, override);
            }

            // Fallback to an Object.create polyfill for older environments.
            var create = Object.create || function(proto) {
              function Ctor() {}
              Ctor.prototype = proto;
              return new Ctor
            };

            // Used to create a custom walker. Will fill in all missing node
            // type properties with the defaults.
            function make(funcs, baseVisitor) {
              var visitor = create(baseVisitor || base$1);
              for (var type in funcs) { visitor[type] = funcs[type]; }
              return visitor
            }

            function skipThrough(node, st, c) { c(node, st); }
            function ignore(_node, _st, _c) {}

            // Node walkers.

            var base$1 = {};

            base$1.Program = base$1.BlockStatement = function (node, st, c) {
              for (var i = 0, list = node.body; i < list.length; i += 1)
                {
                var stmt = list[i];

                c(stmt, st, "Statement");
              }
            };
            base$1.Statement = skipThrough;
            base$1.EmptyStatement = ignore;
            base$1.ExpressionStatement = base$1.ParenthesizedExpression = base$1.ChainExpression =
              function (node, st, c) { return c(node.expression, st, "Expression"); };
            base$1.IfStatement = function (node, st, c) {
              c(node.test, st, "Expression");
              c(node.consequent, st, "Statement");
              if (node.alternate) { c(node.alternate, st, "Statement"); }
            };
            base$1.LabeledStatement = function (node, st, c) { return c(node.body, st, "Statement"); };
            base$1.BreakStatement = base$1.ContinueStatement = ignore;
            base$1.WithStatement = function (node, st, c) {
              c(node.object, st, "Expression");
              c(node.body, st, "Statement");
            };
            base$1.SwitchStatement = function (node, st, c) {
              c(node.discriminant, st, "Expression");
              for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {
                var cs = list$1[i$1];

                if (cs.test) { c(cs.test, st, "Expression"); }
                for (var i = 0, list = cs.consequent; i < list.length; i += 1)
                  {
                  var cons = list[i];

                  c(cons, st, "Statement");
                }
              }
            };
            base$1.SwitchCase = function (node, st, c) {
              if (node.test) { c(node.test, st, "Expression"); }
              for (var i = 0, list = node.consequent; i < list.length; i += 1)
                {
                var cons = list[i];

                c(cons, st, "Statement");
              }
            };
            base$1.ReturnStatement = base$1.YieldExpression = base$1.AwaitExpression = function (node, st, c) {
              if (node.argument) { c(node.argument, st, "Expression"); }
            };
            base$1.ThrowStatement = base$1.SpreadElement =
              function (node, st, c) { return c(node.argument, st, "Expression"); };
            base$1.TryStatement = function (node, st, c) {
              c(node.block, st, "Statement");
              if (node.handler) { c(node.handler, st); }
              if (node.finalizer) { c(node.finalizer, st, "Statement"); }
            };
            base$1.CatchClause = function (node, st, c) {
              if (node.param) { c(node.param, st, "Pattern"); }
              c(node.body, st, "Statement");
            };
            base$1.WhileStatement = base$1.DoWhileStatement = function (node, st, c) {
              c(node.test, st, "Expression");
              c(node.body, st, "Statement");
            };
            base$1.ForStatement = function (node, st, c) {
              if (node.init) { c(node.init, st, "ForInit"); }
              if (node.test) { c(node.test, st, "Expression"); }
              if (node.update) { c(node.update, st, "Expression"); }
              c(node.body, st, "Statement");
            };
            base$1.ForInStatement = base$1.ForOfStatement = function (node, st, c) {
              c(node.left, st, "ForInit");
              c(node.right, st, "Expression");
              c(node.body, st, "Statement");
            };
            base$1.ForInit = function (node, st, c) {
              if (node.type === "VariableDeclaration") { c(node, st); }
              else { c(node, st, "Expression"); }
            };
            base$1.DebuggerStatement = ignore;

            base$1.FunctionDeclaration = function (node, st, c) { return c(node, st, "Function"); };
            base$1.VariableDeclaration = function (node, st, c) {
              for (var i = 0, list = node.declarations; i < list.length; i += 1)
                {
                var decl = list[i];

                c(decl, st);
              }
            };
            base$1.VariableDeclarator = function (node, st, c) {
              c(node.id, st, "Pattern");
              if (node.init) { c(node.init, st, "Expression"); }
            };

            base$1.Function = function (node, st, c) {
              if (node.id) { c(node.id, st, "Pattern"); }
              for (var i = 0, list = node.params; i < list.length; i += 1)
                {
                var param = list[i];

                c(param, st, "Pattern");
              }
              c(node.body, st, node.expression ? "Expression" : "Statement");
            };

            base$1.Pattern = function (node, st, c) {
              if (node.type === "Identifier")
                { c(node, st, "VariablePattern"); }
              else if (node.type === "MemberExpression")
                { c(node, st, "MemberPattern"); }
              else
                { c(node, st); }
            };
            base$1.VariablePattern = ignore;
            base$1.MemberPattern = skipThrough;
            base$1.RestElement = function (node, st, c) { return c(node.argument, st, "Pattern"); };
            base$1.ArrayPattern = function (node, st, c) {
              for (var i = 0, list = node.elements; i < list.length; i += 1) {
                var elt = list[i];

                if (elt) { c(elt, st, "Pattern"); }
              }
            };
            base$1.ObjectPattern = function (node, st, c) {
              for (var i = 0, list = node.properties; i < list.length; i += 1) {
                var prop = list[i];

                if (prop.type === "Property") {
                  if (prop.computed) { c(prop.key, st, "Expression"); }
                  c(prop.value, st, "Pattern");
                } else if (prop.type === "RestElement") {
                  c(prop.argument, st, "Pattern");
                }
              }
            };

            base$1.Expression = skipThrough;
            base$1.ThisExpression = base$1.Super = base$1.MetaProperty = ignore;
            base$1.ArrayExpression = function (node, st, c) {
              for (var i = 0, list = node.elements; i < list.length; i += 1) {
                var elt = list[i];

                if (elt) { c(elt, st, "Expression"); }
              }
            };
            base$1.ObjectExpression = function (node, st, c) {
              for (var i = 0, list = node.properties; i < list.length; i += 1)
                {
                var prop = list[i];

                c(prop, st);
              }
            };
            base$1.FunctionExpression = base$1.ArrowFunctionExpression = base$1.FunctionDeclaration;
            base$1.SequenceExpression = function (node, st, c) {
              for (var i = 0, list = node.expressions; i < list.length; i += 1)
                {
                var expr = list[i];

                c(expr, st, "Expression");
              }
            };
            base$1.TemplateLiteral = function (node, st, c) {
              for (var i = 0, list = node.quasis; i < list.length; i += 1)
                {
                var quasi = list[i];

                c(quasi, st);
              }

              for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)
                {
                var expr = list$1[i$1];

                c(expr, st, "Expression");
              }
            };
            base$1.TemplateElement = ignore;
            base$1.UnaryExpression = base$1.UpdateExpression = function (node, st, c) {
              c(node.argument, st, "Expression");
            };
            base$1.BinaryExpression = base$1.LogicalExpression = function (node, st, c) {
              c(node.left, st, "Expression");
              c(node.right, st, "Expression");
            };
            base$1.AssignmentExpression = base$1.AssignmentPattern = function (node, st, c) {
              c(node.left, st, "Pattern");
              c(node.right, st, "Expression");
            };
            base$1.ConditionalExpression = function (node, st, c) {
              c(node.test, st, "Expression");
              c(node.consequent, st, "Expression");
              c(node.alternate, st, "Expression");
            };
            base$1.NewExpression = base$1.CallExpression = function (node, st, c) {
              c(node.callee, st, "Expression");
              if (node.arguments)
                { for (var i = 0, list = node.arguments; i < list.length; i += 1)
                  {
                    var arg = list[i];

                    c(arg, st, "Expression");
                  } }
            };
            base$1.MemberExpression = function (node, st, c) {
              c(node.object, st, "Expression");
              if (node.computed) { c(node.property, st, "Expression"); }
            };
            base$1.ExportNamedDeclaration = base$1.ExportDefaultDeclaration = function (node, st, c) {
              if (node.declaration)
                { c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression"); }
              if (node.source) { c(node.source, st, "Expression"); }
            };
            base$1.ExportAllDeclaration = function (node, st, c) {
              if (node.exported)
                { c(node.exported, st); }
              c(node.source, st, "Expression");
            };
            base$1.ImportDeclaration = function (node, st, c) {
              for (var i = 0, list = node.specifiers; i < list.length; i += 1)
                {
                var spec = list[i];

                c(spec, st);
              }
              c(node.source, st, "Expression");
            };
            base$1.ImportExpression = function (node, st, c) {
              c(node.source, st, "Expression");
            };
            base$1.ImportSpecifier = base$1.ImportDefaultSpecifier = base$1.ImportNamespaceSpecifier = base$1.Identifier = base$1.Literal = ignore;

            base$1.TaggedTemplateExpression = function (node, st, c) {
              c(node.tag, st, "Expression");
              c(node.quasi, st, "Expression");
            };
            base$1.ClassDeclaration = base$1.ClassExpression = function (node, st, c) { return c(node, st, "Class"); };
            base$1.Class = function (node, st, c) {
              if (node.id) { c(node.id, st, "Pattern"); }
              if (node.superClass) { c(node.superClass, st, "Expression"); }
              c(node.body, st);
            };
            base$1.ClassBody = function (node, st, c) {
              for (var i = 0, list = node.body; i < list.length; i += 1)
                {
                var elt = list[i];

                c(elt, st);
              }
            };
            base$1.MethodDefinition = base$1.Property = function (node, st, c) {
              if (node.computed) { c(node.key, st, "Expression"); }
              c(node.value, st, "Expression");
            };

            const strip = (ast) => {
              if (ast instanceof Array) {
                return ast.map(strip);
              } else if (ast instanceof Object) {
                const stripped = {};
                for (const key of Object.keys(ast)) {
                  if (['end', 'loc', 'start'].includes(key)) {
                    continue;
                  }
                  stripped[key] = strip(ast[key]);
                }
                return stripped;
              } else {
                return ast;
              }
            };

            /**
             * Convert a module to executable ecmascript function.
             * The conversion includes caching constant variables for reuse, and tree pruning.
             *
             * @param {string} script
             * @param {object} options
             * @param {string} options.path - The path to the script for producing relative paths.
             * @param {function(path:string} options.import - A method for resolving imports.
             */

            const toEcmascript = async (script, { path } = {}) => {
              const parseOptions = {
                allowAwaitOutsideFunction: true,
                allowReturnOutsideFunction: true,
                sourceType: 'module',
              };
              let ast = parse$2(script, parseOptions);

              const exportNames = [];

              const body = ast.body;
              const out = [];

              const topLevel = new Map();

              const fromIdToSha = (id) => {
                const entry = topLevel.get(id);
                if (entry !== undefined) {
                  return entry.sha;
                }
              };

              const declareVariable = async (
                declaration,
                declarator,
                { doExport = false } = {}
              ) => {
                const id = declarator.id.name;
                const code = strip(declarator);
                const dependencies = [];

                const Identifier = (node, state, c) => {
                  dependencies.push(node.name);
                };

                recursive(declarator, undefined, { Identifier });

                const dependencyShas = dependencies.map(fromIdToSha);

                const definition = { code, dependencies, dependencyShas };
                const sha = object_hash(definition);
                const entry = { sha, definition };
                topLevel.set(id, entry);
                if (doExport) {
                  exportNames.push(id);
                }

                if (declarator.init) {
                  if (declarator.init.type === 'ArrowFunctionExpression') {
                    // We can't cache functions.
                    out.push(declaration);
                    return;
                  } else if (declarator.init.type === 'Literal') {
                    // Not much point in caching literals.
                    out.push(declaration);
                    return;
                  }
                }
                // Now that we have the sha, we can predict if it can be read from cache.
                const meta = await read(`meta/def/${id}`);
                if (meta && meta.sha === sha) {
                  const readCode = strip(
                    parse$2(`await loadGeometry('data/def/${id}')`, parseOptions)
                  );
                  const readExpression = readCode.body[0].expression;
                  const init = readExpression;
                  out.push({ ...declaration, declarations: [{ ...declarator, init }] });
                } else {
                  out.push({ ...declaration, declarations: [declarator] });
                  // Only cache Shapes.
                  out.push(
                    parse$2(
                      `${id} instanceof Shape && await saveGeometry('data/def/${id}', ${id}) && await write('meta/def/${id}', { sha: '${sha}' });`,
                      parseOptions
                    )
                  );
                }
                out.push(parse$2(`Object.freeze(${id});`, parseOptions));
              };

              for (let nth = 0; nth < body.length; nth++) {
                const entry = body[nth];
                if (entry.type === 'VariableDeclaration') {
                  for (const declarator of entry.declarations) {
                    await declareVariable(entry, declarator);
                  }
                  // out.push(entry);
                } else if (entry.type === 'ExportNamedDeclaration') {
                  // Note the names and replace the export with the declaration.
                  const declaration = entry.declaration;
                  if (declaration.type === 'VariableDeclaration') {
                    for (const declarator of declaration.declarations) {
                      await declareVariable(entry.declaration, declarator, {
                        doExport: true,
                      });
                    }
                  }
                  // out.push(entry.declaration);
                } else if (entry.type === 'ImportDeclaration') {
                  // FIX: This works for non-redefinable modules, but not redefinable modules.
                  const entry = body[nth];
                  // Rewrite
                  //   import { foo } from 'bar';
                  //   import Foo from 'bar';
                  // to
                  //   const { foo } = importModule('bar');
                  //   const Foo = importModule('bar');
                  //
                  // FIX: Handle other variations.
                  const { specifiers, source } = entry;

                  if (specifiers.length === 0) {
                    out.push(parse$2(`await importModule('${source.value}');`, parseOptions));
                  } else {
                    for (const { imported, local, type } of specifiers) {
                      switch (type) {
                        case 'ImportDefaultSpecifier':
                          out.push(
                            parse$2(
                              `const ${local.name} = (await importModule('${source.value}')).default;`,
                              parseOptions
                            )
                          );
                          break;
                        case 'ImportSpecifier':
                          if (local.name !== imported.name) {
                            out.push(
                              parse$2(
                                `const { ${imported.name}: ${local.name} } = await importModule('${source.value}');`,
                                parseOptions
                              )
                            );
                          } else {
                            out.push(
                              parse$2(
                                `const { ${imported.name} } = await importModule('${source.value}');`,
                                parseOptions
                              )
                            );
                          }
                          break;
                      }
                    }
                  }
                } else if (
                  entry.type === 'ExpressionStatement' &&
                  entry.expression.type === 'ObjectExpression'
                ) {
                  out.push(entry);
                } else {
                  out.push(entry);
                }
              }

              // Return the exports as an object.
              out.push(parse$2(`return { ${exportNames.join(', ')} };`, parseOptions));

              const result =
                '\n' + generate(parse$2(out.map(generate).join('\n'), parseOptions));
              return result;
            };

            // FIX: Avoid the extra read-write cycle.
            const view = (
              shape,
              { path, width = 1024, height = 512, position = [100, -100, 100] } = {}
            ) => {
              let nth = 0;
              for (const entry of ensurePages(shape.toDisjointGeometry())) {
                if (path) {
                  const nthPath = `${path}_${nth++}`;
                  addPending(write(nthPath, entry));
                  emit$1({ view: { width, height, position, path: nthPath } });
                } else {
                  emit$1({ view: { width, height, position, geometry: entry } });
                }
              }
              return shape;
            };

            Shape.prototype.view = function ({
              path,
              width = 512,
              height = 256,
              position = [100, -100, 100],
            } = {}) {
              return view(this, { path, width, height, position });
            };

            Shape.prototype.smallView = function ({
              path,
              width = 256,
              height = 128,
              position = [100, -100, 100],
            } = {}) {
              return view(this, { path, width, height, position });
            };

            Shape.prototype.bigView = function ({
              path,
              width = 1024,
              height = 512,
              position = [100, -100, 100],
            } = {}) {
              return view(this, { path, width, height, position });
            };

            Shape.prototype.topView = function ({
              path,
              width = 512,
              height = 256,
              position = [0, 0, 100],
            } = {}) {
              return view(this, { path, width, height, position });
            };

            Shape.prototype.smallTopView = function ({
              path,
              width = 256,
              height = 128,
              position = [0, 0, 100],
            } = {}) {
              return view(this, { path, width, height, position });
            };

            Shape.prototype.bigTopView = function ({
              path,
              width = 1024,
              height = 512,
              position = [0, 0, 100],
            } = {}) {
              return view(this, { path, width, height, position });
            };

            Shape.prototype.frontView = function ({
              path,
              width = 512,
              height = 256,
              position = [0, -100, 0],
            } = {}) {
              return view(this, { path, width, height, position });
            };

            Shape.prototype.smallFrontView = function ({
              path,
              width = 256,
              height = 128,
              position = [0, -100, 0],
            } = {}) {
              return view(this, { path, width, height, position });
            };

            Shape.prototype.bigFrontView = function ({
              path,
              width = 1024,
              height = 512,
              position = [0, -100, 0],
            } = {}) {
              return view(this, { path, width, height, position });
            };

            Shape.prototype.sideView = function ({
              path,
              width = 512,
              height = 256,
              position = [100, 0, 0],
            } = {}) {
              return view(this, { path, width, height, position });
            };

            Shape.prototype.smallSideView = function ({
              path,
              width = 256,
              height = 128,
              position = [100, 0, 0],
            } = {}) {
              return view(this, { path, width, height, position });
            };

            Shape.prototype.bigSideView = function ({
              path,
              width = 1024,
              height = 512,
              position = [100, 0, 0],
            } = {}) {
              return view(this, { path, width, height, position });
            };

            const md = (strings, ...placeholders) => {
              const md = strings.reduce(
                (result, string, i) => result + placeholders[i - 1] + string
              );
              emit$1({ md });
              return md;
            };

            const source = (path, source) => addSource(`cache/${path}`, source);

            /**
             *
             * Defines the interface used by the api to access the rest of the system on
             * behalf of a user. e.g., algorithms and geometries.
             *
             * A user can destructively update this mapping in their code to change what
             * the api uses.
             */

            var api = /*#__PURE__*/Object.freeze({
              __proto__: null,
              Page: Page,
              pack: pack$1,
              md: md,
              source: source,
              emit: emit$1,
              read: read,
              write: write,
              Connector: Connector,
              X: X$2$2,
              Y: Y$2$2,
              Z: Z$1$7,
              ChainedHull: ChainedHull,
              Hull: Hull,
              Loop: Loop,
              Shape: Shape,
              loadGeometry: loadGeometry,
              log: log$2,
              saveGeometry: saveGeometry,
              Line2: Line2,
              Plan: Plan,
              Shell: Shell,
              BenchPlane: BenchPlane,
              BenchSaw: BenchSaw,
              DrillPress: DrillPress,
              HoleRouter: HoleRouter,
              LineRouter: LineRouter,
              ProfileRouter: ProfileRouter,
              Arc: Arc,
              Assembly: Assembly,
              Circle: Circle,
              Cone: Cone,
              Cube: Cube,
              Cylinder: Cylinder,
              Difference: Difference,
              Empty: Empty,
              Hexagon: Hexagon,
              Icosahedron: Icosahedron,
              Intersection: Intersection,
              Layers: Layers,
              Line: Line,
              Path: Path,
              Point: Point,
              Points: Points,
              Polygon: Polygon,
              Polyhedron: Polyhedron,
              Prism: Prism,
              Sphere: Sphere,
              Spiral: Spiral,
              Square: Square,
              Tetrahedron: Tetrahedron,
              Torus: Torus,
              Triangle: Triangle,
              Union: Union,
              Void: Void,
              Wave: Wave,
              Item: Item$3,
              Noise: Noise,
              Random: Random,
              acos: acos,
              cos: cos,
              ease: ease,
              max: max$1,
              min: min$1,
              numbers: numbers,
              sin: sin$1,
              sqrt: sqrt,
              vec: vec,
              foot: foot,
              inch: inch,
              mm: mm,
              mil: mil,
              cm: cm,
              m: m$1,
              thou: thou,
              yard: yard
            });

            const DYNAMIC_MODULES = new Map();

            const registerDynamicModule = (bare, path) =>
              DYNAMIC_MODULES.set(bare, path);

            const buildImportModule = (api) => async (name, { src } = {}) => {
              const internalModule = DYNAMIC_MODULES.get(name);
              if (internalModule !== undefined) {
                const module = await new Promise(function (resolve, reject) { require([internalModule], function (m) { resolve(_interopNamespace(m)); }, reject) });
                return module;
              }
              let script;
              if (script === undefined) {
                const path = `source/${name}`;
                const sources = [];
                if (src) {
                  sources.push(src);
                }
                sources.push(name);
                script = await read(path, { sources, decode: 'utf8' });
              }
              if (script === undefined) {
                throw Error(`Cannot import module ${name}`);
              }
              const ecmascript = await toEcmascript(script);
              const builder = new Function(
                `{ ${Object.keys(api).join(', ')} }`,
                `return async () => { ${ecmascript} };`
              );
              const module = await builder(api);
              const exports = await module();
              return exports;
            };

            const extendedApi = { ...api, toSvg };

            const importModule = buildImportModule(extendedApi);

            extendedApi.importModule = importModule;

            // Register Dynamic libraries.

            const module = (name) => `@jsxcad/api-v1-${name}`;

            registerDynamicModule(module('armature'), './jsxcad-api-v1-armature.js');
            registerDynamicModule(module('connector'), './jsxcad-api-v1-connector.js');
            registerDynamicModule(module('cursor'), './jsxcad-api-v1-cursor.js');
            registerDynamicModule(module('deform'), './jsxcad-api-v1-deform.js');
            registerDynamicModule(module('dst'), './jsxcad-api-v1-dst.js');
            registerDynamicModule(module('dxf'), './jsxcad-api-v1-dxf.js');
            registerDynamicModule(module('extrude'), './jsxcad-api-v1-extrude.js');
            registerDynamicModule(module('font'), './jsxcad-api-v1-font.js');
            registerDynamicModule(module('gcode'), './jsxcad-api-v1-gcode.js');
            registerDynamicModule(module('item'), './jsxcad-api-v1-item.js');
            registerDynamicModule(module('layout'), './jsxcad-api-v1-layout.js');
            registerDynamicModule(module('math'), './jsxcad-api-v1-math.js');
            registerDynamicModule(module('pdf'), './jsxcad-api-v1-pdf.js');
            registerDynamicModule(module('plan'), './jsxcad-api-v1-plan.js');
            registerDynamicModule(module('plans'), './jsxcad-api-v1-plans.js');
            registerDynamicModule(module('png'), './jsxcad-api-v1-png.js');
            registerDynamicModule(module('shape'), './jsxcad-api-v1-shape.js');
            registerDynamicModule(module('shapefile'), './jsxcad-api-v1-shapefile.js');
            registerDynamicModule(module('shapes'), './jsxcad-api-v1-shapes.js');
            registerDynamicModule(module('shell'), './jsxcad-api-v1-shell.js');
            registerDynamicModule(module('stl'), './jsxcad-api-v1-stl.js');
            registerDynamicModule(module('svg'), './jsxcad-api-v1-svg.js');
            registerDynamicModule(module('threejs'), './jsxcad-api-v1-threejs.js');
            registerDynamicModule(module('units'), './jsxcad-api-v1-units.js');

            var api$1 = /*#__PURE__*/Object.freeze({
                        __proto__: null,
                        importModule: importModule,
                        md: md,
                        source: source,
                        emit: emit$1,
                        read: read,
                        write: write,
                        Shape: Shape,
                        loadGeometry: loadGeometry,
                        log: log$2,
                        saveGeometry: saveGeometry,
                        Page: Page,
                        pack: pack$1,
                        Connector: Connector,
                        X: X$2$2,
                        Y: Y$2$2,
                        Z: Z$1$7,
                        ChainedHull: ChainedHull,
                        Hull: Hull,
                        Loop: Loop,
                        Line2: Line2,
                        Plan: Plan,
                        Shell: Shell,
                        BenchPlane: BenchPlane,
                        BenchSaw: BenchSaw,
                        DrillPress: DrillPress,
                        HoleRouter: HoleRouter,
                        LineRouter: LineRouter,
                        ProfileRouter: ProfileRouter,
                        Arc: Arc,
                        Assembly: Assembly,
                        Circle: Circle,
                        Cone: Cone,
                        Cube: Cube,
                        Cylinder: Cylinder,
                        Difference: Difference,
                        Empty: Empty,
                        Hexagon: Hexagon,
                        Icosahedron: Icosahedron,
                        Intersection: Intersection,
                        Layers: Layers,
                        Line: Line,
                        Path: Path,
                        Point: Point,
                        Points: Points,
                        Polygon: Polygon,
                        Polyhedron: Polyhedron,
                        Prism: Prism,
                        Sphere: Sphere,
                        Spiral: Spiral,
                        Square: Square,
                        Tetrahedron: Tetrahedron,
                        Torus: Torus,
                        Triangle: Triangle,
                        Union: Union,
                        Void: Void,
                        Wave: Wave,
                        Item: Item$3,
                        Noise: Noise,
                        Random: Random,
                        acos: acos,
                        cos: cos,
                        ease: ease,
                        max: max$1,
                        min: min$1,
                        numbers: numbers,
                        sin: sin$1,
                        sqrt: sqrt,
                        vec: vec,
                        cm: cm,
                        foot: foot,
                        inch: inch,
                        m: m$1,
                        mil: mil,
                        mm: mm,
                        thou: thou,
                        yard: yard
            });

            const pointsToThreejsPoints = (points) => points;

            const solidToThreejsSolid = (solid) => {
              const normals = [];
              const positions = [];
              for (const surface of solid) {
                for (const triangle of toTriangles({}, surface)) {
                  const plane = toPlane(triangle);
                  if (plane === undefined) {
                    continue;
                  }
                  const [px, py, pz] = plane;
                  for (const [x = 0, y = 0, z = 0] of triangle) {
                    normals.push(px, py, pz);
                    positions.push(x, y, z);
                  }
                }
              }
              return { normals, positions };
            };

            const surfaceToThreejsSurface = (surface) => {
              const normals = [];
              const positions = [];
              for (const triangle of toTriangles({}, surface)) {
                const plane = toPlane(triangle);
                if (plane === undefined) {
                  continue;
                }
                const [px, py, pz] = plane;
                for (const [x = 0, y = 0, z = 0] of triangle) {
                  normals.push(px, py, pz);
                  positions.push(x, y, z);
                }
              }
              return { normals, positions };
            };

            const toThreejsGeometry = (geometry, supertags) => {
              const tags = [...(supertags || []), ...(geometry.tags || [])];
              if (tags.includes('compose/non-positive')) {
                return;
              }
              if (geometry.isThreejsGeometry) {
                return geometry;
              }
              switch (geometry.type) {
                case 'layout':
                case 'assembly':
                case 'disjointAssembly':
                case 'layers':
                  return {
                    type: 'assembly',
                    content: geometry.content.map((content) =>
                      toThreejsGeometry(content, tags)
                    ),
                    tags,
                    isThreejsGeometry: true,
                  };
                case 'sketch':
                  return {
                    type: 'sketch',
                    content: geometry.content.map((content) =>
                      toThreejsGeometry(content, tags)
                    ),
                    tags,
                    isThreejsGeometry: true,
                  };
                case 'item':
                  return {
                    type: 'item',
                    content: geometry.content.map((content) =>
                      toThreejsGeometry(content, tags)
                    ),
                    tags,
                    isThreejsGeometry: true,
                  };
                case 'paths':
                  return {
                    type: 'paths',
                    threejsPaths: geometry.paths,
                    tags,
                    isThreejsGeometry: true,
                  };
                case 'plan':
                  return {
                    type: 'plan',
                    threejsPlan: geometry.plan,
                    threejsMarks: geometry.marks,
                    content: geometry.content.map((content) =>
                      toThreejsGeometry(content, tags)
                    ),
                    tags,
                    isThreejsGeometry: true,
                  };
                case 'points':
                  return {
                    type: 'points',
                    threejsPoints: pointsToThreejsPoints(geometry.points),
                    tags,
                    isThreejsGeometry: true,
                  };
                case 'solid':
                  return {
                    type: 'solid',
                    threejsSolid: solidToThreejsSolid(geometry.solid),
                    tags,
                    isThreejsGeometry: true,
                  };
                case 'surface':
                  return {
                    type: 'surface',
                    threejsSurface: surfaceToThreejsSurface(geometry.surface),
                    tags,
                    isThreejsGeometry: true,
                  };
                case 'z0Surface':
                  return {
                    type: 'surface',
                    threejsSurface: surfaceToThreejsSurface(geometry.z0Surface),
                    tags,
                    isThreejsGeometry: true,
                  };
                default:
                  throw Error(`Unexpected geometry: ${geometry.type}`);
              }
            };

            // shim for using process in browser
            // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

            function defaultSetTimout$3() {
                throw new Error('setTimeout has not been defined');
            }
            function defaultClearTimeout$3 () {
                throw new Error('clearTimeout has not been defined');
            }
            var cachedSetTimeout$3 = defaultSetTimout$3;
            var cachedClearTimeout$3 = defaultClearTimeout$3;
            if (typeof global$1.setTimeout === 'function') {
                cachedSetTimeout$3 = setTimeout;
            }
            if (typeof global$1.clearTimeout === 'function') {
                cachedClearTimeout$3 = clearTimeout;
            }

            function runTimeout$3(fun) {
                if (cachedSetTimeout$3 === setTimeout) {
                    //normal enviroments in sane situations
                    return setTimeout(fun, 0);
                }
                // if setTimeout wasn't available but was latter defined
                if ((cachedSetTimeout$3 === defaultSetTimout$3 || !cachedSetTimeout$3) && setTimeout) {
                    cachedSetTimeout$3 = setTimeout;
                    return setTimeout(fun, 0);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedSetTimeout$3(fun, 0);
                } catch(e){
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                        return cachedSetTimeout$3.call(null, fun, 0);
                    } catch(e){
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                        return cachedSetTimeout$3.call(this, fun, 0);
                    }
                }


            }
            function runClearTimeout$3(marker) {
                if (cachedClearTimeout$3 === clearTimeout) {
                    //normal enviroments in sane situations
                    return clearTimeout(marker);
                }
                // if clearTimeout wasn't available but was latter defined
                if ((cachedClearTimeout$3 === defaultClearTimeout$3 || !cachedClearTimeout$3) && clearTimeout) {
                    cachedClearTimeout$3 = clearTimeout;
                    return clearTimeout(marker);
                }
                try {
                    // when when somebody has screwed with setTimeout but no I.E. maddness
                    return cachedClearTimeout$3(marker);
                } catch (e){
                    try {
                        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                        return cachedClearTimeout$3.call(null, marker);
                    } catch (e){
                        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                        // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                        return cachedClearTimeout$3.call(this, marker);
                    }
                }



            }
            var queue$3 = [];
            var draining$3 = false;
            var currentQueue$3;
            var queueIndex$3 = -1;

            function cleanUpNextTick$3() {
                if (!draining$3 || !currentQueue$3) {
                    return;
                }
                draining$3 = false;
                if (currentQueue$3.length) {
                    queue$3 = currentQueue$3.concat(queue$3);
                } else {
                    queueIndex$3 = -1;
                }
                if (queue$3.length) {
                    drainQueue$3();
                }
            }

            function drainQueue$3() {
                if (draining$3) {
                    return;
                }
                var timeout = runTimeout$3(cleanUpNextTick$3);
                draining$3 = true;

                var len = queue$3.length;
                while(len) {
                    currentQueue$3 = queue$3;
                    queue$3 = [];
                    while (++queueIndex$3 < len) {
                        if (currentQueue$3) {
                            currentQueue$3[queueIndex$3].run();
                        }
                    }
                    queueIndex$3 = -1;
                    len = queue$3.length;
                }
                currentQueue$3 = null;
                draining$3 = false;
                runClearTimeout$3(timeout);
            }
            function nextTick$3(fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for (var i = 1; i < arguments.length; i++) {
                        args[i - 1] = arguments[i];
                    }
                }
                queue$3.push(new Item$4(fun, args));
                if (queue$3.length === 1 && !draining$3) {
                    runTimeout$3(drainQueue$3);
                }
            }
            // v8 likes predictible objects
            function Item$4(fun, array) {
                this.fun = fun;
                this.array = array;
            }
            Item$4.prototype.run = function () {
                this.fun.apply(null, this.array);
            };
            var title$3 = 'browser';
            var platform$3 = 'browser';
            var browser$3 = true;
            var env$3 = {};
            var argv$3 = [];
            var version$4 = ''; // empty string to avoid regexp issues
            var versions$3 = {};
            var release$3 = {};
            var config$3 = {};

            function noop$3() {}

            var on$4 = noop$3;
            var addListener$3 = noop$3;
            var once$3 = noop$3;
            var off$3 = noop$3;
            var removeListener$3 = noop$3;
            var removeAllListeners$3 = noop$3;
            var emit$4 = noop$3;

            function binding$3(name) {
                throw new Error('process.binding is not supported');
            }

            function cwd$3 () { return '/' }
            function chdir$3 (dir) {
                throw new Error('process.chdir is not supported');
            }function umask$3() { return 0; }

            // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
            var performance$3 = global$1.performance || {};
            var performanceNow$3 =
              performance$3.now        ||
              performance$3.mozNow     ||
              performance$3.msNow      ||
              performance$3.oNow       ||
              performance$3.webkitNow  ||
              function(){ return (new Date()).getTime() };

            // generate timestamp or delta
            // see http://nodejs.org/api/process.html#process_process_hrtime
            function hrtime$3(previousTimestamp){
              var clocktime = performanceNow$3.call(performance$3)*1e-3;
              var seconds = Math.floor(clocktime);
              var nanoseconds = Math.floor((clocktime%1)*1e9);
              if (previousTimestamp) {
                seconds = seconds - previousTimestamp[0];
                nanoseconds = nanoseconds - previousTimestamp[1];
                if (nanoseconds<0) {
                  seconds--;
                  nanoseconds += 1e9;
                }
              }
              return [seconds,nanoseconds]
            }

            var startTime$3 = new Date();
            function uptime$3() {
              var currentTime = new Date();
              var dif = currentTime - startTime$3;
              return dif / 1000;
            }

            var process$3 = {
              nextTick: nextTick$3,
              title: title$3,
              browser: browser$3,
              env: env$3,
              argv: argv$3,
              version: version$4,
              versions: versions$3,
              on: on$4,
              addListener: addListener$3,
              once: once$3,
              off: off$3,
              removeListener: removeListener$3,
              removeAllListeners: removeAllListeners$3,
              emit: emit$4,
              binding: binding$3,
              cwd: cwd$3,
              chdir: chdir$3,
              umask: umask$3,
              hrtime: hrtime$3,
              platform: platform$3,
              release: release$3,
              config: config$3,
              uptime: uptime$3
            };

            var commonjsGlobal$4 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

            function unwrapExports$7 (x) {
            	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
            }

            function createCommonjsModule$9(fn, module) {
            	return module = { exports: {} }, fn(module, module.exports), module.exports;
            }

            var workerpool = createCommonjsModule$9(function (module, exports) {
            /**
             * workerpool.js
             * https://github.com/josdejong/workerpool
             *
             * Offload tasks to a pool of workers on node.js and in the browser.
             *
             * @version 6.0.0
             * @date    2020-05-13
             *
             * @license
             * Copyright (C) 2014-2020 Jos de Jong <wjosdejong@gmail.com>
             *
             * Licensed under the Apache License, Version 2.0 (the "License"); you may not
             * use this file except in compliance with the License. You may obtain a copy
             * of the License at
             *
             * http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
             * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
             * License for the specific language governing permissions and limitations under
             * the License.
             */

            (function webpackUniversalModuleDefinition(root, factory) {
            	module.exports = factory();
            })((typeof self !== 'undefined' ? self : commonjsGlobal$4), function() {
            return /******/ (function(modules) { // webpackBootstrap
            /******/ 	// The module cache
            /******/ 	var installedModules = {};
            /******/
            /******/ 	// The require function
            /******/ 	function __webpack_require__(moduleId) {
            /******/
            /******/ 		// Check if module is in cache
            /******/ 		if(installedModules[moduleId]) {
            /******/ 			return installedModules[moduleId].exports;
            /******/ 		}
            /******/ 		// Create a new module (and put it into the cache)
            /******/ 		var module = installedModules[moduleId] = {
            /******/ 			i: moduleId,
            /******/ 			l: false,
            /******/ 			exports: {}
            /******/ 		};
            /******/
            /******/ 		// Execute the module function
            /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /******/
            /******/ 		// Flag the module as loaded
            /******/ 		module.l = true;
            /******/
            /******/ 		// Return the exports of the module
            /******/ 		return module.exports;
            /******/ 	}
            /******/
            /******/
            /******/ 	// expose the modules object (__webpack_modules__)
            /******/ 	__webpack_require__.m = modules;
            /******/
            /******/ 	// expose the module cache
            /******/ 	__webpack_require__.c = installedModules;
            /******/
            /******/ 	// define getter function for harmony exports
            /******/ 	__webpack_require__.d = function(exports, name, getter) {
            /******/ 		if(!__webpack_require__.o(exports, name)) {
            /******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
            /******/ 		}
            /******/ 	};
            /******/
            /******/ 	// define __esModule on exports
            /******/ 	__webpack_require__.r = function(exports) {
            /******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
            /******/ 		}
            /******/ 		Object.defineProperty(exports, '__esModule', { value: true });
            /******/ 	};
            /******/
            /******/ 	// create a fake namespace object
            /******/ 	// mode & 1: value is a module id, require it
            /******/ 	// mode & 2: merge all properties of value into the ns
            /******/ 	// mode & 4: return value when already ns object
            /******/ 	// mode & 8|1: behave like require
            /******/ 	__webpack_require__.t = function(value, mode) {
            /******/ 		if(mode & 1) value = __webpack_require__(value);
            /******/ 		if(mode & 8) return value;
            /******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
            /******/ 		var ns = Object.create(null);
            /******/ 		__webpack_require__.r(ns);
            /******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
            /******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
            /******/ 		return ns;
            /******/ 	};
            /******/
            /******/ 	// getDefaultExport function for compatibility with non-harmony modules
            /******/ 	__webpack_require__.n = function(module) {
            /******/ 		var getter = module && module.__esModule ?
            /******/ 			function getDefault() { return module['default']; } :
            /******/ 			function getModuleExports() { return module; };
            /******/ 		__webpack_require__.d(getter, 'a', getter);
            /******/ 		return getter;
            /******/ 	};
            /******/
            /******/ 	// Object.prototype.hasOwnProperty.call
            /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
            /******/
            /******/ 	// __webpack_public_path__
            /******/ 	__webpack_require__.p = "";
            /******/
            /******/
            /******/ 	// Load entry module and return exports
            /******/ 	return __webpack_require__(__webpack_require__.s = 3);
            /******/ })
            /************************************************************************/
            /******/ ([
            /* 0 */
            /***/ (function(module, exports, __webpack_require__) {

            var requireFoolWebpack = __webpack_require__(2);

            // source: https://github.com/flexdinesh/browser-or-node
            var isNode = function (nodeProcess) {
              return (
                typeof nodeProcess !== 'undefined' &&
                nodeProcess.versions != null &&
                nodeProcess.versions.node != null
              );
            };
            module.exports.isNode = isNode;

            // determines the JavaScript platform: browser or node
            module.exports.platform = typeof process$3 !== 'undefined' && isNode(process$3)
              ? 'node'
              : 'browser';

            // determines whether the code is running in main thread or not
            // note that in node.js we have to check both worker_thread and child_process
            var worker_threads = tryRequireFoolWebpack('worker_threads');
            module.exports.isMainThread = module.exports.platform === 'node'
              ? ((!worker_threads || worker_threads.isMainThread) && !process$3.connected)
              : typeof Window !== 'undefined';

            // determines the number of cpus available
            module.exports.cpus = module.exports.platform === 'browser'
              ? self.navigator.hardwareConcurrency
              : requireFoolWebpack('os').cpus().length;

            function tryRequireFoolWebpack (module) {
              try {
                return requireFoolWebpack(module);
              } catch(err) {
                return null
              }
            }


            /***/ }),
            /* 1 */
            /***/ (function(module, exports, __webpack_require__) {


            /**
             * Promise
             *
             * Inspired by https://gist.github.com/RubaXa/8501359 from RubaXa <trash@rubaxa.org>
             *
             * @param {Function} handler   Called as handler(resolve: Function, reject: Function)
             * @param {Promise} [parent]   Parent promise for propagation of cancel and timeout
             */
            function Promise(handler, parent) {
              var me = this;

              if (!(this instanceof Promise)) {
                throw new SyntaxError('Constructor must be called with the new operator');
              }

              if (typeof handler !== 'function') {
                throw new SyntaxError('Function parameter handler(resolve, reject) missing');
              }

              var _onSuccess = [];
              var _onFail = [];

              // status
              this.resolved = false;
              this.rejected = false;
              this.pending = true;

              /**
               * Process onSuccess and onFail callbacks: add them to the queue.
               * Once the promise is resolve, the function _promise is replace.
               * @param {Function} onSuccess
               * @param {Function} onFail
               * @private
               */
              var _process = function (onSuccess, onFail) {
                _onSuccess.push(onSuccess);
                _onFail.push(onFail);
              };

              /**
               * Add an onSuccess callback and optionally an onFail callback to the Promise
               * @param {Function} onSuccess
               * @param {Function} [onFail]
               * @returns {Promise} promise
               */
              this.then = function (onSuccess, onFail) {
                return new Promise(function (resolve, reject) {
                  var s = onSuccess ? _then(onSuccess, resolve, reject) : resolve;
                  var f = onFail    ? _then(onFail,    resolve, reject) : reject;

                  _process(s, f);
                }, me);
              };

              /**
               * Resolve the promise
               * @param {*} result
               * @type {Function}
               */
              var _resolve = function (result) {
                // update status
                me.resolved = true;
                me.rejected = false;
                me.pending = false;

                _onSuccess.forEach(function (fn) {
                  fn(result);
                });

                _process = function (onSuccess, onFail) {
                  onSuccess(result);
                };

                _resolve = _reject = function () { };

                return me;
              };

              /**
               * Reject the promise
               * @param {Error} error
               * @type {Function}
               */
              var _reject = function (error) {
                // update status
                me.resolved = false;
                me.rejected = true;
                me.pending = false;

                _onFail.forEach(function (fn) {
                  fn(error);
                });

                _process = function (onSuccess, onFail) {
                  onFail(error);
                };

                _resolve = _reject = function () { };

                return me;
              };

              /**
               * Cancel te promise. This will reject the promise with a CancellationError
               * @returns {Promise} self
               */
              this.cancel = function () {
                if (parent) {
                  parent.cancel();
                }
                else {
                  _reject(new CancellationError());
                }

                return me;
              };

              /**
               * Set a timeout for the promise. If the promise is not resolved within
               * the time, the promise will be cancelled and a TimeoutError is thrown.
               * If the promise is resolved in time, the timeout is removed.
               * @param {number} delay     Delay in milliseconds
               * @returns {Promise} self
               */
              this.timeout = function (delay) {
                if (parent) {
                  parent.timeout(delay);
                }
                else {
                  var timer = setTimeout(function () {
                    _reject(new TimeoutError('Promise timed out after ' + delay + ' ms'));
                  }, delay);

                  me.always(function () {
                    clearTimeout(timer);
                  });
                }

                return me;
              };

              // attach handler passing the resolve and reject functions
              handler(function (result) {
                _resolve(result);
              }, function (error) {
                _reject(error);
              });
            }

            /**
             * Execute given callback, then call resolve/reject based on the returned result
             * @param {Function} callback
             * @param {Function} resolve
             * @param {Function} reject
             * @returns {Function}
             * @private
             */
            function _then(callback, resolve, reject) {
              return function (result) {
                try {
                  var res = callback(result);
                  if (res && typeof res.then === 'function' && typeof res['catch'] === 'function') {
                    // method returned a promise
                    res.then(resolve, reject);
                  }
                  else {
                    resolve(res);
                  }
                }
                catch (error) {
                  reject(error);
                }
              }
            }

            /**
             * Add an onFail callback to the Promise
             * @param {Function} onFail
             * @returns {Promise} promise
             */
            Promise.prototype['catch'] = function (onFail) {
              return this.then(null, onFail);
            };

            // TODO: add support for Promise.catch(Error, callback)
            // TODO: add support for Promise.catch(Error, Error, callback)

            /**
             * Execute given callback when the promise either resolves or rejects.
             * @param {Function} fn
             * @returns {Promise} promise
             */
            Promise.prototype.always = function (fn) {
              return this.then(fn, fn);
            };

            /**
             * Create a promise which resolves when all provided promises are resolved,
             * and fails when any of the promises resolves.
             * @param {Promise[]} promises
             * @returns {Promise} promise
             */
            Promise.all = function (promises){
              return new Promise(function (resolve, reject) {
                var remaining = promises.length,
                    results = [];

                if (remaining) {
                  promises.forEach(function (p, i) {
                    p.then(function (result) {
                      results[i] = result;
                      remaining--;
                      if (remaining == 0) {
                        resolve(results);
                      }
                    }, function (error) {
                      remaining = 0;
                      reject(error);
                    });
                  });
                }
                else {
                  resolve(results);
                }
              });
            };

            /**
             * Create a promise resolver
             * @returns {{promise: Promise, resolve: Function, reject: Function}} resolver
             */
            Promise.defer = function () {
              var resolver = {};

              resolver.promise = new Promise(function (resolve, reject) {
                resolver.resolve = resolve;
                resolver.reject = reject;
              });

              return resolver;
            };

            /**
             * Create a cancellation error
             * @param {String} [message]
             * @extends Error
             */
            function CancellationError(message) {
              this.message = message || 'promise cancelled';
              this.stack = (new Error()).stack;
            }

            CancellationError.prototype = new Error();
            CancellationError.prototype.constructor = Error;
            CancellationError.prototype.name = 'CancellationError';

            Promise.CancellationError = CancellationError;


            /**
             * Create a timeout error
             * @param {String} [message]
             * @extends Error
             */
            function TimeoutError(message) {
              this.message = message || 'timeout exceeded';
              this.stack = (new Error()).stack;
            }

            TimeoutError.prototype = new Error();
            TimeoutError.prototype.constructor = Error;
            TimeoutError.prototype.name = 'TimeoutError';

            Promise.TimeoutError = TimeoutError;


            module.exports = Promise;


            /***/ }),
            /* 2 */
            /***/ (function(module, exports) {

            // source of inspiration: https://github.com/sindresorhus/require-fool-webpack
            var requireFoolWebpack = eval(
                'typeof require !== \'undefined\' ' +
                '? require ' +
                ': function (module) { throw new Error(\'Module " + module + " not found.\') }'
            );

            module.exports = requireFoolWebpack;


            /***/ }),
            /* 3 */
            /***/ (function(module, exports, __webpack_require__) {

            var environment = __webpack_require__(0);

            /**
             * Create a new worker pool
             * @param {string} [script]
             * @param {WorkerPoolOptions} [options]
             * @returns {Pool} pool
             */
            exports.pool = function pool(script, options) {
              var Pool = __webpack_require__(4);

              return new Pool(script, options);
            };

            /**
             * Create a worker and optionally register a set of methods to the worker.
             * @param {Object} [methods]
             */
            exports.worker = function worker(methods) {
              var worker = __webpack_require__(8);
              worker.add(methods);
            };

            /**
             * Create a promise.
             * @type {Promise} promise
             */
            exports.Promise = __webpack_require__(1);

            exports.platform = environment.platform;
            exports.isMainThread = environment.isMainThread;
            exports.cpus = environment.cpus;

            /***/ }),
            /* 4 */
            /***/ (function(module, exports, __webpack_require__) {

            var Promise = __webpack_require__(1);
            var WorkerHandler = __webpack_require__(5);
            var environment = __webpack_require__(0);
            var DebugPortAllocator = __webpack_require__(7);
            var DEBUG_PORT_ALLOCATOR = new DebugPortAllocator();
            /**
             * A pool to manage workers
             * @param {String} [script]   Optional worker script
             * @param {WorkerPoolOptions} [options]  See docs
             * @constructor
             */
            function Pool(script, options) {
              if (typeof script === 'string') {
                this.script = script || null;
              }
              else {
                this.script = null;
                options = script;
              }

              this.workers = [];  // queue with all workers
              this.tasks = [];    // queue with tasks awaiting execution

              options = options || {};

              this.forkArgs = options.forkArgs || [];
              this.forkOpts = options.forkOpts || {};
              this.debugPortStart = (options.debugPortStart || 43210);
              this.nodeWorker = options.nodeWorker;
              this.workerType = options.workerType || options.nodeWorker || 'auto';
              this.maxQueueSize = options.maxQueueSize || Infinity;

              // configuration
              if (options && 'maxWorkers' in options) {
                validateMaxWorkers(options.maxWorkers);
                this.maxWorkers = options.maxWorkers;
              }
              else {
                this.maxWorkers = Math.max((environment.cpus || 4) - 1, 1);
              }

              if (options && 'minWorkers' in options) {
                if(options.minWorkers === 'max') {
                  this.minWorkers = this.maxWorkers;
                } else {
                  validateMinWorkers(options.minWorkers);
                  this.minWorkers = options.minWorkers;
                  this.maxWorkers = Math.max(this.minWorkers, this.maxWorkers);     // in case minWorkers is higher than maxWorkers
                }
                this._ensureMinWorkers();
              }

              this._boundNext = this._next.bind(this);


              if (this.workerType === 'thread') {
                WorkerHandler.ensureWorkerThreads();
              }
            }


            /**
             * Execute a function on a worker.
             *
             * Example usage:
             *
             *   var pool = new Pool()
             *
             *   // call a function available on the worker
             *   pool.exec('fibonacci', [6])
             *
             *   // offload a function
             *   function add(a, b) {
             *     return a + b
             *   };
             *   pool.exec(add, [2, 4])
             *       .then(function (result) {
             *         console.log(result); // outputs 6
             *       })
             *       .catch(function(error) {
             *         console.log(error);
             *       });
             *
             * @param {String | Function} method  Function name or function.
             *                                    If `method` is a string, the corresponding
             *                                    method on the worker will be executed
             *                                    If `method` is a Function, the function
             *                                    will be stringified and executed via the
             *                                    workers built-in function `run(fn, args)`.
             * @param {Array} [params]  Function arguments applied when calling the function
             * @return {Promise.<*, Error>} result
             */
            Pool.prototype.exec = function (method, params) {
              // validate type of arguments
              if (params && !Array.isArray(params)) {
                throw new TypeError('Array expected as argument "params"');
              }

              if (typeof method === 'string') {
                var resolver = Promise.defer();

                if (this.tasks.length >= this.maxQueueSize) {
                  throw new Error('Max queue size of ' + this.maxQueueSize + ' reached');
                }

                // add a new task to the queue
                var tasks = this.tasks;
                var task = {
                  method:  method,
                  params:  params,
                  resolver: resolver,
                  timeout: null
                };
                tasks.push(task);

                // replace the timeout method of the Promise with our own,
                // which starts the timer as soon as the task is actually started
                var originalTimeout = resolver.promise.timeout;
                resolver.promise.timeout = function timeout (delay) {
                  if (tasks.indexOf(task) !== -1) {
                    // task is still queued -> start the timer later on
                    task.timeout = delay;
                    return resolver.promise;
                  }
                  else {
                    // task is already being executed -> start timer immediately
                    return originalTimeout.call(resolver.promise, delay);
                  }
                };

                // trigger task execution
                this._next();

                return resolver.promise;
              }
              else if (typeof method === 'function') {
                // send stringified function and function arguments to worker
                return this.exec('run', [String(method), params]);
              }
              else {
                throw new TypeError('Function or string expected as argument "method"');
              }
            };

            /**
             * Create a proxy for current worker. Returns an object containing all
             * methods available on the worker. The methods always return a promise.
             *
             * @return {Promise.<Object, Error>} proxy
             */
            Pool.prototype.proxy = function () {
              if (arguments.length > 0) {
                throw new Error('No arguments expected');
              }

              var pool = this;
              return this.exec('methods')
                  .then(function (methods) {
                    var proxy = {};

                    methods.forEach(function (method) {
                      proxy[method] = function () {
                        return pool.exec(method, Array.prototype.slice.call(arguments));
                      };
                    });

                    return proxy;
                  });
            };

            /**
             * Creates new array with the results of calling a provided callback function
             * on every element in this array.
             * @param {Array} array
             * @param {function} callback  Function taking two arguments:
             *                             `callback(currentValue, index)`
             * @return {Promise.<Array>} Returns a promise which resolves  with an Array
             *                           containing the results of the callback function
             *                           executed for each of the array elements.
             */
            /* TODO: implement map
            Pool.prototype.map = function (array, callback) {
            };
            */

            /**
             * Grab the first task from the queue, find a free worker, and assign the
             * worker to the task.
             * @protected
             */
            Pool.prototype._next = function () {
              if (this.tasks.length > 0) {
                // there are tasks in the queue

                // find an available worker
                var worker = this._getWorker();
                if (worker) {
                  // get the first task from the queue
                  var me = this;
                  var task = this.tasks.shift();

                  // check if the task is still pending (and not cancelled -> promise rejected)
                  if (task.resolver.promise.pending) {
                    // send the request to the worker
                    var promise = worker.exec(task.method, task.params, task.resolver)
                      .then(me._boundNext)
                      .catch(function () {
                        // if the worker crashed and terminated, remove it from the pool
                        if (worker.terminated) {
                          me._removeWorker(worker);
                          // If minWorkers set, spin up new workers to replace the crashed ones
                          me._ensureMinWorkers();
                        }
                        me._next(); // trigger next task in the queue
                      });

                    // start queued timer now
                    if (typeof task.timeout === 'number') {
                      promise.timeout(task.timeout);
                    }
                  } else {
                    // The task taken was already complete (either rejected or resolved), so just trigger next task in the queue
                    me._next();
                  }
                }
              }
            };

            /**
             * Get an available worker. If no worker is available and the maximum number
             * of workers isn't yet reached, a new worker will be created and returned.
             * If no worker is available and the maximum number of workers is reached,
             * null will be returned.
             *
             * @return {WorkerHandler | null} worker
             * @private
             */
            Pool.prototype._getWorker = function() {
              // find a non-busy worker
              var workers = this.workers;
              for (var i = 0; i < workers.length; i++) {
                var worker = workers[i];
                if (worker.busy() === false) {
                  return worker;
                }
              }

              if (workers.length < this.maxWorkers) {
                // create a new worker
                worker = this._createWorkerHandler();
                workers.push(worker);
                return worker;
              }

              return null;
            };

            /**
             * Remove a worker from the pool. For example after a worker terminated for
             * whatever reason
             * @param {WorkerHandler} worker
             * @protected
             */
            Pool.prototype._removeWorker = function(worker) {
              DEBUG_PORT_ALLOCATOR.releasePort(worker.debugPort);
              // terminate the worker (if not already terminated)
              worker.terminate();
              this._removeWorkerFromList(worker);
            };

            /**
             * Remove a worker from the pool list.
             * @param {WorkerHandler} worker
             * @protected
             */
            Pool.prototype._removeWorkerFromList = function(worker) {
              // remove from the list with workers
              var index = this.workers.indexOf(worker);
              if (index !== -1) {
                this.workers.splice(index, 1);
              }
            };

            /**
             * Close all active workers. Tasks currently being executed will be finished first.
             * @param {boolean} [force=false]   If false (default), the workers are terminated
             *                                  after finishing all tasks currently in
             *                                  progress. If true, the workers will be
             *                                  terminated immediately.
             * @param {number} [timeout]        If provided and non-zero, worker termination promise will be rejected
             *                                  after timeout if worker process has not been terminated.
             * @return {Promise.<void, Error>}
             */
            Pool.prototype.terminate = function (force, timeout) {
              // cancel any pending tasks
              this.tasks.forEach(function (task) {
                task.resolver.reject(new Error('Pool terminated'));
              });
              this.tasks.length = 0;

              var f = function (worker) {
                this._removeWorkerFromList(worker);
              };
              var removeWorker = f.bind(this);

              var promises = [];
              var workers = this.workers.slice();
              workers.forEach(function (worker) {
                var termPromise = worker.terminateAndNotify(force, timeout)
                  .then(removeWorker);
                promises.push(termPromise);
              });
              return Promise.all(promises);
            };

            /**
             * Retrieve statistics on tasks and workers.
             * @return {{totalWorkers: number, busyWorkers: number, idleWorkers: number, pendingTasks: number, activeTasks: number}} Returns an object with statistics
             */
            Pool.prototype.stats = function () {
              var totalWorkers = this.workers.length;
              var busyWorkers = this.workers.filter(function (worker) {
                return worker.busy();
              }).length;

              return {
                totalWorkers:  totalWorkers,
                busyWorkers:   busyWorkers,
                idleWorkers:   totalWorkers - busyWorkers,

                pendingTasks:  this.tasks.length,
                activeTasks:   busyWorkers
              };
            };

            /**
             * Ensures that a minimum of minWorkers is up and running
             * @protected
             */
            Pool.prototype._ensureMinWorkers = function() {
              if (this.minWorkers) {
                for(var i = this.workers.length; i < this.minWorkers; i++) {
                  this.workers.push(this._createWorkerHandler());
                }
              }
            };

            /**
             * Helper function to create a new WorkerHandler and pass all options.
             * @return {WorkerHandler}
             * @private
             */
            Pool.prototype._createWorkerHandler = function () {
              return new WorkerHandler(this.script, {
                forkArgs: this.forkArgs,
                forkOpts: this.forkOpts,
                debugPort: DEBUG_PORT_ALLOCATOR.nextAvailableStartingAt(this.debugPortStart),
                workerType: this.workerType
              });
            };

            /**
             * Ensure that the maxWorkers option is an integer >= 1
             * @param {*} maxWorkers
             * @returns {boolean} returns true maxWorkers has a valid value
             */
            function validateMaxWorkers(maxWorkers) {
              if (!isNumber(maxWorkers) || !isInteger(maxWorkers) || maxWorkers < 1) {
                throw new TypeError('Option maxWorkers must be an integer number >= 1');
              }
            }

            /**
             * Ensure that the minWorkers option is an integer >= 0
             * @param {*} minWorkers
             * @returns {boolean} returns true when minWorkers has a valid value
             */
            function validateMinWorkers(minWorkers) {
              if (!isNumber(minWorkers) || !isInteger(minWorkers) || minWorkers < 0) {
                throw new TypeError('Option minWorkers must be an integer number >= 0');
              }
            }

            /**
             * Test whether a variable is a number
             * @param {*} value
             * @returns {boolean} returns true when value is a number
             */
            function isNumber(value) {
              return typeof value === 'number';
            }

            /**
             * Test whether a number is an integer
             * @param {number} value
             * @returns {boolean} Returns true if value is an integer
             */
            function isInteger(value) {
              return Math.round(value) == value;
            }

            module.exports = Pool;


            /***/ }),
            /* 5 */
            /***/ (function(module, exports, __webpack_require__) {


            var Promise = __webpack_require__(1);
            var environment = __webpack_require__(0);
            var requireFoolWebpack = __webpack_require__(2);

            function ensureWorkerThreads() {
              var WorkerThreads = tryRequireWorkerThreads();
              if (!WorkerThreads) {
                throw new Error('WorkerPool: workerType = \'thread\' is not supported, Node >= 11.7.0 required')
              }

              return WorkerThreads;
            }

            // check whether Worker is supported by the browser
            function ensureWebWorker() {
              // Workaround for a bug in PhantomJS (Or QtWebkit): https://github.com/ariya/phantomjs/issues/14534
              if (typeof Worker !== 'function' && (typeof Worker !== 'object' || typeof Worker.prototype.constructor !== 'function')) {
                throw new Error('WorkerPool: Web Workers not supported');
              }
            }

            function tryRequireWorkerThreads() {
              try {
                return requireFoolWebpack('worker_threads');
              } catch(error) {
                if (typeof error === 'object' && error !== null && error.code === 'MODULE_NOT_FOUND') {
                  // no worker_threads available (old version of node.js)
                  return null;
                } else {
                  throw error;
                }
              }
            }

            // get the default worker script
            function getDefaultWorker() {
              if (environment.platform === 'browser') {
                // test whether the browser supports all features that we need
                if (typeof Blob === 'undefined') {
                  throw new Error('Blob not supported by the browser');
                }
                if (!window.URL || typeof window.URL.createObjectURL !== 'function') {
                  throw new Error('URL.createObjectURL not supported by the browser');
                }

                // use embedded worker.js
                var blob = new Blob([__webpack_require__(6)], {type: 'text/javascript'});
                return window.URL.createObjectURL(blob);
              }
              else {
                // use external worker.js in current directory
                return "" + '/worker.js';
              }
            }

            function setupWorker(script, options) {
              if (options.workerType === 'web') { // browser only
                ensureWebWorker();
                return setupBrowserWorker(script, Worker);
              } else if (options.workerType === 'thread') { // node.js only
                WorkerThreads = ensureWorkerThreads();
                return setupWorkerThreadWorker(script, WorkerThreads);
              } else if (options.workerType === 'process' || !options.workerType) { // node.js only
                return setupProcessWorker(script, resolveForkOptions(options), requireFoolWebpack('child_process'));
              } else { // options.workerType === 'auto' or undefined
                if (environment.platform === 'browser') {
                  ensureWebWorker();
                  return setupBrowserWorker(script, Worker);
                }
                else { // environment.platform === 'node'
                  var WorkerThreads = tryRequireWorkerThreads();
                  if (WorkerThreads) {
                    return setupWorkerThreadWorker(script, WorkerThreads);
                  } else {
                    return setupProcessWorker(script, resolveForkOptions(options), requireFoolWebpack('child_process'));
                  }
                }
              }
            }

            function setupBrowserWorker(script, Worker) {
              // create the web worker
              var worker = new Worker(script);

              worker.isBrowserWorker = true;
              // add node.js API to the web worker
              worker.on = function (event, callback) {
                this.addEventListener(event, function (message) {
                  callback(message.data);
                });
              };
              worker.send = function (message) {
                this.postMessage(message);
              };
              return worker;
            }

            function setupWorkerThreadWorker(script, WorkerThreads) {
              var worker = new WorkerThreads.Worker(script, {
                stdout: false, // automatically pipe worker.STDOUT to process.STDOUT
                stderr: false  // automatically pipe worker.STDERR to process.STDERR
              });
              worker.isWorkerThread = true;
              // make the worker mimic a child_process
              worker.send = function(message) {
                this.postMessage(message);
              };

              worker.kill = function() {
                this.terminate();
              };

              worker.disconnect = function() {
                this.terminate();
              };

              return worker;
            }

            function setupProcessWorker(script, options, child_process) {
              // no WorkerThreads, fallback to sub-process based workers
              var worker = child_process.fork(
                script,
                options.forkArgs,
                options.forkOpts
              );

              worker.isChildProcess = true;
              return worker;
            }

            // add debug flags to child processes if the node inspector is active
            function resolveForkOptions(opts) {
              opts = opts || {};

              var processExecArgv = process$3.execArgv.join(' ');
              var inspectorActive = processExecArgv.indexOf('--inspect') !== -1;
              var debugBrk = processExecArgv.indexOf('--debug-brk') !== -1;

              var execArgv = [];
              if (inspectorActive) {
                execArgv.push('--inspect=' + opts.debugPort);

                if (debugBrk) {
                  execArgv.push('--debug-brk');
                }
              }

              process$3.execArgv.forEach(function(arg) {
                if (arg.indexOf('--max-old-space-size') > -1) {
                  execArgv.push(arg);
                }
              });

              return Object.assign({}, opts, {
                forkArgs: opts.forkArgs,
                forkOpts: Object.assign({}, opts.forkOpts, {
                  execArgv: (opts.forkOpts && opts.forkOpts.execArgv || [])
                  .concat(execArgv)
                })
              });
            }

            /**
             * Converts a serialized error to Error
             * @param {Object} obj Error that has been serialized and parsed to object
             * @return {Error} The equivalent Error.
             */
            function objectToError (obj) {
              var temp = new Error('');
              var props = Object.keys(obj);

              for (var i = 0; i < props.length; i++) {
                temp[props[i]] = obj[props[i]];
              }

              return temp
            }

            /**
             * A WorkerHandler controls a single worker. This worker can be a child process
             * on node.js or a WebWorker in a browser environment.
             * @param {String} [script] If no script is provided, a default worker with a
             *                          function run will be created.
             * @param {WorkerPoolOptions} _options See docs
             * @constructor
             */
            function WorkerHandler(script, _options) {
              var me = this;
              var options = _options || {};

              this.script = script || getDefaultWorker();
              this.worker = setupWorker(this.script, options);
              this.debugPort = options.debugPort;

              // The ready message is only sent if the worker.add method is called (And the default script is not used)
              if (!script) {
                this.worker.ready = true;
              }

              // queue for requests that are received before the worker is ready
              this.requestQueue = [];
              this.worker.on('message', function (response) {
                if (typeof response === 'string' && response === 'ready') {
                  me.worker.ready = true;
                  dispatchQueuedRequests();
                } else {
                  // find the task from the processing queue, and run the tasks callback
                  var id = response.id;
                  var task = me.processing[id];
                  if (task !== undefined) {
                    // remove the task from the queue
                    delete me.processing[id];

                    // test if we need to terminate
                    if (me.terminating === true) {
                      // complete worker termination if all tasks are finished
                      me.terminate();
                    }

                    // resolve the task's promise
                    if (response.error) {
                      task.resolver.reject(objectToError(response.error));
                    }
                    else {
                      task.resolver.resolve(response.result);
                    }
                  }
                }
              });

              // reject all running tasks on worker error
              function onError(error) {
                me.terminated = true;
                if (me.terminating && me.terminationHandler) {
                  me.terminationHandler(me);
                }
                me.terminating = false;

                for (var id in me.processing) {
                  if (me.processing[id] !== undefined) {
                    me.processing[id].resolver.reject(error);
                  }
                }
                me.processing = Object.create(null);
              }

              // send all queued requests to worker
              function dispatchQueuedRequests()
              {
                me.requestQueue.forEach(me.worker.send.bind(me.worker));
                me.requestQueue = [];
              }

              var worker = this.worker;
              // listen for worker messages error and exit
              this.worker.on('error', onError);
              this.worker.on('exit', function (exitCode, signalCode) {
                var message = 'Workerpool Worker terminated Unexpectedly\n';

                message += '    exitCode: `' + exitCode + '`\n';
                message += '    signalCode: `' + signalCode + '`\n';

                message += '    workerpool.script: `' +  me.script + '`\n';
                message += '    spawnArgs: `' +  worker.spawnargs + '`\n';
                message += '    spawnfile: `' + worker.spawnfile + '`\n';

                message += '    stdout: `' + worker.stdout + '`\n';
                message += '    stderr: `' + worker.stderr + '`\n';

                onError(new Error(message));
              });

              this.processing = Object.create(null); // queue with tasks currently in progress

              this.terminating = false;
              this.terminated = false;
              this.terminationHandler = null;
              this.lastId = 0;
            }

            /**
             * Get a list with methods available on the worker.
             * @return {Promise.<String[], Error>} methods
             */
            WorkerHandler.prototype.methods = function () {
              return this.exec('methods');
            };

            /**
             * Execute a method with given parameters on the worker
             * @param {String} method
             * @param {Array} [params]
             * @param {{resolve: Function, reject: Function}} [resolver]
             * @return {Promise.<*, Error>} result
             */
            WorkerHandler.prototype.exec = function(method, params, resolver) {
              if (!resolver) {
                resolver = Promise.defer();
              }

              // generate a unique id for the task
              var id = ++this.lastId;

              // register a new task as being in progress
              this.processing[id] = {
                id: id,
                resolver: resolver
              };

              // build a JSON-RPC request
              var request = {
                id: id,
                method: method,
                params: params
              };

              if (this.terminated) {
                resolver.reject(new Error('Worker is terminated'));
              } else if (this.worker.ready) {
                // send the request to the worker
                this.worker.send(request);
              } else {
                this.requestQueue.push(request);
              }

              // on cancellation, force the worker to terminate
              var me = this;
              resolver.promise
                .catch(function (error) {
                  if (error instanceof Promise.CancellationError || error instanceof Promise.TimeoutError) {
                    // remove this task from the queue. It is already rejected (hence this
                    // catch event), and else it will be rejected again when terminating
                    delete me.processing[id];

                    // terminate worker
                    me.terminate(true);
                  } else {
                    throw error;
                  }
                });

              return resolver.promise;
            };

            /**
             * Test whether the worker is working or not
             * @return {boolean} Returns true if the worker is busy
             */
            WorkerHandler.prototype.busy = function () {
              return Object.keys(this.processing).length > 0;
            };

            /**
             * Terminate the worker.
             * @param {boolean} [force=false]   If false (default), the worker is terminated
             *                                  after finishing all tasks currently in
             *                                  progress. If true, the worker will be
             *                                  terminated immediately.
             * @param {function} [callback=null] If provided, will be called when process terminates.
             */
            WorkerHandler.prototype.terminate = function (force, callback) {
              if (force) {
                // cancel all tasks in progress
                for (var id in this.processing) {
                  if (this.processing[id] !== undefined) {
                    this.processing[id].resolver.reject(new Error('Worker terminated'));
                  }
                }
                this.processing = Object.create(null);
              }

              if (typeof callback === 'function') {
                this.terminationHandler = callback;
              }
              if (!this.busy()) {
                // all tasks are finished. kill the worker
                if (this.worker) {
                  if (typeof this.worker.kill === 'function') {
                    this.worker.kill();  // child process
                  }
                  else if (typeof this.worker.terminate === 'function') {
                    this.worker.terminate(); // web worker
                  }
                  else {
                    throw new Error('Failed to terminate worker');
                  }
                  this.worker = null;
                }
                this.terminating = false;
                this.terminated = true;
                if (this.terminationHandler) {
                  this.terminationHandler(this);
                }
              }
              else {
                // we can't terminate immediately, there are still tasks being executed
                this.terminating = true;
              }
            };

            /**
             * Terminate the worker, returning a Promise that resolves when the termination has been done.
             * @param {boolean} [force=false]   If false (default), the worker is terminated
             *                                  after finishing all tasks currently in
             *                                  progress. If true, the worker will be
             *                                  terminated immediately.
             * @param {number} [timeout]        If provided and non-zero, worker termination promise will be rejected
             *                                  after timeout if worker process has not been terminated.
             * @return {Promise.<WorkerHandler, Error>}
             */
            WorkerHandler.prototype.terminateAndNotify = function (force, timeout) {
              var resolver = Promise.defer();
              if (timeout) {
                resolver.promise.timeout = timeout;
              }
              this.terminate(force, function(worker) {
                resolver.resolve(worker);
              });
              return resolver.promise;
            };

            module.exports = WorkerHandler;
            module.exports._tryRequireWorkerThreads = tryRequireWorkerThreads;
            module.exports._setupProcessWorker = setupProcessWorker;
            module.exports._setupBrowserWorker = setupBrowserWorker;
            module.exports._setupWorkerThreadWorker = setupWorkerThreadWorker;
            module.exports.ensureWorkerThreads = ensureWorkerThreads;


            /***/ }),
            /* 6 */
            /***/ (function(module, exports) {

            /**
             * embeddedWorker.js contains an embedded version of worker.js.
             * This file is automatically generated,
             * changes made in this file will be overwritten.
             */
            module.exports = "!function(o){var n={};function t(e){if(n[e])return n[e].exports;var r=n[e]={i:e,l:!1,exports:{}};return o[e].call(r.exports,r,r.exports,t),r.l=!0,r.exports}t.m=o,t.c=n,t.d=function(e,r,o){t.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:o})},t.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},t.t=function(r,e){if(1&e&&(r=t(r)),8&e)return r;if(4&e&&\"object\"==typeof r&&r&&r.__esModule)return r;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,\"default\",{enumerable:!0,value:r}),2&e&&\"string\"!=typeof r)for(var n in r)t.d(o,n,function(e){return r[e]}.bind(null,n));return o},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,\"a\",r),r},t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p=\"\",t(t.s=0)}([function(module,exports,__webpack_require__){var requireFoolWebpack=eval(\"typeof require !== 'undefined' ? require : function (module) { throw new Error('Module \\\" + module + \\\" not found.') }\"),worker={},WorkerThreads,parentPort;if(\"undefined\"!=typeof self&&\"function\"==typeof postMessage&&\"function\"==typeof addEventListener)worker.on=function(e,r){addEventListener(e,function(e){r(e.data)})},worker.send=function(e){postMessage(e)};else{if(\"undefined\"==typeof process)throw new Error(\"Script must be executed as a worker\");try{WorkerThreads=requireFoolWebpack(\"worker_threads\")}catch(e){if(\"object\"!=typeof e||null===e||\"MODULE_NOT_FOUND\"!==e.code)throw e}WorkerThreads&&null!==WorkerThreads.parentPort?(parentPort=WorkerThreads.parentPort,worker.send=parentPort.postMessage.bind(parentPort),worker.on=parentPort.on.bind(parentPort)):(worker.on=process.on.bind(process),worker.send=process.send.bind(process),worker.on(\"disconnect\",function(){process.exit(1)}))}function convertError(o){return Object.getOwnPropertyNames(o).reduce(function(e,r){return Object.defineProperty(e,r,{value:o[r],enumerable:!0})},{})}function isPromise(e){return e&&\"function\"==typeof e.then&&\"function\"==typeof e.catch}worker.methods={},worker.methods.run=function run(fn,args){var f=eval(\"(\"+fn+\")\");return f.apply(f,args)},worker.methods.methods=function(){return Object.keys(worker.methods)},worker.on(\"message\",function(r){try{var e=worker.methods[r.method];if(!e)throw new Error('Unknown method \"'+r.method+'\"');var o=e.apply(e,r.params);isPromise(o)?o.then(function(e){worker.send({id:r.id,result:e,error:null})}).catch(function(e){worker.send({id:r.id,result:null,error:convertError(e)})}):worker.send({id:r.id,result:o,error:null})}catch(e){worker.send({id:r.id,result:null,error:convertError(e)})}}),worker.register=function(e){if(e)for(var r in e)e.hasOwnProperty(r)&&(worker.methods[r]=e[r]);worker.send(\"ready\")},exports.add=worker.register}]);";


            /***/ }),
            /* 7 */
            /***/ (function(module, exports, __webpack_require__) {


            var MAX_PORTS = 65535;
            module.exports = DebugPortAllocator;
            function DebugPortAllocator() {
              this.ports = Object.create(null);
              this.length = 0;
            }

            DebugPortAllocator.prototype.nextAvailableStartingAt = function(starting) {
              while (this.ports[starting] === true) {
                starting++;
              }

              if (starting >= MAX_PORTS) {
                throw new Error('WorkerPool debug port limit reached: ' + starting + '>= ' + MAX_PORTS );
              }

              this.ports[starting] = true;
              this.length++;
              return starting;
            };

            DebugPortAllocator.prototype.releasePort = function(port) {
              delete this.ports[port];
              this.length--;
            };



            /***/ }),
            /* 8 */
            /***/ (function(module, exports, __webpack_require__) {

            /**
             * worker must be started as a child process or a web worker.
             * It listens for RPC messages from the parent process.
             */

            // source of inspiration: https://github.com/sindresorhus/require-fool-webpack
            var requireFoolWebpack = eval(
                'typeof require !== \'undefined\'' +
                ' ? require' +
                ' : function (module) { throw new Error(\'Module " + module + " not found.\') }'
            );

            // create a worker API for sending and receiving messages which works both on
            // node.js and in the browser
            var worker = {};
            if (typeof self !== 'undefined' && typeof postMessage === 'function' && typeof addEventListener === 'function') {
              // worker in the browser
              worker.on = function (event, callback) {
                addEventListener(event, function (message) {
                  callback(message.data);
                });
              };
              worker.send = function (message) {
                postMessage(message);
              };
            }
            else if (typeof process$3 !== 'undefined') {
              // node.js

              var WorkerThreads;
              try {
                WorkerThreads = requireFoolWebpack('worker_threads');
              } catch(error) {
                if (typeof error === 'object' && error !== null && error.code === 'MODULE_NOT_FOUND') ; else {
                  throw error;
                }
              }

              if (WorkerThreads &&
                /* if there is a parentPort, we are in a WorkerThread */
                WorkerThreads.parentPort !== null) {
                var parentPort  = WorkerThreads.parentPort;
                worker.send = parentPort.postMessage.bind(parentPort);
                worker.on = parentPort.on.bind(parentPort);
              } else {
                worker.on = process$3.on.bind(process$3);
                worker.send = process$3.send.bind(process$3);
                // register disconnect handler only for subprocess worker to exit when parent is killed unexpectedly
                worker.on('disconnect', function () {
                  process$3.exit(1);
                });
              }
            }
            else {
              throw new Error('Script must be executed as a worker');
            }

            function convertError(error) {
              return Object.getOwnPropertyNames(error).reduce(function(product, name) {
                return Object.defineProperty(product, name, {
            	value: error[name],
            	enumerable: true
                });
              }, {});
            }

            /**
             * Test whether a value is a Promise via duck typing.
             * @param {*} value
             * @returns {boolean} Returns true when given value is an object
             *                    having functions `then` and `catch`.
             */
            function isPromise(value) {
              return value && (typeof value.then === 'function') && (typeof value.catch === 'function');
            }

            // functions available externally
            worker.methods = {};

            /**
             * Execute a function with provided arguments
             * @param {String} fn     Stringified function
             * @param {Array} [args]  Function arguments
             * @returns {*}
             */
            worker.methods.run = function run(fn, args) {
              var f = eval('(' + fn + ')');
              return f.apply(f, args);
            };

            /**
             * Get a list with methods available on this worker
             * @return {String[]} methods
             */
            worker.methods.methods = function methods() {
              return Object.keys(worker.methods);
            };

            worker.on('message', function (request) {
              try {
                var method = worker.methods[request.method];

                if (method) {
                  // execute the function
                  var result = method.apply(method, request.params);

                  if (isPromise(result)) {
                    // promise returned, resolve this and then return
                    result
                        .then(function (result) {
                          worker.send({
                            id: request.id,
                            result: result,
                            error: null
                          });
                        })
                        .catch(function (err) {
                          worker.send({
                            id: request.id,
                            result: null,
                            error: convertError(err)
                          });
                        });
                  }
                  else {
                    // immediate result
                    worker.send({
                      id: request.id,
                      result: result,
                      error: null
                    });
                  }
                }
                else {
                  throw new Error('Unknown method "' + request.method + '"');
                }
              }
              catch (err) {
                worker.send({
                  id: request.id,
                  result: null,
                  error: convertError(err)
                });
              }
            });

            /**
             * Register methods to the worker
             * @param {Object} methods
             */
            worker.register = function (methods) {

              if (methods) {
                for (var name in methods) {
                  if (methods.hasOwnProperty(name)) {
                    worker.methods[name] = methods[name];
                  }
                }
              }

              worker.send('ready');

            };

            {
              exports.add = worker.register;
            }


            /***/ })
            /******/ ]);
            });

            });

            var workerpool$1 = unwrapExports$7(workerpool);

            /* global postMessage, onmessage:writable, self */

            // Just something to make sure workerpool gets used.
            const foo = () => workerpool$1;

            function computeXYSegmentLength(p1, p2) {
              const segmentLength = Math.sqrt(
                (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1])
              );
              return segmentLength;
            }

            function computeXYPathLength(path) {
              var pathLength = 0;
              var k = 1;
              while (k < path.length) {
                const p1 = path[k - 1];
                const p2 = path[k];
                pathLength = pathLength + computeXYSegmentLength(p1, p2);
                k++;
              }

              return pathLength;
            }

            // Move all the points in a range to a new z-value
            function shiftRange(path, start, end, height) {
              var generatedPath = [path[0]];
              var n = 1;
              while (n < path.length) {
                // Measure the distance with the new point
                const nextTotalLength = computeXYPathLength(
                  generatedPath.concat([path[n]])
                );
                if (nextTotalLength > start && nextTotalLength < end) {
                  var shiftedPoint = path[n];
                  shiftedPoint[2] = height;
                  generatedPath.push(shiftedPoint);
                } else {
                  generatedPath.push(path[n]);
                }
                n++;
              }
              return path;
            }

            // Insert an elevation change a given distance into a path
            function insertPointByDist(path, target, height) {
              var generatedPath = [path[0]];
              // Walk through each point and see if adding it would excede distance
              var k = 1;
              while (k < path.length) {
                // Measure the distance with the new point
                const nextTotalLength = computeXYPathLength(
                  generatedPath.concat([path[k]])
                );
                if (nextTotalLength > target) {
                  const prior = computeXYPathLength(generatedPath);
                  const newSegmentLength = target - prior;

                  const normalVector = normalize(subtract(path[k], path[k - 1]));
                  const scaled = scale(newSegmentLength, normalVector);

                  var newPoint = add(path[k - 1], scaled);
                  newPoint[2] = height; // Set the new point's z value

                  generatedPath.push(newPoint);

                  // Fastforward to the end
                  while (k < path.length) {
                    generatedPath.push(path[k]);
                    k++;
                  }

                  return generatedPath;
                }
                generatedPath.push(path[k]);
                k++;
              }
              // This return catches it if no point is added
              return generatedPath;
            }

            // Add tabs to a pass
            function addTabs(pass, baselineHeight, thickness, tabs, toolSize) {
              const tabHeight = thickness * (-2 / 3);
              console.log(tabHeight);
              // Compute path length
              const totalPathLength = computeXYPathLength(pass.concat([pass[0]]));
              const tabWidth = 4 * toolSize;
              const spaceBetweenTabs = (totalPathLength - tabWidth * tabs) / tabs;
              const bias = totalPathLength / 8 - tabWidth / 2; // Bias the tabs so on a square they appear on the middle of the edges, not at the corners

              var m = 1;
              while (m <= tabs) {
                const tabBegin = m * spaceBetweenTabs + (m - 1) * tabWidth - bias;
                const tabEnd = m * spaceBetweenTabs + (m - 1) * tabWidth + tabWidth - bias;
                pass = insertPointByDist(pass, tabBegin, baselineHeight);
                pass = insertPointByDist(pass, tabBegin, tabHeight);
                pass = shiftRange(pass, tabBegin, tabEnd, tabHeight);
                pass = insertPointByDist(pass, tabEnd, tabHeight);
                pass = insertPointByDist(pass, tabEnd, baselineHeight);
                m++;
              }

              return pass;
            }

            // Essentially moves a pass to the correct depth
            function generatePass(path, depth, hasTabs, thickness, tabs, toolSize) {
              var pass = [];
              // Add all the rest of the points in the pass
              path.forEach((point) => {
                pass.push([point[0], point[1], depth]);
              });
              pass.push([path[0][0], path[0][1], depth]); // Add the first point again to close the path

              if (hasTabs) {
                pass = addTabs(pass, depth, thickness, tabs, toolSize);
              }

              return pass;
            }

            const agent = async ({ question }) => {
              try {
                var { key, values } = question;
                const shape = (nth) => Shape.fromGeometry(values[nth]);
                clearCache();
                switch (key) {
                  case 'assemble':
                    var inputs = values[0].map(Shape.fromGeometry);
                    return Assembly(...inputs).toDisjointGeometry();
                  case 'bounding box':
                    return Shape.fromGeometry(values[0]).measureBoundingBox();
                  case 'circle':
                    return Circle.ofDiameter(values[0], {
                      sides: values[1],
                    }).toKeptGeometry(); // {center: true, sides: values[1] }).toKeptGeometry();
                  case 'color':
                    if (values[1] === 'Keep Out') {
                      return Shape.fromGeometry(values[0])
                        .color('Red')
                        .material('keepout')
                        .toKeptGeometry();
                    } else {
                      return Shape.fromGeometry(values[0])
                        .color(values[1])
                        .toKeptGeometry();
                    }
                  case 'code':
                    inputs = {};
                    for (key in values[1]) {
                      if (values[1][key] != null && typeof values[1][key] === 'object') {
                        inputs[key] = Shape.fromGeometry(values[1][key]);
                      } else {
                        inputs[key] = values[1][key];
                      }
                    }
                    const signature =
                      '{ ' +
                      Object.keys(api$1).join(', ') +
                      ', ' +
                      Object.keys(inputs).join(', ') +
                      ' }';
                    const foo = new Function(signature, values[0]);
                    const returnVal = foo({ ...api$1, ...inputs });
                    if (typeof returnVal === 'object') {
                      return returnVal.toKeptGeometry();
                    } else {
                      return returnVal;
                    }
                  case 'layout':
                    console.log('Doing layout');
                    const solidToSplit = Shape.fromGeometry(values[0]);
                    var flatItems = [];
                    solidToSplit.items().forEach((item) => {
                      flatItems.push(item.flat().to(Z$1$7(0)));
                    });

                    console.log(flatItems);

                    const laidOut = Layers(...flatItems)
                      .Page({ itemMargin: values[1] });

                    return laidOut.toKeptGeometry();
                  case 'difference':
                    return Shape.fromGeometry(values[0])
                      .cut(Shape.fromGeometry(values[1]))
                      .kept()
                      .toKeptGeometry();
                  case 'extractTag':
                    return Shape.fromGeometry(values[0])
                      .keep(values[1])
                      .noVoid()
                      .noPlan()
                      .toKeptGeometry();
                  case 'extrude':
                    return Shape.fromGeometry(values[0])
                      .extrude(values[1])
                      .toKeptGeometry();
                  case 'hull':
                    values = values.map(Shape.fromGeometry);
                    return Hull(...values).toKeptGeometry();
                  case 'intersection':
                    return Shape.fromGeometry(values[0]).cut(shape(1)).toDisjointGeometry();
                  case 'rectangle':
                    return Square(values[0], values[1]).toKeptGeometry();
                  case 'Over Cut Inside Corners':
                    const overcutShape = Shape.fromGeometry(values[0]);
                    const overcutSection = overcutShape.section(Z$1$7());
                    const toolpath = overcutSection.toolpath(values[1], {
                      overcut: true,
                      joinPaths: true,
                    });
                    const height = overcutShape.size().height;
                    const sweep = toolpath.sweep(Circle(values[1])).extrude(height);
                    return overcutShape.cut(sweep).toKeptGeometry();
                  case 'render':
                    var fromGeo = Empty(); // This should be an empty geometry;

                    try {
                      if (values[1] === true && values[2] === false) {
                        // Solid, no wireframe
                        fromGeo = Shape.fromGeometry(values[0]);
                      } else if (values[1] === false && values[2] === true) {
                        fromGeo = Shape.fromGeometry(values[0]).outline();
                      } else if (values[1] === true && values[2] === true) {
                        const intermediate = Shape.fromGeometry(values[0]);
                        fromGeo = intermediate.with(intermediate.outline());
                      }
                    } catch (err) {
                      console.log("Can't display in worker thread");
                      console.log(err);
                    }
                    return toThreejsGeometry(fromGeo.toKeptGeometry());
                  case 'rotate':
                    return Shape.fromGeometry(values[0])
                      .rotateX(values[1])
                      .rotateY(values[2])
                      .rotateZ(values[3])
                      .toKeptGeometry();
                  case 'stl':
                    const inflated = Shape.fromGeometry(values[0]).toKeptGeometry();
                    const stlString = await toStl(inflated);
                    return stlString;
                  case 'svg':
                    const svgString = await toSvg(
                      Shape.fromGeometry(values[0])
                        .Union()
                        .center()
                        .section()
                        .outline()
                        .toKeptGeometry()
                    );
                    return svgString;
                  case 'stackedOutline':
                    const gcodeShape = Shape.fromGeometry(values[0]);
                    const thickness = gcodeShape.size().height;
                    const toolSize = values[1];
                    const numberOfPasses = values[2];
                    // const speed = values[3];
                    const tabs = values[4];
                    const safeHeight = values[5];

                    const distPerPass = (-1 * thickness) / numberOfPasses;

                    var slice = gcodeShape
                      .Union()
                      .center()
                      .section()
                      .toolpath(toolSize, { joinPaths: true });

                    // Split each path into it's layers
                    slice.geometry.paths.forEach((path, index) => {
                      // This generates all the passes for a single cut (ie a single outside or inside profile)
                      var plungePoint = path[0];
                      plungePoint[2] = safeHeight;
                      var newPath = [[0, 0, safeHeight], plungePoint];
                      var i = 1;
                      while (i <= numberOfPasses) {
                        // Paths in the bottom 1/3 have tabs
                        var tabsInThisPass = false;
                        if (i >= numberOfPasses * (2 / 3)) {
                          tabsInThisPass = true;
                        }

                        newPath = newPath.concat(
                          generatePass(
                            path,
                            i * distPerPass,
                            tabsInThisPass,
                            thickness,
                            tabs,
                            toolSize
                          )
                        );

                        i++;
                      }

                      const lastIndex = newPath.length - 1;
                      newPath.push([
                        newPath[lastIndex][0],
                        newPath[lastIndex][1],
                        safeHeight,
                      ]); // Retract back to safe height after finishing move
                      slice.geometry.paths[index] = newPath; // Replaces the existing path with the new multi level one
                    });

                    // A shape can have many paths which need to be cut (ie inside and outside profiles. This joins them all into one
                    var completePath = [[0, 0, safeHeight]];
                    slice.geometry.paths.forEach((path) => {
                      completePath = completePath.concat(path);
                    });

                    slice.geometry.paths = [completePath];

                    return slice.toKeptGeometry();
                  case 'gcode':
                    return 'G0 would be here';
                  case 'outline':
                    return Shape.fromGeometry(values[0])
                      .Union()
                      .center()
                      .section()
                      .outline()
                      .toKeptGeometry();
                  /*
                  case 'SVG Picture':
                    const shape = api.Shape.fromGeometry(values[0]).center();
                    const bounds = shape.measureBoundingBox();
                    const cameraDistance = 6 * Math.max(...bounds[1]);
                    return convertThree.toSvg(
                      { view: { position: [0, 0, cameraDistance], near: 1, far: 10000 } },
                      shape.rotateX(20).rotateY(-45).toKeptGeometry()
                    );
            */
                  case 'size':
                    return Shape.fromGeometry(values[0]).size();
                  case 'tag':
                    return Shape.fromGeometry(values[0]).as(values[1]).toDisjointGeometry();
                  case 'specify':
                    return Shape.fromGeometry(values[0]).Item(values[1]).toDisjointGeometry();
                  case 'translate':
                    return Shape.fromGeometry(values[0])
                      .move(values[1], values[2], values[3])
                      .toDisjointGeometry();
                  case 'getBOM':
                    return Shape.fromGeometry(values[0]).bom();
                  case 'union':
                    return Shape.fromGeometry(values[0]).add(shape(1)).toDisjointGeometry();
                  default:
                    return -1;
                }
              } catch (error) {
                console.log('Called with: ');
                console.log(question);
                console.log(error);
                return -1;
              }
            };

            // create a worker and register public functions
            workerpool$1.worker({
              agent: agent
            });

            exports.foo = foo;

            Object.defineProperty(exports, '__esModule', { value: true });

});
